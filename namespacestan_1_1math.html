<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Stan Math Library: stan::math Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="standoxy.css" rel="stylesheet" type="text/css">
<!--  -->
<script type="text/javascript" src="eigen_navtree_hacks.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stanlogo-main.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a href="https://mc-stan.org/math">Stan Math Library</a>
   &#160;<span id="projectnumber">5.0.0</span>
   </div>
   <div id="projectbrief">Automatic Differentiation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacestan_1_1math.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">stan::math Namespace Reference<div class="ingroups"><a class="el" href="group__eigen__expressions.html">Eigen expressions</a> &raquo; <a class="el" href="group__returning__expressions.html">Returning expressions</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Matrices and templated mathematical functions. </p>
<p>Templated probability distributions. All paramaterizations are based on Bayesian Data Analysis. Function gradients via reverse-mode automatic differentiation. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacestan_1_1math_1_1internal"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_1_1internal.html">internal</a></td></tr>
<tr class="memdesc:namespacestan_1_1math_1_1internal"><td class="mdescLeft">&#160;</td><td class="mdescRight">A comparator that works for any container type that has the brackets operator. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacestan_1_1math_1_1opencl"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_1_1opencl.html">opencl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacestan_1_1math_1_1opencl__kernels"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_1_1opencl__kernels.html">opencl_kernels</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1abs__fun.html">abs_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return elementwise absolute value of the specified real-valued container.  <a href="structstan_1_1math_1_1abs__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1accumulator.html">accumulator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to accumulate values and eventually return their sum.  <a href="classstan_1_1math_1_1accumulator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1accumulator_3_01_t_00_01require__fvar__t_3_01_t_01_4_01_4.html">accumulator&lt; T, require_fvar_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to accumulate values and eventually return their sum.  <a href="classstan_1_1math_1_1accumulator_3_01_t_00_01require__fvar__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1accumulator_3_01_t_00_01require__var__t_3_01_t_01_4_01_4.html">accumulator&lt; T, require_var_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to accumulate values and eventually return their sum.  <a href="classstan_1_1math_1_1accumulator_3_01_t_00_01require__var__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1acos__.html">acos_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1acos__fun.html">acos_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a0225b71faa7dc05c3fd41e70dc6cc34b.html#a0225b71faa7dc05c3fd41e70dc6cc34b">acos()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1acos__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1acosh__.html">acosh_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1acosh__fun.html">acosh_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a1f4aba0a2fc965c0abc4ea84508a09e3.html#a1f4aba0a2fc965c0abc4ea84508a09e3">acosh()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1acosh__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1ad__promotable.html">ad_promotable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the type From can be converted to To using implicit conversions, or both From and To are possibly cv-qualified void), provides the member constant value equal to true.  <a href="structstan_1_1math_1_1ad__promotable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1ad__tape__observer.html">ad_tape_observer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TBB observer object which is a callback hook called whenever the TBB scheduler adds a new thread to the TBB managed threadpool.  <a href="classstan_1_1math_1_1ad__tape__observer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1addition__.html">addition_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1addition__operator__.html">addition_operator_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1adjoint__results__cl.html">adjoint_results_cl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents results that are adjoints of vars in kernel generrator expressions.  <a href="classstan_1_1math_1_1adjoint__results__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1append__col__.html">append_col_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents appending of cols in kernel generator expressions.  <a href="classstan_1_1math_1_1append__col__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1append__return__type.html">append_return_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template metaprogram is used to compute the return type for append_array.  <a href="structstan_1_1math_1_1append__return__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1append__return__type_3_01_eigen_1_1_matrix_3_01_t1_00_01_r_00_01_c_01_4_0055a8b04836654f8c0781baa8c862db5f.html">append_return_type&lt; Eigen::Matrix&lt; T1, R, C &gt;, Eigen::Matrix&lt; T2, R, C &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template metaprogram is used to compute the return type for append_array.  <a href="structstan_1_1math_1_1append__return__type_3_01_eigen_1_1_matrix_3_01_t1_00_01_r_00_01_c_01_4_0055a8b04836654f8c0781baa8c862db5f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1append__return__type_3_01int_00_01int_01_4.html">append_return_type&lt; int, int &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template metaprogram is used to compute the return type for append_array.  <a href="structstan_1_1math_1_1append__return__type_3_01int_00_01int_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1append__return__type_3_01std_1_1vector_3_01_t1_01_4_00_01std_1_1vector_3_01_t2_01_4_01_4.html">append_return_type&lt; std::vector&lt; T1 &gt;, std::vector&lt; T2 &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template metaprogram is used to compute the return type for append_array.  <a href="structstan_1_1math_1_1append__return__type_3_01std_1_1vector_3_01_t1_01_4_00_01std_1_1vector_3_01_t2_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1append__row__.html">append_row_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents appending of rows in kernel generator expressions.  <a href="classstan_1_1math_1_1append__row__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary.html">apply_scalar_unary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template class for vectorization of unary scalar functions defined by a template class <code>F</code> to a scalar, standard library vector, or <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> dense matrix expression template.  <a href="structstan_1_1math_1_1apply__scalar__unary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01fvar_3_01_t_01_4_01_4.html">apply_scalar_unary&lt; F, fvar&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization to fvar for vectorizing a unary scalar function.  <a href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01fvar_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01std_1_1vector_3_01_t_01_4_01_4.html">apply_scalar_unary&lt; F, std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for vectorized functions applying to standard vector containers.  <a href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01std_1_1vector_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__complex__t_3_01_t_01_4_01_4.html">apply_scalar_unary&lt; F, T, require_complex_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for vectorized functions applying to complex arguments.  <a href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__complex__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html">apply_scalar_unary&lt; F, T, require_eigen_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for vectorized functions applying to <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix arguments.  <a href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__floating__point__t_3_01_t_01_4_01_4.html">apply_scalar_unary&lt; F, T, require_floating_point_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for vectorized functions applying to double arguments.  <a href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__floating__point__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__integral__t_3_01_t_01_4_01_4.html">apply_scalar_unary&lt; F, T, require_integral_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization for vectorized functions applying to integer arguments.  <a href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__integral__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01_t_00_01require__var__matrix__t_3_01_t_01_4_01_4.html">apply_scalar_unary&lt; F, T, require_var_matrix_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01var_01_4.html">apply_scalar_unary&lt; F, var &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template specialization to var for vectorizing a unary scalar function.  <a href="structstan_1_1math_1_1apply__scalar__unary_3_01_f_00_01var_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__vector__unary.html">apply_vector_unary</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__vector__unary_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html">apply_vector_unary&lt; T, require_eigen_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template class for vectorization of unary vector functions defined by applying a functor to a standard library vector, <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> dense matrix expression template, or container of these.  <a href="structstan_1_1math_1_1apply__vector__unary_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__vector__unary_3_01_t_00_01require__std__vector__vt_3_01is__containef7817cd68a98167c2f6049cb72bb785a.html">apply_vector_unary&lt; T, require_std_vector_vt&lt; is_container_or_var_matrix, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for use with nested containers (std::vectors).  <a href="structstan_1_1math_1_1apply__vector__unary_3_01_t_00_01require__std__vector__vt_3_01is__containef7817cd68a98167c2f6049cb72bb785a.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__vector__unary_3_01_t_00_01require__std__vector__vt_3_01is__stan__scalar_00_01_t_01_4_01_4.html">apply_vector_unary&lt; T, require_std_vector_vt&lt; is_stan_scalar, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for use with (non-nested) std::vectors.  <a href="structstan_1_1math_1_1apply__vector__unary_3_01_t_00_01require__std__vector__vt_3_01is__stan__scalar_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1apply__vector__unary_3_01_t_00_01require__var__matrix__t_3_01_t_01_4_01_4.html">apply_vector_unary&lt; T, require_var_matrix_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for use with <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;T&gt;</code> types where T inherits from EigenBase.  <a href="structstan_1_1math_1_1apply__vector__unary_3_01_t_00_01require__var__matrix__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1arena__allocator.html">arena_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std library compatible allocator that uses AD stack.  <a href="structstan_1_1math_1_1arena__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1arena__matrix.html">arena_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>Eigen::Matrix</code>, except that the data is stored on AD stack.  <a href="classstan_1_1math_1_1arena__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1arena__matrix_3_01_matrix_type_00_01require__eigen__dense__base__t_3_01_matrix_type_01_4_01_4.html">arena_matrix&lt; MatrixType, require_eigen_dense_base_t&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1arena__matrix_3_01_matrix_type_00_01require__eigen__sparse__base__t_3_01_matrix_type_01_4_01_4.html">arena_matrix&lt; MatrixType, require_eigen_sparse_base_t&lt; MatrixType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1arena__matrix__cl.html">arena_matrix_cl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant of <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> that schedules its destructor to be called, so it can be used on the AD stack.  <a href="classstan_1_1math_1_1arena__matrix__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1array__builder.html">array_builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for building up arrays in an expression (rather than in statements) using an argument-chaining <a class="el" href="classstan_1_1math_1_1array__builder_ac68291870a52844b815e9943ade61692.html#ac68291870a52844b815e9943ade61692" title="Add one element of type S to array, promoting to type T.">add()</a> method and a getter method <a class="el" href="classstan_1_1math_1_1array__builder_a7c140d0f2a6ebfd81c8512ca5a9a4849.html#a7c140d0f2a6ebfd81c8512ca5a9a4849" title="Getter method to return array itself.">array()</a> to return the result.  <a href="classstan_1_1math_1_1array__builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1as__column__vector__or__scalar__.html">as_column_vector_or_scalar_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents as_column_vector_or_scalar of a row or column vector in kernel generator expressions.  <a href="classstan_1_1math_1_1as__column__vector__or__scalar__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1asin__.html">asin_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1asin__fun.html">asin_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_ad7b48158d54565231ca3a7328c11eb21.html#ad7b48158d54565231ca3a7328c11eb21">asin()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1asin__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1asinh__.html">asinh_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1asinh__fun.html">asinh_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a4a1a957be54c795baae42c74c9e53149.html#a4a1a957be54c795baae42c74c9e53149">asinh()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1asinh__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1atan__.html">atan_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1atan__fun.html">atan_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a83986a2a7953042a141b6d808763bd88.html#a83986a2a7953042a141b6d808763bd88">atan()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1atan__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1atanh__.html">atanh_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1atanh__fun.html">atanh_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a2cabe7a1ea8293228faa9e77f6eb1203.html#a2cabe7a1ea8293228faa9e77f6eb1203" title="Return inverse hyperbolic tangent of specified value.">atanh()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1atanh__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1_autodiff_stack_singleton.html">AutodiffStackSingleton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct always provides access to the autodiff stack using the singleton pattern.  <a href="structstan_1_1math_1_1_autodiff_stack_singleton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1beta__.html">beta_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1binary__operation.html">binary_operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a binary operation in kernel generator expressions.  <a href="classstan_1_1math_1_1binary__operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1binomial__coefficient__log__.html">binomial_coefficient_log_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1block__.html">block_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents submatrix block in kernel generator expressions.  <a href="classstan_1_1math_1_1block__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1broadcast__.html">broadcast_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a broadcasting operation in kernel generator expressions.  <a href="classstan_1_1math_1_1broadcast__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1calc__if__.html">calc_if_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a calc_if in kernel generator expressions.  <a href="classstan_1_1math_1_1calc__if__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1cast__.html">cast_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a typecast os scalar in kernel generator expressions.  <a href="classstan_1_1math_1_1cast__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1cbrt__.html">cbrt_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1cbrt__fun.html">cbrt_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a6e56cfe7810faca3dd8a2326affacd26.html#a6e56cfe7810faca3dd8a2326affacd26" title="Return cube root of specified argument.">cbrt()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1cbrt__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1ceil__.html">ceil_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1ceil__fun.html">ceil_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_ae0742bb5eb74b836b005ef099cffc502.html#ae0742bb5eb74b836b005ef099cffc502">ceil()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1ceil__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1chainable__alloc.html">chainable_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classstan_1_1math_1_1chainable__alloc.html" title="A chainable_alloc is an object which is constructed and destructed normally but the memory lifespan i...">chainable_alloc</a> is an object which is constructed and destructed normally but the memory lifespan is managed along with the arena allocator for the gradient calculation.  <a href="classstan_1_1math_1_1chainable__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1chainable__object.html">chainable_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classstan_1_1math_1_1chainable__object.html" title="chainable_object hold another object is useful for connecting the lifetime of a specific object to th...">chainable_object</a></code> hold another object is useful for connecting the lifetime of a specific object to the chainable stack  <a href="classstan_1_1math_1_1chainable__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1check__cl__.html">check_cl_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a check in kernel generator expressions.  <a href="classstan_1_1math_1_1check__cl__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1col__index.html">col_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents operation that determines column index.  <a href="classstan_1_1math_1_1col__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1colwise__max__.html">colwise_max_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents column wise max - reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1colwise__max__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1colwise__min__.html">colwise_min_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents column wise min - reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1colwise__min__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1colwise__prod__.html">colwise_prod_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents column wise product - reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1colwise__prod__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1colwise__reduction.html">colwise_reduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a column wise reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1colwise__reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1colwise__sum__.html">colwise_sum_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents column wise sum - reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1colwise__sum__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1complex__base.html">complex_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for complex numbers.  <a href="classstan_1_1math_1_1complex__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1conjunction.html">conjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::true_type when instantiated with zero or more template parameters, all of which extend the std::true_type.  <a href="structstan_1_1math_1_1conjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1conjunction_3_01_t_00_01_ts_8_8_8_01_4.html">conjunction&lt; T, Ts... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1constant__.html">constant_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a matrix of single repeated value in kernel generator expressions.  <a href="classstan_1_1math_1_1constant__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1copysign__.html">copysign_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1cos__.html">cos_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1cos__fun.html">cos_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_ab75cdb29185b7843a24c68e7dfbc3516.html#ab75cdb29185b7843a24c68e7dfbc3516">cos()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1cos__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1cosh__.html">cosh_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1cosh__fun.html">cosh_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a5241e24973fe1e57704814a1a5d939a4.html#a5241e24973fe1e57704814a1a5d939a4">cosh()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1cosh__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system.html">coupled_ode_system</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system__impl.html">coupled_ode_system_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system__impl_3_01false_00_01_f_00_01_t__y0_00_01_args_8_8_8_01_4.html">coupled_ode_system_impl&lt; false, F, T_y0, Args... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="structstan_1_1math_1_1coupled__ode__system__impl.html">coupled_ode_system_impl</a></code> template specialization when the state or parameters are autodiff types.  <a href="structstan_1_1math_1_1coupled__ode__system__impl_3_01false_00_01_f_00_01_t__y0_00_01_args_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1coupled__ode__system__impl_3_01true_00_01_f_00_01_t__y0_00_01_args_8_8_8_01_4.html">coupled_ode_system_impl&lt; true, F, T_y0, Args... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="structstan_1_1math_1_1coupled__ode__system__impl.html">coupled_ode_system_impl</a></code> for arithmetic arguments reduces to the regular ode system (there are no sensitivities)  <a href="structstan_1_1math_1_1coupled__ode__system__impl_3_01true_00_01_f_00_01_t__y0_00_01_args_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1cov__exp__quad__vari.html">cov_exp_quad_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1cov__exp__quad__vari_3_01_t__x_00_01double_00_01_t__l_01_4.html">cov_exp_quad_vari&lt; T_x, double, T_l &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1cvodes__integrator.html">cvodes_integrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrator interface for CVODES' ODE solvers (Adams &amp; BDF methods).  <a href="classstan_1_1math_1_1cvodes__integrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1cvodes__integrator__adjoint__vari.html">cvodes_integrator_adjoint_vari</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrator interface for CVODES' adjoint ODE solvers (Adams &amp; BDF methods).  <a href="classstan_1_1math_1_1cvodes__integrator__adjoint__vari.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1dae__system.html">dae_system</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDAS DAE system that contains information on residual equation functor, sensitivity residual equation functor, as well as initial conditions.  <a href="classstan_1_1math_1_1dae__system.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1deserializer.html">deserializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class to store a sequence of values which can be deserialized back into structured objects such as scalars, vectors, and matrices.  <a href="structstan_1_1math_1_1deserializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1diagonal__.html">diagonal_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents diagonal of a matrix (as column vector) in kernel generator expressions.  <a href="classstan_1_1math_1_1diagonal__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1digamma__.html">digamma_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1digamma__fun.html">digamma_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_af87890068b9f3e77a15eb60447ccfd77.html#af87890068b9f3e77a15eb60447ccfd77" title="Return the derivative of the log gamma function at the specified argument.">digamma()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1digamma__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1disjunction.html">disjunction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends std::false_type when instantiated with zero or more template parameters, all of which extend the std::false_type.  <a href="structstan_1_1math_1_1disjunction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1disjunction_3_01_cond_00_01_conds_8_8_8_01_4.html">disjunction&lt; Cond, Conds... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1elt__divide__.html">elt_divide_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1elt__function__cl.html">elt_function_cl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an element-wise function in kernel generator expressions.  <a href="classstan_1_1math_1_1elt__function__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1elt__modulo__.html">elt_modulo_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1elt__multiply__.html">elt_multiply_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1equals__.html">equals_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1erf__.html">erf_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1erf__fun.html">erf_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a56f59c3dd3a27e81e8320083e1a0c6c1.html#a56f59c3dd3a27e81e8320083e1a0c6c1">erf()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1erf__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1erfc__.html">erfc_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1erfc__fun.html">erfc_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap the <code><a class="el" href="namespacestan_1_1math_a9994e6390e4a0c155be10c882072ca34.html#a9994e6390e4a0c155be10c882072ca34">erfc()</a></code> so that it can be vectorized.  <a href="structstan_1_1math_1_1erfc__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1exp2__.html">exp2_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1exp2__fun.html">exp2_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a311f94ed9243524c28e9d30dce8045df.html#a311f94ed9243524c28e9d30dce8045df">exp2()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1exp2__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1exp__.html">exp_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1exp__fun.html">exp_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_afeb02d174bb7d5c70db81fa1a9996f57.html#afeb02d174bb7d5c70db81fa1a9996f57">exp()</a></code> so that it can be vectorized.  <a href="structstan_1_1math_1_1exp__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1expm1__.html">expm1_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1expm1__fun.html">expm1_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a23c116678993eabfaf88ab4e92209f31.html#a23c116678993eabfaf88ab4e92209f31">expm1()</a></code> so that it can be vectorized.  <a href="structstan_1_1math_1_1expm1__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1expressions__cl.html">expressions_cl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents multiple expressions that will be calculated in same kernel.  <a href="classstan_1_1math_1_1expressions__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1fabs__.html">fabs_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1fabs__fun.html">fabs_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code>fabs()</code> so that it can be vectorized.  <a href="structstan_1_1math_1_1fabs__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1fdim__.html">fdim_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1_fixed_point_a_d_jac.html">FixedPointADJac</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate Jacobian Jxy(Jacobian of unknown x w.r.t.  <a href="structstan_1_1math_1_1_fixed_point_a_d_jac.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1_fixed_point_solver.html">FixedPointSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed point solver for problem of form.  <a href="structstan_1_1math_1_1_fixed_point_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1_fixed_point_solver_3_01_kinsol_fixed_point_env_3_01_f_01_4_00_01fp__jac__type_01_4.html">FixedPointSolver&lt; KinsolFixedPointEnv&lt; F &gt;, fp_jac_type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for fixed point solver when using KINSOL.  <a href="structstan_1_1math_1_1_fixed_point_solver_3_01_kinsol_fixed_point_env_3_01_f_01_4_00_01fp__jac__type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1floor__.html">floor_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1floor__fun.html">floor_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_aa828ed40aa78417d100d5cdeae54cd2b.html#aa828ed40aa78417d100d5cdeae54cd2b">floor()</a></code> so that it can be vectorized.  <a href="structstan_1_1math_1_1floor__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1fmax__.html">fmax_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1fmin__.html">fmin_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1fmod__.html">fmod_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template class represents scalars used in forward-mode automatic differentiation, which consist of values and directional derivatives of the specified template type.  <a href="structstan_1_1math_1_1fvar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1gevv__vvv__vari.html">gevv_vvv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1greater__than__.html">greater_than_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1greater__than__or__equal__.html">greater_than_or_equal_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_holder.html">Holder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A no-op <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> operation.  <a href="classstan_1_1math_1_1_holder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1holder__cl__.html">holder_cl_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a no-op in kernel generator expressions.  <a href="classstan_1_1math_1_1holder__cl__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1hybrj__functor__solver.html">hybrj_functor_solver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor with the required operators to call <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a>'s algebraic solver.  <a href="structstan_1_1math_1_1hybrj__functor__solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1hypot__.html">hypot_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1idas__integrator.html">idas_integrator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IDAS DAE integrator.  <a href="classstan_1_1math_1_1idas__integrator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1idas__service.html">idas_service</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">For each type of Ode(with different rhs functor F and
senstivity parameters), we allocate mem and workspace for idas.  <a href="structstan_1_1math_1_1idas__service.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1include__summand.html">include_summand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate whether a summand needs to be included in a proportional (log) probability calculation.  <a href="structstan_1_1math_1_1include__summand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1include__summand_3_01propto_00_01_t_01_4.html">include_summand&lt; propto, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if a term with the specified propto value and subterm types should be included in a proportionality calculation.  <a href="structstan_1_1math_1_1include__summand_3_01propto_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type.html">index_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primary template class for the metaprogram to compute the index type of a container.  <a href="structstan_1_1math_1_1index__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html">index_type&lt; T, require_eigen_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram defining typedef for the type of index for an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix, vector, or row vector.  <a href="structstan_1_1math_1_1index__type_3_01_t_00_01require__eigen__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4.html">index_type&lt; T, require_std_vector_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram class to compute the type of index for a standard vector.  <a href="structstan_1_1math_1_1index__type_3_01_t_00_01require__std__vector__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1index__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4.html">index_type&lt; T, std::enable_if_t&lt; std::is_pointer&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="structstan_1_1math_1_1index__type.html" title="Primary template class for the metaprogram to compute the index type of a container.">index_type</a> for pointers.  <a href="structstan_1_1math_1_1index__type_3_01_t_00_01std_1_1enable__if__t_3_01std_1_1is__pointer_3_01_t_01_4_1_1value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1indexing__.html">indexing_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents indexing of a matrix with two matrices of indices.  <a href="classstan_1_1math_1_1indexing__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1inv__cloglog__fun.html">inv_cloglog_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a5bb7dcaa37a8cadd5e4ad89ff323a7d5.html#a5bb7dcaa37a8cadd5e4ad89ff323a7d5">inv_cloglog()</a> so that it can be vectorized.  <a href="structstan_1_1math_1_1inv__cloglog__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1inv__erfc__fun.html">inv_erfc_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap the <code><a class="el" href="namespacestan_1_1math_aab99816a26d0021e1bb5df954414f060.html#aab99816a26d0021e1bb5df954414f060">inv_erfc()</a> function</code> so that it can be vectorized.  <a href="structstan_1_1math_1_1inv__erfc__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1inv__fun.html">inv_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap 1.0 / x so that it can be vectorized.  <a href="structstan_1_1math_1_1inv__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1inv__logit__.html">inv_logit_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1inv__logit__fun.html">inv_logit_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_ae0010641b9d5d7ab95187e4a05993344.html#ae0010641b9d5d7ab95187e4a05993344" title="Returns the inverse logit function applied to the argument.">inv_logit()</a> so that it can be vectorized.  <a href="structstan_1_1math_1_1inv__logit__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1inv___phi__.html">inv_Phi_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1inv___phi__fun.html">inv_Phi_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a9f9475283849b02264ae7eb4472dabcb.html#a9f9475283849b02264ae7eb4472dabcb">inv_Phi()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1inv___phi__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1inv__sqrt__fun.html">inv_sqrt_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code>1 / sqrt(x)</code> so that it can be vectorized.  <a href="structstan_1_1math_1_1inv__sqrt__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1inv__square__.html">inv_square_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1isfinite__.html">isfinite_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1isinf__.html">isinf_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1isnan__.html">isnan_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1kernel__parts.html">kernel_parts</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parts of an OpenCL kernel, generated by an expression.  <a href="structstan_1_1math_1_1kernel__parts.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1kinsol__system__data.html">kinsol_system_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">KINSOL algebraic system data holder.  <a href="classstan_1_1math_1_1kinsol__system__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1_kinsol_fixed_point_env.html">KinsolFixedPointEnv</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">KINSOL algebraic system data holder that handles construction &amp; destruction of SUNDIALS data, as well as auxiliary data that will be used for functor evaluation.  <a href="structstan_1_1math_1_1_kinsol_fixed_point_env.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1lbeta__.html">lbeta_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1ldexp__.html">ldexp_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> is a structure that holds a matrix of type T and the LDLT of its values.  <a href="classstan_1_1math_1_1_l_d_l_t__factor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor_3_01_t_00_01require__eigen__matrix__dynamic__vt_3_01is__var_00_01_t_01_4_01_4.html">LDLT_factor&lt; T, require_eigen_matrix_dynamic_vt&lt; is_var, T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> of an <code>Eigen::Matrix&lt;var, Eigen::Dynamic, Eigen::Dynamic&gt;</code> with <code>alloc_in_arena = True</code> holds a copy of the input matrix and the LDLT of its values, with all member variable allocations are done in the arena.  <a href="classstan_1_1math_1_1_l_d_l_t__factor_3_01_t_00_01require__eigen__matrix__dynamic__vt_3_01is__var_00_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor_3_01_t_00_01require__var__matrix__t_3_01_t_01_4_01_4.html">LDLT_factor&lt; T, require_var_matrix_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> of a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Eigen::MatrixXd&gt;</code> holds a copy of the input <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code> and the LDLT of its values.  <a href="classstan_1_1math_1_1_l_d_l_t__factor_3_01_t_00_01require__var__matrix__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor_3_01_t_00_01std_1_1enable__if__t_3_01bool__constant_3_01isf4ac45f4a445d958dcf96a7b3eb9b05e.html">LDLT_factor&lt; T, std::enable_if_t&lt; bool_constant&lt; is_eigen_matrix_dynamic&lt; T &gt;::value &amp;&amp;!is_var&lt; scalar_type_t&lt; T &gt; &gt;::value &gt;::value &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> is a structure that holds a matrix of type T and the LDLT of its values.  <a href="classstan_1_1math_1_1_l_d_l_t__factor_3_01_t_00_01std_1_1enable__if__t_3_01bool__constant_3_01isf4ac45f4a445d958dcf96a7b3eb9b05e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1less__than__.html">less_than_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1less__than__or__equal__.html">less_than_or_equal_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1lgamma__.html">lgamma_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1lgamma__fun.html">lgamma_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_aa888b5d6ff71fe9ab37deaee025a33bf.html#aa888b5d6ff71fe9ab37deaee025a33bf" title="Return the natural logarithm of the gamma function applied to the specified argument.">lgamma()</a> so that it can be vectorized.  <a href="structstan_1_1math_1_1lgamma__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1lmultiply__.html">lmultiply_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1load__.html">load_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an access to a <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> in kernel generator expressions.  <a href="classstan_1_1math_1_1load__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log10__.html">log10_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log10__fun.html">log10_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_aaadc90acda3e608b200fc3eb6188c486.html#aaadc90acda3e608b200fc3eb6188c486" title="Returns the natural logarithm of ten.">log10()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1log10__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log1m__.html">log1m_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log1m__exp__.html">log1m_exp_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log1m__exp__fun.html">log1m_exp_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a452e4f39f00638a425f76b27c150e8ec.html#a452e4f39f00638a425f76b27c150e8ec" title="Return the natural logarithm of one minus the exponentiation of the specified argument.">log1m_exp()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1log1m__exp__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log1m__fun.html">log1m_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_ae426e656b1c72332aeadeaed27c5ecf4.html#ae426e656b1c72332aeadeaed27c5ecf4">log1m()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1log1m__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log1m__inv__logit__.html">log1m_inv_logit_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log1m__inv__logit__fun.html">log1m_inv_logit_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_aebfd796b601a6cb2b9022ddedd7b6748.html#aebfd796b601a6cb2b9022ddedd7b6748" title="Return the natural logarithm of one minus the inverse logit of the specified argument.">log1m_inv_logit()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1log1m__inv__logit__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log1p__.html">log1p_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log1p__exp__.html">log1p_exp_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log1p__exp__fun.html">log1p_exp_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a7a46dfa4816b15da29603c2a13928996.html#a7a46dfa4816b15da29603c2a13928996">log1p_exp()</a> so that it can be vectorized.  <a href="structstan_1_1math_1_1log1p__exp__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log1p__fun.html">log1p_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a9cb72ed892210a6a63de6e4db6c3c056.html#a9cb72ed892210a6a63de6e4db6c3c056">log1p()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1log1p__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log2__.html">log2_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log2__fun.html">log2_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a44eb38e5b317dadf97e8b359197902ea.html#a44eb38e5b317dadf97e8b359197902ea" title="Return natural logarithm of two.">log2()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1log2__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log__.html">log_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log__diff__exp__.html">log_diff_exp_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log__fun.html">log_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a5494a692abff08cb3585079397b90dab.html#a5494a692abff08cb3585079397b90dab">log()</a></code> so that it can be vectorized.  <a href="structstan_1_1math_1_1log__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log__inv__logit__.html">log_inv_logit_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1log__inv__logit__diff__.html">log_inv_logit_diff_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1log__inv__logit__fun.html">log_inv_logit_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a609450c56db01ed4b4989dc7f9dd755c.html#a609450c56db01ed4b4989dc7f9dd755c">log_inv_logit()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1log__inv__logit__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1logical__and__.html">logical_and_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1logical__negation__.html">logical_negation_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a logical negation in kernel generator expressions.  <a href="classstan_1_1math_1_1logical__negation__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1logical__or__.html">logical_or_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1logit__.html">logit_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1logit__fun.html">logit_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a229da97d194861a2715450b9877173c4.html#a229da97d194861a2715450b9877173c4">logit()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1logit__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an arithmetic matrix on the OpenCL device.  <a href="classstan_1_1math_1_1matrix__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1matrix__cl__base.html">matrix_cl_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-templated base class for <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> simplifies checking if something is <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>.  <a href="classstan_1_1math_1_1matrix__cl__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1matrix__exp__action__handler.html">matrix_exp_action_handler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The implementation of the work by Awad H.  <a href="classstan_1_1math_1_1matrix__exp__action__handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1max__2d__.html">max_2d_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents two dimensional max - reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1max__2d__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1max__op.html">max_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation for max reduction.  <a href="structstan_1_1math_1_1max__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1min__2d__.html">min_2d_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents two dimensional min - reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1min__2d__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1min__op.html">min_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation for min reduction.  <a href="structstan_1_1math_1_1min__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1mpi__cluster.html">mpi_cluster</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI cluster holds MPI resources and must be initialized only once in any MPI program.  <a href="structstan_1_1math_1_1mpi__cluster.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1mpi__command.html">mpi_command</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A MPI command object is used to execute code on worker nodes.  <a href="structstan_1_1math_1_1mpi__command.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1mpi__distributed__apply.html">mpi_distributed_apply</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI command template which calls the static method distributed_apply of the given class F.  <a href="structstan_1_1math_1_1mpi__distributed__apply.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1mpi__is__in__use.html">mpi_is_in_use</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown whenever the MPI resource is busy.  <a href="classstan_1_1math_1_1mpi__is__in__use.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1mpi__parallel__call.html">mpi_parallel_call</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MPI parallel call class manages the distributed evaluation of a collection of tasks following the map - reduce - combine pattern.  <a href="classstan_1_1math_1_1mpi__parallel__call.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1mpi__stop__listen.html">mpi_stop_listen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception used to stop workers nodes from further listening to commands send from the root.  <a href="classstan_1_1math_1_1mpi__stop__listen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1mpi__stop__worker.html">mpi_stop_worker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MPI command used to stop childs nodes from listening for further commands.  <a href="structstan_1_1math_1_1mpi__stop__worker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1multiply__log__.html">multiply_log_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1name__generator.html">name_generator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unique name generator for variables used in generated kernels.  <a href="classstan_1_1math_1_1name__generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1nested__rev__autodiff.html">nested_rev_autodiff</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class following the RAII idiom to start and recover nested autodiff scopes.  <a href="classstan_1_1math_1_1nested__rev__autodiff.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1nlo__functor.html">nlo_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure which gets passed to <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a>'s dogleg algebraic solver.  <a href="structstan_1_1math_1_1nlo__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1not__equals__.html">not_equals_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__ddv__vari.html">op_ddv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__dv__vari.html">op_dv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__dvd__vari.html">op_dvd_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__dvv__vari.html">op_dvv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__matrix__vari.html">op_matrix_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__v__vari.html">op_v_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vd__vari.html">op_vd_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vdd__vari.html">op_vdd_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vdv__vari.html">op_vdv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vector__vari.html">op_vector_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vv__vari.html">op_vv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vvd__vari.html">op_vvd_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1op__vvv__vari.html">op_vvv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1opencl__code__.html">opencl_code_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents custom code in kernel generator expressions.  <a href="classstan_1_1math_1_1opencl__code__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1opencl__code__output.html">opencl_code_output</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents output variable of custom code in kernel generator expressions.  <a href="classstan_1_1math_1_1opencl__code__output.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1opencl__context.html">opencl_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The API to access the methods and values in <a class="el" href="classstan_1_1math_1_1opencl__context__base.html" title="The opencl_context_base class represents an OpenCL context in the standard Meyers singleton design pa...">opencl_context_base</a>.  <a href="classstan_1_1math_1_1opencl__context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1opencl__context__base.html">opencl_context_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <code><a class="el" href="classstan_1_1math_1_1opencl__context__base.html" title="The opencl_context_base class represents an OpenCL context in the standard Meyers singleton design pa...">opencl_context_base</a></code> class represents an OpenCL context in the standard Meyers singleton design pattern.  <a href="classstan_1_1math_1_1opencl__context__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1operands__and__partials.html">operands_and_partials</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template builds partial derivatives with respect to a set of operands.  <a href="classstan_1_1math_1_1operands__and__partials.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00205e3dfc4aa428638a4e542fee8c2c7d.html">operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, Op6, Op7, Op8, fvar&lt; Dx &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class builds partial derivatives with respect to a set of operands.  <a href="classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_00205e3dfc4aa428638a4e542fee8c2c7d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_000785b81a4e0cd5b6ed5a4706b0c63f75.html">operands_and_partials&lt; Op1, Op2, Op3, Op4, Op5, Op6, Op7, Op8, var &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class builds partial derivatives with respect to a set of operands.  <a href="classstan_1_1math_1_1operands__and__partials_3_01_op1_00_01_op2_00_01_op3_00_01_op4_00_01_op5_000785b81a4e0cd5b6ed5a4706b0c63f75.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1operation__cl.html">operation_cl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base for all kernel generator operations.  <a href="classstan_1_1math_1_1operation__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1operation__cl__lhs.html">operation_cl_lhs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base for all kernel generator operations that can be used on left hand side of an expression.  <a href="classstan_1_1math_1_1operation__cl__lhs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1optional__broadcast__.html">optional_broadcast_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an optional broadcasting operation in kernel generator expressions.  <a href="classstan_1_1math_1_1optional__broadcast__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1pass__type.html">pass_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1pass__type_3_01double_01_4.html">pass_type&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1pass__type_3_01int_01_4.html">pass_type&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_phi__.html">Phi_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_phi__approx__.html">Phi_approx_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1_phi__approx__fun.html">Phi_approx_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a5e969ba79729a18cbab9cf9731cced63.html#a5e969ba79729a18cbab9cf9731cced63" title="Return an approximation of the unit normal cumulative distribution function (CDF).">Phi_approx()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1_phi__approx__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1_phi__fun.html">Phi_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a8f550856f585617566096f8f129caff8.html#a8f550856f585617566096f8f129caff8">Phi()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1_phi__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1pinned__matrix.html">pinned_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>Eigen::Matrix</code>, except that the data is stored in (hopefully pinned) memory, allocated by OpenCL driver.  <a href="classstan_1_1math_1_1pinned__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1pow__.html">pow_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1precomp__vv__vari.html">precomp_vv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1precomp__vvv__vari.html">precomp_vvv_vari</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1precomputed__gradients__vari__template.html">precomputed_gradients_vari_template</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variable implementation taking a sequence of operands and partial derivatives with respect to the operands.  <a href="classstan_1_1math_1_1precomputed__gradients__vari__template.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1prod__2d__.html">prod_2d_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents two dimensional product - reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1prod__2d__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1prod__op.html">prod_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation for product reduction.  <a href="structstan_1_1math_1_1prod__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1profile.html">profile</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Profiles C++ lines where the object is in scope.  <a href="classstan_1_1math_1_1profile.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1profile__info.html">profile_info</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class used for storing profiling information.  <a href="classstan_1_1math_1_1profile__info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__elements.html">promote_elements</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct with static function for elementwise type promotion.  <a href="structstan_1_1math_1_1promote__elements.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__elements_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_00_01_6ab59f25ff7ec3f7c102351ffc9e92c7.html">promote_elements&lt; Eigen::Matrix&lt; T, R, C &gt;, Eigen::Matrix&lt; S, R, C &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct with static function for elementwise type promotion.  <a href="structstan_1_1math_1_1promote__elements_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_00_01_6ab59f25ff7ec3f7c102351ffc9e92c7.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__elements_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_00_01_4bbb5eeca2df3769281e2a5aeb9e13c3.html">promote_elements&lt; Eigen::Matrix&lt; T, R, C &gt;, Eigen::Matrix&lt; T, R, C &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct with static function for elementwise type promotion.  <a href="structstan_1_1math_1_1promote__elements_3_01_eigen_1_1_matrix_3_01_t_00_01_r_00_01_c_01_4_00_01_4bbb5eeca2df3769281e2a5aeb9e13c3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__elements_3_01std_1_1vector_3_01_t_01_4_00_01std_1_1vector_3_01_s_01_4_01_4.html">promote_elements&lt; std::vector&lt; T &gt;, std::vector&lt; S &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct with static function for elementwise type promotion.  <a href="structstan_1_1math_1_1promote__elements_3_01std_1_1vector_3_01_t_01_4_00_01std_1_1vector_3_01_s_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__elements_3_01std_1_1vector_3_01_t_01_4_00_01std_1_1vector_3_01_t_01_4_01_4.html">promote_elements&lt; std::vector&lt; T &gt;, std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct with static function for elementwise type promotion.  <a href="structstan_1_1math_1_1promote__elements_3_01std_1_1vector_3_01_t_01_4_00_01std_1_1vector_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__elements_3_01_t_00_01_t_01_4.html">promote_elements&lt; T, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct with static function for elementwise type promotion.  <a href="structstan_1_1math_1_1promote__elements_3_01_t_00_01_t_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type.html">promote_scalar_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate a type for converting a convertible type.  <a href="structstan_1_1math_1_1promote__scalar__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01std_1_1tuple_3_01_promotion_scalars_8_8_8_01_4_06b2709eda18a3a5fb6e91279902bd742.html">promote_scalar_type&lt; std::tuple&lt; PromotionScalars... &gt;, std::tuple&lt; UnPromotedTypes... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_s_00_01require__all__t_3_01is__var_3_016c5eccdcd81e20b0fa598b6620378090.html">promote_scalar_type&lt; T, S, require_all_t&lt; is_var&lt; T &gt;, is_var&lt; S &gt;, is_eigen&lt; value_type_t&lt; S &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code> when the type to convert to is a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code>.  <a href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_s_00_01require__all__t_3_01is__var_3_016c5eccdcd81e20b0fa598b6620378090.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_s_00_01require__all__t_3_01std_1_1is__a40c9697fc3d0d16adcf94696b4bf67ca.html">promote_scalar_type&lt; T, S, require_all_t&lt; std::is_arithmetic&lt; T &gt;, is_var&lt; S &gt;, is_eigen&lt; value_type_t&lt; S &gt; &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code> when the type to convert to is arithmetic.  <a href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_s_00_01require__all__t_3_01std_1_1is__a40c9697fc3d0d16adcf94696b4bf67ca.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_s_00_01require__eigen__dense__base__t_3_01_s_01_4_01_4.html">promote_scalar_type&lt; T, S, require_eigen_dense_base_t&lt; S &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate a type for a matrix, vector, row vector or Eigen::Array whose underlying scalar is converted from the second template parameter type to the first.  <a href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_s_00_01require__eigen__dense__base__t_3_01_s_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01_s_00_01require__eigen__sparse__base__t_3_01_s_01_4_01_4.html">promote_scalar_type&lt; T, S, require_eigen_sparse_base_t&lt; S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01std_1_1vector_3_01_s_01_4_01_4.html">promote_scalar_type&lt; T, std::vector&lt; S &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template metaprogram to calculate a type for a container whose underlying scalar is converted from the second template parameter type to the first.  <a href="structstan_1_1math_1_1promote__scalar__type_3_01_t_00_01std_1_1vector_3_01_s_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1read__fvar__functor.html">read_fvar_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for extracting the values and tangents from a matrix of fvar.  <a href="classstan_1_1math_1_1read__fvar__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1reduction__2d.html">reduction_2d</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a two dimensional reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1reduction__2d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1ref__type__for__opencl.html">ref_type_for_opencl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines appropriate type for assigning expression of given type to, so that the resulting type has directly accessible contiguous colum-major data, which is needed to copy to OpenCL device for construction of <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>.  <a href="structstan_1_1math_1_1ref__type__for__opencl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1ref__type__for__opencl_3_01_t_00_01require__arena__matrix__t_3_01_t_01_4_01_4.html">ref_type_for_opencl&lt; T, require_arena_matrix_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1ref__type__for__opencl_3_01_t_00_01require__not__eigen__t_3_01_t_01_4_01_4.html">ref_type_for_opencl&lt; T, require_not_eigen_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1results__cl.html">results_cl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents results that will be calculated in same kernel.  <a href="classstan_1_1math_1_1results__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1round__.html">round_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1round__fun.html">round_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_ac23adb89034b334771cd25cf0fa6e2e4.html#ac23adb89034b334771cd25cf0fa6e2e4" title="Return the closest integer to the specified argument, with halfway cases rounded away from zero.">round()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1round__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1row__index.html">row_index</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents operation that determines row index.  <a href="classstan_1_1math_1_1row__index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1rowwise__max__.html">rowwise_max_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents rowwise max reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1rowwise__max__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1rowwise__min__.html">rowwise_min_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents rowwise min reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1rowwise__min__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1rowwise__prod__.html">rowwise_prod_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents rowwise product reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1rowwise__prod__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1rowwise__reduction.html">rowwise_reduction</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a rowwise reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1rowwise__reduction.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1rowwise__sum__.html">rowwise_sum_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents rowwise sum reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1rowwise__sum__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1rsqrt__.html">rsqrt_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1scalar__.html">scalar_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a scalar in kernel generator expressions.  <a href="classstan_1_1math_1_1scalar__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1_scoped_chainable_stack.html">ScopedChainableStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The AD tape of reverse mode AD is by default stored globally within the process (or thread).  <a href="classstan_1_1math_1_1_scoped_chainable_stack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1select__.html">select_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a selection operation in kernel generator expressions.  <a href="classstan_1_1math_1_1select__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view.html">seq_view</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01double_00_01std_1_1vector_3_01int_01_4_01_4.html">seq_view&lt; double, std::vector&lt; int &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_011_00_01_eigen_1_1_dynamic_01_4_01_4.html">seq_view&lt; T, Eigen::Matrix&lt; S, 1, Eigen::Dynamic &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1_dynamic_00_011_01_4_01_4.html">seq_view&lt; T, Eigen::Matrix&lt; S, Eigen::Dynamic, 1 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01_eigen_1_1_matrix_3_01_s_00_01_eigen_1_1_dynamic_00_01_eigen_1_1_dynamic_01_4_01_4.html">seq_view&lt; T, Eigen::Matrix&lt; S, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01std_1_1vector_3_01_s_01_4_01_4.html">seq_view&lt; T, std::vector&lt; S &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01std_1_1vector_3_01std_1_1vector_3_01_t_01_4_01_4_01_4.html">seq_view&lt; T, std::vector&lt; std::vector&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1seq__view_3_01_t_00_01std_1_1vector_3_01_t_01_4_01_4.html">seq_view&lt; T, std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1serializer.html">serializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to serialize structures to an internal stored sequence of scalars.  <a href="structstan_1_1math_1_1serializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1sign__fun.html">sign_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a490231ac3d0382d97667cc0711f5b3af.html#a490231ac3d0382d97667cc0711f5b3af" title="Returns signs of the arguments.">sign()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1sign__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1sin__.html">sin_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1sin__fun.html">sin_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a03498ae670c61712c7fb60381e97368e.html#a03498ae670c61712c7fb60381e97368e">sin()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1sin__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1sinh__.html">sinh_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1sinh__fun.html">sinh_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_a78c0cb63b379f6bdb4d5f77de9f95e66.html#a78c0cb63b379f6bdb4d5f77de9f95e66">sinh()</a> so that it can be vectorized.  <a href="structstan_1_1math_1_1sinh__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1sqrt__.html">sqrt_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1sqrt__fun.html">sqrt_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a81819d20047b4d6c264b58e35bb2c48d.html#a81819d20047b4d6c264b58e35bb2c48d">sqrt()</a></code> so that it can be vectorized.  <a href="structstan_1_1math_1_1sqrt__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1square__.html">square_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1square__fun.html">square_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_af94738d2bfd07182b4aaa7e18a62fb74.html#af94738d2bfd07182b4aaa7e18a62fb74">square()</a> so that it can be vectorized.  <a href="structstan_1_1math_1_1square__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1stack__alloc.html">stack_alloc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance of this class provides a memory pool through which blocks of raw memory may be allocated and then collected simultaneously.  <a href="classstan_1_1math_1_1stack__alloc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1std__normal__log__qf__fun.html">std_normal_log_qf_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_ac9d92215be48252702d0aa90083a371d.html#ac9d92215be48252702d0aa90083a371d">std_normal_log_qf()</a> so it can be vectorized.  <a href="structstan_1_1math_1_1std__normal__log__qf__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1step__fun.html">step_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a4ee16e810d0e707c24f7274af63f8635.html#a4ee16e810d0e707c24f7274af63f8635" title="The step, or Heaviside, function.">step()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1step__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1store__type.html">store_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1store__type_3_01double_01_4.html">store_type&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1store__type_3_01int_01_4.html">store_type&lt; int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1stored__gradient__vari.html">stored_gradient_vari</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A var implementation that stores the daughter variable implementation pointers and the partial derivative with respect to the result explicitly in arrays constructed on the autodiff memory stack.  <a href="classstan_1_1math_1_1stored__gradient__vari.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1subtraction__.html">subtraction_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1subtraction__operator__.html">subtraction_operator_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1sum__2d__.html">sum_2d_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents two dimensional sum - reduction in kernel generator expressions.  <a href="classstan_1_1math_1_1sum__2d__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1sum__op.html">sum_op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operation for sum reduction.  <a href="structstan_1_1math_1_1sum__op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1tan__.html">tan_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1tan__fun.html">tan_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a89071e8c3d80fe0b2ac0b23c345e9a9e.html#a89071e8c3d80fe0b2ac0b23c345e9a9e">tan()</a></code> so that it can be vectorized.  <a href="structstan_1_1math_1_1tan__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1tanh__.html">tanh_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1tanh__fun.html">tanh_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_ab32c5cd88becea57416c65688771a7c8.html#ab32c5cd88becea57416c65688771a7c8">tanh()</a></code> so that it can be vectorized.  <a href="structstan_1_1math_1_1tanh__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1tgamma__.html">tgamma_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1tgamma__fun.html">tgamma_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <a class="el" href="namespacestan_1_1math_acad338502e3115d34682603230479d41.html#acad338502e3115d34682603230479d41" title="Return the result of applying the gamma function to the specified argument.">tgamma()</a> so that it can be vectorized.  <a href="structstan_1_1math_1_1tgamma__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1to__int__fun.html">to_int_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return elementwise integer value of the specified real-valued container.  <a href="structstan_1_1math_1_1to__int__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1transpose__.html">transpose_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a transpose in kernel generator expressions.  <a href="classstan_1_1math_1_1transpose__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1trigamma__.html">trigamma_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1trigamma__fun.html">trigamma_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_a84f337f6b108752daafab06640e2c229.html#a84f337f6b108752daafab06640e2c229" title="Return the value of the trigamma function at the specified argument (i.e., the second derivative of t...">trigamma()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1trigamma__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1trunc__.html">trunc_</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstan_1_1math_1_1trunc__fun.html">trunc_fun</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to wrap <code><a class="el" href="namespacestan_1_1math_afac4060d610887434f513b38fb8457d6.html#afac4060d610887434f513b38fb8457d6" title="Return the nearest integral value that is not larger in magnitude than the specified argument.">trunc()</a></code> so it can be vectorized.  <a href="structstan_1_1math_1_1trunc__fun.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1unary__minus__.html">unary_minus_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an unary minus operation in kernel generator expressions.  <a href="classstan_1_1math_1_1unary__minus__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1unary__operation__cl.html">unary_operation_cl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a unary operation in kernel generator expressions.  <a href="classstan_1_1math_1_1unary__operation__cl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1unsafe__chainable__object.html">unsafe_chainable_object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classstan_1_1math_1_1unsafe__chainable__object.html" title="unsafe_chainable_object hold another object and is useful for connecting the lifetime of a specific o...">unsafe_chainable_object</a></code> hold another object and is useful for connecting the lifetime of a specific object to the chainable stack.  <a href="classstan_1_1math_1_1unsafe__chainable__object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1val__adj__functor.html">val_adj_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for extracting the values and adjoints from a matrix of var or vari.  <a href="classstan_1_1math_1_1val__adj__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1var__value_3_01_t_00_01internal_1_1require__matrix__var__value_3_01_t_01_4_01_4.html">var_value&lt; T, internal::require_matrix_var_value&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Independent (input) and dependent (output) variables for gradients.  <a href="classstan_1_1math_1_1var__value_3_01_t_00_01internal_1_1require__matrix__var__value_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1var__value_3_01_t_00_01require__floating__point__t_3_01_t_01_4_01_4.html">var_value&lt; T, require_floating_point_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Independent (input) and dependent (output) variables for gradients.  <a href="classstan_1_1math_1_1var__value_3_01_t_00_01require__floating__point__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__base.html">vari_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract base class that all <code><a class="el" href="classstan_1_1math_1_1vari__value.html">vari_value</a></code> and it's derived classes inherit.  <a href="classstan_1_1math_1_1vari__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__cl__base.html">vari_cl_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__value.html">vari_value</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__value_3_01_t_00_01require__all__t_3_01is__plain__type_3_01_t_01_4_00_668033d9a4bfddcaba56f859af1eb1d1.html">vari_value&lt; T, require_all_t&lt; is_plain_type&lt; T &gt;, is_eigen_dense_base&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable implementation for <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> dense matrix types.  <a href="classstan_1_1math_1_1vari__value_3_01_t_00_01require__all__t_3_01is__plain__type_3_01_t_01_4_00_668033d9a4bfddcaba56f859af1eb1d1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__value_3_01_t_00_01require__eigen__sparse__base__t_3_01_t_01_4_01_4.html">vari_value&lt; T, require_eigen_sparse_base_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable implementation for <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> sparse matrix types.  <a href="classstan_1_1math_1_1vari__value_3_01_t_00_01require__eigen__sparse__base__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__value_3_01_t_00_01require__matrix__cl__t_3_01_t_01_4_01_4.html">vari_value&lt; T, require_matrix_cl_t&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable implementation for <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code>.  <a href="classstan_1_1math_1_1vari__value_3_01_t_00_01require__matrix__cl__t_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__value_3_01_t_00_01require__t_3_01std_1_1is__floating__point_3_01_t_01_4_01_4_01_4.html">vari_value&lt; T, require_t&lt; std::is_floating_point&lt; T &gt; &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The variable implementation for floating point types.  <a href="classstan_1_1math_1_1vari__value_3_01_t_00_01require__t_3_01std_1_1is__floating__point_3_01_t_01_4_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__view.html">vari_view</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code><a class="el" href="classstan_1_1math_1_1vari__view.html" title="A vari_view is used to read from a slice of a vari_value with an inner eigen type.">vari_view</a></code> is used to read from a slice of a <code><a class="el" href="classstan_1_1math_1_1vari__value.html">vari_value</a></code> with an inner eigen type.  <a href="classstan_1_1math_1_1vari__view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__view_3_01_t_00_01require__all__t_3_01is__eigen_3_01_t_01_4_00_01bool_d1f607cdd61996bbd47cd360a469bd85.html">vari_view&lt; T, require_all_t&lt; is_eigen&lt; T &gt;, bool_constant&lt;!is_plain_type&lt; T &gt;::value &gt; &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__view_3_01_t_00_01require__kernel__expression__lhs__t_3_01_t_01_4_01_4.html">vari_view&lt; T, require_kernel_expression_lhs_t&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vari__view__eigen.html">vari_view_eigen</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This struct is follows the CRTP for methods common to <code><a class="el" href="classstan_1_1math_1_1vari__view.html" title="A vari_view is used to read from a slice of a vari_value with an inner eigen type.">vari_view</a>&lt;&gt;</code> and <code><a class="el" href="classstan_1_1math_1_1vari__value.html">vari_value</a>&lt;Matrix&gt;</code>.  <a href="classstan_1_1math_1_1vari__view__eigen.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vi__adj__functor.html">vi_adj_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for extracting the varis and adjoints from a matrix of var.  <a href="classstan_1_1math_1_1vi__adj__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vi__val__adj__functor.html">vi_val_adj_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for extracting the vari*, values, and adjoints from a matrix of var.  <a href="classstan_1_1math_1_1vi__val__adj__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1vi__val__functor.html">vi_val_functor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor for extracting the varis and values from a matrix of var.  <a href="classstan_1_1math_1_1vi__val__functor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1welford__covar__estimator.html">welford_covar_estimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstan_1_1math_1_1welford__var__estimator.html">welford_var_estimator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a98ff1baf06b8c5e2fc241bba99d0a97d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a98ff1baf06b8c5e2fc241bba99d0a97d.html#a98ff1baf06b8c5e2fc241bba99d0a97d">size_type</a> = Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt;::Index</td></tr>
<tr class="memdesc:a98ff1baf06b8c5e2fc241bba99d0a97d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for sizes and indexes in an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix with double elements.  <br /></td></tr>
<tr class="separator:a98ff1baf06b8c5e2fc241bba99d0a97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7898e4d60b5aa24048803800dcb92615"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7898e4d60b5aa24048803800dcb92615.html#a7898e4d60b5aa24048803800dcb92615">matrix_fd</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; double &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a7898e4d60b5aa24048803800dcb92615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bcca60033395307902857ddcf00d7e7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1bcca60033395307902857ddcf00d7e7.html#a1bcca60033395307902857ddcf00d7e7">matrix_ffd</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; double &gt; &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a1bcca60033395307902857ddcf00d7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a24a6f0fc822a9aea9fd4429305e3a4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7a24a6f0fc822a9aea9fd4429305e3a4.html#a7a24a6f0fc822a9aea9fd4429305e3a4">vector_fd</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; double &gt;, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:a7a24a6f0fc822a9aea9fd4429305e3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db34b298ebf1a5b3c72826ba0c68109"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9db34b298ebf1a5b3c72826ba0c68109.html#a9db34b298ebf1a5b3c72826ba0c68109">vector_ffd</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; double &gt; &gt;, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:a9db34b298ebf1a5b3c72826ba0c68109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29cb25574a0d858496122b9ff6a1fee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa29cb25574a0d858496122b9ff6a1fee.html#aa29cb25574a0d858496122b9ff6a1fee">row_vector_fd</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; double &gt;, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:aa29cb25574a0d858496122b9ff6a1fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b230b5832302359ccf4437bd70cb88"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac3b230b5832302359ccf4437bd70cb88.html#ac3b230b5832302359ccf4437bd70cb88">row_vector_ffd</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; double &gt; &gt;, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:ac3b230b5832302359ccf4437bd70cb88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e63f5c51a7bf76fdacf93d54b150e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa4e63f5c51a7bf76fdacf93d54b150e6.html#aa4e63f5c51a7bf76fdacf93d54b150e6">matrix_fv</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:aa4e63f5c51a7bf76fdacf93d54b150e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e35797725b8511533174aa1eec85a50"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4e35797725b8511533174aa1eec85a50.html#a4e35797725b8511533174aa1eec85a50">matrix_ffv</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a4e35797725b8511533174aa1eec85a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf25849f264623f024b4f6dc48b4c1a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abaf25849f264623f024b4f6dc48b4c1a.html#abaf25849f264623f024b4f6dc48b4c1a">vector_fv</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:abaf25849f264623f024b4f6dc48b4c1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae794f45250a72fb1b3f25bcb8f9c6df6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae794f45250a72fb1b3f25bcb8f9c6df6.html#ae794f45250a72fb1b3f25bcb8f9c6df6">vector_ffv</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &gt;, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="separator:ae794f45250a72fb1b3f25bcb8f9c6df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14c80b2ada12fd626e3420a69383fad"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af14c80b2ada12fd626e3420a69383fad.html#af14c80b2ada12fd626e3420a69383fad">row_vector_fv</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:af14c80b2ada12fd626e3420a69383fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0339be280ad62d6dc20d9527b03d46d1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0339be280ad62d6dc20d9527b03d46d1.html#a0339be280ad62d6dc20d9527b03d46d1">row_vector_ffv</a> = Eigen::Matrix&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &gt;, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="separator:a0339be280ad62d6dc20d9527b03d46d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd9b4d7342506a6dc93ca872bbcc9dd6"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="namespacestan_1_1math_ac87ada2bc2f3a7388f0c092d906f11f8.html#ac87ada2bc2f3a7388f0c092d906f11f8">assign_op_cl</a> AssignOp = assign_op_cl::equals&gt; </td></tr>
<tr class="memitem:gadd9b4d7342506a6dc93ca872bbcc9dd6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a> = std::conditional_t&lt; std::is_lvalue_reference&lt; T &gt;::value, decltype(<a class="el" href="group__opencl__kernel__generator_gad9dac47c0aa34d350bcf7e7f76fa87c1.html#gad9dac47c0aa34d350bcf7e7f76fa87c1">as_operation_cl</a>&lt; AssignOp &gt;(std::declval&lt; T &gt;())), std::remove_reference_t&lt; decltype(<a class="el" href="group__opencl__kernel__generator_gad9dac47c0aa34d350bcf7e7f76fa87c1.html#gad9dac47c0aa34d350bcf7e7f76fa87c1">as_operation_cl</a>&lt; AssignOp &gt;(std::declval&lt; T &gt;()))&gt; &gt;</td></tr>
<tr class="memdesc:gadd9b4d7342506a6dc93ca872bbcc9dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type that results when converting any valid kernel generator expression into operation.  <br /></td></tr>
<tr class="separator:gadd9b4d7342506a6dc93ca872bbcc9dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac08c412f337e77ef2acea8890a1e3f75"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac08c412f337e77ef2acea8890a1e3f75"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gac08c412f337e77ef2acea8890a1e3f75.html#gac08c412f337e77ef2acea8890a1e3f75">is_without_output</a> = <a class="el" href="structstan_1_1math_1_1internal_1_1is__without__output__impl.html">internal::is_without_output_impl</a>&lt; std::decay_t&lt; T &gt; &gt;</td></tr>
<tr class="separator:gac08c412f337e77ef2acea8890a1e3f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga885842e4dc32fa88f0a50f24344e854f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga885842e4dc32fa88f0a50f24344e854f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga885842e4dc32fa88f0a50f24344e854f.html#ga885842e4dc32fa88f0a50f24344e854f">is_colwise_reduction</a> = <a class="el" href="structstan_1_1math_1_1internal_1_1is__colwise__reduction__impl.html">internal::is_colwise_reduction_impl</a>&lt; std::decay_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga885842e4dc32fa88f0a50f24344e854f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a kernel generator expression is a colwise reduction.  <br /></td></tr>
<tr class="separator:ga885842e4dc32fa88f0a50f24344e854f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861ef063af54567bfa6b90a8bfd8d0bc"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a861ef063af54567bfa6b90a8bfd8d0bc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a861ef063af54567bfa6b90a8bfd8d0bc.html#a861ef063af54567bfa6b90a8bfd8d0bc">common_scalar_t</a> = typename std::common_type_t&lt; typename std::remove_reference_t&lt; Types &gt;::Scalar... &gt;</td></tr>
<tr class="memdesc:a861ef063af54567bfa6b90a8bfd8d0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for <code>std::common_type_t</code>  <br /></td></tr>
<tr class="separator:a861ef063af54567bfa6b90a8bfd8d0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac046f4a23bff8176c919a8a7f7dfdf6e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac046f4a23bff8176c919a8a7f7dfdf6e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gac046f4a23bff8176c919a8a7f7dfdf6e.html#gac046f4a23bff8176c919a8a7f7dfdf6e">is_reduction_2d</a> = <a class="el" href="structstan_1_1math_1_1internal_1_1is__reduction__2d__impl.html">internal::is_reduction_2d_impl</a>&lt; std::decay_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:gac046f4a23bff8176c919a8a7f7dfdf6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a kernel generator expression is a colwise reduction.  <br /></td></tr>
<tr class="separator:gac046f4a23bff8176c919a8a7f7dfdf6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fb6779eb99f22b6b0ce2662e630e78"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a89fb6779eb99f22b6b0ce2662e630e78"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a89fb6779eb99f22b6b0ce2662e630e78.html#a89fb6779eb99f22b6b0ce2662e630e78">ref_type_for_opencl_t</a> = typename <a class="el" href="structstan_1_1math_1_1ref__type__for__opencl.html">ref_type_for_opencl</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a89fb6779eb99f22b6b0ce2662e630e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8ebba551a7f21f55b348e6af8c9264"><td class="memTemplParams" colspan="2">template&lt;int B = 0&gt; </td></tr>
<tr class="memitem:adb8ebba551a7f21f55b348e6af8c9264"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adb8ebba551a7f21f55b348e6af8c9264.html#adb8ebba551a7f21f55b348e6af8c9264">boost_policy_t</a> = boost::math::policies::policy&lt; boost::math::policies::overflow_error&lt; boost::math::policies::errno_on_error &gt;, boost::math::policies::pole_error&lt; boost::math::policies::errno_on_error &gt;, boost::math::policies::promote_double&lt; false &gt;, boost::math::policies::digits2&lt; B &gt; &gt;</td></tr>
<tr class="memdesc:adb8ebba551a7f21f55b348e6af8c9264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boost policy that overrides the defaults to match the built-in C++ standard library functions.  <br /></td></tr>
<tr class="separator:adb8ebba551a7f21f55b348e6af8c9264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2e8a0b7c1cca979b7ff43cbb75ca65"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aca2e8a0b7c1cca979b7ff43cbb75ca65.html#aca2e8a0b7c1cca979b7ff43cbb75ca65">matrix_d</a> = Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:aca2e8a0b7c1cca979b7ff43cbb75ca65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for matrix of double values.  <br /></td></tr>
<tr class="separator:aca2e8a0b7c1cca979b7ff43cbb75ca65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4954408ac287ec405ca9b7bf59b3c19b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4954408ac287ec405ca9b7bf59b3c19b.html#a4954408ac287ec405ca9b7bf59b3c19b">vector_d</a> = Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:a4954408ac287ec405ca9b7bf59b3c19b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for (column) vector of double values.  <br /></td></tr>
<tr class="separator:a4954408ac287ec405ca9b7bf59b3c19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc78fff4ae93add582ece429d038796a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abc78fff4ae93add582ece429d038796a.html#abc78fff4ae93add582ece429d038796a">row_vector_d</a> = Eigen::Matrix&lt; double, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:abc78fff4ae93add582ece429d038796a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type for (row) vector of double values.  <br /></td></tr>
<tr class="separator:abc78fff4ae93add582ece429d038796a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26415bab11ad81529d0773ea8aeed544"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a26415bab11ad81529d0773ea8aeed544"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a26415bab11ad81529d0773ea8aeed544.html#a26415bab11ad81529d0773ea8aeed544">index_type_t</a> = typename <a class="el" href="structstan_1_1math_1_1index__type.html">index_type</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a26415bab11ad81529d0773ea8aeed544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47313edb9e9a3f50f4423f5b54b14da7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga47313edb9e9a3f50f4423f5b54b14da7"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_ga47313edb9e9a3f50f4423f5b54b14da7.html#ga47313edb9e9a3f50f4423f5b54b14da7">require_tuple_t</a> = <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:ga47313edb9e9a3f50f4423f5b54b14da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type satisfies <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>.  <br /></td></tr>
<tr class="separator:ga47313edb9e9a3f50f4423f5b54b14da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4445afe30360a232c34a8ef2efaea14"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf4445afe30360a232c34a8ef2efaea14"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_gaf4445afe30360a232c34a8ef2efaea14.html#gaf4445afe30360a232c34a8ef2efaea14">require_not_tuple_t</a> = <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; std::decay_t&lt; T &gt; &gt; &gt;</td></tr>
<tr class="memdesc:gaf4445afe30360a232c34a8ef2efaea14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require type does not satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>.  <br /></td></tr>
<tr class="separator:gaf4445afe30360a232c34a8ef2efaea14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga902ae119ff8d5c58048bef0993a087dd"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga902ae119ff8d5c58048bef0993a087dd"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_ga902ae119ff8d5c58048bef0993a087dd.html#ga902ae119ff8d5c58048bef0993a087dd">require_all_tuple_t</a> = <a class="el" href="namespacestan_adddf362fef97adf67b57ba8818d73a67.html#adddf362fef97adf67b57ba8818d73a67">require_all_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga902ae119ff8d5c58048bef0993a087dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require all of the types satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>.  <br /></td></tr>
<tr class="separator:ga902ae119ff8d5c58048bef0993a087dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c6cf84c6e0253fd1901f0ac56fef29e"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga7c6cf84c6e0253fd1901f0ac56fef29e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tuple__types_ga7c6cf84c6e0253fd1901f0ac56fef29e.html#ga7c6cf84c6e0253fd1901f0ac56fef29e">require_all_not_tuple_t</a> = <a class="el" href="namespacestan_a557173ff88d2e9cf7c48e3527d470219.html#a557173ff88d2e9cf7c48e3527d470219">require_all_not_t</a>&lt; <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>&lt; std::decay_t&lt; Types &gt; &gt;... &gt;</td></tr>
<tr class="memdesc:ga7c6cf84c6e0253fd1901f0ac56fef29e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Require none of the types satisfy <a class="el" href="structstan_1_1math_1_1is__tuple.html">is_tuple</a>.  <br /></td></tr>
<tr class="separator:ga7c6cf84c6e0253fd1901f0ac56fef29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262f0bbc91c3ceb4e56c7d582a94238a"><td class="memTemplParams" colspan="2">template&lt;typename Mat , int NewOptions&gt; </td></tr>
<tr class="memitem:a262f0bbc91c3ceb4e56c7d582a94238a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a262f0bbc91c3ceb4e56c7d582a94238a.html#a262f0bbc91c3ceb4e56c7d582a94238a">change_eigen_options_t</a> = typename <a class="el" href="structstan_1_1math_1_1internal_1_1change__eigen__options__impl.html">internal::change_eigen_options_impl</a>&lt; <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; std::decay_t&lt; Mat &gt; &gt;, NewOptions &gt;::type</td></tr>
<tr class="memdesc:a262f0bbc91c3ceb4e56c7d582a94238a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the options of an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix or array.  <br /></td></tr>
<tr class="separator:a262f0bbc91c3ceb4e56c7d582a94238a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe75d9025a62ed58292f17f09ce61da"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a3fe75d9025a62ed58292f17f09ce61da"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">promote_scalar_t</a> = typename <a class="el" href="structstan_1_1math_1_1promote__scalar__type.html">promote_scalar_type</a>&lt; std::decay_t&lt; T &gt;, std::decay_t&lt; S &gt; &gt;::type</td></tr>
<tr class="separator:a3fe75d9025a62ed58292f17f09ce61da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1478180b7648f5b65e0ba8d884577196"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1478180b7648f5b65e0ba8d884577196.html#a1478180b7648f5b65e0ba8d884577196">ChainableStack</a> = <a class="el" href="structstan_1_1math_1_1_autodiff_stack_singleton.html">AutodiffStackSingleton</a>&lt; <a class="el" href="classstan_1_1math_1_1vari__base.html">vari_base</a>, <a class="el" href="classstan_1_1math_1_1chainable__alloc.html">chainable_alloc</a> &gt;</td></tr>
<tr class="separator:a1478180b7648f5b65e0ba8d884577196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49098e039d56b27054ae93e6644d847"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac49098e039d56b27054ae93e6644d847.html#ac49098e039d56b27054ae93e6644d847">precomputed_gradients_vari</a> = <a class="el" href="classstan_1_1math_1_1precomputed__gradients__vari__template.html">precomputed_gradients_vari_template</a>&lt; std::tuple&lt;&gt;, std::tuple&lt;&gt; &gt;</td></tr>
<tr class="separator:ac49098e039d56b27054ae93e6644d847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab94f7d025f462907958259d7246d43"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeab94f7d025f462907958259d7246d43.html#aeab94f7d025f462907958259d7246d43">profile_key</a> = std::pair&lt; std::string, std::thread::id &gt;</td></tr>
<tr class="separator:aeab94f7d025f462907958259d7246d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2987607977388020c006e04c7688986a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2987607977388020c006e04c7688986a.html#a2987607977388020c006e04c7688986a">profile_map</a> = tbb::concurrent_unordered_map&lt; <a class="el" href="namespacestan_1_1math_aeab94f7d025f462907958259d7246d43.html#aeab94f7d025f462907958259d7246d43">profile_key</a>, <a class="el" href="classstan_1_1math_1_1profile__info.html">profile_info</a>, <a class="el" href="structstan_1_1math_1_1internal_1_1hash__profile__key.html">internal::hash_profile_key</a>, <a class="el" href="structstan_1_1math_1_1internal_1_1equal__profile__key.html">internal::equal_profile_key</a> &gt;</td></tr>
<tr class="separator:a2987607977388020c006e04c7688986a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1b132685d7ca52bbeb05731a5674d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3a1b132685d7ca52bbeb05731a5674d5.html#a3a1b132685d7ca52bbeb05731a5674d5">matrix_v</a> = Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a3a1b132685d7ca52bbeb05731a5674d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a matrix holding <code>var</code> values.  <br /></td></tr>
<tr class="separator:a3a1b132685d7ca52bbeb05731a5674d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8c89394ec1b09c99d6a5bd2eabfba5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab8c89394ec1b09c99d6a5bd2eabfba5.html#aab8c89394ec1b09c99d6a5bd2eabfba5">vector_v</a> = Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:aab8c89394ec1b09c99d6a5bd2eabfba5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a (column) vector holding <code>var</code> values.  <br /></td></tr>
<tr class="separator:aab8c89394ec1b09c99d6a5bd2eabfba5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42483d058e437874b89ced9a3add3e9b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a42483d058e437874b89ced9a3add3e9b.html#a42483d058e437874b89ced9a3add3e9b">row_vector_v</a> = Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a42483d058e437874b89ced9a3add3e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a row vector holding <code>var</code> values.  <br /></td></tr>
<tr class="separator:a42483d058e437874b89ced9a3add3e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0453aa14ed8e8f9963ad346ea9c9f6c5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0453aa14ed8e8f9963ad346ea9c9f6c5.html#a0453aa14ed8e8f9963ad346ea9c9f6c5">matrix_vi</a> = Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> *, Eigen::Dynamic, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:a0453aa14ed8e8f9963ad346ea9c9f6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a matrix holding <code>vari*</code> values.  <br /></td></tr>
<tr class="separator:a0453aa14ed8e8f9963ad346ea9c9f6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e37d2da65eb3dac4b57e7d4d89cd23d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9e37d2da65eb3dac4b57e7d4d89cd23d.html#a9e37d2da65eb3dac4b57e7d4d89cd23d">vector_vi</a> = Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> *, Eigen::Dynamic, 1 &gt;</td></tr>
<tr class="memdesc:a9e37d2da65eb3dac4b57e7d4d89cd23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a (column) vector holding <code>vari*</code> values.  <br /></td></tr>
<tr class="separator:a9e37d2da65eb3dac4b57e7d4d89cd23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fbf381dbc3d352d29919b2b8d8ea71"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa9fbf381dbc3d352d29919b2b8d8ea71.html#aa9fbf381dbc3d352d29919b2b8d8ea71">row_vector_vi</a> = Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> *, 1, Eigen::Dynamic &gt;</td></tr>
<tr class="memdesc:aa9fbf381dbc3d352d29919b2b8d8ea71"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of a row vector holding <code>vari*</code> values.  <br /></td></tr>
<tr class="separator:aa9fbf381dbc3d352d29919b2b8d8ea71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1141ed12907bf4b7c268faa6126762"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> = <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; double &gt;</td></tr>
<tr class="separator:abf1141ed12907bf4b7c268faa6126762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ee1c81e14d0a137cfd8bc8f1ddac46"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> = <a class="el" href="classstan_1_1math_1_1vari__value.html">vari_value</a>&lt; double &gt;</td></tr>
<tr class="separator:a61ee1c81e14d0a137cfd8bc8f1ddac46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac87ada2bc2f3a7388f0c092d906f11f8"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac87ada2bc2f3a7388f0c092d906f11f8.html#ac87ada2bc2f3a7388f0c092d906f11f8">assign_op_cl</a> { <br />
&#160;&#160;<a class="el" href="namespacestan_1_1math_ac87ada2bc2f3a7388f0c092d906f11f8.html#ac87ada2bc2f3a7388f0c092d906f11f8a51c3f59625962b899c03595d6cdfb284">equals</a>
, <br />
&#160;&#160;<a class="el" href="namespacestan_1_1math_ac87ada2bc2f3a7388f0c092d906f11f8.html#ac87ada2bc2f3a7388f0c092d906f11f8a01d3d673eedecf1dd544acb3099759de">plus_equals</a>
, <br />
&#160;&#160;<a class="el" href="namespacestan_1_1math_ac87ada2bc2f3a7388f0c092d906f11f8.html#ac87ada2bc2f3a7388f0c092d906f11f8a53fe413abd6a90b5cdf5883287908f60">minus_equals</a>
, <br />
&#160;&#160;<a class="el" href="namespacestan_1_1math_ac87ada2bc2f3a7388f0c092d906f11f8.html#ac87ada2bc2f3a7388f0c092d906f11f8ac249e77e5901a1ce89a7dd258e84defb">divide_equals</a>
, <br />
&#160;&#160;<a class="el" href="namespacestan_1_1math_ac87ada2bc2f3a7388f0c092d906f11f8.html#ac87ada2bc2f3a7388f0c092d906f11f8ab9e749b16d0fde00390fc09231977cb7">multiply_equals</a>
<br />
 }</td></tr>
<tr class="memdesc:ac87ada2bc2f3a7388f0c092d906f11f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ops that decide the type of assignment for LHS operations.  <a href="namespacestan_1_1math_ac87ada2bc2f3a7388f0c092d906f11f8.html#ac87ada2bc2f3a7388f0c092d906f11f8">More...</a><br /></td></tr>
<tr class="separator:ac87ada2bc2f3a7388f0c092d906f11f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9528c837d04c7f4d0a92b8f9e3238925"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> { <br />
&#160;&#160;<a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925a9ac677ee4eec25d9e59707a661d2c5e1">Diagonal</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925ab75fcdd2d72d9e000beab48622402d93">Lower</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925a19de5b94f7b83900d4b296d9fa491aec">Upper</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925a54851ed2f0a6af25a1b7fdaf83df6a1f">Entire</a> = 3
<br />
 }</td></tr>
<tr class="separator:a9528c837d04c7f4d0a92b8f9e3238925"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5b0dbe10537c33325d1663707365740f"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__col__vector__types_ga16729dba6fafa4f518defdf9cccd3488.html#ga16729dba6fafa4f518defdf9cccd3488">require_eigen_col_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5b0dbe10537c33325d1663707365740f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5b0dbe10537c33325d1663707365740f.html#a5b0dbe10537c33325d1663707365740f">unit_vector_constrain</a> (const EigMat &amp;y)</td></tr>
<tr class="separator:a5b0dbe10537c33325d1663707365740f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83c2d6f94d37cf1a07a0636a6be7abd"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename T , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, EigMat &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af83c2d6f94d37cf1a07a0636a6be7abd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af83c2d6f94d37cf1a07a0636a6be7abd.html#af83c2d6f94d37cf1a07a0636a6be7abd">unit_vector_constrain</a> (const EigMat &amp;y, T &amp;lp)</td></tr>
<tr class="separator:af83c2d6f94d37cf1a07a0636a6be7abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c9323f83643d7adf1e21794c480d1d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa3c9323f83643d7adf1e21794c480d1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa3c9323f83643d7adf1e21794c480d1d.html#aa3c9323f83643d7adf1e21794c480d1d">operator+</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:aa3c9323f83643d7adf1e21794c480d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified forward mode addends.  <br /></td></tr>
<tr class="separator:aa3c9323f83643d7adf1e21794c480d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafdcdda7bd94f37da800fa4c6a13e954"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aafdcdda7bd94f37da800fa4c6a13e954"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aafdcdda7bd94f37da800fa4c6a13e954.html#aafdcdda7bd94f37da800fa4c6a13e954">operator+</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:aafdcdda7bd94f37da800fa4c6a13e954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified double and forward mode addends.  <br /></td></tr>
<tr class="separator:aafdcdda7bd94f37da800fa4c6a13e954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72d73366cac96cb49759be6359a01e0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad72d73366cac96cb49759be6359a01e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad72d73366cac96cb49759be6359a01e0.html#ad72d73366cac96cb49759be6359a01e0">operator+</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="memdesc:ad72d73366cac96cb49759be6359a01e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified forward mode and double addends.  <br /></td></tr>
<tr class="separator:ad72d73366cac96cb49759be6359a01e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1920c4ddebeadf8d01fc5ad94afb034e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1920c4ddebeadf8d01fc5ad94afb034e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1920c4ddebeadf8d01fc5ad94afb034e.html#a1920c4ddebeadf8d01fc5ad94afb034e">operator/</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a1920c4ddebeadf8d01fc5ad94afb034e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of dividing the first argument by the second.  <br /></td></tr>
<tr class="separator:a1920c4ddebeadf8d01fc5ad94afb034e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850fed611f834985cec929c9bd96cb60"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a850fed611f834985cec929c9bd96cb60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a850fed611f834985cec929c9bd96cb60.html#a850fed611f834985cec929c9bd96cb60">operator/</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, U x2)</td></tr>
<tr class="memdesc:a850fed611f834985cec929c9bd96cb60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of dividing the first argument by the second.  <br /></td></tr>
<tr class="separator:a850fed611f834985cec929c9bd96cb60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c02e43a684075967b56240607643332"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3c02e43a684075967b56240607643332"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3c02e43a684075967b56240607643332.html#a3c02e43a684075967b56240607643332">operator/</a> (U x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a3c02e43a684075967b56240607643332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of dividing the first argument by the second.  <br /></td></tr>
<tr class="separator:a3c02e43a684075967b56240607643332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49d0f9915a5e8df1fcec4a68efbaba4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa49d0f9915a5e8df1fcec4a68efbaba4"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa49d0f9915a5e8df1fcec4a68efbaba4.html#aa49d0f9915a5e8df1fcec4a68efbaba4">operator/</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;x1, const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;x2)</td></tr>
<tr class="separator:aa49d0f9915a5e8df1fcec4a68efbaba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0d803e870debb134af75263616c87c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abf0d803e870debb134af75263616c87c"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abf0d803e870debb134af75263616c87c.html#abf0d803e870debb134af75263616c87c">operator/</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;x1, const std::complex&lt; U &gt; &amp;x2)</td></tr>
<tr class="separator:abf0d803e870debb134af75263616c87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa239aab922d48312c203f7b172f1afaa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa239aab922d48312c203f7b172f1afaa"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa239aab922d48312c203f7b172f1afaa.html#aa239aab922d48312c203f7b172f1afaa">operator/</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:aa239aab922d48312c203f7b172f1afaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62148604112dab952ea41b233cd4b43b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a62148604112dab952ea41b233cd4b43b"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a62148604112dab952ea41b233cd4b43b.html#a62148604112dab952ea41b233cd4b43b">operator/</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;x1, U x2)</td></tr>
<tr class="separator:a62148604112dab952ea41b233cd4b43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1f8bdf56bcaa7b95a5fad710520521"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8d1f8bdf56bcaa7b95a5fad710520521"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8d1f8bdf56bcaa7b95a5fad710520521.html#a8d1f8bdf56bcaa7b95a5fad710520521">operator/</a> (const std::complex&lt; U &gt; &amp;x1, const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;x2)</td></tr>
<tr class="separator:a8d1f8bdf56bcaa7b95a5fad710520521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07de261501b87a5b422f7f52033958c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae07de261501b87a5b422f7f52033958c"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae07de261501b87a5b422f7f52033958c.html#ae07de261501b87a5b422f7f52033958c">operator/</a> (const std::complex&lt; U &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:ae07de261501b87a5b422f7f52033958c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd01034feb6dae429fe8b315f097566"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abdd01034feb6dae429fe8b315f097566"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abdd01034feb6dae429fe8b315f097566.html#abdd01034feb6dae429fe8b315f097566">operator/</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;x2)</td></tr>
<tr class="separator:abdd01034feb6dae429fe8b315f097566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8f6ca4b8249fbd46407569c3b2dd2f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , typename  = std::enable_if_t&lt;std::is_arithmetic&lt;U&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a0c8f6ca4b8249fbd46407569c3b2dd2f"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0c8f6ca4b8249fbd46407569c3b2dd2f.html#a0c8f6ca4b8249fbd46407569c3b2dd2f">operator/</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const std::complex&lt; U &gt; &amp;x2)</td></tr>
<tr class="separator:a0c8f6ca4b8249fbd46407569c3b2dd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0d3d26056e24120165ed369def9d88"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0a0d3d26056e24120165ed369def9d88"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0a0d3d26056e24120165ed369def9d88.html#a0a0d3d26056e24120165ed369def9d88">operator/</a> (U x1, const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;x2)</td></tr>
<tr class="separator:a0a0d3d26056e24120165ed369def9d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431129b4a75d77ab60f6cd749bef5a11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a431129b4a75d77ab60f6cd749bef5a11"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a431129b4a75d77ab60f6cd749bef5a11.html#a431129b4a75d77ab60f6cd749bef5a11">operator==</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a431129b4a75d77ab60f6cd749bef5a11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified variables have equal values as defined by <code>==</code>.  <br /></td></tr>
<tr class="separator:a431129b4a75d77ab60f6cd749bef5a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15161ab182b02d135f79a13d68c7318d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15161ab182b02d135f79a13d68c7318d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a15161ab182b02d135f79a13d68c7318d.html#a15161ab182b02d135f79a13d68c7318d">operator==</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:a15161ab182b02d135f79a13d68c7318d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the the first variable has a value equal to the second argument as defined by by <code>==</code>.  <br /></td></tr>
<tr class="separator:a15161ab182b02d135f79a13d68c7318d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4930059b979a995acd759a0746bfc201"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4930059b979a995acd759a0746bfc201"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4930059b979a995acd759a0746bfc201.html#a4930059b979a995acd759a0746bfc201">operator==</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a4930059b979a995acd759a0746bfc201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the the first argument is equal to the value of the second argument as defined by by <code>==</code>.  <br /></td></tr>
<tr class="separator:a4930059b979a995acd759a0746bfc201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17fefa51b18df1adec77e49f4e792fbc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17fefa51b18df1adec77e49f4e792fbc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a17fefa51b18df1adec77e49f4e792fbc.html#a17fefa51b18df1adec77e49f4e792fbc">operator&gt;</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a17fefa51b18df1adec77e49f4e792fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument has a greater value than the second as defined by <code>&gt;</code>.  <br /></td></tr>
<tr class="separator:a17fefa51b18df1adec77e49f4e792fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c850c94b22aab8ffd895bdf8faebded"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c850c94b22aab8ffd895bdf8faebded"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9c850c94b22aab8ffd895bdf8faebded.html#a9c850c94b22aab8ffd895bdf8faebded">operator&gt;</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:a9c850c94b22aab8ffd895bdf8faebded"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument has a greater value than the second as defined by <code>&gt;</code>.  <br /></td></tr>
<tr class="separator:a9c850c94b22aab8ffd895bdf8faebded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7b92bb244d32edb94b17c8039ae826"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba7b92bb244d32edb94b17c8039ae826"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aba7b92bb244d32edb94b17c8039ae826.html#aba7b92bb244d32edb94b17c8039ae826">operator&gt;</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:aba7b92bb244d32edb94b17c8039ae826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument has a greater value than the second as defined by <code>&gt;</code>.  <br /></td></tr>
<tr class="separator:aba7b92bb244d32edb94b17c8039ae826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dee5c21281cc75cad8ebf9f6c43b98f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5dee5c21281cc75cad8ebf9f6c43b98f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5dee5c21281cc75cad8ebf9f6c43b98f.html#a5dee5c21281cc75cad8ebf9f6c43b98f">operator&gt;=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a5dee5c21281cc75cad8ebf9f6c43b98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the value of the first argument is greater than or equal to that of the second as defined by <code>&gt;=</code>.  <br /></td></tr>
<tr class="separator:a5dee5c21281cc75cad8ebf9f6c43b98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2097caea2b790905ee2948ef72727df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2097caea2b790905ee2948ef72727df"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac2097caea2b790905ee2948ef72727df.html#ac2097caea2b790905ee2948ef72727df">operator&gt;=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:ac2097caea2b790905ee2948ef72727df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the value of the first argument has a value greater than or equal to the second argument as defined by <code>&gt;=</code>.  <br /></td></tr>
<tr class="separator:ac2097caea2b790905ee2948ef72727df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813edaa4311e1a4c206952f75a85eba8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a813edaa4311e1a4c206952f75a85eba8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a813edaa4311e1a4c206952f75a85eba8.html#a813edaa4311e1a4c206952f75a85eba8">operator&gt;=</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a813edaa4311e1a4c206952f75a85eba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument is greater than or equal to the value of the second argument as defined by <code>&gt;=</code>.  <br /></td></tr>
<tr class="separator:a813edaa4311e1a4c206952f75a85eba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b0c7ff4961eb7333aa81f685da55f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50b0c7ff4961eb7333aa81f685da55f4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a50b0c7ff4961eb7333aa81f685da55f4.html#a50b0c7ff4961eb7333aa81f685da55f4">operator&lt;</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a50b0c7ff4961eb7333aa81f685da55f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument has a value less than the value of the second argument as defined by <code>&lt;</code>.  <br /></td></tr>
<tr class="separator:a50b0c7ff4961eb7333aa81f685da55f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0194df340cc3564835ff04086374cf97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0194df340cc3564835ff04086374cf97"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0194df340cc3564835ff04086374cf97.html#a0194df340cc3564835ff04086374cf97">operator&lt;</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a0194df340cc3564835ff04086374cf97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument is less than the value of the second argument as defined by <code>&lt;</code>.  <br /></td></tr>
<tr class="separator:a0194df340cc3564835ff04086374cf97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2c489941c560664036ee190c9028360"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af2c489941c560664036ee190c9028360"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af2c489941c560664036ee190c9028360.html#af2c489941c560664036ee190c9028360">operator&lt;</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:af2c489941c560664036ee190c9028360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument has a value less than the second argument as defined by <code>&lt;</code>.  <br /></td></tr>
<tr class="separator:af2c489941c560664036ee190c9028360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450ef8aaef08c3137f70a087ae3905c6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a450ef8aaef08c3137f70a087ae3905c6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a450ef8aaef08c3137f70a087ae3905c6.html#a450ef8aaef08c3137f70a087ae3905c6">operator&lt;=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a450ef8aaef08c3137f70a087ae3905c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument has a value less than or equal to the value of the second argument as defined by <code>&lt;=</code>.  <br /></td></tr>
<tr class="separator:a450ef8aaef08c3137f70a087ae3905c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95d660226997cbba13176cec459adaf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab95d660226997cbba13176cec459adaf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab95d660226997cbba13176cec459adaf.html#ab95d660226997cbba13176cec459adaf">operator&lt;=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:ab95d660226997cbba13176cec459adaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument has a value less than or equal to the second argument as defined by <code>&lt;=</code>.  <br /></td></tr>
<tr class="separator:ab95d660226997cbba13176cec459adaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5de0aa5a40e981ece663f96ad41997"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca5de0aa5a40e981ece663f96ad41997"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aca5de0aa5a40e981ece663f96ad41997.html#aca5de0aa5a40e981ece663f96ad41997">operator&lt;=</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:aca5de0aa5a40e981ece663f96ad41997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument is less than or equal to the second argument's value as defined by <code>&lt;=</code>.  <br /></td></tr>
<tr class="separator:aca5de0aa5a40e981ece663f96ad41997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921c589235fb3b02790ae0c72d0cbb97"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a921c589235fb3b02790ae0c72d0cbb97"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a921c589235fb3b02790ae0c72d0cbb97.html#a921c589235fb3b02790ae0c72d0cbb97">operator&amp;&amp;</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a921c589235fb3b02790ae0c72d0cbb97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical conjunction of the values of the two arguments as defined by <code>&amp;&amp;</code>.  <br /></td></tr>
<tr class="separator:a921c589235fb3b02790ae0c72d0cbb97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894b3696d8c6ff62a4f048f09ce5d9d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a894b3696d8c6ff62a4f048f09ce5d9d7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a894b3696d8c6ff62a4f048f09ce5d9d7.html#a894b3696d8c6ff62a4f048f09ce5d9d7">operator&amp;&amp;</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:a894b3696d8c6ff62a4f048f09ce5d9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical conjunction of the values of the two arguments as defined by <code>&amp;&amp;</code>.  <br /></td></tr>
<tr class="separator:a894b3696d8c6ff62a4f048f09ce5d9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811bbfb8303583dace9a03927066f3b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a811bbfb8303583dace9a03927066f3b9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a811bbfb8303583dace9a03927066f3b9.html#a811bbfb8303583dace9a03927066f3b9">operator&amp;&amp;</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a811bbfb8303583dace9a03927066f3b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical conjunction of the values of the two arguments as defined by <code>&amp;&amp;</code>.  <br /></td></tr>
<tr class="separator:a811bbfb8303583dace9a03927066f3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870df08c01d3f20b6d309490007cd891"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a870df08c01d3f20b6d309490007cd891"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a870df08c01d3f20b6d309490007cd891.html#a870df08c01d3f20b6d309490007cd891">operator||</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a870df08c01d3f20b6d309490007cd891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical disjunction of the values of the two arguments as defined by <code>||</code>.  <br /></td></tr>
<tr class="separator:a870df08c01d3f20b6d309490007cd891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5214b079d9b04b99cd67d232198cafd7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5214b079d9b04b99cd67d232198cafd7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5214b079d9b04b99cd67d232198cafd7.html#a5214b079d9b04b99cd67d232198cafd7">operator||</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:a5214b079d9b04b99cd67d232198cafd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical disjunction of the values of the two arguments as defined by <code>||</code>.  <br /></td></tr>
<tr class="separator:a5214b079d9b04b99cd67d232198cafd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcd53339db17c038636407786822243"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7fcd53339db17c038636407786822243"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7fcd53339db17c038636407786822243.html#a7fcd53339db17c038636407786822243">operator||</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a7fcd53339db17c038636407786822243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical disjunction of the values of the two arguments as defined by <code>||</code>.  <br /></td></tr>
<tr class="separator:a7fcd53339db17c038636407786822243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281ceef7713d3dce22bcf6eb7dccc49c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a281ceef7713d3dce22bcf6eb7dccc49c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a281ceef7713d3dce22bcf6eb7dccc49c.html#a281ceef7713d3dce22bcf6eb7dccc49c">operator*</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a281ceef7713d3dce22bcf6eb7dccc49c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the two arguments.  <br /></td></tr>
<tr class="separator:a281ceef7713d3dce22bcf6eb7dccc49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3f10f930319fe7a3cd091532349756"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3f3f10f930319fe7a3cd091532349756"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3f3f10f930319fe7a3cd091532349756.html#a3f3f10f930319fe7a3cd091532349756">operator*</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a3f3f10f930319fe7a3cd091532349756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the two arguments.  <br /></td></tr>
<tr class="separator:a3f3f10f930319fe7a3cd091532349756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ccc0821898c37b4d8a4cbe944668f2d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ccc0821898c37b4d8a4cbe944668f2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4ccc0821898c37b4d8a4cbe944668f2d.html#a4ccc0821898c37b4d8a4cbe944668f2d">operator*</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:a4ccc0821898c37b4d8a4cbe944668f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the two arguments.  <br /></td></tr>
<tr class="separator:a4ccc0821898c37b4d8a4cbe944668f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96926bba7791f82fbe15ce0041db7d3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad96926bba7791f82fbe15ce0041db7d3"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad96926bba7791f82fbe15ce0041db7d3.html#ad96926bba7791f82fbe15ce0041db7d3">operator*</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt; &gt; &amp;x, const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="memdesc:ad96926bba7791f82fbe15ce0041db7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the two complex fvar&lt;T&gt; arguments.  <br /></td></tr>
<tr class="separator:ad96926bba7791f82fbe15ce0041db7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd10c6a5843ac94c58c0154854b59f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9fd10c6a5843ac94c58c0154854b59f8"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9fd10c6a5843ac94c58c0154854b59f8.html#a9fd10c6a5843ac94c58c0154854b59f8">operator*</a> (const std::complex&lt; double &gt; &amp;x, const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt; &gt; &amp;y)</td></tr>
<tr class="memdesc:a9fd10c6a5843ac94c58c0154854b59f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of std::complex&lt;double&gt; and std::complex&lt;fvar&lt;T&gt;&gt; arguments.  <br /></td></tr>
<tr class="separator:a9fd10c6a5843ac94c58c0154854b59f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991ca1d79717a2d8603a55d03385cad1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a991ca1d79717a2d8603a55d03385cad1"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a991ca1d79717a2d8603a55d03385cad1.html#a991ca1d79717a2d8603a55d03385cad1">operator*</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">stan::math::fvar</a>&lt; T &gt; &gt; &amp;x, const std::complex&lt; double &gt; &amp;y)</td></tr>
<tr class="memdesc:a991ca1d79717a2d8603a55d03385cad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of std::complex&lt;double&gt; and std::complex&lt;fvar&lt;T&gt;&gt; arguments.  <br /></td></tr>
<tr class="separator:a991ca1d79717a2d8603a55d03385cad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65438bf17da7bbedb06bc7c381cea865"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65438bf17da7bbedb06bc7c381cea865"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a65438bf17da7bbedb06bc7c381cea865.html#a65438bf17da7bbedb06bc7c381cea865">operator!=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a65438bf17da7bbedb06bc7c381cea865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the value of the two arguments are not equal as defined by <code>!=</code>.  <br /></td></tr>
<tr class="separator:a65438bf17da7bbedb06bc7c381cea865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e121241958fdcc4d2190bc532e9bc5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a41e121241958fdcc4d2190bc532e9bc5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a41e121241958fdcc4d2190bc532e9bc5.html#a41e121241958fdcc4d2190bc532e9bc5">operator!=</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:a41e121241958fdcc4d2190bc532e9bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the value of the first argument is not equal to the second argument as defined by <code>!=</code>.  <br /></td></tr>
<tr class="separator:a41e121241958fdcc4d2190bc532e9bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae982faec66434385fda1c728b0b2bf3d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae982faec66434385fda1c728b0b2bf3d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae982faec66434385fda1c728b0b2bf3d.html#ae982faec66434385fda1c728b0b2bf3d">operator!=</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:ae982faec66434385fda1c728b0b2bf3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the first argument is not equal to the value of the second argument as defined by <code>!=</code>.  <br /></td></tr>
<tr class="separator:ae982faec66434385fda1c728b0b2bf3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf7f119b1757ca7f89fe6c2a16cc1fb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1cf7f119b1757ca7f89fe6c2a16cc1fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1cf7f119b1757ca7f89fe6c2a16cc1fb.html#a1cf7f119b1757ca7f89fe6c2a16cc1fb">operator-</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a1cf7f119b1757ca7f89fe6c2a16cc1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of the specified arguments.  <br /></td></tr>
<tr class="separator:a1cf7f119b1757ca7f89fe6c2a16cc1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4843a3600ff3f2eaf35ddc21c9e48280"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4843a3600ff3f2eaf35ddc21c9e48280"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4843a3600ff3f2eaf35ddc21c9e48280.html#a4843a3600ff3f2eaf35ddc21c9e48280">operator-</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a4843a3600ff3f2eaf35ddc21c9e48280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of the specified arguments.  <br /></td></tr>
<tr class="separator:a4843a3600ff3f2eaf35ddc21c9e48280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bfd063f3b4e10b99918688361f134c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa0bfd063f3b4e10b99918688361f134c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa0bfd063f3b4e10b99918688361f134c.html#aa0bfd063f3b4e10b99918688361f134c">operator-</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="memdesc:aa0bfd063f3b4e10b99918688361f134c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of the specified arguments.  <br /></td></tr>
<tr class="separator:aa0bfd063f3b4e10b99918688361f134c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d14f76ae4eecc53dcce53aad8e7f008"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d14f76ae4eecc53dcce53aad8e7f008"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0d14f76ae4eecc53dcce53aad8e7f008.html#a0d14f76ae4eecc53dcce53aad8e7f008">operator-</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a0d14f76ae4eecc53dcce53aad8e7f008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negation of the specified argument.  <br /></td></tr>
<tr class="separator:a0d14f76ae4eecc53dcce53aad8e7f008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a42c3b738d9cc30ea0494cc80c7443"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2a42c3b738d9cc30ea0494cc80c7443"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae2a42c3b738d9cc30ea0494cc80c7443.html#ae2a42c3b738d9cc30ea0494cc80c7443">operator!</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:ae2a42c3b738d9cc30ea0494cc80c7443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negation of the value of the argument as defined by <code>!</code>.  <br /></td></tr>
<tr class="separator:ae2a42c3b738d9cc30ea0494cc80c7443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a71691368cb480fab0bde8acc3aed3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a93a71691368cb480fab0bde8acc3aed3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a93a71691368cb480fab0bde8acc3aed3.html#a93a71691368cb480fab0bde8acc3aed3">operator+</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a93a71691368cb480fab0bde8acc3aed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the argument.  <br /></td></tr>
<tr class="separator:a93a71691368cb480fab0bde8acc3aed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07668d449deca145c19b0feaf564f789"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a07668d449deca145c19b0feaf564f789"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a07668d449deca145c19b0feaf564f789.html#a07668d449deca145c19b0feaf564f789">abs</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a07668d449deca145c19b0feaf564f789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b0fd0a4a0dc99b7d2976c86d0ed2488"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b0fd0a4a0dc99b7d2976c86d0ed2488"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7b0fd0a4a0dc99b7d2976c86d0ed2488.html#a7b0fd0a4a0dc99b7d2976c86d0ed2488">abs</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:a7b0fd0a4a0dc99b7d2976c86d0ed2488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute value of the complex argument.  <br /></td></tr>
<tr class="separator:a7b0fd0a4a0dc99b7d2976c86d0ed2488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0225b71faa7dc05c3fd41e70dc6cc34b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0225b71faa7dc05c3fd41e70dc6cc34b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0225b71faa7dc05c3fd41e70dc6cc34b.html#a0225b71faa7dc05c3fd41e70dc6cc34b">acos</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a0225b71faa7dc05c3fd41e70dc6cc34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21ce95be53a6cdaefdb698e5f1650a9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac21ce95be53a6cdaefdb698e5f1650a9"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac21ce95be53a6cdaefdb698e5f1650a9.html#ac21ce95be53a6cdaefdb698e5f1650a9">acos</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;x)</td></tr>
<tr class="memdesc:ac21ce95be53a6cdaefdb698e5f1650a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arc cosine of the complex argument.  <br /></td></tr>
<tr class="separator:ac21ce95be53a6cdaefdb698e5f1650a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4aba0a2fc965c0abc4ea84508a09e3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f4aba0a2fc965c0abc4ea84508a09e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1f4aba0a2fc965c0abc4ea84508a09e3.html#a1f4aba0a2fc965c0abc4ea84508a09e3">acosh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a1f4aba0a2fc965c0abc4ea84508a09e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508a0c1dc26f6b50193726d3fc9c0f90"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a508a0c1dc26f6b50193726d3fc9c0f90"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a508a0c1dc26f6b50193726d3fc9c0f90.html#a508a0c1dc26f6b50193726d3fc9c0f90">acosh</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:a508a0c1dc26f6b50193726d3fc9c0f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arc cosine of the complex argument.  <br /></td></tr>
<tr class="separator:a508a0c1dc26f6b50193726d3fc9c0f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500fda68d64f44323202b69ffa804f5f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a500fda68d64f44323202b69ffa804f5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a500fda68d64f44323202b69ffa804f5f.html#a500fda68d64f44323202b69ffa804f5f">arg</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:a500fda68d64f44323202b69ffa804f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the phase angle of the complex argument.  <br /></td></tr>
<tr class="separator:a500fda68d64f44323202b69ffa804f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b48158d54565231ca3a7328c11eb21"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7b48158d54565231ca3a7328c11eb21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad7b48158d54565231ca3a7328c11eb21.html#ad7b48158d54565231ca3a7328c11eb21">asin</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ad7b48158d54565231ca3a7328c11eb21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea908b00cc9137f5aa42852831139e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afea908b00cc9137f5aa42852831139e5"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afea908b00cc9137f5aa42852831139e5.html#afea908b00cc9137f5aa42852831139e5">asin</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:afea908b00cc9137f5aa42852831139e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arc sine of the complex argument.  <br /></td></tr>
<tr class="separator:afea908b00cc9137f5aa42852831139e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1a957be54c795baae42c74c9e53149"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4a1a957be54c795baae42c74c9e53149"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a1a957be54c795baae42c74c9e53149.html#a4a1a957be54c795baae42c74c9e53149">asinh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a4a1a957be54c795baae42c74c9e53149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27fc8b54c3cec118263895ef946ff27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af27fc8b54c3cec118263895ef946ff27"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af27fc8b54c3cec118263895ef946ff27.html#af27fc8b54c3cec118263895ef946ff27">asinh</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:af27fc8b54c3cec118263895ef946ff27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arcsine of the complex argument.  <br /></td></tr>
<tr class="separator:af27fc8b54c3cec118263895ef946ff27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83986a2a7953042a141b6d808763bd88"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a83986a2a7953042a141b6d808763bd88"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a83986a2a7953042a141b6d808763bd88.html#a83986a2a7953042a141b6d808763bd88">atan</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a83986a2a7953042a141b6d808763bd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce3e90ed22feeb14db3124698447c20"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8ce3e90ed22feeb14db3124698447c20"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8ce3e90ed22feeb14db3124698447c20.html#a8ce3e90ed22feeb14db3124698447c20">atan</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:a8ce3e90ed22feeb14db3124698447c20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arc tangent of the complex argument.  <br /></td></tr>
<tr class="separator:a8ce3e90ed22feeb14db3124698447c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed54632759bb9aa5acb08f4cc26fc56"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ed54632759bb9aa5acb08f4cc26fc56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3ed54632759bb9aa5acb08f4cc26fc56.html#a3ed54632759bb9aa5acb08f4cc26fc56">atan2</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a3ed54632759bb9aa5acb08f4cc26fc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e35011a92d17289235290cc4cb9e536"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e35011a92d17289235290cc4cb9e536"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9e35011a92d17289235290cc4cb9e536.html#a9e35011a92d17289235290cc4cb9e536">atan2</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a9e35011a92d17289235290cc4cb9e536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a952fb66adb3f17c688d8f41ff822a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9a952fb66adb3f17c688d8f41ff822a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af9a952fb66adb3f17c688d8f41ff822a.html#af9a952fb66adb3f17c688d8f41ff822a">atan2</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:af9a952fb66adb3f17c688d8f41ff822a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cabe7a1ea8293228faa9e77f6eb1203"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2cabe7a1ea8293228faa9e77f6eb1203"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2cabe7a1ea8293228faa9e77f6eb1203.html#a2cabe7a1ea8293228faa9e77f6eb1203">atanh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a2cabe7a1ea8293228faa9e77f6eb1203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return inverse hyperbolic tangent of specified value.  <br /></td></tr>
<tr class="separator:a2cabe7a1ea8293228faa9e77f6eb1203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbeff704625bedff73f9ce3da30fd842"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acbeff704625bedff73f9ce3da30fd842"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acbeff704625bedff73f9ce3da30fd842.html#acbeff704625bedff73f9ce3da30fd842">atanh</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:acbeff704625bedff73f9ce3da30fd842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arc tangent of the complex argument.  <br /></td></tr>
<tr class="separator:acbeff704625bedff73f9ce3da30fd842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bbfda2b69ee6211f6142ec2ee242b7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af5bbfda2b69ee6211f6142ec2ee242b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af5bbfda2b69ee6211f6142ec2ee242b7.html#af5bbfda2b69ee6211f6142ec2ee242b7">bessel_first_kind</a> (int v, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:af5bbfda2b69ee6211f6142ec2ee242b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f0757d31e5d089675cbac0a88c675a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa0f0757d31e5d089675cbac0a88c675a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa0f0757d31e5d089675cbac0a88c675a.html#aa0f0757d31e5d089675cbac0a88c675a">bessel_second_kind</a> (int v, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:aa0f0757d31e5d089675cbac0a88c675a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99ae904f47e5d734efc6854f1ccf4ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae99ae904f47e5d734efc6854f1ccf4ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:ae99ae904f47e5d734efc6854f1ccf4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return fvar with the beta function applied to the specified arguments and its gradient.  <br /></td></tr>
<tr class="separator:ae99ae904f47e5d734efc6854f1ccf4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f270e0c167824d7d78e76d8054a62d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa9f270e0c167824d7d78e76d8054a62d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa9f270e0c167824d7d78e76d8054a62d.html#aa9f270e0c167824d7d78e76d8054a62d">beta</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:aa9f270e0c167824d7d78e76d8054a62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27d9df13054021c80c4a58fe64decd62"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a27d9df13054021c80c4a58fe64decd62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a27d9df13054021c80c4a58fe64decd62.html#a27d9df13054021c80c4a58fe64decd62">beta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:a27d9df13054021c80c4a58fe64decd62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eba8ef245b0d37c5366dc5e5a71a27"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4eba8ef245b0d37c5366dc5e5a71a27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad4eba8ef245b0d37c5366dc5e5a71a27.html#ad4eba8ef245b0d37c5366dc5e5a71a27">binary_log_loss</a> (int y, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y_hat)</td></tr>
<tr class="separator:ad4eba8ef245b0d37c5366dc5e5a71a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e56cfe7810faca3dd8a2326affacd26"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e56cfe7810faca3dd8a2326affacd26"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6e56cfe7810faca3dd8a2326affacd26.html#a6e56cfe7810faca3dd8a2326affacd26">cbrt</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a6e56cfe7810faca3dd8a2326affacd26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return cube root of specified argument.  <br /></td></tr>
<tr class="separator:a6e56cfe7810faca3dd8a2326affacd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0742bb5eb74b836b005ef099cffc502"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae0742bb5eb74b836b005ef099cffc502"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae0742bb5eb74b836b005ef099cffc502.html#ae0742bb5eb74b836b005ef099cffc502">ceil</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ae0742bb5eb74b836b005ef099cffc502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75cdb29185b7843a24c68e7dfbc3516"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab75cdb29185b7843a24c68e7dfbc3516"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab75cdb29185b7843a24c68e7dfbc3516.html#ab75cdb29185b7843a24c68e7dfbc3516">cos</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ab75cdb29185b7843a24c68e7dfbc3516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6a01b5bef9be153a9e66a7182373e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c6a01b5bef9be153a9e66a7182373e7"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9c6a01b5bef9be153a9e66a7182373e7.html#a9c6a01b5bef9be153a9e66a7182373e7">cos</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:a9c6a01b5bef9be153a9e66a7182373e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cosine of the complex argument.  <br /></td></tr>
<tr class="separator:a9c6a01b5bef9be153a9e66a7182373e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5241e24973fe1e57704814a1a5d939a4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5241e24973fe1e57704814a1a5d939a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5241e24973fe1e57704814a1a5d939a4.html#a5241e24973fe1e57704814a1a5d939a4">cosh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a5241e24973fe1e57704814a1a5d939a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e8ee98b111358d0dd2693b8b42543b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a99e8ee98b111358d0dd2693b8b42543b"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a99e8ee98b111358d0dd2693b8b42543b.html#a99e8ee98b111358d0dd2693b8b42543b">cosh</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:a99e8ee98b111358d0dd2693b8b42543b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic cosine of the complex argument.  <br /></td></tr>
<tr class="separator:a99e8ee98b111358d0dd2693b8b42543b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6e34093bbdb995eaa0e3778876f1e1"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5b6e34093bbdb995eaa0e3778876f1e1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5b6e34093bbdb995eaa0e3778876f1e1.html#a5b6e34093bbdb995eaa0e3778876f1e1">determinant</a> (const EigMat &amp;m)</td></tr>
<tr class="separator:a5b6e34093bbdb995eaa0e3778876f1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87890068b9f3e77a15eb60447ccfd77"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af87890068b9f3e77a15eb60447ccfd77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af87890068b9f3e77a15eb60447ccfd77.html#af87890068b9f3e77a15eb60447ccfd77">digamma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:af87890068b9f3e77a15eb60447ccfd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the derivative of the log gamma function at the specified argument.  <br /></td></tr>
<tr class="separator:af87890068b9f3e77a15eb60447ccfd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f59c3dd3a27e81e8320083e1a0c6c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56f59c3dd3a27e81e8320083e1a0c6c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a56f59c3dd3a27e81e8320083e1a0c6c1.html#a56f59c3dd3a27e81e8320083e1a0c6c1">erf</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a56f59c3dd3a27e81e8320083e1a0c6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9994e6390e4a0c155be10c882072ca34"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9994e6390e4a0c155be10c882072ca34"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9994e6390e4a0c155be10c882072ca34.html#a9994e6390e4a0c155be10c882072ca34">erfc</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a9994e6390e4a0c155be10c882072ca34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb02d174bb7d5c70db81fa1a9996f57"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afeb02d174bb7d5c70db81fa1a9996f57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afeb02d174bb7d5c70db81fa1a9996f57.html#afeb02d174bb7d5c70db81fa1a9996f57">exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:afeb02d174bb7d5c70db81fa1a9996f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab234bffe3e13dd6f1012adae6782f18c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab234bffe3e13dd6f1012adae6782f18c"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab234bffe3e13dd6f1012adae6782f18c.html#ab234bffe3e13dd6f1012adae6782f18c">exp</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:ab234bffe3e13dd6f1012adae6782f18c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural exponentiation (base e) of the specified complex number.  <br /></td></tr>
<tr class="separator:ab234bffe3e13dd6f1012adae6782f18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311f94ed9243524c28e9d30dce8045df"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a311f94ed9243524c28e9d30dce8045df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a311f94ed9243524c28e9d30dce8045df.html#a311f94ed9243524c28e9d30dce8045df">exp2</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a311f94ed9243524c28e9d30dce8045df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23c116678993eabfaf88ab4e92209f31"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a23c116678993eabfaf88ab4e92209f31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a23c116678993eabfaf88ab4e92209f31.html#a23c116678993eabfaf88ab4e92209f31">expm1</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a23c116678993eabfaf88ab4e92209f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c86bad3306a04411a146a90185938f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8c86bad3306a04411a146a90185938f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af8c86bad3306a04411a146a90185938f.html#af8c86bad3306a04411a146a90185938f">fabs</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:af8c86bad3306a04411a146a90185938f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7684e64852beaa124bb048019b09e8c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7684e64852beaa124bb048019b09e8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad7684e64852beaa124bb048019b09e8c.html#ad7684e64852beaa124bb048019b09e8c">falling_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="memdesc:ad7684e64852beaa124bb048019b09e8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return autodiff variable with the gradient and result of the falling factorial function applied to the inputs.  <br /></td></tr>
<tr class="separator:ad7684e64852beaa124bb048019b09e8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188371cf63ba35d4afb3bad5cd98e378"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a188371cf63ba35d4afb3bad5cd98e378"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a188371cf63ba35d4afb3bad5cd98e378.html#a188371cf63ba35d4afb3bad5cd98e378">fdim</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a188371cf63ba35d4afb3bad5cd98e378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference of the specified values (C++11).  <br /></td></tr>
<tr class="separator:a188371cf63ba35d4afb3bad5cd98e378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4acb16cf6144e4c3d87aa278b061b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5c4acb16cf6144e4c3d87aa278b061b6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5c4acb16cf6144e4c3d87aa278b061b6.html#a5c4acb16cf6144e4c3d87aa278b061b6">fdim</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="memdesc:a5c4acb16cf6144e4c3d87aa278b061b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference of the specified values (C++11).  <br /></td></tr>
<tr class="separator:a5c4acb16cf6144e4c3d87aa278b061b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2ae243392a63af3d02eda3b358e3bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f2ae243392a63af3d02eda3b358e3bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9f2ae243392a63af3d02eda3b358e3bd.html#a9f2ae243392a63af3d02eda3b358e3bd">fdim</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a9f2ae243392a63af3d02eda3b358e3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference of the specified values (C++11).  <br /></td></tr>
<tr class="separator:a9f2ae243392a63af3d02eda3b358e3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa828ed40aa78417d100d5cdeae54cd2b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa828ed40aa78417d100d5cdeae54cd2b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa828ed40aa78417d100d5cdeae54cd2b.html#aa828ed40aa78417d100d5cdeae54cd2b">floor</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aa828ed40aa78417d100d5cdeae54cd2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7735a4591faa177d9e9d01ce8c14d46"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af7735a4591faa177d9e9d01ce8c14d46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af7735a4591faa177d9e9d01ce8c14d46.html#af7735a4591faa177d9e9d01ce8c14d46">fma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt; &amp;x2, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T3 &gt; &amp;x3)</td></tr>
<tr class="memdesc:af7735a4591faa177d9e9d01ce8c14d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add operation (C99).  <br /></td></tr>
<tr class="separator:af7735a4591faa177d9e9d01ce8c14d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8a3bda921e9372335febbc279162fa"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aed8a3bda921e9372335febbc279162fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aed8a3bda921e9372335febbc279162fa.html#aed8a3bda921e9372335febbc279162fa">fma</a> (const T1 &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt; &amp;x2, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T3 &gt; &amp;x3)</td></tr>
<tr class="memdesc:aed8a3bda921e9372335febbc279162fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <br /></td></tr>
<tr class="separator:aed8a3bda921e9372335febbc279162fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71aebb0eafa0f37c62f20108ab77e065"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a71aebb0eafa0f37c62f20108ab77e065"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a71aebb0eafa0f37c62f20108ab77e065.html#a71aebb0eafa0f37c62f20108ab77e065">fma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt; &amp;x1, const T2 &amp;x2, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T3 &gt; &amp;x3)</td></tr>
<tr class="memdesc:a71aebb0eafa0f37c62f20108ab77e065"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <br /></td></tr>
<tr class="separator:a71aebb0eafa0f37c62f20108ab77e065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3cab8b1ce81022c92447018d7e52ff"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5f3cab8b1ce81022c92447018d7e52ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5f3cab8b1ce81022c92447018d7e52ff.html#a5f3cab8b1ce81022c92447018d7e52ff">fma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt; &amp;x2, const T3 &amp;x3)</td></tr>
<tr class="memdesc:a5f3cab8b1ce81022c92447018d7e52ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <br /></td></tr>
<tr class="separator:a5f3cab8b1ce81022c92447018d7e52ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e8ddb710f5d962e98f871f55038b76"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a25e8ddb710f5d962e98f871f55038b76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a25e8ddb710f5d962e98f871f55038b76.html#a25e8ddb710f5d962e98f871f55038b76">fma</a> (const T1 &amp;x1, const T2 &amp;x2, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T3 &gt; &amp;x3)</td></tr>
<tr class="memdesc:a25e8ddb710f5d962e98f871f55038b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <br /></td></tr>
<tr class="separator:a25e8ddb710f5d962e98f871f55038b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fc0d232b69f027706cea91b56ef102"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab4fc0d232b69f027706cea91b56ef102"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab4fc0d232b69f027706cea91b56ef102.html#ab4fc0d232b69f027706cea91b56ef102">fma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt; &amp;x1, const T2 &amp;x2, const T3 &amp;x3)</td></tr>
<tr class="memdesc:ab4fc0d232b69f027706cea91b56ef102"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <br /></td></tr>
<tr class="separator:ab4fc0d232b69f027706cea91b56ef102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe5cc58e59cb87f4848b1d43213f178"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aebe5cc58e59cb87f4848b1d43213f178"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aebe5cc58e59cb87f4848b1d43213f178.html#aebe5cc58e59cb87f4848b1d43213f178">fma</a> (const T1 &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt; &amp;x2, const T3 &amp;x3)</td></tr>
<tr class="memdesc:aebe5cc58e59cb87f4848b1d43213f178"><td class="mdescLeft">&#160;</td><td class="mdescRight">See all-var input signature for details on the function and derivatives.  <br /></td></tr>
<tr class="separator:aebe5cc58e59cb87f4848b1d43213f178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95251809634cd7ea7642ef2675a6b15"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa95251809634cd7ea7642ef2675a6b15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa95251809634cd7ea7642ef2675a6b15.html#aa95251809634cd7ea7642ef2675a6b15">fmax</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:aa95251809634cd7ea7642ef2675a6b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greater of the two specified arguments.  <br /></td></tr>
<tr class="separator:aa95251809634cd7ea7642ef2675a6b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92d3404f1be84cb349b3ead6676f16a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af92d3404f1be84cb349b3ead6676f16a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af92d3404f1be84cb349b3ead6676f16a.html#af92d3404f1be84cb349b3ead6676f16a">fmax</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:af92d3404f1be84cb349b3ead6676f16a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greater of the two specified arguments.  <br /></td></tr>
<tr class="separator:af92d3404f1be84cb349b3ead6676f16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e1bc43d434a47ddbab3d6f950c0e2a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9e1bc43d434a47ddbab3d6f950c0e2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad9e1bc43d434a47ddbab3d6f950c0e2a.html#ad9e1bc43d434a47ddbab3d6f950c0e2a">fmax</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="memdesc:ad9e1bc43d434a47ddbab3d6f950c0e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greater of the two specified arguments.  <br /></td></tr>
<tr class="separator:ad9e1bc43d434a47ddbab3d6f950c0e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf8fa6e43f164c9d590823196f75f44"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2cf8fa6e43f164c9d590823196f75f44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2cf8fa6e43f164c9d590823196f75f44.html#a2cf8fa6e43f164c9d590823196f75f44">fmin</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a2cf8fa6e43f164c9d590823196f75f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57dd1dea504c0541774d812dca199d2d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57dd1dea504c0541774d812dca199d2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a57dd1dea504c0541774d812dca199d2d.html#a57dd1dea504c0541774d812dca199d2d">fmin</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a57dd1dea504c0541774d812dca199d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdb7d22e1d9ace8d1cdd9914193aef4d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abdb7d22e1d9ace8d1cdd9914193aef4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abdb7d22e1d9ace8d1cdd9914193aef4d.html#abdb7d22e1d9ace8d1cdd9914193aef4d">fmin</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:abdb7d22e1d9ace8d1cdd9914193aef4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accacafb8d596c8d75d84d3d1c74236d8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:accacafb8d596c8d75d84d3d1c74236d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_accacafb8d596c8d75d84d3d1c74236d8.html#accacafb8d596c8d75d84d3d1c74236d8">fmod</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:accacafb8d596c8d75d84d3d1c74236d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f7e2cf46f232de94280f4ff01c900a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a01f7e2cf46f232de94280f4ff01c900a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a01f7e2cf46f232de94280f4ff01c900a.html#a01f7e2cf46f232de94280f4ff01c900a">fmod</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:a01f7e2cf46f232de94280f4ff01c900a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08f19ae17d760ed7bb0791114f582d3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae08f19ae17d760ed7bb0791114f582d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae08f19ae17d760ed7bb0791114f582d3.html#ae08f19ae17d760ed7bb0791114f582d3">fmod</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:ae08f19ae17d760ed7bb0791114f582d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab144fc84b869e5afbd889156678e599d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab144fc84b869e5afbd889156678e599d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab144fc84b869e5afbd889156678e599d.html#ab144fc84b869e5afbd889156678e599d">gamma_p</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:ab144fc84b869e5afbd889156678e599d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6f13dc4a376baec2516310a7f7d2c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b6f13dc4a376baec2516310a7f7d2c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6b6f13dc4a376baec2516310a7f7d2c2.html#a6b6f13dc4a376baec2516310a7f7d2c2">gamma_p</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:a6b6f13dc4a376baec2516310a7f7d2c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07970175987f3278db6f7472491509bc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a07970175987f3278db6f7472491509bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a07970175987f3278db6f7472491509bc.html#a07970175987f3278db6f7472491509bc">gamma_p</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a07970175987f3278db6f7472491509bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85b7d84cab4fcfc6625cde1d0c95f85"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae85b7d84cab4fcfc6625cde1d0c95f85"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae85b7d84cab4fcfc6625cde1d0c95f85.html#ae85b7d84cab4fcfc6625cde1d0c95f85">gamma_q</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:ae85b7d84cab4fcfc6625cde1d0c95f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b20addd38c52d748d545ad40619d083"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b20addd38c52d748d545ad40619d083"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9b20addd38c52d748d545ad40619d083.html#a9b20addd38c52d748d545ad40619d083">gamma_q</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:a9b20addd38c52d748d545ad40619d083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f50b5a6bdfd3ce275dc90304def229c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f50b5a6bdfd3ce275dc90304def229c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8f50b5a6bdfd3ce275dc90304def229c.html#a8f50b5a6bdfd3ce275dc90304def229c">gamma_q</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a8f50b5a6bdfd3ce275dc90304def229c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89740a27ac232e6024a691f7581e817b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a89740a27ac232e6024a691f7581e817b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a89740a27ac232e6024a691f7581e817b.html#a89740a27ac232e6024a691f7581e817b">grad_inc_beta</a> (<a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;g1, <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;g2, <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; a, <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; b, <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; z)</td></tr>
<tr class="memdesc:a89740a27ac232e6024a691f7581e817b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradient of the incomplete beta function beta(a, b, z) with respect to the first two arguments.  <br /></td></tr>
<tr class="separator:a89740a27ac232e6024a691f7581e817b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd0dfe99ff73db332ca44199439687b"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tz , typename FvarT  = return_type_t&lt;Ta, Tz&gt;, <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; Ta, Tz &gt; *  = nullptr, <a class="el" href="group__fvar__types_ga0acbafcf4967524342a974e6afed202a.html#ga0acbafcf4967524342a974e6afed202a">require_any_fvar_t</a>&lt; Ta, Tz &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0bd0dfe99ff73db332ca44199439687b"><td class="memTemplItemLeft" align="right" valign="top">FvarT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0bd0dfe99ff73db332ca44199439687b.html#a0bd0dfe99ff73db332ca44199439687b">hypergeometric_1f0</a> (const Ta &amp;a, const Tz &amp;z)</td></tr>
<tr class="memdesc:a0bd0dfe99ff73db332ca44199439687b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Hypergeometric 1F0 function applied to the input arguments: \( _1F_0(a;;z) = \sum_{k=1}^{\infty}\frac{\left(a\right)_kz^k}{k!}\).  <br /></td></tr>
<tr class="separator:a0bd0dfe99ff73db332ca44199439687b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d24e9b8412f526a261d15f1c58f6c1"><td class="memTemplParams" colspan="2">template&lt;typename Ta1 , typename Ta2 , typename Tb , typename Tz , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; Ta1, Ta2, Tb, Tz &gt; *  = nullptr, <a class="el" href="group__fvar__types_ga0acbafcf4967524342a974e6afed202a.html#ga0acbafcf4967524342a974e6afed202a">require_any_fvar_t</a>&lt; Ta1, Ta2, Tb, Tz &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a60d24e9b8412f526a261d15f1c58f6c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Ta1, Ta1, Tb, Tz &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a60d24e9b8412f526a261d15f1c58f6c1.html#a60d24e9b8412f526a261d15f1c58f6c1">hypergeometric_2F1</a> (const Ta1 &amp;a1, const Ta2 &amp;a2, const Tb &amp;b, const Tz &amp;z)</td></tr>
<tr class="memdesc:a60d24e9b8412f526a261d15f1c58f6c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gauss hypergeometric function applied to the input arguments: \(_2F_1(a_1,a_2;b;z)\).  <br /></td></tr>
<tr class="separator:a60d24e9b8412f526a261d15f1c58f6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdce17007b904cd5107751e6d141030"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , typename Tz , typename FvarT  = return_type_t&lt;Ta, Tb, Tz&gt;, bool grad_a = !is_constant&lt;Ta&gt;::value, bool grad_b = !is_constant&lt;Tb&gt;::value, bool grad_z = !is_constant&lt;Tz&gt;::value, <a class="el" href="group__vector__types_ga1b4c392b9d20db66ae254ef9833f9717.html#ga1b4c392b9d20db66ae254ef9833f9717">require_all_vector_t</a>&lt; Ta, Tb &gt; *  = nullptr, <a class="el" href="group__fvar__types_gab36397aaabf5accbfc5a0909ce0e3290.html#gab36397aaabf5accbfc5a0909ce0e3290">require_fvar_t</a>&lt; FvarT &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aacdce17007b904cd5107751e6d141030"><td class="memTemplItemLeft" align="right" valign="top">FvarT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aacdce17007b904cd5107751e6d141030.html#aacdce17007b904cd5107751e6d141030">hypergeometric_pFq</a> (const Ta &amp;a, const Tb &amp;b, const Tz &amp;z)</td></tr>
<tr class="memdesc:aacdce17007b904cd5107751e6d141030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the generalized hypergeometric (pFq) function applied to the input arguments.  <br /></td></tr>
<tr class="separator:aacdce17007b904cd5107751e6d141030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00cd0d0044bd0b199db315a364bd20f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00cd0d0044bd0b199db315a364bd20f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a00cd0d0044bd0b199db315a364bd20f7.html#a00cd0d0044bd0b199db315a364bd20f7">hypot</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a00cd0d0044bd0b199db315a364bd20f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of the hypotenuse of a right triangle with opposite and adjacent side lengths given by the specified arguments (C++11).  <br /></td></tr>
<tr class="separator:a00cd0d0044bd0b199db315a364bd20f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdaf0532173f70b0b8949c06a79259a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bdaf0532173f70b0b8949c06a79259a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9bdaf0532173f70b0b8949c06a79259a.html#a9bdaf0532173f70b0b8949c06a79259a">hypot</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="memdesc:a9bdaf0532173f70b0b8949c06a79259a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of the hypotenuse of a right triangle with opposite and adjacent side lengths given by the specified arguments (C++11).  <br /></td></tr>
<tr class="separator:a9bdaf0532173f70b0b8949c06a79259a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be95562708ddb23d5ba1127593f63b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2be95562708ddb23d5ba1127593f63b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2be95562708ddb23d5ba1127593f63b1.html#a2be95562708ddb23d5ba1127593f63b1">hypot</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a2be95562708ddb23d5ba1127593f63b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of the hypotenuse of a right triangle with opposite and adjacent side lengths given by the specified arguments (C++11).  <br /></td></tr>
<tr class="separator:a2be95562708ddb23d5ba1127593f63b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c002f08a261e88b7052728a17448fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa3c002f08a261e88b7052728a17448fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa3c002f08a261e88b7052728a17448fe.html#aa3c002f08a261e88b7052728a17448fe">inc_beta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;a, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;b, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aa3c002f08a261e88b7052728a17448fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e658b211d5e3be437c342739a1b2db8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e658b211d5e3be437c342739a1b2db8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1e658b211d5e3be437c342739a1b2db8.html#a1e658b211d5e3be437c342739a1b2db8">inc_beta</a> (double a, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;b, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a1e658b211d5e3be437c342739a1b2db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23367b5211c6b41e02dca98cbe5a2dae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a23367b5211c6b41e02dca98cbe5a2dae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a23367b5211c6b41e02dca98cbe5a2dae.html#a23367b5211c6b41e02dca98cbe5a2dae">inc_beta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;a, double b, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a23367b5211c6b41e02dca98cbe5a2dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6a6d601d9efd165c89ce15e5b6d3fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8c6a6d601d9efd165c89ce15e5b6d3fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8c6a6d601d9efd165c89ce15e5b6d3fd.html#a8c6a6d601d9efd165c89ce15e5b6d3fd">inc_beta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;a, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;b, double x)</td></tr>
<tr class="separator:a8c6a6d601d9efd165c89ce15e5b6d3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e49c56a2774d0eea7d25dab6ecce114"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e49c56a2774d0eea7d25dab6ecce114"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4e49c56a2774d0eea7d25dab6ecce114.html#a4e49c56a2774d0eea7d25dab6ecce114">inc_beta</a> (double a, double b, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a4e49c56a2774d0eea7d25dab6ecce114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1cb0089e1602ddaf28b9412b2ef1ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e1cb0089e1602ddaf28b9412b2ef1ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9e1cb0089e1602ddaf28b9412b2ef1ac.html#a9e1cb0089e1602ddaf28b9412b2ef1ac">inc_beta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;a, double b, double x)</td></tr>
<tr class="separator:a9e1cb0089e1602ddaf28b9412b2ef1ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29654a2bcbb4f03f58a9404b267eec6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa29654a2bcbb4f03f58a9404b267eec6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa29654a2bcbb4f03f58a9404b267eec6.html#aa29654a2bcbb4f03f58a9404b267eec6">inc_beta</a> (double a, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;b, double x)</td></tr>
<tr class="separator:aa29654a2bcbb4f03f58a9404b267eec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd273d6fda1b0a302c1032c3cf91ef7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aefd273d6fda1b0a302c1032c3cf91ef7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aefd273d6fda1b0a302c1032c3cf91ef7.html#aefd273d6fda1b0a302c1032c3cf91ef7">inv</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aefd273d6fda1b0a302c1032c3cf91ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb7dcaa37a8cadd5e4ad89ff323a7d5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5bb7dcaa37a8cadd5e4ad89ff323a7d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5bb7dcaa37a8cadd5e4ad89ff323a7d5.html#a5bb7dcaa37a8cadd5e4ad89ff323a7d5">inv_cloglog</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a5bb7dcaa37a8cadd5e4ad89ff323a7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab99816a26d0021e1bb5df954414f060"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab99816a26d0021e1bb5df954414f060"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab99816a26d0021e1bb5df954414f060.html#aab99816a26d0021e1bb5df954414f060">inv_erfc</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aab99816a26d0021e1bb5df954414f060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7d63752a239ee801392435e9841367"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T1, T2, T3 &gt; *  = nullptr, <a class="el" href="group__fvar__types_ga0acbafcf4967524342a974e6afed202a.html#ga0acbafcf4967524342a974e6afed202a">require_any_fvar_t</a>&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9b7d63752a239ee801392435e9841367"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="namespacestan_aabaa16e71f5249e2921c992ae2006995.html#aabaa16e71f5249e2921c992ae2006995">partials_return_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9b7d63752a239ee801392435e9841367.html#a9b7d63752a239ee801392435e9841367">inv_inc_beta</a> (const T1 &amp;a, const T2 &amp;b, const T3 &amp;p)</td></tr>
<tr class="memdesc:a9b7d63752a239ee801392435e9841367"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of the normalized incomplete beta function of a, b, with probability p.  <br /></td></tr>
<tr class="separator:a9b7d63752a239ee801392435e9841367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0010641b9d5d7ab95187e4a05993344"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae0010641b9d5d7ab95187e4a05993344"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae0010641b9d5d7ab95187e4a05993344.html#ae0010641b9d5d7ab95187e4a05993344">inv_logit</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:ae0010641b9d5d7ab95187e4a05993344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse logit function applied to the argument.  <br /></td></tr>
<tr class="separator:ae0010641b9d5d7ab95187e4a05993344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9475283849b02264ae7eb4472dabcb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f9475283849b02264ae7eb4472dabcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9f9475283849b02264ae7eb4472dabcb.html#a9f9475283849b02264ae7eb4472dabcb">inv_Phi</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="separator:a9f9475283849b02264ae7eb4472dabcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb364653df48e278a5463dcfab5345d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aedb364653df48e278a5463dcfab5345d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aedb364653df48e278a5463dcfab5345d.html#aedb364653df48e278a5463dcfab5345d">inv_sqrt</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aedb364653df48e278a5463dcfab5345d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e06fba4a23adac049865e0715c4a191"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2e06fba4a23adac049865e0715c4a191"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2e06fba4a23adac049865e0715c4a191.html#a2e06fba4a23adac049865e0715c4a191">inv_square</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a2e06fba4a23adac049865e0715c4a191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9758a1234f70a8b8954caff1a3ffbf03"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9758a1234f70a8b8954caff1a3ffbf03"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, EigMat::RowsAtCompileTime, EigMat::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9758a1234f70a8b8954caff1a3ffbf03.html#a9758a1234f70a8b8954caff1a3ffbf03">inverse</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a9758a1234f70a8b8954caff1a3ffbf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward mode specialization of calculating the inverse of the matrix.  <br /></td></tr>
<tr class="separator:a9758a1234f70a8b8954caff1a3ffbf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad359149ebad087910f96e62f88287c1f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad359149ebad087910f96e62f88287c1f"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad359149ebad087910f96e62f88287c1f.html#ad359149ebad087910f96e62f88287c1f">is_inf</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:ad359149ebad087910f96e62f88287c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the input's value is infinite and 0 otherwise.  <br /></td></tr>
<tr class="separator:ad359149ebad087910f96e62f88287c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254953197ba565e7d5ef61ea7fa0fbd2"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__fvar__types_gab36397aaabf5accbfc5a0909ce0e3290.html#gab36397aaabf5accbfc5a0909ce0e3290">require_fvar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a254953197ba565e7d5ef61ea7fa0fbd2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a254953197ba565e7d5ef61ea7fa0fbd2.html#a254953197ba565e7d5ef61ea7fa0fbd2">is_nan</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:a254953197ba565e7d5ef61ea7fa0fbd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the input's value is NaN and 0 otherwise.  <br /></td></tr>
<tr class="separator:a254953197ba565e7d5ef61ea7fa0fbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281df36ccb31fc7ed3c6dad5992da7a2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a281df36ccb31fc7ed3c6dad5992da7a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a281df36ccb31fc7ed3c6dad5992da7a2.html#a281df36ccb31fc7ed3c6dad5992da7a2">lambert_w0</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a281df36ccb31fc7ed3c6dad5992da7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584c7a349fe52ff297fe8e438db5fd8f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a584c7a349fe52ff297fe8e438db5fd8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a584c7a349fe52ff297fe8e438db5fd8f.html#a584c7a349fe52ff297fe8e438db5fd8f">lambert_wm1</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a584c7a349fe52ff297fe8e438db5fd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e48d5cd0470ac716a02d368e77c8c8a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e48d5cd0470ac716a02d368e77c8c8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4e48d5cd0470ac716a02d368e77c8c8a.html#a4e48d5cd0470ac716a02d368e77c8c8a">lbeta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a4e48d5cd0470ac716a02d368e77c8c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade33ccb1d79cf42827faaa7bed59332b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ade33ccb1d79cf42827faaa7bed59332b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade33ccb1d79cf42827faaa7bed59332b.html#ade33ccb1d79cf42827faaa7bed59332b">lbeta</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:ade33ccb1d79cf42827faaa7bed59332b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d31066d08b709acd1a7ac8100c1b1e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a57d31066d08b709acd1a7ac8100c1b1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a57d31066d08b709acd1a7ac8100c1b1e.html#a57d31066d08b709acd1a7ac8100c1b1e">lbeta</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:a57d31066d08b709acd1a7ac8100c1b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79803245d1e00e19ff973fc119fb80d2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a79803245d1e00e19ff973fc119fb80d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a79803245d1e00e19ff973fc119fb80d2.html#a79803245d1e00e19ff973fc119fb80d2">ldexp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;a, int b)</td></tr>
<tr class="memdesc:a79803245d1e00e19ff973fc119fb80d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of a (the significand) times 2 to power b (the exponent).  <br /></td></tr>
<tr class="separator:a79803245d1e00e19ff973fc119fb80d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa888b5d6ff71fe9ab37deaee025a33bf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa888b5d6ff71fe9ab37deaee025a33bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa888b5d6ff71fe9ab37deaee025a33bf.html#aa888b5d6ff71fe9ab37deaee025a33bf">lgamma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:aa888b5d6ff71fe9ab37deaee025a33bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the gamma function applied to the specified argument.  <br /></td></tr>
<tr class="separator:aa888b5d6ff71fe9ab37deaee025a33bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b49bfffa54e476df6fa902052c493e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b49bfffa54e476df6fa902052c493e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9b49bfffa54e476df6fa902052c493e7.html#a9b49bfffa54e476df6fa902052c493e7">lmgamma</a> (int x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a9b49bfffa54e476df6fa902052c493e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70dc434e6485c32aac018c358c058f38"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70dc434e6485c32aac018c358c058f38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a70dc434e6485c32aac018c358c058f38.html#a70dc434e6485c32aac018c358c058f38">lmultiply</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a70dc434e6485c32aac018c358c058f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a48f23893e65c8c59dce1d4294b075"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a55a48f23893e65c8c59dce1d4294b075"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a55a48f23893e65c8c59dce1d4294b075.html#a55a48f23893e65c8c59dce1d4294b075">lmultiply</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a55a48f23893e65c8c59dce1d4294b075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a90f2810e5d5751ef6380593fbd9c56"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5a90f2810e5d5751ef6380593fbd9c56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5a90f2810e5d5751ef6380593fbd9c56.html#a5a90f2810e5d5751ef6380593fbd9c56">lmultiply</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:a5a90f2810e5d5751ef6380593fbd9c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5494a692abff08cb3585079397b90dab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5494a692abff08cb3585079397b90dab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5494a692abff08cb3585079397b90dab.html#a5494a692abff08cb3585079397b90dab">log</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a5494a692abff08cb3585079397b90dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5deee4efbcfcb52ada79522d4eddd4cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5deee4efbcfcb52ada79522d4eddd4cb"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5deee4efbcfcb52ada79522d4eddd4cb.html#a5deee4efbcfcb52ada79522d4eddd4cb">log</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:a5deee4efbcfcb52ada79522d4eddd4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm (base e) of the specified complex argument.  <br /></td></tr>
<tr class="separator:a5deee4efbcfcb52ada79522d4eddd4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e51a36762b9c6687292deefcb0aff70"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3e51a36762b9c6687292deefcb0aff70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3e51a36762b9c6687292deefcb0aff70.html#a3e51a36762b9c6687292deefcb0aff70">log10</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a3e51a36762b9c6687292deefcb0aff70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ff1f9b9c492c9e9312019f463cc81c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae2ff1f9b9c492c9e9312019f463cc81c"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae2ff1f9b9c492c9e9312019f463cc81c.html#ae2ff1f9b9c492c9e9312019f463cc81c">log10</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:ae2ff1f9b9c492c9e9312019f463cc81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base 10 logarithm of the specified complex number.  <br /></td></tr>
<tr class="separator:ae2ff1f9b9c492c9e9312019f463cc81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae426e656b1c72332aeadeaed27c5ecf4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae426e656b1c72332aeadeaed27c5ecf4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae426e656b1c72332aeadeaed27c5ecf4.html#ae426e656b1c72332aeadeaed27c5ecf4">log1m</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ae426e656b1c72332aeadeaed27c5ecf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452e4f39f00638a425f76b27c150e8ec"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a452e4f39f00638a425f76b27c150e8ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a452e4f39f00638a425f76b27c150e8ec.html#a452e4f39f00638a425f76b27c150e8ec">log1m_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a452e4f39f00638a425f76b27c150e8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one minus the exponentiation of the specified argument.  <br /></td></tr>
<tr class="separator:a452e4f39f00638a425f76b27c150e8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebfd796b601a6cb2b9022ddedd7b6748"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aebfd796b601a6cb2b9022ddedd7b6748"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aebfd796b601a6cb2b9022ddedd7b6748.html#aebfd796b601a6cb2b9022ddedd7b6748">log1m_inv_logit</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:aebfd796b601a6cb2b9022ddedd7b6748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one minus the inverse logit of the specified argument.  <br /></td></tr>
<tr class="separator:aebfd796b601a6cb2b9022ddedd7b6748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb72ed892210a6a63de6e4db6c3c056"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9cb72ed892210a6a63de6e4db6c3c056"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9cb72ed892210a6a63de6e4db6c3c056.html#a9cb72ed892210a6a63de6e4db6c3c056">log1p</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a9cb72ed892210a6a63de6e4db6c3c056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a46dfa4816b15da29603c2a13928996"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7a46dfa4816b15da29603c2a13928996"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7a46dfa4816b15da29603c2a13928996.html#a7a46dfa4816b15da29603c2a13928996">log1p_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a7a46dfa4816b15da29603c2a13928996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f44a995c8e1c24206b8399c16e7efd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a95f44a995c8e1c24206b8399c16e7efd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a95f44a995c8e1c24206b8399c16e7efd.html#a95f44a995c8e1c24206b8399c16e7efd">log2</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a95f44a995c8e1c24206b8399c16e7efd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base two logarithm of the specified argument.  <br /></td></tr>
<tr class="separator:a95f44a995c8e1c24206b8399c16e7efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42b163550f61a7a0929371968db4f397"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a42b163550f61a7a0929371968db4f397"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a42b163550f61a7a0929371968db4f397.html#a42b163550f61a7a0929371968db4f397">log_determinant</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a42b163550f61a7a0929371968db4f397"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log absolute determinant of the specified square matrix.  <br /></td></tr>
<tr class="separator:a42b163550f61a7a0929371968db4f397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa543c0712c92ac2ace35d6a7c79c355"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa543c0712c92ac2ace35d6a7c79c355"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaa543c0712c92ac2ace35d6a7c79c355.html#aaa543c0712c92ac2ace35d6a7c79c355">log_diff_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:aaa543c0712c92ac2ace35d6a7c79c355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7774575fc67e235ffc4bbc456139b533"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T1 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7774575fc67e235ffc4bbc456139b533"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7774575fc67e235ffc4bbc456139b533.html#a7774575fc67e235ffc4bbc456139b533">log_diff_exp</a> (const T1 &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T2 &gt; &amp;x2)</td></tr>
<tr class="separator:a7774575fc67e235ffc4bbc456139b533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafd90ac04c36458536264548240197a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acafd90ac04c36458536264548240197a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acafd90ac04c36458536264548240197a.html#acafd90ac04c36458536264548240197a">log_diff_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T1 &gt; &amp;x1, const T2 &amp;x2)</td></tr>
<tr class="separator:acafd90ac04c36458536264548240197a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8caae19799aa4e1ecfbc33b2f96b3a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc8caae19799aa4e1ecfbc33b2f96b3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acc8caae19799aa4e1ecfbc33b2f96b3a.html#acc8caae19799aa4e1ecfbc33b2f96b3a">log_falling_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="separator:acc8caae19799aa4e1ecfbc33b2f96b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751c650c4fc0ce434d1e8fafa5e9895c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a751c650c4fc0ce434d1e8fafa5e9895c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a751c650c4fc0ce434d1e8fafa5e9895c.html#a751c650c4fc0ce434d1e8fafa5e9895c">log_falling_factorial</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="separator:a751c650c4fc0ce434d1e8fafa5e9895c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf5bb1bf603c0b1df1009e5baa4e844"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aebf5bb1bf603c0b1df1009e5baa4e844"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aebf5bb1bf603c0b1df1009e5baa4e844.html#aebf5bb1bf603c0b1df1009e5baa4e844">log_falling_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double n)</td></tr>
<tr class="separator:aebf5bb1bf603c0b1df1009e5baa4e844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609450c56db01ed4b4989dc7f9dd755c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a609450c56db01ed4b4989dc7f9dd755c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a609450c56db01ed4b4989dc7f9dd755c.html#a609450c56db01ed4b4989dc7f9dd755c">log_inv_logit</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a609450c56db01ed4b4989dc7f9dd755c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473fe3d160b0ca4dbbf5e4a947c6a407"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a473fe3d160b0ca4dbbf5e4a947c6a407"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a473fe3d160b0ca4dbbf5e4a947c6a407.html#a473fe3d160b0ca4dbbf5e4a947c6a407">log_inv_logit_diff</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:a473fe3d160b0ca4dbbf5e4a947c6a407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns fvar with the natural logarithm of the difference of the inverse logits of the specified arguments and its gradients.  <br /></td></tr>
<tr class="separator:a473fe3d160b0ca4dbbf5e4a947c6a407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8ea4d51dbfe20a53d0dc7ca3f47470"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c8ea4d51dbfe20a53d0dc7ca3f47470"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6c8ea4d51dbfe20a53d0dc7ca3f47470.html#a6c8ea4d51dbfe20a53d0dc7ca3f47470">log_inv_logit_diff</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double y)</td></tr>
<tr class="separator:a6c8ea4d51dbfe20a53d0dc7ca3f47470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55927ef94ccff6b7d77cffd3bf710823"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a55927ef94ccff6b7d77cffd3bf710823"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a55927ef94ccff6b7d77cffd3bf710823.html#a55927ef94ccff6b7d77cffd3bf710823">log_inv_logit_diff</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="separator:a55927ef94ccff6b7d77cffd3bf710823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938cde7de0933bf75aa436720b5c90a9"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , typename T_lambda1 , typename T_lambda2 , int N&gt; </td></tr>
<tr class="memitem:a938cde7de0933bf75aa436720b5c90a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a938cde7de0933bf75aa436720b5c90a9.html#a938cde7de0933bf75aa436720b5c90a9">log_mix_partial_helper</a> (const T_theta &amp;theta, const T_lambda1 &amp;lambda1, const T_lambda2 &amp;lambda2, <a class="el" href="group__type__trait_ga546483131616701876a9f1307f5a413d.html#ga546483131616701876a9f1307f5a413d">promote_args_t</a>&lt; T_theta, T_lambda1, T_lambda2 &gt;(&amp;partials_array)[N])</td></tr>
<tr class="separator:a938cde7de0933bf75aa436720b5c90a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b114842ecd2603ebb3deed90227c36b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8b114842ecd2603ebb3deed90227c36b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8b114842ecd2603ebb3deed90227c36b.html#a8b114842ecd2603ebb3deed90227c36b">log_mix</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;theta, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda2)</td></tr>
<tr class="memdesc:a8b114842ecd2603ebb3deed90227c36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log mixture density with specified mixing proportion and log densities and its derivative at each.  <br /></td></tr>
<tr class="separator:a8b114842ecd2603ebb3deed90227c36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320bce6e23ee93eec2891e549af3a5a4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; P &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a320bce6e23ee93eec2891e549af3a5a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a320bce6e23ee93eec2891e549af3a5a4.html#a320bce6e23ee93eec2891e549af3a5a4">log_mix</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;theta, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda1, P lambda2)</td></tr>
<tr class="separator:a320bce6e23ee93eec2891e549af3a5a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f568dba733efbac97c4cb136e5b6be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; P &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a32f568dba733efbac97c4cb136e5b6be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a32f568dba733efbac97c4cb136e5b6be.html#a32f568dba733efbac97c4cb136e5b6be">log_mix</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;theta, P lambda1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda2)</td></tr>
<tr class="separator:a32f568dba733efbac97c4cb136e5b6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3d84c6a909a5d9ccee469a64c13a72"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; P &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afe3d84c6a909a5d9ccee469a64c13a72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afe3d84c6a909a5d9ccee469a64c13a72.html#afe3d84c6a909a5d9ccee469a64c13a72">log_mix</a> (P theta, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda2)</td></tr>
<tr class="separator:afe3d84c6a909a5d9ccee469a64c13a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf2b0f9e923d3c05243e265127064b1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P1 , typename P2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; P1, P2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abbf2b0f9e923d3c05243e265127064b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abbf2b0f9e923d3c05243e265127064b1.html#abbf2b0f9e923d3c05243e265127064b1">log_mix</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;theta, P1 lambda1, P2 lambda2)</td></tr>
<tr class="separator:abbf2b0f9e923d3c05243e265127064b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf579f35ca2a1696ee629c2d84d065f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P1 , typename P2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; P1, P2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2bf579f35ca2a1696ee629c2d84d065f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2bf579f35ca2a1696ee629c2d84d065f.html#a2bf579f35ca2a1696ee629c2d84d065f">log_mix</a> (P1 theta, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda1, P2 lambda2)</td></tr>
<tr class="separator:a2bf579f35ca2a1696ee629c2d84d065f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05cfc914453b88a0a5342763b0448b7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P1 , typename P2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; P1, P2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae05cfc914453b88a0a5342763b0448b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae05cfc914453b88a0a5342763b0448b7.html#ae05cfc914453b88a0a5342763b0448b7">log_mix</a> (P1 theta, P2 lambda1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;lambda2)</td></tr>
<tr class="separator:ae05cfc914453b88a0a5342763b0448b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1d820eab819168ff378b340cbe5b8f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0a1d820eab819168ff378b340cbe5b8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0a1d820eab819168ff378b340cbe5b8f.html#a0a1d820eab819168ff378b340cbe5b8f">log_rising_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="separator:a0a1d820eab819168ff378b340cbe5b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b3bcfa8ba3d9bbb8e9df4abc314580"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a81b3bcfa8ba3d9bbb8e9df4abc314580"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a81b3bcfa8ba3d9bbb8e9df4abc314580.html#a81b3bcfa8ba3d9bbb8e9df4abc314580">log_rising_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, double n)</td></tr>
<tr class="separator:a81b3bcfa8ba3d9bbb8e9df4abc314580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af61259ddda91ec9805792adb7231702a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af61259ddda91ec9805792adb7231702a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af61259ddda91ec9805792adb7231702a.html#af61259ddda91ec9805792adb7231702a">log_rising_factorial</a> (double x, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;n)</td></tr>
<tr class="separator:af61259ddda91ec9805792adb7231702a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8d1fba816ec9bab4fa798aee35e0241"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__vector__types_ga29ee195dfac10dcd24307d8b949d4451.html#ga29ee195dfac10dcd24307d8b949d4451">require_vector_st</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac8d1fba816ec9bab4fa798aee35e0241"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac8d1fba816ec9bab4fa798aee35e0241.html#ac8d1fba816ec9bab4fa798aee35e0241">log_softmax</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ac8d1fba816ec9bab4fa798aee35e0241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log softmax of the specified vector or container of vectors.  <br /></td></tr>
<tr class="separator:ac8d1fba816ec9bab4fa798aee35e0241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe205d42086ba9dea3af93b235562cd8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afe205d42086ba9dea3af93b235562cd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afe205d42086ba9dea3af93b235562cd8.html#afe205d42086ba9dea3af93b235562cd8">log_sum_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:afe205d42086ba9dea3af93b235562cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91cc3de5910123f1d67318a7c0b63fda"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91cc3de5910123f1d67318a7c0b63fda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a91cc3de5910123f1d67318a7c0b63fda.html#a91cc3de5910123f1d67318a7c0b63fda">log_sum_exp</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a91cc3de5910123f1d67318a7c0b63fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bfc35a4e5ac8e7ca6548bd5a55870a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0bfc35a4e5ac8e7ca6548bd5a55870a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0bfc35a4e5ac8e7ca6548bd5a55870a3.html#a0bfc35a4e5ac8e7ca6548bd5a55870a3">log_sum_exp</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:a0bfc35a4e5ac8e7ca6548bd5a55870a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c58a64be70f069f3a2a86ef475101b"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__container__types_ga7bc6670ad3273187c8b6fff5c86288ae.html#ga7bc6670ad3273187c8b6fff5c86288ae">require_container_st</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae7c58a64be70f069f3a2a86ef475101b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae7c58a64be70f069f3a2a86ef475101b.html#ae7c58a64be70f069f3a2a86ef475101b">log_sum_exp</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae7c58a64be70f069f3a2a86ef475101b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the sum of the exponentiated values of the specified matrix of values.  <br /></td></tr>
<tr class="separator:ae7c58a64be70f069f3a2a86ef475101b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229da97d194861a2715450b9877173c4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a229da97d194861a2715450b9877173c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a229da97d194861a2715450b9877173c4.html#a229da97d194861a2715450b9877173c4">logit</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a229da97d194861a2715450b9877173c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0cfaaa35ed78c2a12842125064b3751"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__eigen__types_ga06fcddbaf041c31d2c20c8b006ebba79.html#ga06fcddbaf041c31d2c20c8b006ebba79">require_all_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, T1, T2 &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac0cfaaa35ed78c2a12842125064b3751"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T1 &gt;, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac0cfaaa35ed78c2a12842125064b3751.html#ac0cfaaa35ed78c2a12842125064b3751">mdivide_left</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="separator:ac0cfaaa35ed78c2a12842125064b3751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee1e116fde0635486654e926e46765a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; std::is_arithmetic, T1 &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5ee1e116fde0635486654e926e46765a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T2 &gt;, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5ee1e116fde0635486654e926e46765a.html#a5ee1e116fde0635486654e926e46765a">mdivide_left</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="separator:a5ee1e116fde0635486654e926e46765a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808bee7ef8c1f2f924082902d8b61eb3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename EigMat , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; std::is_arithmetic, T &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a808bee7ef8c1f2f924082902d8b61eb3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, EigMat::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a808bee7ef8c1f2f924082902d8b61eb3.html#a808bee7ef8c1f2f924082902d8b61eb3">mdivide_left_ldlt</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A, const EigMat &amp;b)</td></tr>
<tr class="memdesc:a808bee7ef8c1f2f924082902d8b61eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> of A.  <br /></td></tr>
<tr class="separator:a808bee7ef8c1f2f924082902d8b61eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a3da322f0169ff67640e16d75f82ba"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__eigen__types_ga06fcddbaf041c31d2c20c8b006ebba79.html#ga06fcddbaf041c31d2c20c8b006ebba79">require_all_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, T1, T2 &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae7a3da322f0169ff67640e16d75f82ba"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T1 &gt;, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae7a3da322f0169ff67640e16d75f82ba.html#ae7a3da322f0169ff67640e16d75f82ba">mdivide_left_tri_low</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="separator:ae7a3da322f0169ff67640e16d75f82ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728e50a07c193d8fee08d901838b3418"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; double, T1 &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a728e50a07c193d8fee08d901838b3418"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T2 &gt;, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a728e50a07c193d8fee08d901838b3418.html#a728e50a07c193d8fee08d901838b3418">mdivide_left_tri_low</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="separator:a728e50a07c193d8fee08d901838b3418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c05df08c712363aa21b77d8834ba2ad"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, T1 &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T2 &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; double, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0c05df08c712363aa21b77d8834ba2ad"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T1 &gt;, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0c05df08c712363aa21b77d8834ba2ad.html#a0c05df08c712363aa21b77d8834ba2ad">mdivide_left_tri_low</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="separator:a0c05df08c712363aa21b77d8834ba2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795819fe0d7a24027ea88b5da2ce75f3"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga06fcddbaf041c31d2c20c8b006ebba79.html#ga06fcddbaf041c31d2c20c8b006ebba79">require_all_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, EigMat1, EigMat2 &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a795819fe0d7a24027ea88b5da2ce75f3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat1 &gt;, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a795819fe0d7a24027ea88b5da2ce75f3.html#a795819fe0d7a24027ea88b5da2ce75f3">mdivide_right</a> (const EigMat1 &amp;A, const EigMat2 &amp;b)</td></tr>
<tr class="separator:a795819fe0d7a24027ea88b5da2ce75f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3da81da1e7a5162f5002ba5846bd159"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; std::is_arithmetic, EigMat1 &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af3da81da1e7a5162f5002ba5846bd159"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat2 &gt;, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af3da81da1e7a5162f5002ba5846bd159.html#af3da81da1e7a5162f5002ba5846bd159">mdivide_right</a> (const EigMat1 &amp;A, const EigMat2 &amp;b)</td></tr>
<tr class="separator:af3da81da1e7a5162f5002ba5846bd159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3293ab7589a3737cc35158ec22b2425c"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga06fcddbaf041c31d2c20c8b006ebba79.html#ga06fcddbaf041c31d2c20c8b006ebba79">require_all_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, EigMat1, EigMat2 &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3293ab7589a3737cc35158ec22b2425c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat1 &gt;, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3293ab7589a3737cc35158ec22b2425c.html#a3293ab7589a3737cc35158ec22b2425c">mdivide_right_tri_low</a> (const EigMat1 &amp;A, const EigMat2 &amp;b)</td></tr>
<tr class="separator:a3293ab7589a3737cc35158ec22b2425c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f61e1b2c7e2f53cc586ef9331602b9"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; std::is_arithmetic, EigMat1 &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a41f61e1b2c7e2f53cc586ef9331602b9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat2 &gt;, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a41f61e1b2c7e2f53cc586ef9331602b9.html#a41f61e1b2c7e2f53cc586ef9331602b9">mdivide_right_tri_low</a> (const EigMat1 &amp;A, const EigMat2 &amp;b)</td></tr>
<tr class="separator:a41f61e1b2c7e2f53cc586ef9331602b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a8f24cd163d4bf2b8b5e1565fd3ee5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a70a8f24cd163d4bf2b8b5e1565fd3ee5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a70a8f24cd163d4bf2b8b5e1565fd3ee5.html#a70a8f24cd163d4bf2b8b5e1565fd3ee5">modified_bessel_first_kind</a> (int v, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:a70a8f24cd163d4bf2b8b5e1565fd3ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9702b98a1045e32944fa88f9a625a9e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab9702b98a1045e32944fa88f9a625a9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab9702b98a1045e32944fa88f9a625a9e.html#ab9702b98a1045e32944fa88f9a625a9e">modified_bessel_second_kind</a> (int v, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;z)</td></tr>
<tr class="separator:ab9702b98a1045e32944fa88f9a625a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68817034db6ea04cda51c87bc86329a6"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , <a class="el" href="group__eigen__types_ga06fcddbaf041c31d2c20c8b006ebba79.html#ga06fcddbaf041c31d2c20c8b006ebba79">require_all_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="namespacestan_a1f4146fe117dbf61403c3c021c07c728.html#a1f4146fe117dbf61403c3c021c07c728">require_not_eigen_row_and_col_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a68817034db6ea04cda51c87bc86329a6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a68817034db6ea04cda51c87bc86329a6.html#a68817034db6ea04cda51c87bc86329a6">multiply</a> (const Mat1 &amp;m1, const Mat2 &amp;m2)</td></tr>
<tr class="memdesc:a68817034db6ea04cda51c87bc86329a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the specified matrices.  <br /></td></tr>
<tr class="separator:a68817034db6ea04cda51c87bc86329a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfad301844f8e98ce438764293c25e0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0cfad301844f8e98ce438764293c25e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0cfad301844f8e98ce438764293c25e0.html#a0cfad301844f8e98ce438764293c25e0">multiply_log</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a0cfad301844f8e98ce438764293c25e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98771ff0c7c19615c4728f9f42cdfe49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a98771ff0c7c19615c4728f9f42cdfe49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a98771ff0c7c19615c4728f9f42cdfe49.html#a98771ff0c7c19615c4728f9f42cdfe49">multiply_log</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="separator:a98771ff0c7c19615c4728f9f42cdfe49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa8441b0233dc11ae8a1b463b8c4bbd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0fa8441b0233dc11ae8a1b463b8c4bbd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0fa8441b0233dc11ae8a1b463b8c4bbd.html#a0fa8441b0233dc11ae8a1b463b8c4bbd">multiply_log</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="separator:a0fa8441b0233dc11ae8a1b463b8c4bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0061514e9f05e846b6b3c881cf232f5c"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0061514e9f05e846b6b3c881cf232f5c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, EigMat::RowsAtCompileTime, EigMat::RowsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0061514e9f05e846b6b3c881cf232f5c.html#a0061514e9f05e846b6b3c881cf232f5c">multiply_lower_tri_self_transpose</a> (const EigMat &amp;m)</td></tr>
<tr class="separator:a0061514e9f05e846b6b3c881cf232f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f97d42ac61723dcb90af2512808b00b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2f97d42ac61723dcb90af2512808b00b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f97d42ac61723dcb90af2512808b00b.html#a2f97d42ac61723dcb90af2512808b00b">norm</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:a2f97d42ac61723dcb90af2512808b00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the squared magnitude of the complex argument.  <br /></td></tr>
<tr class="separator:a2f97d42ac61723dcb90af2512808b00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a82697cb0e7f7ff15e6d33382dec0b"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af6a82697cb0e7f7ff15e6d33382dec0b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af6a82697cb0e7f7ff15e6d33382dec0b.html#af6a82697cb0e7f7ff15e6d33382dec0b">norm1</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:af6a82697cb0e7f7ff15e6d33382dec0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L1 norm of the specified vector of values.  <br /></td></tr>
<tr class="separator:af6a82697cb0e7f7ff15e6d33382dec0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c35ec2e065a564903d2b4e33bb53a1"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af9c35ec2e065a564903d2b4e33bb53a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af9c35ec2e065a564903d2b4e33bb53a1.html#af9c35ec2e065a564903d2b4e33bb53a1">norm2</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:af9c35ec2e065a564903d2b4e33bb53a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the L2 norm of the specified vector of values.  <br /></td></tr>
<tr class="separator:af9c35ec2e065a564903d2b4e33bb53a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cff7f73d01841f7380ad62d72ecdff4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7cff7f73d01841f7380ad62d72ecdff4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7cff7f73d01841f7380ad62d72ecdff4.html#a7cff7f73d01841f7380ad62d72ecdff4">owens_t</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a7cff7f73d01841f7380ad62d72ecdff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Owen's T function applied to the specified arguments.  <br /></td></tr>
<tr class="separator:a7cff7f73d01841f7380ad62d72ecdff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65df7ac3dc3ba57f8472ff49afd22448"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65df7ac3dc3ba57f8472ff49afd22448"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a65df7ac3dc3ba57f8472ff49afd22448.html#a65df7ac3dc3ba57f8472ff49afd22448">owens_t</a> (double x1, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x2)</td></tr>
<tr class="memdesc:a65df7ac3dc3ba57f8472ff49afd22448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Owen's T function applied to the specified arguments.  <br /></td></tr>
<tr class="separator:a65df7ac3dc3ba57f8472ff49afd22448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38022f8f7246e918066bee45f6e6f79"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae38022f8f7246e918066bee45f6e6f79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae38022f8f7246e918066bee45f6e6f79.html#ae38022f8f7246e918066bee45f6e6f79">owens_t</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x1, double x2)</td></tr>
<tr class="memdesc:ae38022f8f7246e918066bee45f6e6f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return Owen's T function applied to the specified arguments.  <br /></td></tr>
<tr class="separator:ae38022f8f7246e918066bee45f6e6f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f550856f585617566096f8f129caff8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f550856f585617566096f8f129caff8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8f550856f585617566096f8f129caff8.html#a8f550856f585617566096f8f129caff8">Phi</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a8f550856f585617566096f8f129caff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e969ba79729a18cbab9cf9731cced63"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e969ba79729a18cbab9cf9731cced63"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5e969ba79729a18cbab9cf9731cced63.html#a5e969ba79729a18cbab9cf9731cced63">Phi_approx</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a5e969ba79729a18cbab9cf9731cced63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an approximation of the unit normal cumulative distribution function (CDF).  <br /></td></tr>
<tr class="separator:a5e969ba79729a18cbab9cf9731cced63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5592b56371a0039d3a556e084b2150a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5592b56371a0039d3a556e084b2150a8"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5592b56371a0039d3a556e084b2150a8.html#a5592b56371a0039d3a556e084b2150a8">polar</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;r, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;theta)</td></tr>
<tr class="memdesc:a5592b56371a0039d3a556e084b2150a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns complex number with specified magnitude and phase angle.  <br /></td></tr>
<tr class="separator:a5592b56371a0039d3a556e084b2150a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f4bfe08488051a887dac3771742605"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a47f4bfe08488051a887dac3771742605"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a47f4bfe08488051a887dac3771742605.html#a47f4bfe08488051a887dac3771742605">polar</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;r, U theta)</td></tr>
<tr class="memdesc:a47f4bfe08488051a887dac3771742605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns complex number with specified magnitude and phase angle.  <br /></td></tr>
<tr class="separator:a47f4bfe08488051a887dac3771742605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5db749919e74dcc51cb1572ec62338"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a7a5db749919e74dcc51cb1572ec62338"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7a5db749919e74dcc51cb1572ec62338.html#a7a5db749919e74dcc51cb1572ec62338">polar</a> (U r, const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;theta)</td></tr>
<tr class="memdesc:a7a5db749919e74dcc51cb1572ec62338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns complex number with specified magnitude and phase angle.  <br /></td></tr>
<tr class="separator:a7a5db749919e74dcc51cb1572ec62338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7c2a78c6e2f7fe7a6187d408732ae2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__fvar__types_ga0acbafcf4967524342a974e6afed202a.html#ga0acbafcf4967524342a974e6afed202a">require_any_fvar_t</a>&lt; <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; T1 &gt;, <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; T2 &gt; &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4f7c2a78c6e2f7fe7a6187d408732ae2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4f7c2a78c6e2f7fe7a6187d408732ae2.html#a4f7c2a78c6e2f7fe7a6187d408732ae2">pow</a> (const T1 &amp;x1, const T2 &amp;x2)</td></tr>
<tr class="separator:a4f7c2a78c6e2f7fe7a6187d408732ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9117311154b775d7b345ee5a7ce87eb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__matrix__types_gad5983b53cc2875bec421ecdbd43d336b.html#gad5983b53cc2875bec421ecdbd43d336b">require_all_not_matrix_st</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T1, T2 &gt; *  = nullptr, <a class="el" href="group__fvar__types_ga0acbafcf4967524342a974e6afed202a.html#ga0acbafcf4967524342a974e6afed202a">require_any_fvar_t</a>&lt; <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; T1 &gt;, <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; T2 &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa9117311154b775d7b345ee5a7ce87eb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa9117311154b775d7b345ee5a7ce87eb.html#aa9117311154b775d7b345ee5a7ce87eb">pow</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:aa9117311154b775d7b345ee5a7ce87eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise raising of the first argument to the power of the second argument.  <br /></td></tr>
<tr class="separator:aa9117311154b775d7b345ee5a7ce87eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24337e3af682981f05d1cc022e675891"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24337e3af682981f05d1cc022e675891"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a24337e3af682981f05d1cc022e675891.html#a24337e3af682981f05d1cc022e675891">primitive_value</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a24337e3af682981f05d1cc022e675891"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the primitive value of the specified forward-mode autodiff variable.  <br /></td></tr>
<tr class="separator:a24337e3af682981f05d1cc022e675891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad38abfd19af64a6b7ee724bee486b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ad38abfd19af64a6b7ee724bee486b5"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ad38abfd19af64a6b7ee724bee486b5.html#a9ad38abfd19af64a6b7ee724bee486b5">proj</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:a9ad38abfd19af64a6b7ee724bee486b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the projection of the complex argument onto the Riemann sphere.  <br /></td></tr>
<tr class="separator:a9ad38abfd19af64a6b7ee724bee486b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1593f14d3bdb598945a8ee56fee094"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga76e63e3ea85c77800e3a4cda6aed0357.html#ga76e63e3ea85c77800e3a4cda6aed0357">require_not_eigen_col_vector_t</a>&lt; EigMat2 &gt; *  = nullptr, <a class="el" href="group__fvar__types_ga0bbeba0604a99a81b25f2f6249be82c1.html#ga0bbeba0604a99a81b25f2f6249be82c1">require_any_vt_fvar</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6a1593f14d3bdb598945a8ee56fee094"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">promote_scalar_t</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, EigMat2 &gt;, EigMat2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6a1593f14d3bdb598945a8ee56fee094.html#a6a1593f14d3bdb598945a8ee56fee094">quad_form</a> (const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:a6a1593f14d3bdb598945a8ee56fee094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \).  <br /></td></tr>
<tr class="separator:a6a1593f14d3bdb598945a8ee56fee094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dacb62879839777b842032fd847f35d"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename ColVec , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; ColVec &gt; *  = nullptr, <a class="el" href="group__fvar__types_ga0bbeba0604a99a81b25f2f6249be82c1.html#ga0bbeba0604a99a81b25f2f6249be82c1">require_any_vt_fvar</a>&lt; EigMat, ColVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6dacb62879839777b842032fd847f35d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat, ColVec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6dacb62879839777b842032fd847f35d.html#a6dacb62879839777b842032fd847f35d">quad_form</a> (const EigMat &amp;A, const ColVec &amp;B)</td></tr>
<tr class="memdesc:a6dacb62879839777b842032fd847f35d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \).  <br /></td></tr>
<tr class="separator:a6dacb62879839777b842032fd847f35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e356e03f9763ae6f273f5b6b300926"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga76e63e3ea85c77800e3a4cda6aed0357.html#ga76e63e3ea85c77800e3a4cda6aed0357">require_not_eigen_col_vector_t</a>&lt; EigMat2 &gt; *  = nullptr, <a class="el" href="group__fvar__types_ga0bbeba0604a99a81b25f2f6249be82c1.html#ga0bbeba0604a99a81b25f2f6249be82c1">require_any_vt_fvar</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa8e356e03f9763ae6f273f5b6b300926"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">promote_scalar_t</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, EigMat2 &gt;, EigMat2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa8e356e03f9763ae6f273f5b6b300926.html#aa8e356e03f9763ae6f273f5b6b300926">quad_form_sym</a> (const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:aa8e356e03f9763ae6f273f5b6b300926"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \) of a symmetric matrix.  <br /></td></tr>
<tr class="separator:aa8e356e03f9763ae6f273f5b6b300926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a537b911d3ad1e4e507a43e8014d35"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename ColVec , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; ColVec &gt; *  = nullptr, <a class="el" href="group__fvar__types_ga0bbeba0604a99a81b25f2f6249be82c1.html#ga0bbeba0604a99a81b25f2f6249be82c1">require_any_vt_fvar</a>&lt; EigMat, ColVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a57a537b911d3ad1e4e507a43e8014d35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat, ColVec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a57a537b911d3ad1e4e507a43e8014d35.html#a57a537b911d3ad1e4e507a43e8014d35">quad_form_sym</a> (const EigMat &amp;A, const ColVec &amp;B)</td></tr>
<tr class="memdesc:a57a537b911d3ad1e4e507a43e8014d35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \) of a symmetric matrix.  <br /></td></tr>
<tr class="separator:a57a537b911d3ad1e4e507a43e8014d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a58ef73a4780899fdc9e1d04bc0a08"><td class="memTemplParams" colspan="2">template&lt;typename EigFvar , typename EigOut &gt; </td></tr>
<tr class="memitem:ac4a58ef73a4780899fdc9e1d04bc0a08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac4a58ef73a4780899fdc9e1d04bc0a08.html#ac4a58ef73a4780899fdc9e1d04bc0a08">read_fvar</a> (const EigFvar &amp;FvarMat, EigOut &amp;ValMat, EigOut &amp;DMat)</td></tr>
<tr class="memdesc:ac4a58ef73a4780899fdc9e1d04bc0a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function applying the <a class="el" href="classstan_1_1math_1_1read__fvar__functor.html" title="Functor for extracting the values and tangents from a matrix of fvar.">read_fvar_functor</a> to extract the values and tangets of a given fvar matrix into separate matrices.  <br /></td></tr>
<tr class="separator:ac4a58ef73a4780899fdc9e1d04bc0a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46c0455299c79ad2a8172df6caa498b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab46c0455299c79ad2a8172df6caa498b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab46c0455299c79ad2a8172df6caa498b.html#ab46c0455299c79ad2a8172df6caa498b">rising_factorial</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="memdesc:ab46c0455299c79ad2a8172df6caa498b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return autodiff variable with the gradient and result of the rising factorial function applied to the inputs.  <br /></td></tr>
<tr class="separator:ab46c0455299c79ad2a8172df6caa498b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23adb89034b334771cd25cf0fa6e2e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac23adb89034b334771cd25cf0fa6e2e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac23adb89034b334771cd25cf0fa6e2e4.html#ac23adb89034b334771cd25cf0fa6e2e4">round</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:ac23adb89034b334771cd25cf0fa6e2e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the closest integer to the specified argument, with halfway cases rounded away from zero.  <br /></td></tr>
<tr class="separator:ac23adb89034b334771cd25cf0fa6e2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03498ae670c61712c7fb60381e97368e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a03498ae670c61712c7fb60381e97368e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a03498ae670c61712c7fb60381e97368e.html#a03498ae670c61712c7fb60381e97368e">sin</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a03498ae670c61712c7fb60381e97368e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ae12966e4e2e82dd0f699e95ded8694"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ae12966e4e2e82dd0f699e95ded8694"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1ae12966e4e2e82dd0f699e95ded8694.html#a1ae12966e4e2e82dd0f699e95ded8694">sin</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:a1ae12966e4e2e82dd0f699e95ded8694"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sine of the complex argument.  <br /></td></tr>
<tr class="separator:a1ae12966e4e2e82dd0f699e95ded8694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c0cb63b379f6bdb4d5f77de9f95e66"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a78c0cb63b379f6bdb4d5f77de9f95e66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a78c0cb63b379f6bdb4d5f77de9f95e66.html#a78c0cb63b379f6bdb4d5f77de9f95e66">sinh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a78c0cb63b379f6bdb4d5f77de9f95e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588b18ddd8acdf02420fd1d1c465942a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a588b18ddd8acdf02420fd1d1c465942a"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a588b18ddd8acdf02420fd1d1c465942a.html#a588b18ddd8acdf02420fd1d1c465942a">sinh</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:a588b18ddd8acdf02420fd1d1c465942a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic sine of the complex argument.  <br /></td></tr>
<tr class="separator:a588b18ddd8acdf02420fd1d1c465942a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0a27848dbb868c6bd0eece92064a10"><td class="memTemplParams" colspan="2">template&lt;typename ColVec , <a class="el" href="group__eigen__col__vector__types_ga16729dba6fafa4f518defdf9cccd3488.html#ga16729dba6fafa4f518defdf9cccd3488">require_eigen_col_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, ColVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4f0a27848dbb868c6bd0eece92064a10"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4f0a27848dbb868c6bd0eece92064a10.html#a4f0a27848dbb868c6bd0eece92064a10">softmax</a> (const ColVec &amp;alpha)</td></tr>
<tr class="separator:a4f0a27848dbb868c6bd0eece92064a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81819d20047b4d6c264b58e35bb2c48d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a81819d20047b4d6c264b58e35bb2c48d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a81819d20047b4d6c264b58e35bb2c48d.html#a81819d20047b4d6c264b58e35bb2c48d">sqrt</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a81819d20047b4d6c264b58e35bb2c48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5f4ad140fd929539f88e268e02fac2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7e5f4ad140fd929539f88e268e02fac2"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7e5f4ad140fd929539f88e268e02fac2.html#a7e5f4ad140fd929539f88e268e02fac2">sqrt</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:a7e5f4ad140fd929539f88e268e02fac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of the complex argument.  <br /></td></tr>
<tr class="separator:a7e5f4ad140fd929539f88e268e02fac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94738d2bfd07182b4aaa7e18a62fb74"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af94738d2bfd07182b4aaa7e18a62fb74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af94738d2bfd07182b4aaa7e18a62fb74.html#af94738d2bfd07182b4aaa7e18a62fb74">square</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:af94738d2bfd07182b4aaa7e18a62fb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87b3178ebb47bc38eb73d3cb0d7bc40"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__fvar__types_gab36397aaabf5accbfc5a0909ce0e3290.html#gab36397aaabf5accbfc5a0909ce0e3290">require_fvar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab87b3178ebb47bc38eb73d3cb0d7bc40"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab87b3178ebb47bc38eb73d3cb0d7bc40.html#ab87b3178ebb47bc38eb73d3cb0d7bc40">sum</a> (const std::vector&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:ab87b3178ebb47bc38eb73d3cb0d7bc40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the entries of the specified standard vector.  <br /></td></tr>
<tr class="separator:ab87b3178ebb47bc38eb73d3cb0d7bc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e94757d2d429c4b0a09e0cf00343a3"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af8e94757d2d429c4b0a09e0cf00343a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af8e94757d2d429c4b0a09e0cf00343a3.html#af8e94757d2d429c4b0a09e0cf00343a3">sum</a> (const T &amp;m)</td></tr>
<tr class="memdesc:af8e94757d2d429c4b0a09e0cf00343a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the entries of the specified matrix.  <br /></td></tr>
<tr class="separator:af8e94757d2d429c4b0a09e0cf00343a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89071e8c3d80fe0b2ac0b23c345e9a9e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a89071e8c3d80fe0b2ac0b23c345e9a9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a89071e8c3d80fe0b2ac0b23c345e9a9e.html#a89071e8c3d80fe0b2ac0b23c345e9a9e">tan</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a89071e8c3d80fe0b2ac0b23c345e9a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d2c155a8629305349bd76b6f1fa71a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa7d2c155a8629305349bd76b6f1fa71a"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa7d2c155a8629305349bd76b6f1fa71a.html#aa7d2c155a8629305349bd76b6f1fa71a">tan</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:aa7d2c155a8629305349bd76b6f1fa71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tangent of the complex argument.  <br /></td></tr>
<tr class="separator:aa7d2c155a8629305349bd76b6f1fa71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32c5cd88becea57416c65688771a7c8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab32c5cd88becea57416c65688771a7c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab32c5cd88becea57416c65688771a7c8.html#ab32c5cd88becea57416c65688771a7c8">tanh</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ab32c5cd88becea57416c65688771a7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139e23e0483341a97777b51a6b967033"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a139e23e0483341a97777b51a6b967033"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a139e23e0483341a97777b51a6b967033.html#a139e23e0483341a97777b51a6b967033">tanh</a> (const std::complex&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt; &amp;z)</td></tr>
<tr class="memdesc:a139e23e0483341a97777b51a6b967033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic tangent of the complex argument.  <br /></td></tr>
<tr class="separator:a139e23e0483341a97777b51a6b967033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c6057f60e89dc91f9d17cd36c00355b"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0c6057f60e89dc91f9d17cd36c00355b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, EigMat::RowsAtCompileTime, EigMat::RowsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0c6057f60e89dc91f9d17cd36c00355b.html#a0c6057f60e89dc91f9d17cd36c00355b">tcrossprod</a> (const EigMat &amp;m)</td></tr>
<tr class="separator:a0c6057f60e89dc91f9d17cd36c00355b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad338502e3115d34682603230479d41"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acad338502e3115d34682603230479d41"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acad338502e3115d34682603230479d41.html#acad338502e3115d34682603230479d41">tgamma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:acad338502e3115d34682603230479d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of applying the gamma function to the specified argument.  <br /></td></tr>
<tr class="separator:acad338502e3115d34682603230479d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab424a82e433d7c3797ed64c8fad9dce3"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__fvar__types_gaa4ca446563403081ee19f97627328108.html#gaa4ca446563403081ee19f97627328108">require_not_fvar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab424a82e433d7c3797ed64c8fad9dce3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab424a82e433d7c3797ed64c8fad9dce3.html#ab424a82e433d7c3797ed64c8fad9dce3">to_fvar</a> (const T &amp;x)</td></tr>
<tr class="separator:ab424a82e433d7c3797ed64c8fad9dce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3771423102a25c004b23ff0fd8f8ead"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__fvar__types_gab36397aaabf5accbfc5a0909ce0e3290.html#gab36397aaabf5accbfc5a0909ce0e3290">require_fvar_t</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af3771423102a25c004b23ff0fd8f8ead"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af3771423102a25c004b23ff0fd8f8ead.html#af3771423102a25c004b23ff0fd8f8ead">to_fvar</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:af3771423102a25c004b23ff0fd8f8ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_fvar for [containers of] fvars.  <br /></td></tr>
<tr class="separator:af3771423102a25c004b23ff0fd8f8ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3815c6bb240bddc14835ad9e9edbce"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e3815c6bb240bddc14835ad9e9edbce"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4e3815c6bb240bddc14835ad9e9edbce.html#a4e3815c6bb240bddc14835ad9e9edbce">to_fvar</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:a4e3815c6bb240bddc14835ad9e9edbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae364116e0f91dcd801f2cf757c18b182"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae364116e0f91dcd801f2cf757c18b182"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae364116e0f91dcd801f2cf757c18b182.html#ae364116e0f91dcd801f2cf757c18b182">to_fvar</a> (const std::vector&lt; T &gt; &amp;v, const std::vector&lt; T &gt; &amp;d)</td></tr>
<tr class="separator:ae364116e0f91dcd801f2cf757c18b182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20110ebe2308f900e4393b8aa69f236"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga93918b2590606552cac973a4397ab38a.html#ga93918b2590606552cac973a4397ab38a">require_not_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad20110ebe2308f900e4393b8aa69f236"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">promote_scalar_t</a>&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt;, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad20110ebe2308f900e4393b8aa69f236.html#ad20110ebe2308f900e4393b8aa69f236">to_fvar</a> (const T &amp;m)</td></tr>
<tr class="separator:ad20110ebe2308f900e4393b8aa69f236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7a00f2b9ebddd91065796e8a13a0eb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0c7a00f2b9ebddd91065796e8a13a0eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">promote_scalar_t</a>&lt; <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T1 &gt; &gt;, T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0c7a00f2b9ebddd91065796e8a13a0eb.html#a0c7a00f2b9ebddd91065796e8a13a0eb">to_fvar</a> (const T1 &amp;val, const T2 &amp;deriv)</td></tr>
<tr class="separator:a0c7a00f2b9ebddd91065796e8a13a0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfff6ba01b015f838e62299a222263eb"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr, <a class="el" href="group__fvar__types_ga0bbeba0604a99a81b25f2f6249be82c1.html#ga0bbeba0604a99a81b25f2f6249be82c1">require_any_vt_fvar</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acfff6ba01b015f838e62299a222263eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, EigMat2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acfff6ba01b015f838e62299a222263eb.html#acfff6ba01b015f838e62299a222263eb">trace_quad_form</a> (const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="separator:acfff6ba01b015f838e62299a222263eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f337f6b108752daafab06640e2c229"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a84f337f6b108752daafab06640e2c229"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a84f337f6b108752daafab06640e2c229.html#a84f337f6b108752daafab06640e2c229">trigamma</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;u)</td></tr>
<tr class="memdesc:a84f337f6b108752daafab06640e2c229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the trigamma function at the specified argument (i.e., the second derivative of the log Gamma function at the specified argument).  <br /></td></tr>
<tr class="separator:a84f337f6b108752daafab06640e2c229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac4060d610887434f513b38fb8457d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afac4060d610887434f513b38fb8457d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afac4060d610887434f513b38fb8457d6.html#afac4060d610887434f513b38fb8457d6">trunc</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:afac4060d610887434f513b38fb8457d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the nearest integral value that is not larger in magnitude than the specified argument.  <br /></td></tr>
<tr class="separator:afac4060d610887434f513b38fb8457d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541f8f9d951f4d48c457dcecad5e326b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a541f8f9d951f4d48c457dcecad5e326b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a541f8f9d951f4d48c457dcecad5e326b.html#a541f8f9d951f4d48c457dcecad5e326b">value_of</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a541f8f9d951f4d48c457dcecad5e326b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified variable.  <br /></td></tr>
<tr class="separator:a541f8f9d951f4d48c457dcecad5e326b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b8cbdec7c35e7c93b0f47dae3c5498"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a00b8cbdec7c35e7c93b0f47dae3c5498"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a00b8cbdec7c35e7c93b0f47dae3c5498.html#a00b8cbdec7c35e7c93b0f47dae3c5498">value_of_rec</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a00b8cbdec7c35e7c93b0f47dae3c5498"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified variable.  <br /></td></tr>
<tr class="separator:a00b8cbdec7c35e7c93b0f47dae3c5498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf43f9830e1d60caa8b7001ed16b36e7"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... TArgs, <a class="el" href="group__fvar__types_ga45226eaefc79330cad798db7c5a3a62d.html#ga45226eaefc79330cad798db7c5a3a62d">require_any_st_fvar</a>&lt; TArgs... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adf43f9830e1d60caa8b7001ed16b36e7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adf43f9830e1d60caa8b7001ed16b36e7.html#adf43f9830e1d60caa8b7001ed16b36e7">finite_diff</a> (const F &amp;func, const TArgs &amp;... args)</td></tr>
<tr class="memdesc:adf43f9830e1d60caa8b7001ed16b36e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an fvar&lt;T&gt; where the tangent is calculated by finite-differencing.  <br /></td></tr>
<tr class="separator:adf43f9830e1d60caa8b7001ed16b36e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410200762bf5cf510708cc72e89cd00c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a410200762bf5cf510708cc72e89cd00c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a410200762bf5cf510708cc72e89cd00c.html#a410200762bf5cf510708cc72e89cd00c">gradient</a> (const F &amp;f, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, T &amp;fx, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;grad_fx)</td></tr>
<tr class="memdesc:a410200762bf5cf510708cc72e89cd00c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value and the gradient of the specified function at the specified argument.  <br /></td></tr>
<tr class="separator:a410200762bf5cf510708cc72e89cd00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7006e79de4699a89e4980e1a6097770"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:ab7006e79de4699a89e4980e1a6097770"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab7006e79de4699a89e4980e1a6097770.html#ab7006e79de4699a89e4980e1a6097770">hessian</a> (const F &amp;f, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, T &amp;fx, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;<a class="el" href="namespacestan_1_1math_a22dec695eb198173799ce3dd1c7c6302.html#a22dec695eb198173799ce3dd1c7c6302">grad</a>, Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;H)</td></tr>
<tr class="memdesc:ab7006e79de4699a89e4980e1a6097770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value, the gradient, and the Hessian, of the specified function at the specified argument in time O(N^3) time and O(N^2) space.  <br /></td></tr>
<tr class="separator:ab7006e79de4699a89e4980e1a6097770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cfc9f7c437cfedfed173731fbd8027"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_a , typename T_b , typename... Args, <a class="el" href="group__fvar__types_ga45226eaefc79330cad798db7c5a3a62d.html#ga45226eaefc79330cad798db7c5a3a62d">require_any_st_fvar</a>&lt; T_a, T_b, Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a65cfc9f7c437cfedfed173731fbd8027"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_a, T_b, Args... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a65cfc9f7c437cfedfed173731fbd8027.html#a65cfc9f7c437cfedfed173731fbd8027">integrate_1d_impl</a> (const F &amp;f, const T_a &amp;a, const T_b &amp;b, double relative_tolerance, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:a65cfc9f7c437cfedfed173731fbd8027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the integral of f from a to b to the given relative tolerance.  <br /></td></tr>
<tr class="separator:a65cfc9f7c437cfedfed173731fbd8027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d9f775e895fe2e260e6c04a6b628d3"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_a , typename T_b , typename T_theta , <a class="el" href="group__fvar__types_ga0acbafcf4967524342a974e6afed202a.html#ga0acbafcf4967524342a974e6afed202a">require_any_fvar_t</a>&lt; T_a, T_b, T_theta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac1d9f775e895fe2e260e6c04a6b628d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_a, T_b, T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac1d9f775e895fe2e260e6c04a6b628d3.html#ac1d9f775e895fe2e260e6c04a6b628d3">integrate_1d</a> (const F &amp;f, const T_a &amp;a, const T_b &amp;b, const std::vector&lt; T_theta &gt; &amp;theta, const std::vector&lt; double &gt; &amp;x_r, const std::vector&lt; int &gt; &amp;x_i, std::ostream *msgs, const double relative_tolerance)</td></tr>
<tr class="memdesc:ac1d9f775e895fe2e260e6c04a6b628d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integral of the single variable function f from a to b to within a specified relative tolerance.  <br /></td></tr>
<tr class="separator:ac1d9f775e895fe2e260e6c04a6b628d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130c490b4d72b62bac8d835492731da3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a130c490b4d72b62bac8d835492731da3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a130c490b4d72b62bac8d835492731da3.html#a130c490b4d72b62bac8d835492731da3">jacobian</a> (const F &amp;f, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;fx, Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;J)</td></tr>
<tr class="separator:a130c490b4d72b62bac8d835492731da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d92215be48252702d0aa90083a371d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9d92215be48252702d0aa90083a371d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac9d92215be48252702d0aa90083a371d.html#ac9d92215be48252702d0aa90083a371d">std_normal_log_qf</a> (const <a class="el" href="structstan_1_1math_1_1fvar.html">fvar</a>&lt; T &gt; &amp;p)</td></tr>
<tr class="separator:ac9d92215be48252702d0aa90083a371d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7add35b0758b1d0541f7e919c36412f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7add35b0758b1d0541f7e919c36412f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7add35b0758b1d0541f7e919c36412f9.html#a7add35b0758b1d0541f7e919c36412f9">is_aligned</a> (T *ptr, unsigned int bytes_aligned)</td></tr>
<tr class="memdesc:a7add35b0758b1d0541f7e919c36412f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified pointer is aligned on the number of bytes.  <br /></td></tr>
<tr class="separator:a7add35b0758b1d0541f7e919c36412f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0597dca74b96a4287c6f848489288d44"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a0597dca74b96a4287c6f848489288d44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0597dca74b96a4287c6f848489288d44.html#a0597dca74b96a4287c6f848489288d44">derivative</a> (const F &amp;f, const T &amp;x, T &amp;fx, T &amp;dfx_dx)</td></tr>
<tr class="memdesc:a0597dca74b96a4287c6f848489288d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the derivative of the specified univariate function at the specified argument.  <br /></td></tr>
<tr class="separator:a0597dca74b96a4287c6f848489288d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90abf1400d2766c892fc438a83f7b4c1"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a90abf1400d2766c892fc438a83f7b4c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a90abf1400d2766c892fc438a83f7b4c1.html#a90abf1400d2766c892fc438a83f7b4c1">finite_diff_grad_hessian</a> (const F &amp;f, const Eigen::VectorXd &amp;x, double &amp;fx, Eigen::MatrixXd &amp;hess, std::vector&lt; Eigen::MatrixXd &gt; &amp;grad_hess_fx, double epsilon=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-04)</td></tr>
<tr class="memdesc:a90abf1400d2766c892fc438a83f7b4c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value and the gradient of the hessian of the specified function at the specified argument using second-order autodiff and first-order finite difference.  <br /></td></tr>
<tr class="separator:a90abf1400d2766c892fc438a83f7b4c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01f72777ad8719863ce55d610b656091"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a01f72777ad8719863ce55d610b656091"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a01f72777ad8719863ce55d610b656091.html#a01f72777ad8719863ce55d610b656091">finite_diff_grad_hessian_auto</a> (const F &amp;f, const Eigen::VectorXd &amp;x, double &amp;fx, Eigen::MatrixXd &amp;hess, std::vector&lt; Eigen::MatrixXd &gt; &amp;grad_hess_fx)</td></tr>
<tr class="memdesc:a01f72777ad8719863ce55d610b656091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value, Hessian, and the gradient of the Hessian of the specified function at the specified argument using second-order autodiff and first-order finite difference.  <br /></td></tr>
<tr class="separator:a01f72777ad8719863ce55d610b656091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367affe85da63060b14ae8bc988f0df6"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a367affe85da63060b14ae8bc988f0df6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a367affe85da63060b14ae8bc988f0df6.html#a367affe85da63060b14ae8bc988f0df6">grad_hessian</a> (const F &amp;f, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, double &amp;fx, Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;H, std::vector&lt; Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &gt; &amp;grad_H)</td></tr>
<tr class="memdesc:a367affe85da63060b14ae8bc988f0df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value, the Hessian, and the gradient of the Hessian of the specified function at the specified argument.  <br /></td></tr>
<tr class="separator:a367affe85da63060b14ae8bc988f0df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7face099d2313985131cde21ae17d8f"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:aa7face099d2313985131cde21ae17d8f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa7face099d2313985131cde21ae17d8f.html#aa7face099d2313985131cde21ae17d8f">grad_tr_mat_times_hessian</a> (const F &amp;f, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;M, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;grad_tr_MH)</td></tr>
<tr class="separator:aa7face099d2313985131cde21ae17d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4059a767ad9af62d85cfb9685e250e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename F &gt; </td></tr>
<tr class="memitem:aef4059a767ad9af62d85cfb9685e250e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aef4059a767ad9af62d85cfb9685e250e.html#aef4059a767ad9af62d85cfb9685e250e">gradient_dot_vector</a> (const F &amp;f, const Eigen::Matrix&lt; T1, Eigen::Dynamic, 1 &gt; &amp;x, const Eigen::Matrix&lt; T2, Eigen::Dynamic, 1 &gt; &amp;v, T1 &amp;fx, T1 &amp;grad_fx_dot_v)</td></tr>
<tr class="separator:aef4059a767ad9af62d85cfb9685e250e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01474168e03d94b982b6b4fd694b3302"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a01474168e03d94b982b6b4fd694b3302"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a01474168e03d94b982b6b4fd694b3302.html#a01474168e03d94b982b6b4fd694b3302">hessian</a> (const F &amp;f, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, double &amp;fx, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;<a class="el" href="namespacestan_1_1math_a22dec695eb198173799ce3dd1c7c6302.html#a22dec695eb198173799ce3dd1c7c6302">grad</a>, Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;H)</td></tr>
<tr class="memdesc:a01474168e03d94b982b6b4fd694b3302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value, the gradient, and the Hessian, of the specified function at the specified argument in O(N^2) time and O(N^2) space.  <br /></td></tr>
<tr class="separator:a01474168e03d94b982b6b4fd694b3302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69389a1cd22b50df04a87245292f7f85"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a69389a1cd22b50df04a87245292f7f85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a69389a1cd22b50df04a87245292f7f85.html#a69389a1cd22b50df04a87245292f7f85">hessian_times_vector</a> (const F &amp;f, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;v, double &amp;fx, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;Hv)</td></tr>
<tr class="separator:a69389a1cd22b50df04a87245292f7f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb76a7877dac777de4757af8f2677be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a1bb76a7877dac777de4757af8f2677be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1bb76a7877dac777de4757af8f2677be.html#a1bb76a7877dac777de4757af8f2677be">hessian_times_vector</a> (const F &amp;f, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;v, T &amp;fx, Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;Hv)</td></tr>
<tr class="separator:a1bb76a7877dac777de4757af8f2677be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75dae6137f91377c351b2f648b1c18e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:af75dae6137f91377c351b2f648b1c18e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af75dae6137f91377c351b2f648b1c18e.html#af75dae6137f91377c351b2f648b1c18e">partial_derivative</a> (const F &amp;f, const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, int n, T &amp;fx, T &amp;dfx_dxn)</td></tr>
<tr class="memdesc:af75dae6137f91377c351b2f648b1c18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the partial derivative of the specified multivariate function at the specified argument.  <br /></td></tr>
<tr class="separator:af75dae6137f91377c351b2f648b1c18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6779742b7bf4dfa2b9e7d6cc58806179"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga948d431ec5773ff848a6bfa0d0b7aa79.html#ga948d431ec5773ff848a6bfa0d0b7aa79">require_st_arithmetic</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6779742b7bf4dfa2b9e7d6cc58806179"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6779742b7bf4dfa2b9e7d6cc58806179.html#ga6779742b7bf4dfa2b9e7d6cc58806179">to_matrix_cl</a> (T &amp;&amp;src)</td></tr>
<tr class="memdesc:ga6779742b7bf4dfa2b9e7d6cc58806179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix, <code>std::vector</code> or scalar to the destination matrix that is stored on the OpenCL device.  <br /></td></tr>
<tr class="separator:ga6779742b7bf4dfa2b9e7d6cc58806179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf2a61125c6dca5e5a400d56e24cc6d5"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T_ret &gt; *  = nullptr, <a class="el" href="group__matrix__cl__types_gaf18202a28f3c86c16368f08c04f6532d.html#gaf18202a28f3c86c16368f08c04f6532d">require_matrix_cl_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__same__types_ga138d3e9c6d2deaf56afdac86932d73bd.html#ga138d3e9c6d2deaf56afdac86932d73bd">require_st_same</a>&lt; T_ret, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadf2a61125c6dca5e5a400d56e24cc6d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gadf2a61125c6dca5e5a400d56e24cc6d5.html#gadf2a61125c6dca5e5a400d56e24cc6d5">from_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="memdesc:gadf2a61125c6dca5e5a400d56e24cc6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source matrix that is stored on the OpenCL device to the destination <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix.  <br /></td></tr>
<tr class="separator:gadf2a61125c6dca5e5a400d56e24cc6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad35b73b8bb6ac116683220a20f4c317d"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , typename T , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__matrix__cl__types_ga1af53d2ea2874ab39e60e796c8f2c074.html#ga1af53d2ea2874ab39e60e796c8f2c074">require_not_matrix_cl_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad35b73b8bb6ac116683220a20f4c317d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gad35b73b8bb6ac116683220a20f4c317d.html#gad35b73b8bb6ac116683220a20f4c317d">from_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="memdesc:gad35b73b8bb6ac116683220a20f4c317d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies result of a kernel generator expression to the specified destination type.  <br /></td></tr>
<tr class="separator:gad35b73b8bb6ac116683220a20f4c317d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44e84cc75a88ea72d01c090997fdc556"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__same__types_ga29595127b6ba2b597e5723c80dee1b61.html#ga29595127b6ba2b597e5723c80dee1b61">require_same_t</a>&lt; T_dst, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga44e84cc75a88ea72d01c090997fdc556"><td class="memTemplItemLeft" align="right" valign="top">T_dst&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga44e84cc75a88ea72d01c090997fdc556.html#ga44e84cc75a88ea72d01c090997fdc556">from_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:ga44e84cc75a88ea72d01c090997fdc556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy A 1 by 1 source matrix from the Device to the host.  <br /></td></tr>
<tr class="separator:ga44e84cc75a88ea72d01c090997fdc556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f99f6ae3dd35f205631e839119f5541"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1f99f6ae3dd35f205631e839119f5541"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga1f99f6ae3dd35f205631e839119f5541.html#ga1f99f6ae3dd35f205631e839119f5541">from_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="memdesc:ga1f99f6ae3dd35f205631e839119f5541"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source kernel generator expression or matrix that is stored on the OpenCL device to the destination <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix.  <br /></td></tr>
<tr class="separator:ga1f99f6ae3dd35f205631e839119f5541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga490df7651c22c9e06d09da69ad303e30"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__cl__types_gaf18202a28f3c86c16368f08c04f6532d.html#gaf18202a28f3c86c16368f08c04f6532d">require_matrix_cl_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga490df7651c22c9e06d09da69ad303e30"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga490df7651c22c9e06d09da69ad303e30.html#ga490df7651c22c9e06d09da69ad303e30">packed_copy</a> (const T &amp;src)</td></tr>
<tr class="memdesc:ga490df7651c22c9e06d09da69ad303e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Packs the square flat triangular matrix on the OpenCL device and copies it to the std::vector.  <br /></td></tr>
<tr class="separator:ga490df7651c22c9e06d09da69ad303e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2e616a6b56f91890a325b9aa28adc22"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> matrix_view, typename Vec , typename Vec_scalar  = scalar_type_t&lt;Vec&gt;, <a class="el" href="group__vector__types_ga038ee4f0c3ca5d626e5159485ac74c8a.html#ga038ee4f0c3ca5d626e5159485ac74c8a">require_vector_vt</a>&lt; std::is_arithmetic, Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae2e616a6b56f91890a325b9aa28adc22"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; Vec_scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae2e616a6b56f91890a325b9aa28adc22.html#gae2e616a6b56f91890a325b9aa28adc22">packed_copy</a> (Vec &amp;&amp;src, int <a class="el" href="group__opencl_ga3d2a437bd1589a69547c959adda767f5.html#ga3d2a437bd1589a69547c959adda767f5">rows</a>)</td></tr>
<tr class="memdesc:gae2e616a6b56f91890a325b9aa28adc22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the packed triangular matrix from the source std::vector to an OpenCL buffer and unpacks it to a flat matrix on the OpenCL device.  <br /></td></tr>
<tr class="separator:gae2e616a6b56f91890a325b9aa28adc22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aa1f3ae0bc5f8b2d42217b8dc26f78c"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__cl__types_gaf18202a28f3c86c16368f08c04f6532d.html#gaf18202a28f3c86c16368f08c04f6532d">require_matrix_cl_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4aa1f3ae0bc5f8b2d42217b8dc26f78c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga4aa1f3ae0bc5f8b2d42217b8dc26f78c.html#ga4aa1f3ae0bc5f8b2d42217b8dc26f78c">copy_cl</a> (const T &amp;src)</td></tr>
<tr class="memdesc:ga4aa1f3ae0bc5f8b2d42217b8dc26f78c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source matrix to the destination matrix.  <br /></td></tr>
<tr class="separator:ga4aa1f3ae0bc5f8b2d42217b8dc26f78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37fe55b7d7b3c0ae69f331104dcd3d64"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga37fe55b7d7b3c0ae69f331104dcd3d64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__error__checks__opencl_ga37fe55b7d7b3c0ae69f331104dcd3d64.html#ga37fe55b7d7b3c0ae69f331104dcd3d64">check_mat_not_size_one</a> (const char *function, const char *name, const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ga37fe55b7d7b3c0ae69f331104dcd3d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> has a single element.  <br /></td></tr>
<tr class="separator:ga37fe55b7d7b3c0ae69f331104dcd3d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga423364ebfbb176382d94cb3e2786d4cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__error__checks__opencl_ga423364ebfbb176382d94cb3e2786d4cc.html#ga423364ebfbb176382d94cb3e2786d4cc">check_opencl_error</a> (const char *function, const cl::Error &amp;<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>)</td></tr>
<tr class="memdesc:ga423364ebfbb176382d94cb3e2786d4cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws the domain error with specifying the OpenCL error that occurred.  <br /></td></tr>
<tr class="separator:ga423364ebfbb176382d94cb3e2786d4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ea8fac58afac1cbf0d1351f849dd102"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga3ea8fac58afac1cbf0d1351f849dd102"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__error__checks__opencl_ga3ea8fac58afac1cbf0d1351f849dd102.html#ga3ea8fac58afac1cbf0d1351f849dd102">check_symmetric</a> (const char *function, const char *name, const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;y)</td></tr>
<tr class="memdesc:ga3ea8fac58afac1cbf0d1351f849dd102"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> is symmetric.  <br /></td></tr>
<tr class="separator:ga3ea8fac58afac1cbf0d1351f849dd102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15a3d98d59dfcc1e81c2a28d207cb645"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__cl__types_gaf18202a28f3c86c16368f08c04f6532d.html#gaf18202a28f3c86c16368f08c04f6532d">require_matrix_cl_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga15a3d98d59dfcc1e81c2a28d207cb645"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__error__checks__opencl_ga15a3d98d59dfcc1e81c2a28d207cb645.html#ga15a3d98d59dfcc1e81c2a28d207cb645">check_triangular</a> (const char *function, const char *name, const T &amp;A)</td></tr>
<tr class="memdesc:ga15a3d98d59dfcc1e81c2a28d207cb645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> is either upper triangular or lower triangular.  <br /></td></tr>
<tr class="separator:ga15a3d98d59dfcc1e81c2a28d207cb645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a8107a1e78d28e7803dfd4a038e381"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac4a8107a1e78d28e7803dfd4a038e381.html#ac4a8107a1e78d28e7803dfd4a038e381">indexing_rev</a> (<a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;adj, const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; int &gt; &amp;idx, const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;res)</td></tr>
<tr class="memdesc:ac4a8107a1e78d28e7803dfd4a038e381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs reverse pass for indexing operation on the OpenCL device.  <br /></td></tr>
<tr class="separator:ac4a8107a1e78d28e7803dfd4a038e381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb1db7fccc42c2b7e5520838ac53e43d"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;Ta, Tb&gt;&gt; </td></tr>
<tr class="memitem:gaeb1db7fccc42c2b7e5520838ac53e43d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaeb1db7fccc42c2b7e5520838ac53e43d.html#gaeb1db7fccc42c2b7e5520838ac53e43d">append_row</a> (Ta &amp;&amp;a, Tb &amp;&amp;b)</td></tr>
<tr class="memdesc:gaeb1db7fccc42c2b7e5520838ac53e43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack the rows of the first argument on top of the second argument.  <br /></td></tr>
<tr class="separator:gaeb1db7fccc42c2b7e5520838ac53e43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga445eb497e5d75296e287de54a4dacc2c"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;Ta, Tb&gt;&gt; </td></tr>
<tr class="memitem:ga445eb497e5d75296e287de54a4dacc2c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga445eb497e5d75296e287de54a4dacc2c.html#ga445eb497e5d75296e287de54a4dacc2c">append_col</a> (Ta &amp;&amp;a, Tb &amp;&amp;b)</td></tr>
<tr class="memdesc:ga445eb497e5d75296e287de54a4dacc2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stack the cols of the arguments.  <br /></td></tr>
<tr class="separator:ga445eb497e5d75296e287de54a4dacc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49b6d73fd76664578829b28d346a4f45"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga49b6d73fd76664578829b28d346a4f45"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga49b6d73fd76664578829b28d346a4f45.html#ga49b6d73fd76664578829b28d346a4f45">as_column_vector_or_scalar</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga49b6d73fd76664578829b28d346a4f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">as_column_vector_or_scalar of a kernel generator expression.  <br /></td></tr>
<tr class="separator:ga49b6d73fd76664578829b28d346a4f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9dac47c0aa34d350bcf7e7f76fa87c1"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacestan_1_1math_ac87ada2bc2f3a7388f0c092d906f11f8.html#ac87ada2bc2f3a7388f0c092d906f11f8">assign_op_cl</a> AssignOp = assign_op_cl::equals, typename T_operation , typename  = std::enable_if_t&lt;std::is_base_of&lt;              operation_cl_base, std::remove_reference_t&lt;T_operation&gt;&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gad9dac47c0aa34d350bcf7e7f76fa87c1"><td class="memTemplItemLeft" align="right" valign="top">T_operation &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gad9dac47c0aa34d350bcf7e7f76fa87c1.html#gad9dac47c0aa34d350bcf7e7f76fa87c1">as_operation_cl</a> (T_operation &amp;&amp;a)</td></tr>
<tr class="memdesc:gad9dac47c0aa34d350bcf7e7f76fa87c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts any valid kernel generator expression into an operation.  <br /></td></tr>
<tr class="separator:gad9dac47c0aa34d350bcf7e7f76fa87c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36ac239f64776ec025ff70fbf5aed461"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacestan_1_1math_ac87ada2bc2f3a7388f0c092d906f11f8.html#ac87ada2bc2f3a7388f0c092d906f11f8">assign_op_cl</a> AssignOp = assign_op_cl::equals, typename T_scalar , typename  = require_arithmetic_t&lt;T_scalar&gt;, <a class="el" href="group__same__types_ga151adb676402a791de98a5d743d7a10d.html#ga151adb676402a791de98a5d743d7a10d">require_not_same_t</a>&lt; T_scalar, bool &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga36ac239f64776ec025ff70fbf5aed461"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1scalar__.html">scalar_</a>&lt; T_scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga36ac239f64776ec025ff70fbf5aed461.html#ga36ac239f64776ec025ff70fbf5aed461">as_operation_cl</a> (const T_scalar a)</td></tr>
<tr class="memdesc:ga36ac239f64776ec025ff70fbf5aed461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts any valid kernel generator expression into an operation.  <br /></td></tr>
<tr class="separator:ga36ac239f64776ec025ff70fbf5aed461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafff4255d4674bd7dae3632700094472e"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacestan_1_1math_ac87ada2bc2f3a7388f0c092d906f11f8.html#ac87ada2bc2f3a7388f0c092d906f11f8">assign_op_cl</a> AssignOp = assign_op_cl::equals&gt; </td></tr>
<tr class="memitem:gafff4255d4674bd7dae3632700094472e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1scalar__.html">scalar_</a>&lt; char &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gafff4255d4674bd7dae3632700094472e.html#gafff4255d4674bd7dae3632700094472e">as_operation_cl</a> (const bool a)</td></tr>
<tr class="memdesc:gafff4255d4674bd7dae3632700094472e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts any valid kernel generator expression into an operation.  <br /></td></tr>
<tr class="separator:gafff4255d4674bd7dae3632700094472e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bb015f1a8fa5e4e2310762f1ce4ac67"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacestan_1_1math_ac87ada2bc2f3a7388f0c092d906f11f8.html#ac87ada2bc2f3a7388f0c092d906f11f8">assign_op_cl</a> AssignOp = assign_op_cl::equals, typename T_matrix_cl , typename  = require_any_t&lt;is_matrix_cl&lt;T_matrix_cl&gt;,                                   is_arena_matrix_cl&lt;T_matrix_cl&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga1bb015f1a8fa5e4e2310762f1ce4ac67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1load__.html">load_</a>&lt; T_matrix_cl, AssignOp &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga1bb015f1a8fa5e4e2310762f1ce4ac67.html#ga1bb015f1a8fa5e4e2310762f1ce4ac67">as_operation_cl</a> (T_matrix_cl &amp;&amp;a)</td></tr>
<tr class="memdesc:ga1bb015f1a8fa5e4e2310762f1ce4ac67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts any valid kernel generator expression into an operation.  <br /></td></tr>
<tr class="separator:ga1bb015f1a8fa5e4e2310762f1ce4ac67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf6132c8d1c8f5f21d8f5f145db38fc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0bf6132c8d1c8f5f21d8f5f145db38fc"><td class="memTemplItemLeft" align="right" valign="top">constexpr const char *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0bf6132c8d1c8f5f21d8f5f145db38fc.html#a0bf6132c8d1c8f5f21d8f5f145db38fc">assignment_op</a> () noexcept</td></tr>
<tr class="separator:a0bf6132c8d1c8f5f21d8f5f145db38fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1989f3481ad084e7829e05e7208957c5"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gacd5c059c1d9e54bdf3ee973388a47896.html#gacd5c059c1d9e54bdf3ee973388a47896">require_any_not_arithmetic_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1989f3481ad084e7829e05e7208957c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1addition__operator__.html">addition_operator_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga1989f3481ad084e7829e05e7208957c5.html#ga1989f3481ad084e7829e05e7208957c5">operator+</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga1989f3481ad084e7829e05e7208957c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga505ddf2b97212a094fd7e9bbfeaab005"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gacd5c059c1d9e54bdf3ee973388a47896.html#gacd5c059c1d9e54bdf3ee973388a47896">require_any_not_arithmetic_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga505ddf2b97212a094fd7e9bbfeaab005"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1addition__.html">addition_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga505ddf2b97212a094fd7e9bbfeaab005.html#ga505ddf2b97212a094fd7e9bbfeaab005">add</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga505ddf2b97212a094fd7e9bbfeaab005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga904fefe8e6ed4f7cfa3af309853b9210"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gacd5c059c1d9e54bdf3ee973388a47896.html#gacd5c059c1d9e54bdf3ee973388a47896">require_any_not_arithmetic_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga904fefe8e6ed4f7cfa3af309853b9210"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1subtraction__operator__.html">subtraction_operator_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga904fefe8e6ed4f7cfa3af309853b9210.html#ga904fefe8e6ed4f7cfa3af309853b9210">operator-</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga904fefe8e6ed4f7cfa3af309853b9210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ba76fcd6f07dba878951e8e2f078076"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gacd5c059c1d9e54bdf3ee973388a47896.html#gacd5c059c1d9e54bdf3ee973388a47896">require_any_not_arithmetic_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0ba76fcd6f07dba878951e8e2f078076"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1subtraction__.html">subtraction_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga0ba76fcd6f07dba878951e8e2f078076.html#ga0ba76fcd6f07dba878951e8e2f078076">subtract</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga0ba76fcd6f07dba878951e8e2f078076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05afa2f979e687aa3d7aeb8bb490155b"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gacd5c059c1d9e54bdf3ee973388a47896.html#gacd5c059c1d9e54bdf3ee973388a47896">require_any_not_arithmetic_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga05afa2f979e687aa3d7aeb8bb490155b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1elt__multiply__.html">elt_multiply_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga05afa2f979e687aa3d7aeb8bb490155b.html#ga05afa2f979e687aa3d7aeb8bb490155b">elt_multiply</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga05afa2f979e687aa3d7aeb8bb490155b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga642857aedb73cb70e1303617d963e087"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gacd5c059c1d9e54bdf3ee973388a47896.html#gacd5c059c1d9e54bdf3ee973388a47896">require_any_not_arithmetic_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga642857aedb73cb70e1303617d963e087"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1elt__divide__.html">elt_divide_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga642857aedb73cb70e1303617d963e087.html#ga642857aedb73cb70e1303617d963e087">elt_divide</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga642857aedb73cb70e1303617d963e087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b9b34c6bc0d779ff251fa7cb66f0ca1"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gacd5c059c1d9e54bdf3ee973388a47896.html#gacd5c059c1d9e54bdf3ee973388a47896">require_any_not_arithmetic_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0b9b34c6bc0d779ff251fa7cb66f0ca1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1elt__modulo__.html">elt_modulo_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga0b9b34c6bc0d779ff251fa7cb66f0ca1.html#ga0b9b34c6bc0d779ff251fa7cb66f0ca1">operator%</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga0b9b34c6bc0d779ff251fa7cb66f0ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ec92b488e804c945dfb691500ae19b0"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gacd5c059c1d9e54bdf3ee973388a47896.html#gacd5c059c1d9e54bdf3ee973388a47896">require_any_not_arithmetic_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2ec92b488e804c945dfb691500ae19b0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1less__than__.html">less_than_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga2ec92b488e804c945dfb691500ae19b0.html#ga2ec92b488e804c945dfb691500ae19b0">operator&lt;</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga2ec92b488e804c945dfb691500ae19b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga723d1952545ce9ebfa44fc41dbfc1fdb"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gacd5c059c1d9e54bdf3ee973388a47896.html#gacd5c059c1d9e54bdf3ee973388a47896">require_any_not_arithmetic_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga723d1952545ce9ebfa44fc41dbfc1fdb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1less__than__or__equal__.html">less_than_or_equal_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga723d1952545ce9ebfa44fc41dbfc1fdb.html#ga723d1952545ce9ebfa44fc41dbfc1fdb">operator&lt;=</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga723d1952545ce9ebfa44fc41dbfc1fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44a528b7f3f53ef06e3865065f89df64"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gacd5c059c1d9e54bdf3ee973388a47896.html#gacd5c059c1d9e54bdf3ee973388a47896">require_any_not_arithmetic_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga44a528b7f3f53ef06e3865065f89df64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1greater__than__.html">greater_than_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga44a528b7f3f53ef06e3865065f89df64.html#ga44a528b7f3f53ef06e3865065f89df64">operator&gt;</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga44a528b7f3f53ef06e3865065f89df64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47cfdf86bbececf2b3d1ac7b2f4f48c5"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gacd5c059c1d9e54bdf3ee973388a47896.html#gacd5c059c1d9e54bdf3ee973388a47896">require_any_not_arithmetic_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga47cfdf86bbececf2b3d1ac7b2f4f48c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1greater__than__or__equal__.html">greater_than_or_equal_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga47cfdf86bbececf2b3d1ac7b2f4f48c5.html#ga47cfdf86bbececf2b3d1ac7b2f4f48c5">operator&gt;=</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga47cfdf86bbececf2b3d1ac7b2f4f48c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac30735a4584a3dfb94426ab75285a050"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gacd5c059c1d9e54bdf3ee973388a47896.html#gacd5c059c1d9e54bdf3ee973388a47896">require_any_not_arithmetic_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac30735a4584a3dfb94426ab75285a050"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1equals__.html">equals_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gac30735a4584a3dfb94426ab75285a050.html#gac30735a4584a3dfb94426ab75285a050">operator==</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:gac30735a4584a3dfb94426ab75285a050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ab9787b40be051da7471e89dbea09ea"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gacd5c059c1d9e54bdf3ee973388a47896.html#gacd5c059c1d9e54bdf3ee973388a47896">require_any_not_arithmetic_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3ab9787b40be051da7471e89dbea09ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1not__equals__.html">not_equals_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga3ab9787b40be051da7471e89dbea09ea.html#ga3ab9787b40be051da7471e89dbea09ea">operator!=</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga3ab9787b40be051da7471e89dbea09ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f72fb5eacc4c121f8156fe174af75aa"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gacd5c059c1d9e54bdf3ee973388a47896.html#gacd5c059c1d9e54bdf3ee973388a47896">require_any_not_arithmetic_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7f72fb5eacc4c121f8156fe174af75aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1logical__or__.html">logical_or_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga7f72fb5eacc4c121f8156fe174af75aa.html#ga7f72fb5eacc4c121f8156fe174af75aa">operator||</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:ga7f72fb5eacc4c121f8156fe174af75aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfbebbd352f46e3bee1ff3e152747595"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gacd5c059c1d9e54bdf3ee973388a47896.html#gacd5c059c1d9e54bdf3ee973388a47896">require_any_not_arithmetic_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacfbebbd352f46e3bee1ff3e152747595"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1logical__and__.html">logical_and_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gacfbebbd352f46e3bee1ff3e152747595.html#gacfbebbd352f46e3bee1ff3e152747595">operator&amp;&amp;</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="separator:gacfbebbd352f46e3bee1ff3e152747595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05b83e442459266370c1fcdb6837d0d4"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , typename  = require_arithmetic_t&lt;T_a&gt;, typename  = require_all_kernel_expressions_t&lt;T_b&gt;&gt; </td></tr>
<tr class="memitem:ga05b83e442459266370c1fcdb6837d0d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1elt__multiply__.html">elt_multiply_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga05b83e442459266370c1fcdb6837d0d4.html#ga05b83e442459266370c1fcdb6837d0d4">operator*</a> (T_a a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:ga05b83e442459266370c1fcdb6837d0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of a scalar and a kernel generator expression.  <br /></td></tr>
<tr class="separator:ga05b83e442459266370c1fcdb6837d0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1644f0c590f237ad58cd6ece1ba96153"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , typename  = require_all_kernel_expressions_t&lt;T_a&gt;, typename  = require_arithmetic_t&lt;T_b&gt;&gt; </td></tr>
<tr class="memitem:ga1644f0c590f237ad58cd6ece1ba96153"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1elt__multiply__.html">elt_multiply_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_a &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga1644f0c590f237ad58cd6ece1ba96153.html#ga1644f0c590f237ad58cd6ece1ba96153">operator*</a> (T_a &amp;&amp;a, const T_b b)</td></tr>
<tr class="memdesc:ga1644f0c590f237ad58cd6ece1ba96153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of a kernel generator expression and a scalar.  <br /></td></tr>
<tr class="separator:ga1644f0c590f237ad58cd6ece1ba96153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d6bb538a249a820efc2c1c6c9623bfd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga1d6bb538a249a820efc2c1c6c9623bfd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga1d6bb538a249a820efc2c1c6c9623bfd.html#ga1d6bb538a249a820efc2c1c6c9623bfd">block_zero_based</a> (T &amp;&amp;a, int start_row, int start_col, int <a class="el" href="group__opencl_ga3d2a437bd1589a69547c959adda767f5.html#ga3d2a437bd1589a69547c959adda767f5">rows</a>, int <a class="el" href="group__opencl_ga2b2bf6efe8102f577be540859fde068f.html#ga2b2bf6efe8102f577be540859fde068f">cols</a>)</td></tr>
<tr class="memdesc:ga1d6bb538a249a820efc2c1c6c9623bfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block of a kernel generator expression.  <br /></td></tr>
<tr class="separator:ga1d6bb538a249a820efc2c1c6c9623bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd16ecbfb480688fb732d01e223fab77"><td class="memTemplParams" colspan="2">template&lt;bool Colwise, bool Rowwise, typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gacd16ecbfb480688fb732d01e223fab77"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gacd16ecbfb480688fb732d01e223fab77.html#gacd16ecbfb480688fb732d01e223fab77">broadcast</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:gacd16ecbfb480688fb732d01e223fab77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast an expression in specified dimension(s).  <br /></td></tr>
<tr class="separator:gacd16ecbfb480688fb732d01e223fab77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ffbc8e3f24b76f2c0b94515c3de334a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga7ffbc8e3f24b76f2c0b94515c3de334a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga7ffbc8e3f24b76f2c0b94515c3de334a.html#ga7ffbc8e3f24b76f2c0b94515c3de334a">rowwise_broadcast</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga7ffbc8e3f24b76f2c0b94515c3de334a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast an expression in rowwise dimmension.  <br /></td></tr>
<tr class="separator:ga7ffbc8e3f24b76f2c0b94515c3de334a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa28ef8d2761ad8fa48ad1778f53d82ba"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaa28ef8d2761ad8fa48ad1778f53d82ba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaa28ef8d2761ad8fa48ad1778f53d82ba.html#gaa28ef8d2761ad8fa48ad1778f53d82ba">colwise_broadcast</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:gaa28ef8d2761ad8fa48ad1778f53d82ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast an expression in colwise dimmension.  <br /></td></tr>
<tr class="separator:gaa28ef8d2761ad8fa48ad1778f53d82ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1ffe8c372a7efb4fb9b23c4fae089be"><td class="memTemplParams" colspan="2">template&lt;bool Do_Calculate, typename T , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr, std::enable_if_t&lt; Do_Calculate &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa1ffe8c372a7efb4fb9b23c4fae089be"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1calc__if__.html">calc_if_</a>&lt; true, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaa1ffe8c372a7efb4fb9b23c4fae089be.html#gaa1ffe8c372a7efb4fb9b23c4fae089be">calc_if</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gaa1ffe8c372a7efb4fb9b23c4fae089be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5fe9f03a02f0f91fe12e78c5cd2d0915"><td class="memTemplParams" colspan="2">template&lt;bool Do_Calculate, typename T , std::enable_if_t&lt;!Do_Calculate &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5fe9f03a02f0f91fe12e78c5cd2d0915"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1calc__if__.html">calc_if_</a>&lt; false, <a class="el" href="classstan_1_1math_1_1scalar__.html">scalar_</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5fe9f03a02f0f91fe12e78c5cd2d0915.html#ga5fe9f03a02f0f91fe12e78c5cd2d0915">calc_if</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga5fe9f03a02f0f91fe12e78c5cd2d0915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaace1262353bcb0ba8e369e99f3c5339e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaace1262353bcb0ba8e369e99f3c5339e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaace1262353bcb0ba8e369e99f3c5339e.html#gaace1262353bcb0ba8e369e99f3c5339e">cast</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:gaace1262353bcb0ba8e369e99f3c5339e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typecast a kernel generator expression scalar.  <br /></td></tr>
<tr class="separator:gaace1262353bcb0ba8e369e99f3c5339e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5904efe5d55bebac3db9dafde40cd512"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename T , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5904efe5d55bebac3db9dafde40cd512"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5904efe5d55bebac3db9dafde40cd512.html#ga5904efe5d55bebac3db9dafde40cd512">cast</a> (T a)</td></tr>
<tr class="memdesc:ga5904efe5d55bebac3db9dafde40cd512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typecast a scalar.  <br /></td></tr>
<tr class="separator:ga5904efe5d55bebac3db9dafde40cd512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b0a4a52a729c417161974bfd526c043"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga1b0a4a52a729c417161974bfd526c043"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga1b0a4a52a729c417161974bfd526c043.html#ga1b0a4a52a729c417161974bfd526c043">check_cl</a> (const char *function, const char *var_name, T &amp;&amp;y, const char *must_be)</td></tr>
<tr class="memdesc:ga1b0a4a52a729c417161974bfd526c043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a check on opencl matrix or expression.  <br /></td></tr>
<tr class="separator:ga1b0a4a52a729c417161974bfd526c043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c8533589d450256f0bb58ebb086f68"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac1c8533589d450256f0bb58ebb086f68"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gac1c8533589d450256f0bb58ebb086f68.html#gac1c8533589d450256f0bb58ebb086f68">colwise_sum</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:gac1c8533589d450256f0bb58ebb086f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column wise sum - reduction of a kernel generator expression.  <br /></td></tr>
<tr class="separator:gac1c8533589d450256f0bb58ebb086f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e6cea99ace723931f31c6bda069c088"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e6cea99ace723931f31c6bda069c088"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5e6cea99ace723931f31c6bda069c088.html#ga5e6cea99ace723931f31c6bda069c088">colwise_prod</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga5e6cea99ace723931f31c6bda069c088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column wise product - reduction of a kernel generator expression.  <br /></td></tr>
<tr class="separator:ga5e6cea99ace723931f31c6bda069c088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cfb404a55fe1fd585eb06122493f67b"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9cfb404a55fe1fd585eb06122493f67b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga9cfb404a55fe1fd585eb06122493f67b.html#ga9cfb404a55fe1fd585eb06122493f67b">colwise_max</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga9cfb404a55fe1fd585eb06122493f67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column wise max - reduction of a kernel generator expression.  <br /></td></tr>
<tr class="separator:ga9cfb404a55fe1fd585eb06122493f67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5446e97dca7e1fb6288d29df4528cede"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5446e97dca7e1fb6288d29df4528cede"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5446e97dca7e1fb6288d29df4528cede.html#ga5446e97dca7e1fb6288d29df4528cede">colwise_min</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga5446e97dca7e1fb6288d29df4528cede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column wise min - reduction of a kernel generator expression.  <br /></td></tr>
<tr class="separator:ga5446e97dca7e1fb6288d29df4528cede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240b3ea66c560edf50c4b63dab6775c0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__kernel__expression__lhs__types_ga1c44716e311a75053a72c4e3d53bd46e.html#ga1c44716e311a75053a72c4e3d53bd46e">require_kernel_expression_lhs_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a240b3ea66c560edf50c4b63dab6775c0"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a240b3ea66c560edf50c4b63dab6775c0.html#a240b3ea66c560edf50c4b63dab6775c0">operator+=</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:a240b3ea66c560edf50c4b63dab6775c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bdcd919027229035279ea0f157e5eff"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__kernel__expression__lhs__types_ga1c44716e311a75053a72c4e3d53bd46e.html#ga1c44716e311a75053a72c4e3d53bd46e">require_kernel_expression_lhs_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7bdcd919027229035279ea0f157e5eff"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7bdcd919027229035279ea0f157e5eff.html#a7bdcd919027229035279ea0f157e5eff">operator-=</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:a7bdcd919027229035279ea0f157e5eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfa876f91c64c09b6c76add5105d74a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__kernel__expression__lhs__types_ga1c44716e311a75053a72c4e3d53bd46e.html#ga1c44716e311a75053a72c4e3d53bd46e">require_kernel_expression_lhs_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adbfa876f91c64c09b6c76add5105d74a"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adbfa876f91c64c09b6c76add5105d74a.html#adbfa876f91c64c09b6c76add5105d74a">operator*=</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:adbfa876f91c64c09b6c76add5105d74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71e31d4c847f3f3fd6d5d35d699b02dc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga71e31d4c847f3f3fd6d5d35d699b02dc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga71e31d4c847f3f3fd6d5d35d699b02dc.html#ga71e31d4c847f3f3fd6d5d35d699b02dc">constant</a> (const T a, int <a class="el" href="group__opencl_ga3d2a437bd1589a69547c959adda767f5.html#ga3d2a437bd1589a69547c959adda767f5">rows</a>, int <a class="el" href="group__opencl_ga2b2bf6efe8102f577be540859fde068f.html#ga2b2bf6efe8102f577be540859fde068f">cols</a>)</td></tr>
<tr class="memdesc:ga71e31d4c847f3f3fd6d5d35d699b02dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix of repeated values in kernel generator expressions.  <br /></td></tr>
<tr class="separator:ga71e31d4c847f3f3fd6d5d35d699b02dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6ad1aee7528a82a3261ee6e096cd7ea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gad6ad1aee7528a82a3261ee6e096cd7ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gad6ad1aee7528a82a3261ee6e096cd7ea.html#gad6ad1aee7528a82a3261ee6e096cd7ea">diagonal</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:gad6ad1aee7528a82a3261ee6e096cd7ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Diagonal of a kernel generator expression.  <br /></td></tr>
<tr class="separator:gad6ad1aee7528a82a3261ee6e096cd7ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eace19a0b21427112095de7f6eb8e9c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga2eace19a0b21427112095de7f6eb8e9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1rsqrt__.html">rsqrt_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga2eace19a0b21427112095de7f6eb8e9c.html#ga2eace19a0b21427112095de7f6eb8e9c">rsqrt</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga2eace19a0b21427112095de7f6eb8e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1b9aa7c96d2e33fa46b528db2534770"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gad1b9aa7c96d2e33fa46b528db2534770"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1sqrt__.html">sqrt_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gad1b9aa7c96d2e33fa46b528db2534770.html#gad1b9aa7c96d2e33fa46b528db2534770">sqrt</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gad1b9aa7c96d2e33fa46b528db2534770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga462e1cbe5465c202e75586ea141814d6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga462e1cbe5465c202e75586ea141814d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1cbrt__.html">cbrt_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga462e1cbe5465c202e75586ea141814d6.html#ga462e1cbe5465c202e75586ea141814d6">cbrt</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga462e1cbe5465c202e75586ea141814d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47471bb3dedd3e4f3b52376623621c52"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga47471bb3dedd3e4f3b52376623621c52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1exp__.html">exp_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga47471bb3dedd3e4f3b52376623621c52.html#ga47471bb3dedd3e4f3b52376623621c52">exp</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga47471bb3dedd3e4f3b52376623621c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae36378cdf408100c1b6f040c48bbc991"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gae36378cdf408100c1b6f040c48bbc991"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1exp2__.html">exp2_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gae36378cdf408100c1b6f040c48bbc991.html#gae36378cdf408100c1b6f040c48bbc991">exp2</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gae36378cdf408100c1b6f040c48bbc991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f83fd6521d9a1eb9330f50a3ec2674c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga4f83fd6521d9a1eb9330f50a3ec2674c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1expm1__.html">expm1_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga4f83fd6521d9a1eb9330f50a3ec2674c.html#ga4f83fd6521d9a1eb9330f50a3ec2674c">expm1</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga4f83fd6521d9a1eb9330f50a3ec2674c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4a9aa1d569482e75b36c1495032cda"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga5a4a9aa1d569482e75b36c1495032cda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log__.html">log_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5a4a9aa1d569482e75b36c1495032cda.html#ga5a4a9aa1d569482e75b36c1495032cda">log</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga5a4a9aa1d569482e75b36c1495032cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga501e5a47c6717b0e6001bc5ecf518e0d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga501e5a47c6717b0e6001bc5ecf518e0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log2__.html">log2_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga501e5a47c6717b0e6001bc5ecf518e0d.html#ga501e5a47c6717b0e6001bc5ecf518e0d">log2</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga501e5a47c6717b0e6001bc5ecf518e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23de75562aff6e79a6e7ad747b87afcc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga23de75562aff6e79a6e7ad747b87afcc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log10__.html">log10_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga23de75562aff6e79a6e7ad747b87afcc.html#ga23de75562aff6e79a6e7ad747b87afcc">log10</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga23de75562aff6e79a6e7ad747b87afcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5649c403c455a58fb01dd634e7a7be6a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga5649c403c455a58fb01dd634e7a7be6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log1p__.html">log1p_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5649c403c455a58fb01dd634e7a7be6a.html#ga5649c403c455a58fb01dd634e7a7be6a">log1p</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga5649c403c455a58fb01dd634e7a7be6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga902301e835e11580ed4274b64a310b0a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga902301e835e11580ed4274b64a310b0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1sin__.html">sin_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga902301e835e11580ed4274b64a310b0a.html#ga902301e835e11580ed4274b64a310b0a">sin</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga902301e835e11580ed4274b64a310b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd7d6396bdf936218669de35e8d843b1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gabd7d6396bdf936218669de35e8d843b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1sinh__.html">sinh_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gabd7d6396bdf936218669de35e8d843b1.html#gabd7d6396bdf936218669de35e8d843b1">sinh</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gabd7d6396bdf936218669de35e8d843b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa615836bb5cc648b3befa892046d7444"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaa615836bb5cc648b3befa892046d7444"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1cos__.html">cos_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaa615836bb5cc648b3befa892046d7444.html#gaa615836bb5cc648b3befa892046d7444">cos</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gaa615836bb5cc648b3befa892046d7444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a6703db2392b6cef014797740a65320"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga3a6703db2392b6cef014797740a65320"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1cosh__.html">cosh_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga3a6703db2392b6cef014797740a65320.html#ga3a6703db2392b6cef014797740a65320">cosh</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga3a6703db2392b6cef014797740a65320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09117e8f53f0573f14129ac3515d36f1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga09117e8f53f0573f14129ac3515d36f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1tan__.html">tan_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga09117e8f53f0573f14129ac3515d36f1.html#ga09117e8f53f0573f14129ac3515d36f1">tan</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga09117e8f53f0573f14129ac3515d36f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab769c9a49dc59d30ea48a745ed115bd2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gab769c9a49dc59d30ea48a745ed115bd2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1tanh__.html">tanh_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gab769c9a49dc59d30ea48a745ed115bd2.html#gab769c9a49dc59d30ea48a745ed115bd2">tanh</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gab769c9a49dc59d30ea48a745ed115bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb3076a07af3a8fd84618fad720a05d4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gacb3076a07af3a8fd84618fad720a05d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1asin__.html">asin_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gacb3076a07af3a8fd84618fad720a05d4.html#gacb3076a07af3a8fd84618fad720a05d4">asin</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gacb3076a07af3a8fd84618fad720a05d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8df1e77c4e0ea2a14bf2c2c541331cfe"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga8df1e77c4e0ea2a14bf2c2c541331cfe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1asinh__.html">asinh_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga8df1e77c4e0ea2a14bf2c2c541331cfe.html#ga8df1e77c4e0ea2a14bf2c2c541331cfe">asinh</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga8df1e77c4e0ea2a14bf2c2c541331cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d6528918a51cc3a276df8712aebf442"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga1d6528918a51cc3a276df8712aebf442"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1acos__.html">acos_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga1d6528918a51cc3a276df8712aebf442.html#ga1d6528918a51cc3a276df8712aebf442">acos</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga1d6528918a51cc3a276df8712aebf442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga582d5a747a034033d9d0e283a5415154"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga582d5a747a034033d9d0e283a5415154"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1acosh__.html">acosh_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga582d5a747a034033d9d0e283a5415154.html#ga582d5a747a034033d9d0e283a5415154">acosh</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga582d5a747a034033d9d0e283a5415154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f37bb3087c968b3b15d4fa67b743778"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga2f37bb3087c968b3b15d4fa67b743778"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1atan__.html">atan_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga2f37bb3087c968b3b15d4fa67b743778.html#ga2f37bb3087c968b3b15d4fa67b743778">atan</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga2f37bb3087c968b3b15d4fa67b743778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabac96a980d5e5609d5f0406c9fab7dec"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gabac96a980d5e5609d5f0406c9fab7dec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1atanh__.html">atanh_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gabac96a980d5e5609d5f0406c9fab7dec.html#gabac96a980d5e5609d5f0406c9fab7dec">atanh</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gabac96a980d5e5609d5f0406c9fab7dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga348ccd062227dd87861a5814d7fb9522"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga348ccd062227dd87861a5814d7fb9522"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1tgamma__.html">tgamma_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga348ccd062227dd87861a5814d7fb9522.html#ga348ccd062227dd87861a5814d7fb9522">tgamma</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga348ccd062227dd87861a5814d7fb9522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5de1b62cc92eb90fee57eda09592821a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga5de1b62cc92eb90fee57eda09592821a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1lgamma__.html">lgamma_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5de1b62cc92eb90fee57eda09592821a.html#ga5de1b62cc92eb90fee57eda09592821a">lgamma</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga5de1b62cc92eb90fee57eda09592821a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa3a0be1b48306c15add18d96f6796bd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaaa3a0be1b48306c15add18d96f6796bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1erf__.html">erf_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaaa3a0be1b48306c15add18d96f6796bd.html#gaaa3a0be1b48306c15add18d96f6796bd">erf</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gaaa3a0be1b48306c15add18d96f6796bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90b7f8cfe7498b666bbbf01fd519725e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga90b7f8cfe7498b666bbbf01fd519725e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1erfc__.html">erfc_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga90b7f8cfe7498b666bbbf01fd519725e.html#ga90b7f8cfe7498b666bbbf01fd519725e">erfc</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga90b7f8cfe7498b666bbbf01fd519725e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga917698216325b80844f330406506bdae"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga917698216325b80844f330406506bdae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1floor__.html">floor_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga917698216325b80844f330406506bdae.html#ga917698216325b80844f330406506bdae">floor</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga917698216325b80844f330406506bdae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga135bd89c147c13b5f0865ef605a5460f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga135bd89c147c13b5f0865ef605a5460f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1round__.html">round_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga135bd89c147c13b5f0865ef605a5460f.html#ga135bd89c147c13b5f0865ef605a5460f">round</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga135bd89c147c13b5f0865ef605a5460f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ce389bbced50faf45fdc02bb8052593"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga4ce389bbced50faf45fdc02bb8052593"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1ceil__.html">ceil_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga4ce389bbced50faf45fdc02bb8052593.html#ga4ce389bbced50faf45fdc02bb8052593">ceil</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga4ce389bbced50faf45fdc02bb8052593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f70e721679458cc5debe06d7d27a86"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gab0f70e721679458cc5debe06d7d27a86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1fabs__.html">fabs_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gab0f70e721679458cc5debe06d7d27a86.html#gab0f70e721679458cc5debe06d7d27a86">fabs</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gab0f70e721679458cc5debe06d7d27a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33b5c9bd5c24d46d47dbb23fd0ebe088"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga33b5c9bd5c24d46d47dbb23fd0ebe088"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1trunc__.html">trunc_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga33b5c9bd5c24d46d47dbb23fd0ebe088.html#ga33b5c9bd5c24d46d47dbb23fd0ebe088">trunc</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga33b5c9bd5c24d46d47dbb23fd0ebe088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa0a560034bc9bdaae38d599f22c128c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gafa0a560034bc9bdaae38d599f22c128c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1digamma__.html">digamma_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gafa0a560034bc9bdaae38d599f22c128c.html#gafa0a560034bc9bdaae38d599f22c128c">digamma</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gafa0a560034bc9bdaae38d599f22c128c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4989380f86f48efb14c17727e7af7b4d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga4989380f86f48efb14c17727e7af7b4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log1m__.html">log1m_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga4989380f86f48efb14c17727e7af7b4d.html#ga4989380f86f48efb14c17727e7af7b4d">log1m</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga4989380f86f48efb14c17727e7af7b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga913081d1c4041a5fe94e59aee275f919"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga913081d1c4041a5fe94e59aee275f919"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log__inv__logit__.html">log_inv_logit_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga913081d1c4041a5fe94e59aee275f919.html#ga913081d1c4041a5fe94e59aee275f919">log_inv_logit</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga913081d1c4041a5fe94e59aee275f919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5de6ec9c63ae6c15112b5fd0afbd9a7c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga5de6ec9c63ae6c15112b5fd0afbd9a7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log1m__exp__.html">log1m_exp_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5de6ec9c63ae6c15112b5fd0afbd9a7c.html#ga5de6ec9c63ae6c15112b5fd0afbd9a7c">log1m_exp</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga5de6ec9c63ae6c15112b5fd0afbd9a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf1ac41ebe1d11f713ac5932d0592f62"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gacf1ac41ebe1d11f713ac5932d0592f62"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log1p__exp__.html">log1p_exp_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gacf1ac41ebe1d11f713ac5932d0592f62.html#gacf1ac41ebe1d11f713ac5932d0592f62">log1p_exp</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gacf1ac41ebe1d11f713ac5932d0592f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35bee15195026bea2e80c7ad0b124f2c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga35bee15195026bea2e80c7ad0b124f2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1inv__square__.html">inv_square_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga35bee15195026bea2e80c7ad0b124f2c.html#ga35bee15195026bea2e80c7ad0b124f2c">inv_square</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga35bee15195026bea2e80c7ad0b124f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaccf85b1e3a35cd5c3884e7147684455"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaaccf85b1e3a35cd5c3884e7147684455"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1inv__logit__.html">inv_logit_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaaccf85b1e3a35cd5c3884e7147684455.html#gaaccf85b1e3a35cd5c3884e7147684455">inv_logit</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gaaccf85b1e3a35cd5c3884e7147684455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0a4ef2fed4f4eeb4dab68d5700b4470"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gab0a4ef2fed4f4eeb4dab68d5700b4470"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1logit__.html">logit_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gab0a4ef2fed4f4eeb4dab68d5700b4470.html#gab0a4ef2fed4f4eeb4dab68d5700b4470">logit</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gab0a4ef2fed4f4eeb4dab68d5700b4470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad90a9c30576bbdf6e1d5fdcc4a0d9fbd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gad90a9c30576bbdf6e1d5fdcc4a0d9fbd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1_phi__.html">Phi_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gad90a9c30576bbdf6e1d5fdcc4a0d9fbd.html#gad90a9c30576bbdf6e1d5fdcc4a0d9fbd">Phi</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gad90a9c30576bbdf6e1d5fdcc4a0d9fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40db03af491c81d0a24a47b94c8a6c13"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga40db03af491c81d0a24a47b94c8a6c13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1_phi__approx__.html">Phi_approx_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga40db03af491c81d0a24a47b94c8a6c13.html#ga40db03af491c81d0a24a47b94c8a6c13">Phi_approx</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga40db03af491c81d0a24a47b94c8a6c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1dd3a6b0d264c1f385ff9e081243e469"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga1dd3a6b0d264c1f385ff9e081243e469"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1inv___phi__.html">inv_Phi_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga1dd3a6b0d264c1f385ff9e081243e469.html#ga1dd3a6b0d264c1f385ff9e081243e469">inv_Phi</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga1dd3a6b0d264c1f385ff9e081243e469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae80729d493b39e9040b4e042c0f6cf46"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gae80729d493b39e9040b4e042c0f6cf46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log1m__inv__logit__.html">log1m_inv_logit_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gae80729d493b39e9040b4e042c0f6cf46.html#gae80729d493b39e9040b4e042c0f6cf46">log1m_inv_logit</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gae80729d493b39e9040b4e042c0f6cf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87d816b04680d39b89cfca9c3bbb6d14"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga87d816b04680d39b89cfca9c3bbb6d14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1trigamma__.html">trigamma_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga87d816b04680d39b89cfca9c3bbb6d14.html#ga87d816b04680d39b89cfca9c3bbb6d14">trigamma</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga87d816b04680d39b89cfca9c3bbb6d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb2c7fbfbc95ddd0318b896d8a52082a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaeb2c7fbfbc95ddd0318b896d8a52082a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1square__.html">square_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaeb2c7fbfbc95ddd0318b896d8a52082a.html#gaeb2c7fbfbc95ddd0318b896d8a52082a">square</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gaeb2c7fbfbc95ddd0318b896d8a52082a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga109792496bf9bf58b08128f9e4b47b3f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga109792496bf9bf58b08128f9e4b47b3f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1isfinite__.html">isfinite_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga109792496bf9bf58b08128f9e4b47b3f.html#ga109792496bf9bf58b08128f9e4b47b3f">isfinite</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga109792496bf9bf58b08128f9e4b47b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b4c25e8ee54e5332493e7304842dd7a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga2b4c25e8ee54e5332493e7304842dd7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1isinf__.html">isinf_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga2b4c25e8ee54e5332493e7304842dd7a.html#ga2b4c25e8ee54e5332493e7304842dd7a">isinf</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:ga2b4c25e8ee54e5332493e7304842dd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe91f29f426d93bc47c16fd49780225d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Cond  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gafe91f29f426d93bc47c16fd49780225d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1isnan__.html">isnan_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gafe91f29f426d93bc47c16fd49780225d.html#gafe91f29f426d93bc47c16fd49780225d">isnan</a> (T &amp;&amp;a)</td></tr>
<tr class="separator:gafe91f29f426d93bc47c16fd49780225d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cfde1873a2ea45f20942fa94633e8ea"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5cfde1873a2ea45f20942fa94633e8ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1fdim__.html">fdim_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5cfde1873a2ea45f20942fa94633e8ea.html#ga5cfde1873a2ea45f20942fa94633e8ea">fdim</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga5cfde1873a2ea45f20942fa94633e8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa152ffd837a230f6dff7f5a52291e2b5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa152ffd837a230f6dff7f5a52291e2b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1fmax__.html">fmax_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaa152ffd837a230f6dff7f5a52291e2b5.html#gaa152ffd837a230f6dff7f5a52291e2b5">fmax</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:gaa152ffd837a230f6dff7f5a52291e2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15516facbd91fa59e9980fcf10ef4ec8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga15516facbd91fa59e9980fcf10ef4ec8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1fmin__.html">fmin_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga15516facbd91fa59e9980fcf10ef4ec8.html#ga15516facbd91fa59e9980fcf10ef4ec8">fmin</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga15516facbd91fa59e9980fcf10ef4ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4bef4df4851b2aa4386ab1d7d74d51f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa4bef4df4851b2aa4386ab1d7d74d51f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1fmod__.html">fmod_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaa4bef4df4851b2aa4386ab1d7d74d51f.html#gaa4bef4df4851b2aa4386ab1d7d74d51f">fmod</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:gaa4bef4df4851b2aa4386ab1d7d74d51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga53f522954017d94fede2ee8af6f380ef"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga53f522954017d94fede2ee8af6f380ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1hypot__.html">hypot_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga53f522954017d94fede2ee8af6f380ef.html#ga53f522954017d94fede2ee8af6f380ef">hypot</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga53f522954017d94fede2ee8af6f380ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga439de776ba6fa10dee41844296b2340b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga439de776ba6fa10dee41844296b2340b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1ldexp__.html">ldexp_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga439de776ba6fa10dee41844296b2340b.html#ga439de776ba6fa10dee41844296b2340b">ldexp</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga439de776ba6fa10dee41844296b2340b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e1d7f9b77373c028f2ce7f0efa68fb2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7e1d7f9b77373c028f2ce7f0efa68fb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1pow__.html">pow_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga7e1d7f9b77373c028f2ce7f0efa68fb2.html#ga7e1d7f9b77373c028f2ce7f0efa68fb2">pow</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga7e1d7f9b77373c028f2ce7f0efa68fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2c3fb0d568d789671ec921f249e5488"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf2c3fb0d568d789671ec921f249e5488"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1copysign__.html">copysign_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaf2c3fb0d568d789671ec921f249e5488.html#gaf2c3fb0d568d789671ec921f249e5488">copysign</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:gaf2c3fb0d568d789671ec921f249e5488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed28c744a5a04feb0d9d6e44b13c624f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaed28c744a5a04feb0d9d6e44b13c624f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1beta__.html">beta_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaed28c744a5a04feb0d9d6e44b13c624f.html#gaed28c744a5a04feb0d9d6e44b13c624f">beta</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:gaed28c744a5a04feb0d9d6e44b13c624f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3651fc69aff7d97cf08e996ba854dc9e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3651fc69aff7d97cf08e996ba854dc9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1binomial__coefficient__log__.html">binomial_coefficient_log_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga3651fc69aff7d97cf08e996ba854dc9e.html#ga3651fc69aff7d97cf08e996ba854dc9e">binomial_coefficient_log</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga3651fc69aff7d97cf08e996ba854dc9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga022089d551156e981b9893e7214bb4f5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga022089d551156e981b9893e7214bb4f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1lbeta__.html">lbeta_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga022089d551156e981b9893e7214bb4f5.html#ga022089d551156e981b9893e7214bb4f5">lbeta</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga022089d551156e981b9893e7214bb4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga222917a695f02d58f9e46fcaf9e8bba9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga222917a695f02d58f9e46fcaf9e8bba9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log__inv__logit__diff__.html">log_inv_logit_diff_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga222917a695f02d58f9e46fcaf9e8bba9.html#ga222917a695f02d58f9e46fcaf9e8bba9">log_inv_logit_diff</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga222917a695f02d58f9e46fcaf9e8bba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a1b0beb472f6556665af1311c730300"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6a1b0beb472f6556665af1311c730300"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1log__diff__exp__.html">log_diff_exp_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga6a1b0beb472f6556665af1311c730300.html#ga6a1b0beb472f6556665af1311c730300">log_diff_exp</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga6a1b0beb472f6556665af1311c730300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65e19ae75344abdb2480484b523ced8b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga65e19ae75344abdb2480484b523ced8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1multiply__log__.html">multiply_log_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga65e19ae75344abdb2480484b523ced8b.html#ga65e19ae75344abdb2480484b523ced8b">multiply_log</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:ga65e19ae75344abdb2480484b523ced8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6350afa9bc18cc778f46c2060c3e443"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad6350afa9bc18cc778f46c2060c3e443"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1lmultiply__.html">lmultiply_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T1 &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gad6350afa9bc18cc778f46c2060c3e443.html#gad6350afa9bc18cc778f46c2060c3e443">lmultiply</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:gad6350afa9bc18cc778f46c2060c3e443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a4354d64457f958a5bd96518c952249"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ptrs, <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T, Ptrs... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5a4354d64457f958a5bd96518c952249"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5a4354d64457f958a5bd96518c952249.html#ga5a4354d64457f958a5bd96518c952249">holder_cl</a> (T &amp;&amp;a, Ptrs *... ptrs)</td></tr>
<tr class="memdesc:ga5a4354d64457f958a5bd96518c952249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a no-op operation that also holds pointer to some other expressions, allocated on heap.  <br /></td></tr>
<tr class="separator:ga5a4354d64457f958a5bd96518c952249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1606a52cb1b2b478689f4d0cc3d515e4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args, <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; decltype(std::declval&lt; T &gt;()(std::declval&lt; Args &amp; &gt;()...)), Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1606a52cb1b2b478689f4d0cc3d515e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga1606a52cb1b2b478689f4d0cc3d515e4.html#ga1606a52cb1b2b478689f4d0cc3d515e4">make_holder_cl</a> (const T &amp;func, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:ga1606a52cb1b2b478689f4d0cc3d515e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an expression from given arguments using given functor.  <br /></td></tr>
<tr class="separator:ga1606a52cb1b2b478689f4d0cc3d515e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd7112f019bbee28c6882bef07779e05"><td class="memTemplParams" colspan="2">template&lt;typename T_mat , typename T_row_index , typename T_col_index , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_mat, T_row_index, T_col_index &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacd7112f019bbee28c6882bef07779e05"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gacd7112f019bbee28c6882bef07779e05.html#gacd7112f019bbee28c6882bef07779e05">indexing</a> (T_mat &amp;&amp;mat, T_row_index &amp;&amp;<a class="el" href="classstan_1_1math_1_1row__index.html">row_index</a>, T_col_index &amp;&amp;<a class="el" href="classstan_1_1math_1_1col__index.html">col_index</a>)</td></tr>
<tr class="memdesc:gacd7112f019bbee28c6882bef07779e05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index a kernel generator expression using two expressions for indices.  <br /></td></tr>
<tr class="separator:gacd7112f019bbee28c6882bef07779e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b81ef398cfaf0b0c049900db611533"><td class="memTemplParams" colspan="2">template&lt;typename T_matrix , typename T_vector , typename  = require_all_kernel_expressions_t&lt;T_matrix, T_vector&gt;&gt; </td></tr>
<tr class="memitem:ab5b81ef398cfaf0b0c049900db611533"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab5b81ef398cfaf0b0c049900db611533.html#ab5b81ef398cfaf0b0c049900db611533">matrix_vector_multiply</a> (T_matrix &amp;&amp;matrix, T_vector &amp;&amp;vector)</td></tr>
<tr class="memdesc:ab5b81ef398cfaf0b0c049900db611533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies a matrix and a vector on an OpenCL device.  <br /></td></tr>
<tr class="separator:ab5b81ef398cfaf0b0c049900db611533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad26276edfb566ab2b352612571f9a67c"><td class="memTemplParams" colspan="2">template&lt;typename... T_expressions&gt; </td></tr>
<tr class="memitem:gad26276edfb566ab2b352612571f9a67c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1expressions__cl.html">expressions_cl</a>&lt; T_expressions... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gad26276edfb566ab2b352612571f9a67c.html#gad26276edfb566ab2b352612571f9a67c">expressions</a> (T_expressions &amp;&amp;... expressions)</td></tr>
<tr class="memdesc:gad26276edfb566ab2b352612571f9a67c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces types for constructing <code><a class="el" href="classstan_1_1math_1_1expressions__cl.html" title="Represents multiple expressions that will be calculated in same kernel.">expressions_cl</a></code> object.  <br /></td></tr>
<tr class="separator:gad26276edfb566ab2b352612571f9a67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25bbfbed551e80e97d55ca836e1f2521"><td class="memTemplParams" colspan="2">template&lt;typename... T_results&gt; </td></tr>
<tr class="memitem:ga25bbfbed551e80e97d55ca836e1f2521"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1results__cl.html">results_cl</a>&lt; T_results... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga25bbfbed551e80e97d55ca836e1f2521.html#ga25bbfbed551e80e97d55ca836e1f2521">results</a> (T_results &amp;&amp;... results)</td></tr>
<tr class="memdesc:ga25bbfbed551e80e97d55ca836e1f2521"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces types for constructing <code><a class="el" href="classstan_1_1math_1_1results__cl.html" title="Represents results that will be calculated in same kernel.">results_cl</a></code> object.  <br /></td></tr>
<tr class="separator:ga25bbfbed551e80e97d55ca836e1f2521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d711e389b4c78c0d11c974f53b30c88"><td class="memTemplParams" colspan="2">template&lt;const char * Code, typename... T_arguments, <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_arguments... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5d711e389b4c78c0d11c974f53b30c88"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga5d711e389b4c78c0d11c974f53b30c88.html#ga5d711e389b4c78c0d11c974f53b30c88">opencl_code</a> (std::tuple&lt; typename std::pair&lt; const char *, T_arguments &gt;::first_type... &gt; names, T_arguments &amp;&amp;... arguments)</td></tr>
<tr class="memdesc:ga5d711e389b4c78c0d11c974f53b30c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom code in kernel generator expressions.  <br /></td></tr>
<tr class="separator:ga5d711e389b4c78c0d11c974f53b30c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56cbcda6d47bb8ee10506d408af4b71f"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga56cbcda6d47bb8ee10506d408af4b71f.html#ga56cbcda6d47bb8ee10506d408af4b71f">operator&lt;&lt;</a> (std::ostream &amp;os, <a class="el" href="structstan_1_1math_1_1kernel__parts.html">kernel_parts</a> &amp;parts)</td></tr>
<tr class="separator:ga56cbcda6d47bb8ee10506d408af4b71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2baa95f400abbdc05e10af4cc76167a0"><td class="memTemplParams" colspan="2">template&lt;bool Colwise, bool Rowwise, typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a2baa95f400abbdc05e10af4cc76167a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1optional__broadcast__.html">optional_broadcast_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt;, Colwise, Rowwise &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2baa95f400abbdc05e10af4cc76167a0.html#a2baa95f400abbdc05e10af4cc76167a0">optional_broadcast</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a2baa95f400abbdc05e10af4cc76167a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast an expression in specified dimension(s) if the size along that dimension equals 1.  <br /></td></tr>
<tr class="separator:a2baa95f400abbdc05e10af4cc76167a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78040a58375a862be6e9e5e91ec195f3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a78040a58375a862be6e9e5e91ec195f3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a78040a58375a862be6e9e5e91ec195f3.html#a78040a58375a862be6e9e5e91ec195f3">rowwise_optional_broadcast</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a78040a58375a862be6e9e5e91ec195f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast an expression in rowwise dimmension if the number of columns equals to 1.  <br /></td></tr>
<tr class="separator:a78040a58375a862be6e9e5e91ec195f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459ea8ec2e84f892c39c6a2dac77eb6e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a459ea8ec2e84f892c39c6a2dac77eb6e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a459ea8ec2e84f892c39c6a2dac77eb6e.html#a459ea8ec2e84f892c39c6a2dac77eb6e">colwise_optional_broadcast</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a459ea8ec2e84f892c39c6a2dac77eb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcast an expression in colwise dimmension if the number of rows equals to 1.  <br /></td></tr>
<tr class="separator:a459ea8ec2e84f892c39c6a2dac77eb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1462faace0d3fa31a5667ac49b26a823"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1462faace0d3fa31a5667ac49b26a823"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga1462faace0d3fa31a5667ac49b26a823.html#ga1462faace0d3fa31a5667ac49b26a823">sum_2d</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga1462faace0d3fa31a5667ac49b26a823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two dimensional sum - reduction of a kernel generator expression.  <br /></td></tr>
<tr class="separator:ga1462faace0d3fa31a5667ac49b26a823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac70073b0bfbd8cbab725c43d64826bd8"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac70073b0bfbd8cbab725c43d64826bd8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gac70073b0bfbd8cbab725c43d64826bd8.html#gac70073b0bfbd8cbab725c43d64826bd8">prod_2d</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:gac70073b0bfbd8cbab725c43d64826bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two dimensional product - reduction of a kernel generator expression.  <br /></td></tr>
<tr class="separator:gac70073b0bfbd8cbab725c43d64826bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeeae5d88f953fd148edfaa002e20c883"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaeeae5d88f953fd148edfaa002e20c883"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaeeae5d88f953fd148edfaa002e20c883.html#gaeeae5d88f953fd148edfaa002e20c883">max_2d</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:gaeeae5d88f953fd148edfaa002e20c883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two dimensional max - reduction of a kernel generator expression.  <br /></td></tr>
<tr class="separator:gaeeae5d88f953fd148edfaa002e20c883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40f26738b59030414c5284f3e5a65e94"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga40f26738b59030414c5284f3e5a65e94"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga40f26738b59030414c5284f3e5a65e94.html#ga40f26738b59030414c5284f3e5a65e94">min_2d</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga40f26738b59030414c5284f3e5a65e94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two dimensional min - reduction of a kernel generator expression.  <br /></td></tr>
<tr class="separator:ga40f26738b59030414c5284f3e5a65e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cd6efc415346ed609b5e879489e138f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga9cd6efc415346ed609b5e879489e138f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga9cd6efc415346ed609b5e879489e138f.html#ga9cd6efc415346ed609b5e879489e138f">rowwise_sum</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga9cd6efc415346ed609b5e879489e138f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rowwise sum reduction of a kernel generator expression.  <br /></td></tr>
<tr class="separator:ga9cd6efc415346ed609b5e879489e138f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab329e15841c51999d18caf1b11fc4d6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gaab329e15841c51999d18caf1b11fc4d6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_gaab329e15841c51999d18caf1b11fc4d6.html#gaab329e15841c51999d18caf1b11fc4d6">rowwise_prod</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:gaab329e15841c51999d18caf1b11fc4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rowwise product reduction of a kernel generator expression.  <br /></td></tr>
<tr class="separator:gaab329e15841c51999d18caf1b11fc4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cffcf5d84759ac5f6c46f19b33d3a7b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga6cffcf5d84759ac5f6c46f19b33d3a7b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga6cffcf5d84759ac5f6c46f19b33d3a7b.html#ga6cffcf5d84759ac5f6c46f19b33d3a7b">rowwise_max</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga6cffcf5d84759ac5f6c46f19b33d3a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rowwise max reduction of a kernel generator expression.  <br /></td></tr>
<tr class="separator:ga6cffcf5d84759ac5f6c46f19b33d3a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c7b84610288363139813944780f22f4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga7c7b84610288363139813944780f22f4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga7c7b84610288363139813944780f22f4.html#ga7c7b84610288363139813944780f22f4">rowwise_min</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ga7c7b84610288363139813944780f22f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Min reduction of a kernel generator expression.  <br /></td></tr>
<tr class="separator:ga7c7b84610288363139813944780f22f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ad2a294f1b90cca6baeaf86910b3cd7"><td class="memTemplParams" colspan="2">template&lt;typename T_condition , typename T_then , typename T_else , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_condition, T_then, T_else &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gacd5c059c1d9e54bdf3ee973388a47896.html#gacd5c059c1d9e54bdf3ee973388a47896">require_any_not_arithmetic_t</a>&lt; T_condition, T_then, T_else &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1ad2a294f1b90cca6baeaf86910b3cd7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1select__.html">select_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_condition &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_then &gt;, <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T_else &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga1ad2a294f1b90cca6baeaf86910b3cd7.html#ga1ad2a294f1b90cca6baeaf86910b3cd7">select</a> (T_condition &amp;&amp;condition, T_then &amp;&amp;then, T_else &amp;&amp;els)</td></tr>
<tr class="memdesc:ga1ad2a294f1b90cca6baeaf86910b3cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selection operation on kernel generator expressions.  <br /></td></tr>
<tr class="separator:ga1ad2a294f1b90cca6baeaf86910b3cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58874b947f34c4e6158fb996af4aa4e4"><td class="memTemplParams" colspan="2">template&lt;typename Arg , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;Arg&gt;&gt; </td></tr>
<tr class="memitem:ga58874b947f34c4e6158fb996af4aa4e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl__kernel__generator_ga58874b947f34c4e6158fb996af4aa4e4.html#ga58874b947f34c4e6158fb996af4aa4e4">transpose</a> (Arg &amp;&amp;a)</td></tr>
<tr class="memdesc:ga58874b947f34c4e6158fb996af4aa4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a kernel generator expression.  <br /></td></tr>
<tr class="separator:ga58874b947f34c4e6158fb996af4aa4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455f30f5ce100c02ac1145cf1a01dc3b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a455f30f5ce100c02ac1145cf1a01dc3b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a455f30f5ce100c02ac1145cf1a01dc3b.html#a455f30f5ce100c02ac1145cf1a01dc3b">type_str</a> ()</td></tr>
<tr class="memdesc:a455f30f5ce100c02ac1145cf1a01dc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines a string name of a type.  <br /></td></tr>
<tr class="separator:a455f30f5ce100c02ac1145cf1a01dc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad578b08682555d22784b9d33822e68c8"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad578b08682555d22784b9d33822e68c8"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad578b08682555d22784b9d33822e68c8.html#ad578b08682555d22784b9d33822e68c8">type_str&lt; double &gt;</a> ()</td></tr>
<tr class="separator:ad578b08682555d22784b9d33822e68c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55f52e09caf33a7e02a2f96c6cd98c9"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab55f52e09caf33a7e02a2f96c6cd98c9"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab55f52e09caf33a7e02a2f96c6cd98c9.html#ab55f52e09caf33a7e02a2f96c6cd98c9">type_str&lt; int &gt;</a> ()</td></tr>
<tr class="separator:ab55f52e09caf33a7e02a2f96c6cd98c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d642f94e1d1cb337c5821b01eb2347"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad8d642f94e1d1cb337c5821b01eb2347"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad8d642f94e1d1cb337c5821b01eb2347.html#ad8d642f94e1d1cb337c5821b01eb2347">type_str&lt; char &gt;</a> ()</td></tr>
<tr class="separator:ad8d642f94e1d1cb337c5821b01eb2347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6b06bd25e0b04d659682e31215b3bb"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1d6b06bd25e0b04d659682e31215b3bb"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1d6b06bd25e0b04d659682e31215b3bb.html#a1d6b06bd25e0b04d659682e31215b3bb">type_str&lt; bool &gt;</a> ()</td></tr>
<tr class="separator:a1d6b06bd25e0b04d659682e31215b3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da81255d214f2aaf499b47ede1cf015"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5da81255d214f2aaf499b47ede1cf015"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1logical__negation__.html">logical_negation_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5da81255d214f2aaf499b47ede1cf015.html#a5da81255d214f2aaf499b47ede1cf015">operator!</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a5da81255d214f2aaf499b47ede1cf015"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logical negation of a kernel generator expression.  <br /></td></tr>
<tr class="separator:a5da81255d214f2aaf499b47ede1cf015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808d0b9938b0dc673d5ce63cfcc37b60"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a808d0b9938b0dc673d5ce63cfcc37b60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1unary__minus__.html">unary_minus_</a>&lt; <a class="el" href="group__opencl__kernel__generator_gadd9b4d7342506a6dc93ca872bbcc9dd6.html#gadd9b4d7342506a6dc93ca872bbcc9dd6">as_operation_cl_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a808d0b9938b0dc673d5ce63cfcc37b60.html#a808d0b9938b0dc673d5ce63cfcc37b60">operator-</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a808d0b9938b0dc673d5ce63cfcc37b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary minus of a kernel generator expression.  <br /></td></tr>
<tr class="separator:a808d0b9938b0dc673d5ce63cfcc37b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_ga9850bbd8d516b87d722ad54947bb9c9f.html#ga9850bbd8d516b87d722ad54947bb9c9f">either</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> left_view, const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> right_view)</td></tr>
<tr class="memdesc:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which parts are nonzero in any of the input views.  <br /></td></tr>
<tr class="separator:ga9850bbd8d516b87d722ad54947bb9c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga338a285d4ba933ba6aa7240908919e0f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_ga338a285d4ba933ba6aa7240908919e0f.html#ga338a285d4ba933ba6aa7240908919e0f">both</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> left_view, const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> right_view)</td></tr>
<tr class="memdesc:ga338a285d4ba933ba6aa7240908919e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which parts are nonzero in both input views.  <br /></td></tr>
<tr class="separator:ga338a285d4ba933ba6aa7240908919e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd63c8a601189c916c8a2157066adb7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_gadd63c8a601189c916c8a2157066adb7c.html#gadd63c8a601189c916c8a2157066adb7c">contains_nonzero</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view, const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> part)</td></tr>
<tr class="memdesc:gadd63c8a601189c916c8a2157066adb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a view contains certain nonzero part.  <br /></td></tr>
<tr class="separator:gadd63c8a601189c916c8a2157066adb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafccee2b081b9edd7c6e6d211157e5490"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_gafccee2b081b9edd7c6e6d211157e5490.html#gafccee2b081b9edd7c6e6d211157e5490">transpose</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view)</td></tr>
<tr class="memdesc:gafccee2b081b9edd7c6e6d211157e5490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a view - swaps lower and upper parts.  <br /></td></tr>
<tr class="separator:gafccee2b081b9edd7c6e6d211157e5490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga747f014e58d824281b725a7d4868dd77"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_ga747f014e58d824281b725a7d4868dd77.html#ga747f014e58d824281b725a7d4868dd77">invert</a> (const <a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> view)</td></tr>
<tr class="memdesc:ga747f014e58d824281b725a7d4868dd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts a view.  <br /></td></tr>
<tr class="separator:ga747f014e58d824281b725a7d4868dd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27e938e6fdd621c5903cc37401c54909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl_ga27e938e6fdd621c5903cc37401c54909.html#ga27e938e6fdd621c5903cc37401c54909">from_eigen_uplo_type</a> (Eigen::UpLoType eigen_type)</td></tr>
<tr class="memdesc:ga27e938e6fdd621c5903cc37401c54909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view from <code>Eigen::UpLoType</code>.  <br /></td></tr>
<tr class="separator:ga27e938e6fdd621c5903cc37401c54909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae46253a70141bc9eef9e6fe5bf278b78"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl__kernels_gae46253a70141bc9eef9e6fe5bf278b78.html#gae46253a70141bc9eef9e6fe5bf278b78">either</a> (int left_view, int right_view)</td></tr>
<tr class="memdesc:gae46253a70141bc9eef9e6fe5bf278b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which parts are nonzero in any of the input views.  <br /></td></tr>
<tr class="separator:gae46253a70141bc9eef9e6fe5bf278b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e1f78a060854c0ee5eaf42a9eb21cd5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl__kernels_ga4e1f78a060854c0ee5eaf42a9eb21cd5.html#ga4e1f78a060854c0ee5eaf42a9eb21cd5">both</a> (int left_view, int right_view)</td></tr>
<tr class="memdesc:ga4e1f78a060854c0ee5eaf42a9eb21cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines which parts are nonzero in both input views.  <br /></td></tr>
<tr class="separator:ga4e1f78a060854c0ee5eaf42a9eb21cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6329dbb31a5e13ede128e993ceb1093f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__opencl__kernels_ga6329dbb31a5e13ede128e993ceb1093f.html#ga6329dbb31a5e13ede128e993ceb1093f">contains_nonzero</a> (int view, int part)</td></tr>
<tr class="memdesc:ga6329dbb31a5e13ede128e993ceb1093f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a view contains certain nonzero part.  <br /></td></tr>
<tr class="separator:ga6329dbb31a5e13ede128e993ceb1093f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9df9f4a3afc7cd815fc369d54ab2a9c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_arithmetic_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:gac9df9f4a3afc7cd815fc369d54ab2a9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac9df9f4a3afc7cd815fc369d54ab2a9c.html#gac9df9f4a3afc7cd815fc369d54ab2a9c">multiply_transpose</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:gac9df9f4a3afc7cd815fc369d54ab2a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of a square OpenCL matrix with its transpose.  <br /></td></tr>
<tr class="separator:gac9df9f4a3afc7cd815fc369d54ab2a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7096ca355b7d691a87e1472a4f4984f"><td class="memTemplParams" colspan="2">template&lt;typename T_m , typename T_a , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_m &gt; *  = nullptr, <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_a &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa7096ca355b7d691a87e1472a4f4984f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa7096ca355b7d691a87e1472a4f4984f.html#aa7096ca355b7d691a87e1472a4f4984f">add_diag</a> (T_m &amp;&amp;mat, T_a &amp;&amp;to_add)</td></tr>
<tr class="memdesc:aa7096ca355b7d691a87e1472a4f4984f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matrix with values added along the main diagonal.  <br /></td></tr>
<tr class="separator:aa7096ca355b7d691a87e1472a4f4984f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad208a430755d3caf47cbb1f76dd0e74"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_y , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x, T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aad208a430755d3caf47cbb1f76dd0e74"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aad208a430755d3caf47cbb1f76dd0e74.html#aad208a430755d3caf47cbb1f76dd0e74">append_array</a> (T_x &amp;&amp;x, T_y &amp;&amp;y)</td></tr>
<tr class="memdesc:aad208a430755d3caf47cbb1f76dd0e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the concatenation of two specified vectors in the order of the arguments.  <br /></td></tr>
<tr class="separator:aad208a430755d3caf47cbb1f76dd0e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd48f844a3b4e7eaa4a59c785a36eda8"><td class="memTemplParams" colspan="2">template&lt;typename T_n_cl , typename T_prob_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_prob_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabd48f844a3b4e7eaa4a59c785a36eda8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gabd48f844a3b4e7eaa4a59c785a36eda8.html#gabd48f844a3b4e7eaa4a59c785a36eda8">bernoulli_cdf</a> (const T_n_cl &amp;n, const T_prob_cl &amp;theta)</td></tr>
<tr class="memdesc:gabd48f844a3b4e7eaa4a59c785a36eda8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CDF of the Bernoulli distribution.  <br /></td></tr>
<tr class="separator:gabd48f844a3b4e7eaa4a59c785a36eda8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34b74e05b278f83c07ae46a43636442c"><td class="memTemplParams" colspan="2">template&lt;typename T_n_cl , typename T_prob_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_prob_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga34b74e05b278f83c07ae46a43636442c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga34b74e05b278f83c07ae46a43636442c.html#ga34b74e05b278f83c07ae46a43636442c">bernoulli_lccdf</a> (const T_n_cl &amp;n, const T_prob_cl &amp;theta)</td></tr>
<tr class="memdesc:ga34b74e05b278f83c07ae46a43636442c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log CCDF of the Bernoulli distribution.  <br /></td></tr>
<tr class="separator:ga34b74e05b278f83c07ae46a43636442c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2915cef2601b4ca4c438849a45d88c6f"><td class="memTemplParams" colspan="2">template&lt;typename T_n_cl , typename T_prob_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_prob_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2915cef2601b4ca4c438849a45d88c6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga2915cef2601b4ca4c438849a45d88c6f.html#ga2915cef2601b4ca4c438849a45d88c6f">bernoulli_lcdf</a> (const T_n_cl &amp;n, const T_prob_cl &amp;theta)</td></tr>
<tr class="memdesc:ga2915cef2601b4ca4c438849a45d88c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log CDF of the Bernoulli distribution.  <br /></td></tr>
<tr class="separator:ga2915cef2601b4ca4c438849a45d88c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada680649d4f1ecf2a665168c088465b5"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_x_cl , typename T_y_cl , typename T_alpha_cl , typename T_beta_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gada680649d4f1ecf2a665168c088465b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x_cl, T_alpha_cl, T_beta_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gada680649d4f1ecf2a665168c088465b5.html#gada680649d4f1ecf2a665168c088465b5">bernoulli_logit_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gada680649d4f1ecf2a665168c088465b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Bernoulli distribution and logit link function.  <br /></td></tr>
<tr class="separator:gada680649d4f1ecf2a665168c088465b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1be5c09c704e2d50fb652f1067bca7f8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_prob_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_prob_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1be5c09c704e2d50fb652f1067bca7f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga1be5c09c704e2d50fb652f1067bca7f8.html#ga1be5c09c704e2d50fb652f1067bca7f8">bernoulli_logit_lpmf</a> (const T_n_cl &amp;n, const T_prob_cl &amp;theta)</td></tr>
<tr class="memdesc:ga1be5c09c704e2d50fb652f1067bca7f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the logit-parametrized Bernoulli distribution.  <br /></td></tr>
<tr class="separator:ga1be5c09c704e2d50fb652f1067bca7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga458b9954e62495f1d9165725c14603d4"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_prob_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_prob_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga458b9954e62495f1d9165725c14603d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga458b9954e62495f1d9165725c14603d4.html#ga458b9954e62495f1d9165725c14603d4">bernoulli_lpmf</a> (const T_n_cl &amp;n, const T_prob_cl &amp;theta)</td></tr>
<tr class="memdesc:ga458b9954e62495f1d9165725c14603d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Bernoulli distribution.  <br /></td></tr>
<tr class="separator:ga458b9954e62495f1d9165725c14603d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e4aef070113680165b3cc5423f93950"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_size1_cl , typename T_size2_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_size1_cl, T_size2_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_size1_cl, T_size2_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2e4aef070113680165b3cc5423f93950"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_size1_cl, T_size2_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2e4aef070113680165b3cc5423f93950.html#ga2e4aef070113680165b3cc5423f93950">beta_binomial_lpmf</a> (const T_n_cl &amp;n, const T_N_cl N, const T_size1_cl &amp;alpha, const T_size2_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga2e4aef070113680165b3cc5423f93950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Beta-Binomial distribution with given population size, prior success, and prior failure parameters.  <br /></td></tr>
<tr class="separator:ga2e4aef070113680165b3cc5423f93950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1958cd702be988949f2f5054302b8514"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_succ_cl , typename T_scale_fail_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1958cd702be988949f2f5054302b8514"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_succ_cl, T_scale_fail_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga1958cd702be988949f2f5054302b8514.html#ga1958cd702be988949f2f5054302b8514">beta_lpdf</a> (const T_y_cl &amp;y, const T_scale_succ_cl &amp;alpha, const T_scale_fail_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga1958cd702be988949f2f5054302b8514"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the beta density for the specified scalar(s) given the specified sample stan::math::size(s).  <br /></td></tr>
<tr class="separator:ga1958cd702be988949f2f5054302b8514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88348aa350be49d2b9b4eab03ddecbdb"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_prec_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_prec_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_prec_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga88348aa350be49d2b9b4eab03ddecbdb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_prec_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga88348aa350be49d2b9b4eab03ddecbdb.html#ga88348aa350be49d2b9b4eab03ddecbdb">beta_proportion_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_prec_cl &amp;kappa)</td></tr>
<tr class="memdesc:ga88348aa350be49d2b9b4eab03ddecbdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the beta density for specified y, location, and precision: beta_proportion_lpdf(y | mu, kappa) = beta_lpdf(y | mu * kappa, (1 - mu) * kappa).  <br /></td></tr>
<tr class="separator:ga88348aa350be49d2b9b4eab03ddecbdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83245e10f653f642b08964360a02a543"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_N_cl, T_x_cl, T_alpha_cl, T_beta_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a83245e10f653f642b08964360a02a543"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x_cl, T_alpha_cl, T_beta_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a83245e10f653f642b08964360a02a543.html#a83245e10f653f642b08964360a02a543">binomial_logit_glm_lpmf</a> (const T_n_cl &amp;n, const T_N_cl &amp;N, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:a83245e10f653f642b08964360a02a543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22974de84a4f7c530aad6fd2657e098d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_prob_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga1e58259e90935ab5ef20d2a5835104df.html#ga1e58259e90935ab5ef20d2a5835104df">require_any_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga22974de84a4f7c530aad6fd2657e098d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga22974de84a4f7c530aad6fd2657e098d.html#ga22974de84a4f7c530aad6fd2657e098d">binomial_logit_lpmf</a> (const T_n_cl &amp;n, const T_N_cl N, const T_prob_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga22974de84a4f7c530aad6fd2657e098d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial log PMF in logit parametrization.  <br /></td></tr>
<tr class="separator:ga22974de84a4f7c530aad6fd2657e098d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31c30135fdfb922c32838de8223ac8ae"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_N_cl , typename T_prob_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga1e58259e90935ab5ef20d2a5835104df.html#ga1e58259e90935ab5ef20d2a5835104df">require_any_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_N_cl, T_prob_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga31c30135fdfb922c32838de8223ac8ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga31c30135fdfb922c32838de8223ac8ae.html#ga31c30135fdfb922c32838de8223ac8ae">binomial_lpmf</a> (const T_n_cl &amp;n, const T_N_cl N, const T_prob_cl &amp;theta)</td></tr>
<tr class="memdesc:ga31c30135fdfb922c32838de8223ac8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF for the binomial distribution evaluated at the specified success, population size, and chance of success.  <br /></td></tr>
<tr class="separator:ga31c30135fdfb922c32838de8223ac8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78d6a17dad1f8172090578a7cd1fb372"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:a78d6a17dad1f8172090578a7cd1fb372"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a78d6a17dad1f8172090578a7cd1fb372.html#a78d6a17dad1f8172090578a7cd1fb372">block</a> (T_x &amp;&amp;x, size_t i, size_t j, size_t nrows, size_t ncols)</td></tr>
<tr class="memdesc:a78d6a17dad1f8172090578a7cd1fb372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a nrows x ncols submatrix starting at (i-1, j-1).  <br /></td></tr>
<tr class="separator:a78d6a17dad1f8172090578a7cd1fb372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaebba67775ecfd1a8bd3c4f0e146b8504"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_x, T_alpha, T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaebba67775ecfd1a8bd3c4f0e146b8504"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaebba67775ecfd1a8bd3c4f0e146b8504.html#gaebba67775ecfd1a8bd3c4f0e146b8504">categorical_logit_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gaebba67775ecfd1a8bd3c4f0e146b8504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with categorical distribution and logit (softmax) link function.  <br /></td></tr>
<tr class="separator:gaebba67775ecfd1a8bd3c4f0e146b8504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7142ba28cdfdffee8b453c6d5ad6a325"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7142ba28cdfdffee8b453c6d5ad6a325"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7142ba28cdfdffee8b453c6d5ad6a325.html#ga7142ba28cdfdffee8b453c6d5ad6a325">cauchy_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga7142ba28cdfdffee8b453c6d5ad6a325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cauchy cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga7142ba28cdfdffee8b453c6d5ad6a325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40f5400878f7e042bbe910af7b89b122"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga40f5400878f7e042bbe910af7b89b122"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga40f5400878f7e042bbe910af7b89b122.html#ga40f5400878f7e042bbe910af7b89b122">cauchy_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga40f5400878f7e042bbe910af7b89b122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cauchy log complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga40f5400878f7e042bbe910af7b89b122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bf031eab3679d4f6f39b9f5626241dc"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6bf031eab3679d4f6f39b9f5626241dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6bf031eab3679d4f6f39b9f5626241dc.html#ga6bf031eab3679d4f6f39b9f5626241dc">cauchy_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga6bf031eab3679d4f6f39b9f5626241dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cauchy cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga6bf031eab3679d4f6f39b9f5626241dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f93dad000040f304fca4d7e64faa415"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3f93dad000040f304fca4d7e64faa415"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3f93dad000040f304fca4d7e64faa415.html#ga3f93dad000040f304fca4d7e64faa415">cauchy_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga3f93dad000040f304fca4d7e64faa415"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Cauchy density for the specified scalar(s) given the specified location parameter(s) and scale parameter(s).  <br /></td></tr>
<tr class="separator:ga3f93dad000040f304fca4d7e64faa415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27802809e14425c3dbdf22129b9dc443"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_dof_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_dof_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga27802809e14425c3dbdf22129b9dc443"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga27802809e14425c3dbdf22129b9dc443.html#ga27802809e14425c3dbdf22129b9dc443">chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu)</td></tr>
<tr class="memdesc:ga27802809e14425c3dbdf22129b9dc443"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a chi-squared density for y with the specified degrees of freedom parameter.  <br /></td></tr>
<tr class="separator:ga27802809e14425c3dbdf22129b9dc443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39985908b00f0505f4e4fec1012709af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a39985908b00f0505f4e4fec1012709af.html#a39985908b00f0505f4e4fec1012709af">cholesky_decompose</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;A)</td></tr>
<tr class="memdesc:a39985908b00f0505f4e4fec1012709af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric matrix on the OpenCL device.  <br /></td></tr>
<tr class="separator:a39985908b00f0505f4e4fec1012709af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0576c38beac678f1164a2cfc172e941e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:ga0576c38beac678f1164a2cfc172e941e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0576c38beac678f1164a2cfc172e941e.html#ga0576c38beac678f1164a2cfc172e941e">col</a> (T_x &amp;&amp;x, size_t j)</td></tr>
<tr class="memdesc:ga0576c38beac678f1164a2cfc172e941e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified column of the specified kernel generator expression using start-at-1 indexing.  <br /></td></tr>
<tr class="separator:ga0576c38beac678f1164a2cfc172e941e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b2bf6efe8102f577be540859fde068f"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2b2bf6efe8102f577be540859fde068f"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2b2bf6efe8102f577be540859fde068f.html#ga2b2bf6efe8102f577be540859fde068f">cols</a> (const T_x &amp;x)</td></tr>
<tr class="memdesc:ga2b2bf6efe8102f577be540859fde068f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of columns in the specified kernel generator expression.  <br /></td></tr>
<tr class="separator:ga2b2bf6efe8102f577be540859fde068f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27f17ba9df72b7f71dd9df068bce800"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af27f17ba9df72b7f71dd9df068bce800"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af27f17ba9df72b7f71dd9df068bce800.html#af27f17ba9df72b7f71dd9df068bce800">columns_dot_product</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="memdesc:af27f17ba9df72b7f71dd9df068bce800"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of columns of the specified matrices.  <br /></td></tr>
<tr class="separator:af27f17ba9df72b7f71dd9df068bce800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691b94587823c4e693fc46da8a13e33e"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a691b94587823c4e693fc46da8a13e33e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a691b94587823c4e693fc46da8a13e33e.html#a691b94587823c4e693fc46da8a13e33e">columns_dot_self</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a691b94587823c4e693fc46da8a13e33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each column of a matrix with itself.  <br /></td></tr>
<tr class="separator:a691b94587823c4e693fc46da8a13e33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef2d29ab9580b97017968d1d6f7fa8d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaef2d29ab9580b97017968d1d6f7fa8d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaef2d29ab9580b97017968d1d6f7fa8d.html#aaef2d29ab9580b97017968d1d6f7fa8d">lb_constrain</a> (T &amp;&amp;x, L &amp;&amp;lb)</td></tr>
<tr class="memdesc:aaef2d29ab9580b97017968d1d6f7fa8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-bounded value for the specified unconstrained input and specified lower bound.  <br /></td></tr>
<tr class="separator:aaef2d29ab9580b97017968d1d6f7fa8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af087a399bed41edf6d77ab35ddca4d0a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af087a399bed41edf6d77ab35ddca4d0a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af087a399bed41edf6d77ab35ddca4d0a.html#af087a399bed41edf6d77ab35ddca4d0a">lb_constrain</a> (const T &amp;x, const L &amp;lb, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L &gt; &amp;lp)</td></tr>
<tr class="memdesc:af087a399bed41edf6d77ab35ddca4d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-bounded value for the specified unconstrained input and specified lower bound.  <br /></td></tr>
<tr class="separator:af087a399bed41edf6d77ab35ddca4d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14cecebfd4ac6d08274c8e3ffb85f44"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; L, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad14cecebfd4ac6d08274c8e3ffb85f44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad14cecebfd4ac6d08274c8e3ffb85f44.html#ad14cecebfd4ac6d08274c8e3ffb85f44">lub_constrain</a> (const T &amp;x, const L &amp;lb, const U &amp;ub)</td></tr>
<tr class="memdesc:ad14cecebfd4ac6d08274c8e3ffb85f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower and upper-bounded matrix derived by transforming the specified free matrix given the specified lower and upper bounds.  <br /></td></tr>
<tr class="separator:ad14cecebfd4ac6d08274c8e3ffb85f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a018d8d8c78c73dd618e9a54e14874fd8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; L, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a018d8d8c78c73dd618e9a54e14874fd8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a018d8d8c78c73dd618e9a54e14874fd8.html#a018d8d8c78c73dd618e9a54e14874fd8">lub_constrain</a> (const T &amp;x, const L &amp;lb, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:a018d8d8c78c73dd618e9a54e14874fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower and upper-bounded matrix derived by transforming the specified free matrix given the specified lower and upper bounds.  <br /></td></tr>
<tr class="separator:a018d8d8c78c73dd618e9a54e14874fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a19c333f7166115c84c8e572024190"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T, M, S &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T, M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a84a19c333f7166115c84c8e572024190"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a84a19c333f7166115c84c8e572024190.html#a84a19c333f7166115c84c8e572024190">offset_multiplier_constrain</a> (const T &amp;x, const M &amp;mu, const S &amp;sigma)</td></tr>
<tr class="memdesc:a84a19c333f7166115c84c8e572024190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearly transformed value for the specified unconstrained input and specified offset and multiplier.  <br /></td></tr>
<tr class="separator:a84a19c333f7166115c84c8e572024190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ce36845aba7dd406c468cadd1bf4c8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T, M, S &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T, M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae0ce36845aba7dd406c468cadd1bf4c8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae0ce36845aba7dd406c468cadd1bf4c8.html#ae0ce36845aba7dd406c468cadd1bf4c8">offset_multiplier_constrain</a> (const T &amp;x, const M &amp;mu, const S &amp;sigma, double &amp;lp)</td></tr>
<tr class="memdesc:ae0ce36845aba7dd406c468cadd1bf4c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearly transformed value for the specified unconstrained input and specified offset and multiplier.  <br /></td></tr>
<tr class="separator:ae0ce36845aba7dd406c468cadd1bf4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7fb6c2b6644f9037eb82172cf6193b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abe7fb6c2b6644f9037eb82172cf6193b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abe7fb6c2b6644f9037eb82172cf6193b.html#abe7fb6c2b6644f9037eb82172cf6193b">ub_constrain</a> (T &amp;&amp;x, U &amp;&amp;ub)</td></tr>
<tr class="memdesc:abe7fb6c2b6644f9037eb82172cf6193b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper-bounded value for the specified unconstrained matrix and upper bound.  <br /></td></tr>
<tr class="separator:abe7fb6c2b6644f9037eb82172cf6193b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f42613664a16b7fcc43d2f83d9e94c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac3f42613664a16b7fcc43d2f83d9e94c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac3f42613664a16b7fcc43d2f83d9e94c.html#ac3f42613664a16b7fcc43d2f83d9e94c">ub_constrain</a> (const T &amp;x, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:ac3f42613664a16b7fcc43d2f83d9e94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper-bounded value for the specified unconstrained matrix and upper bound.  <br /></td></tr>
<tr class="separator:ac3f42613664a16b7fcc43d2f83d9e94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079cf546b247c376fb3b9a59ae29236e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a079cf546b247c376fb3b9a59ae29236e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a079cf546b247c376fb3b9a59ae29236e.html#a079cf546b247c376fb3b9a59ae29236e">unit_vector_constrain</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:a079cf546b247c376fb3b9a59ae29236e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the given free vector.  <br /></td></tr>
<tr class="separator:a079cf546b247c376fb3b9a59ae29236e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7cfcede7ee2b3c895c9fdc6622f8876"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac7cfcede7ee2b3c895c9fdc6622f8876"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac7cfcede7ee2b3c895c9fdc6622f8876.html#ac7cfcede7ee2b3c895c9fdc6622f8876">unit_vector_constrain</a> (T_x &amp;&amp;x, double &amp;lp)</td></tr>
<tr class="memdesc:ac7cfcede7ee2b3c895c9fdc6622f8876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the given free vector.  <br /></td></tr>
<tr class="separator:ac7cfcede7ee2b3c895c9fdc6622f8876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3dc2b0579b44b4b2f4fd4f6a4477695"><td class="memTemplParams" colspan="2">template&lt;typename T_A , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_A&gt;&gt; </td></tr>
<tr class="memitem:ac3dc2b0579b44b4b2f4fd4f6a4477695"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; typename std::decay_t&lt; T_A &gt;::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac3dc2b0579b44b4b2f4fd4f6a4477695.html#ac3dc2b0579b44b4b2f4fd4f6a4477695">crossprod</a> (T_A &amp;&amp;A)</td></tr>
<tr class="memdesc:ac3dc2b0579b44b4b2f4fd4f6a4477695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of pre-multiplying a matrix by its own transpose.  <br /></td></tr>
<tr class="separator:ac3dc2b0579b44b4b2f4fd4f6a4477695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794e5c0e3bc4bc31ff2c71420dbac85c"><td class="memTemplParams" colspan="2">template&lt;typename T_vec , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a794e5c0e3bc4bc31ff2c71420dbac85c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a794e5c0e3bc4bc31ff2c71420dbac85c.html#a794e5c0e3bc4bc31ff2c71420dbac85c">cumulative_sum</a> (T_vec &amp;&amp;v)</td></tr>
<tr class="memdesc:a794e5c0e3bc4bc31ff2c71420dbac85c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cumulative sum of the specified vector.  <br /></td></tr>
<tr class="separator:a794e5c0e3bc4bc31ff2c71420dbac85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb676be2193f182909bf366c075344af"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afb676be2193f182909bf366c075344af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afb676be2193f182909bf366c075344af.html#afb676be2193f182909bf366c075344af">diag_matrix</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:afb676be2193f182909bf366c075344af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a square diagonal matrix with the specified vector of coefficients as the diagonal values.  <br /></td></tr>
<tr class="separator:afb676be2193f182909bf366c075344af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2449099b2cf82b17e9f67d10de36ac40"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2449099b2cf82b17e9f67d10de36ac40"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2449099b2cf82b17e9f67d10de36ac40.html#a2449099b2cf82b17e9f67d10de36ac40">diag_post_multiply</a> (const T1 &amp;m1, const T2 &amp;m2)</td></tr>
<tr class="memdesc:a2449099b2cf82b17e9f67d10de36ac40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of a matrix and the diagonal matrix formed from the vector or row_vector.  <br /></td></tr>
<tr class="separator:a2449099b2cf82b17e9f67d10de36ac40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4d31a16d3609e40c78e1a81b9b63f7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2f4d31a16d3609e40c78e1a81b9b63f7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f4d31a16d3609e40c78e1a81b9b63f7.html#a2f4d31a16d3609e40c78e1a81b9b63f7">diag_pre_multiply</a> (const T1 &amp;m1, const T2 &amp;m2)</td></tr>
<tr class="memdesc:a2f4d31a16d3609e40c78e1a81b9b63f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the diagonal matrix formed from the vector or row_vector and a matrix.  <br /></td></tr>
<tr class="separator:a2f4d31a16d3609e40c78e1a81b9b63f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaff473895b1f11e364afd4c2d3cb5cab4.html#gaff473895b1f11e364afd4c2d3cb5cab4">dims</a> (const T_x &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="memdesc:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> overload of the dims helper function in <a class="el" href="prim_2fun_2dims_8hpp.html">prim/fun/dims.hpp</a>.  <br /></td></tr>
<tr class="separator:gaff473895b1f11e364afd4c2d3cb5cab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5603f6eef0dc72e15804d640a005841e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob_cl , typename T_prior_size_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_prob_cl, T_prior_size_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_prob_cl, T_prior_size_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5603f6eef0dc72e15804d640a005841e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob_cl, T_prior_size_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5603f6eef0dc72e15804d640a005841e.html#ga5603f6eef0dc72e15804d640a005841e">dirichlet_lpdf</a> (const T_prob_cl &amp;theta, const T_prior_size_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga5603f6eef0dc72e15804d640a005841e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Dirichlet density for the given theta and a vector of prior sample sizes, alpha.  <br /></td></tr>
<tr class="separator:ga5603f6eef0dc72e15804d640a005841e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4365e541726f9e871af45878c75594d8"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4365e541726f9e871af45878c75594d8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4365e541726f9e871af45878c75594d8.html#a4365e541726f9e871af45878c75594d8">distance</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="memdesc:a4365e541726f9e871af45878c75594d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between the specified vectors.  <br /></td></tr>
<tr class="separator:a4365e541726f9e871af45878c75594d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_a&gt;&gt; </td></tr>
<tr class="memitem:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7fcb23d1bea081595030aedd230f5cf9.html#ga7fcb23d1bea081595030aedd230f5cf9">divide</a> (T_a &amp;&amp;a, double d)</td></tr>
<tr class="memdesc:ga7fcb23d1bea081595030aedd230f5cf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise division of the kernel generator expression.  <br /></td></tr>
<tr class="separator:ga7fcb23d1bea081595030aedd230f5cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc44cdfe2d3632d1e5481cff15fb65b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga2cc44cdfe2d3632d1e5481cff15fb65b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2cc44cdfe2d3632d1e5481cff15fb65b.html#ga2cc44cdfe2d3632d1e5481cff15fb65b">divide_columns</a> (<a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;A, const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;B)</td></tr>
<tr class="memdesc:ga2cc44cdfe2d3632d1e5481cff15fb65b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each column of a matrix by a vector.  <br /></td></tr>
<tr class="separator:ga2cc44cdfe2d3632d1e5481cff15fb65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eb269aa25fab63bb03b617210151e4a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_arithmetic_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga8eb269aa25fab63bb03b617210151e4a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga8eb269aa25fab63bb03b617210151e4a.html#ga8eb269aa25fab63bb03b617210151e4a">divide_columns</a> (<a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;A, const T2 &amp;divisor)</td></tr>
<tr class="memdesc:ga8eb269aa25fab63bb03b617210151e4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides each column of a matrix by a scalar.  <br /></td></tr>
<tr class="separator:ga8eb269aa25fab63bb03b617210151e4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae433ef8a331544c0ab889ee7ec6e0ba6"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae433ef8a331544c0ab889ee7ec6e0ba6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae433ef8a331544c0ab889ee7ec6e0ba6.html#ae433ef8a331544c0ab889ee7ec6e0ba6">dot_product</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="memdesc:ae433ef8a331544c0ab889ee7ec6e0ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified vectors.  <br /></td></tr>
<tr class="separator:ae433ef8a331544c0ab889ee7ec6e0ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37be6da87f3444ae2f7a00f6fee2983"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac37be6da87f3444ae2f7a00f6fee2983"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac37be6da87f3444ae2f7a00f6fee2983.html#ac37be6da87f3444ae2f7a00f6fee2983">dot_self</a> (const T &amp;a)</td></tr>
<tr class="memdesc:ac37be6da87f3444ae2f7a00f6fee2983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns squared norm of a vector or matrix.  <br /></td></tr>
<tr class="separator:ac37be6da87f3444ae2f7a00f6fee2983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2894417c746d65ba9021b076e37bc163"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2894417c746d65ba9021b076e37bc163"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2894417c746d65ba9021b076e37bc163.html#ga2894417c746d65ba9021b076e37bc163">double_exponential_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga2894417c746d65ba9021b076e37bc163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double exponential cumulative density function.  <br /></td></tr>
<tr class="separator:ga2894417c746d65ba9021b076e37bc163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d0996b3465a9ebeb23d16b3f3b17cb5"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7d0996b3465a9ebeb23d16b3f3b17cb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7d0996b3465a9ebeb23d16b3f3b17cb5.html#ga7d0996b3465a9ebeb23d16b3f3b17cb5">double_exponential_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga7d0996b3465a9ebeb23d16b3f3b17cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double exponential log complementary cumulative density function.  <br /></td></tr>
<tr class="separator:ga7d0996b3465a9ebeb23d16b3f3b17cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5b3b220580811803b6992e61887a13"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e5b3b220580811803b6992e61887a13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5e5b3b220580811803b6992e61887a13.html#ga5e5b3b220580811803b6992e61887a13">double_exponential_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga5e5b3b220580811803b6992e61887a13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double exponential log cumulative density function.  <br /></td></tr>
<tr class="separator:ga5e5b3b220580811803b6992e61887a13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac068dac657d8b37285df182b652f308a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac068dac657d8b37285df182b652f308a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac068dac657d8b37285df182b652f308a.html#gac068dac657d8b37285df182b652f308a">double_exponential_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gac068dac657d8b37285df182b652f308a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double exponential log probability density function.  <br /></td></tr>
<tr class="separator:gac068dac657d8b37285df182b652f308a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337899befb35f669ba240a3596288e24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a337899befb35f669ba240a3596288e24.html#a337899befb35f669ba240a3596288e24">eigenvalues_sym</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;m)</td></tr>
<tr class="separator:a337899befb35f669ba240a3596288e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a089e341c3f31c860478ef205bf551675"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a089e341c3f31c860478ef205bf551675.html#a089e341c3f31c860478ef205bf551675">eigenvectors_sym</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;m)</td></tr>
<tr class="separator:a089e341c3f31c860478ef205bf551675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9ed504293af9cdc9cd8599ee49f737c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac9ed504293af9cdc9cd8599ee49f737c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac9ed504293af9cdc9cd8599ee49f737c.html#gac9ed504293af9cdc9cd8599ee49f737c">exp_mod_normal_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="memdesc:gac9ed504293af9cdc9cd8599ee49f737c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double exponential cumulative density function.  <br /></td></tr>
<tr class="separator:gac9ed504293af9cdc9cd8599ee49f737c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32fcb6886b7ff193f317af94e439203d"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga32fcb6886b7ff193f317af94e439203d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga32fcb6886b7ff193f317af94e439203d.html#ga32fcb6886b7ff193f317af94e439203d">exp_mod_normal_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="memdesc:ga32fcb6886b7ff193f317af94e439203d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exp mod normal log complementary cumulative density function.  <br /></td></tr>
<tr class="separator:ga32fcb6886b7ff193f317af94e439203d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10cbc426176ab6b9924cc1acff27c37c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga10cbc426176ab6b9924cc1acff27c37c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga10cbc426176ab6b9924cc1acff27c37c.html#ga10cbc426176ab6b9924cc1acff27c37c">exp_mod_normal_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="memdesc:ga10cbc426176ab6b9924cc1acff27c37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the exp mod normal log cumulative density function.  <br /></td></tr>
<tr class="separator:ga10cbc426176ab6b9924cc1acff27c37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae039c40c36fc71cd9c4714e5c5fe0aa1"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae039c40c36fc71cd9c4714e5c5fe0aa1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae039c40c36fc71cd9c4714e5c5fe0aa1.html#gae039c40c36fc71cd9c4714e5c5fe0aa1">exp_mod_normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_inv_scale_cl &amp;lambda)</td></tr>
<tr class="memdesc:gae039c40c36fc71cd9c4714e5c5fe0aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the exp mod normal distribution.  <br /></td></tr>
<tr class="separator:gae039c40c36fc71cd9c4714e5c5fe0aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd3aa08ca68b5172c7ab6707f40150d5"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gafd3aa08ca68b5172c7ab6707f40150d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gafd3aa08ca68b5172c7ab6707f40150d5.html#gafd3aa08ca68b5172c7ab6707f40150d5">exponential_cdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gafd3aa08ca68b5172c7ab6707f40150d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the exponential cumulative distribution function for the given y and beta.  <br /></td></tr>
<tr class="separator:gafd3aa08ca68b5172c7ab6707f40150d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e0a717f891977f057b1b959432fb047"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2e0a717f891977f057b1b959432fb047"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga2e0a717f891977f057b1b959432fb047.html#ga2e0a717f891977f057b1b959432fb047">exponential_lccdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga2e0a717f891977f057b1b959432fb047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log exponential cumulative distribution function for the given y and beta.  <br /></td></tr>
<tr class="separator:ga2e0a717f891977f057b1b959432fb047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5d45dda59c036aa28a02cefb705144c1"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5d45dda59c036aa28a02cefb705144c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5d45dda59c036aa28a02cefb705144c1.html#ga5d45dda59c036aa28a02cefb705144c1">exponential_lcdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga5d45dda59c036aa28a02cefb705144c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log exponential cumulative distribution function for the given y and beta.  <br /></td></tr>
<tr class="separator:ga5d45dda59c036aa28a02cefb705144c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab17062b58db7edb5ce19299e743101ea"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab17062b58db7edb5ce19299e743101ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gab17062b58db7edb5ce19299e743101ea.html#gab17062b58db7edb5ce19299e743101ea">exponential_lpdf</a> (const T_y_cl &amp;y, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gab17062b58db7edb5ce19299e743101ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an exponential density for y with the specified inverse scale parameter.  <br /></td></tr>
<tr class="separator:gab17062b58db7edb5ce19299e743101ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf74727b2f75188f45d939879917da067"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf74727b2f75188f45d939879917da067"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaf74727b2f75188f45d939879917da067.html#gaf74727b2f75188f45d939879917da067">frechet_cdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gaf74727b2f75188f45d939879917da067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the frechet cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gaf74727b2f75188f45d939879917da067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6e65c8e3e2c35410a0351008149d8f5"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae6e65c8e3e2c35410a0351008149d8f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae6e65c8e3e2c35410a0351008149d8f5.html#gae6e65c8e3e2c35410a0351008149d8f5">frechet_lccdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gae6e65c8e3e2c35410a0351008149d8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the frechet log complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gae6e65c8e3e2c35410a0351008149d8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e4df0fd56d7b6aa89f3593cd4b9ef00"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1e4df0fd56d7b6aa89f3593cd4b9ef00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga1e4df0fd56d7b6aa89f3593cd4b9ef00.html#ga1e4df0fd56d7b6aa89f3593cd4b9ef00">frechet_lcdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga1e4df0fd56d7b6aa89f3593cd4b9ef00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the frechet log cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga1e4df0fd56d7b6aa89f3593cd4b9ef00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f0299951bbc9cf5045068dc51841342"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4f0299951bbc9cf5045068dc51841342"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga4f0299951bbc9cf5045068dc51841342.html#ga4f0299951bbc9cf5045068dc51841342">frechet_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga4f0299951bbc9cf5045068dc51841342"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the frechet density for the specified scalar(s) given the specified sample stan::math::size(s).  <br /></td></tr>
<tr class="separator:ga4f0299951bbc9cf5045068dc51841342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga269c6886b8fe609e094cf4f9c07e9f74"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga269c6886b8fe609e094cf4f9c07e9f74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga269c6886b8fe609e094cf4f9c07e9f74.html#ga269c6886b8fe609e094cf4f9c07e9f74">gamma_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga269c6886b8fe609e094cf4f9c07e9f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a gamma density for y with the specified shape and inverse scale parameters.  <br /></td></tr>
<tr class="separator:ga269c6886b8fe609e094cf4f9c07e9f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ae66d06eb626b8357a5fc74289bfe42"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_sigma &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7ae66d06eb626b8357a5fc74289bfe42"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7ae66d06eb626b8357a5fc74289bfe42.html#ga7ae66d06eb626b8357a5fc74289bfe42">gp_dot_prod_cov</a> (const T_x &amp;x, const T_sigma sigma)</td></tr>
<tr class="memdesc:ga7ae66d06eb626b8357a5fc74289bfe42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product kernel on the GPU.  <br /></td></tr>
<tr class="separator:ga7ae66d06eb626b8357a5fc74289bfe42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb569d6717740727352a2b67d23adfc"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_y , typename T_sigma , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_x, T_y &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_sigma &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadfb569d6717740727352a2b67d23adfc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gadfb569d6717740727352a2b67d23adfc.html#gadfb569d6717740727352a2b67d23adfc">gp_dot_prod_cov</a> (const T_x &amp;x, const T_y &amp;y, const T_sigma sigma)</td></tr>
<tr class="memdesc:gadfb569d6717740727352a2b67d23adfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dot product kernel on the GPU.  <br /></td></tr>
<tr class="separator:gadfb569d6717740727352a2b67d23adfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67c459084eb40e844e676391316c5bc9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename  = require_all_arithmetic_t&lt;T1, T2, T3&gt;&gt; </td></tr>
<tr class="memitem:ga67c459084eb40e844e676391316c5bc9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga67c459084eb40e844e676391316c5bc9.html#ga67c459084eb40e844e676391316c5bc9">gp_exp_quad_cov</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="memdesc:ga67c459084eb40e844e676391316c5bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared exponential kernel on the GPU.  <br /></td></tr>
<tr class="separator:ga67c459084eb40e844e676391316c5bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff43fb0f414ae018ece6488dc112d22d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , typename  = require_all_arithmetic_t&lt;T1, T2, T3, T4&gt;&gt; </td></tr>
<tr class="memitem:gaff43fb0f414ae018ece6488dc112d22d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaff43fb0f414ae018ece6488dc112d22d.html#gaff43fb0f414ae018ece6488dc112d22d">gp_exp_quad_cov</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T1 &gt; &amp;x, const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T2 &gt; &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="memdesc:gaff43fb0f414ae018ece6488dc112d22d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squared exponential kernel on the GPU.  <br /></td></tr>
<tr class="separator:gaff43fb0f414ae018ece6488dc112d22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac47f7d0f97a1035236ac74de3b965020"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac47f7d0f97a1035236ac74de3b965020"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac47f7d0f97a1035236ac74de3b965020.html#gac47f7d0f97a1035236ac74de3b965020">gp_exponential_cov</a> (const T1 &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="memdesc:gac47f7d0f97a1035236ac74de3b965020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matern exponential kernel on the GPU.  <br /></td></tr>
<tr class="separator:gac47f7d0f97a1035236ac74de3b965020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63ac2500cbe6777efe781d2738148ed4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T3, T4 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga63ac2500cbe6777efe781d2738148ed4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga63ac2500cbe6777efe781d2738148ed4.html#ga63ac2500cbe6777efe781d2738148ed4">gp_exponential_cov</a> (const T1 &amp;x, const T2 &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="memdesc:ga63ac2500cbe6777efe781d2738148ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matern exponential kernel on the GPU.  <br /></td></tr>
<tr class="separator:ga63ac2500cbe6777efe781d2738148ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42d71e19927c390c7e2ca70ffe71d600"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga42d71e19927c390c7e2ca70ffe71d600"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga42d71e19927c390c7e2ca70ffe71d600.html#ga42d71e19927c390c7e2ca70ffe71d600">gp_matern32_cov</a> (const T1 &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="memdesc:ga42d71e19927c390c7e2ca70ffe71d600"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matern 3/2 kernel on the GPU.  <br /></td></tr>
<tr class="separator:ga42d71e19927c390c7e2ca70ffe71d600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85aa537a04d32939114f7dd8b75fdc5b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T3, T4 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga85aa537a04d32939114f7dd8b75fdc5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga85aa537a04d32939114f7dd8b75fdc5b.html#ga85aa537a04d32939114f7dd8b75fdc5b">gp_matern32_cov</a> (const T1 &amp;x, const T2 &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="memdesc:ga85aa537a04d32939114f7dd8b75fdc5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matern 3/2 kernel on the GPU.  <br /></td></tr>
<tr class="separator:ga85aa537a04d32939114f7dd8b75fdc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5e4b95241432025c0dbf5693659fda"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaea5e4b95241432025c0dbf5693659fda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaea5e4b95241432025c0dbf5693659fda.html#gaea5e4b95241432025c0dbf5693659fda">gp_matern52_cov</a> (const T1 &amp;x, const T2 sigma, const T3 length_scale)</td></tr>
<tr class="memdesc:gaea5e4b95241432025c0dbf5693659fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matern 5/2 kernel on the GPU.  <br /></td></tr>
<tr class="separator:gaea5e4b95241432025c0dbf5693659fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07fab169578cad9bff602bc9c60453a7"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T4 , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T3, T4 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga07fab169578cad9bff602bc9c60453a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3, T4 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga07fab169578cad9bff602bc9c60453a7.html#ga07fab169578cad9bff602bc9c60453a7">gp_matern52_cov</a> (const T1 &amp;x, const T2 &amp;y, const T3 sigma, const T4 length_scale)</td></tr>
<tr class="memdesc:ga07fab169578cad9bff602bc9c60453a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matern 5/2 kernel on the GPU.  <br /></td></tr>
<tr class="separator:ga07fab169578cad9bff602bc9c60453a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac840c0972e9a72dd9791352953c6904b"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac840c0972e9a72dd9791352953c6904b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac840c0972e9a72dd9791352953c6904b.html#gac840c0972e9a72dd9791352953c6904b">gumbel_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gac840c0972e9a72dd9791352953c6904b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gumbel cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gac840c0972e9a72dd9791352953c6904b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac26240cad067ee7137cc57ae7e71c8da"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac26240cad067ee7137cc57ae7e71c8da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac26240cad067ee7137cc57ae7e71c8da.html#gac26240cad067ee7137cc57ae7e71c8da">gumbel_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gac26240cad067ee7137cc57ae7e71c8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gumbel log complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gac26240cad067ee7137cc57ae7e71c8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37b5904be5c33f9ef6b1ee7a5a3f46c1"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga37b5904be5c33f9ef6b1ee7a5a3f46c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga37b5904be5c33f9ef6b1ee7a5a3f46c1.html#ga37b5904be5c33f9ef6b1ee7a5a3f46c1">gumbel_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga37b5904be5c33f9ef6b1ee7a5a3f46c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gumbel log complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga37b5904be5c33f9ef6b1ee7a5a3f46c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88e0447c99bb53c2c8a2ff906e47c39e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga88e0447c99bb53c2c8a2ff906e47c39e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga88e0447c99bb53c2c8a2ff906e47c39e.html#ga88e0447c99bb53c2c8a2ff906e47c39e">gumbel_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga88e0447c99bb53c2c8a2ff906e47c39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gumbel log probability density for the given location and scale.  <br /></td></tr>
<tr class="separator:ga88e0447c99bb53c2c8a2ff906e47c39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe637c649bea17f34938bf704ef60f0"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:abfe637c649bea17f34938bf704ef60f0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abfe637c649bea17f34938bf704ef60f0.html#abfe637c649bea17f34938bf704ef60f0">head</a> (T_x &amp;&amp;x, size_t n)</td></tr>
<tr class="memdesc:abfe637c649bea17f34938bf704ef60f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a vector or row vector (same as input) from the front of the specified vector or row vector.  <br /></td></tr>
<tr class="separator:abfe637c649bea17f34938bf704ef60f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd0997e88883571dd1e2ce4211ed4c7"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__matrix__cl__types_gaf18202a28f3c86c16368f08c04f6532d.html#gaf18202a28f3c86c16368f08c04f6532d">require_matrix_cl_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9dd0997e88883571dd1e2ce4211ed4c7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9dd0997e88883571dd1e2ce4211ed4c7.html#a9dd0997e88883571dd1e2ce4211ed4c7">identity_matrix</a> (int K)</td></tr>
<tr class="memdesc:a9dd0997e88883571dd1e2ce4211ed4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a square identity matrix.  <br /></td></tr>
<tr class="separator:a9dd0997e88883571dd1e2ce4211ed4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8c2964caa6056c143f9d4f5b4a58cd"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:a4a8c2964caa6056c143f9d4f5b4a58cd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a8c2964caa6056c143f9d4f5b4a58cd.html#a4a8c2964caa6056c143f9d4f5b4a58cd">inv</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:a4a8c2964caa6056c143f9d4f5b4a58cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise 1.0 / x of the specified argument, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:a4a8c2964caa6056c143f9d4f5b4a58cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaba5763101e834c65f55ae9061198e91"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_dof_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_dof_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaaba5763101e834c65f55ae9061198e91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaaba5763101e834c65f55ae9061198e91.html#gaaba5763101e834c65f55ae9061198e91">inv_chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu)</td></tr>
<tr class="memdesc:gaaba5763101e834c65f55ae9061198e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an inverse chi-squared density for y with the specified degrees of freedom parameter.  <br /></td></tr>
<tr class="separator:gaaba5763101e834c65f55ae9061198e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a6835ceb0371d066c976f968d9a9b3"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:a87a6835ceb0371d066c976f968d9a9b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a87a6835ceb0371d066c976f968d9a9b3.html#a87a6835ceb0371d066c976f968d9a9b3">inv_cloglog</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:a87a6835ceb0371d066c976f968d9a9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse complementary log-log function.  <br /></td></tr>
<tr class="separator:a87a6835ceb0371d066c976f968d9a9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7b17b21db462d52896cbb001bd7fe4f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab7b17b21db462d52896cbb001bd7fe4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gab7b17b21db462d52896cbb001bd7fe4f.html#gab7b17b21db462d52896cbb001bd7fe4f">inv_gamma_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gab7b17b21db462d52896cbb001bd7fe4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an inverse gamma density for y with the specified shape and scale parameters.  <br /></td></tr>
<tr class="separator:gab7b17b21db462d52896cbb001bd7fe4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16f311fb7acec6ddd7b910545ad2b2d"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:af16f311fb7acec6ddd7b910545ad2b2d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af16f311fb7acec6ddd7b910545ad2b2d.html#af16f311fb7acec6ddd7b910545ad2b2d">inv_sqrt</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:af16f311fb7acec6ddd7b910545ad2b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise <code>1 / sqrt(x)</code> of the specified kernel generator expression.  <br /></td></tr>
<tr class="separator:af16f311fb7acec6ddd7b910545ad2b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7802f2b80410744fd64711a697f944"><td class="memTemplParams" colspan="2">template&lt;typename T_theta_cl , typename T_lambda_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_theta_cl, T_lambda_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ade7802f2b80410744fd64711a697f944"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade7802f2b80410744fd64711a697f944.html#ade7802f2b80410744fd64711a697f944">log_mix</a> (const T_theta_cl &amp;theta, const T_lambda_cl &amp;lambda)</td></tr>
<tr class="memdesc:ade7802f2b80410744fd64711a697f944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log mixture density with specified mixing proportions and log densities.  <br /></td></tr>
<tr class="separator:ade7802f2b80410744fd64711a697f944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72ada14000f17b0cdfa0ea2d66a4d69"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab72ada14000f17b0cdfa0ea2d66a4d69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab72ada14000f17b0cdfa0ea2d66a4d69.html#ab72ada14000f17b0cdfa0ea2d66a4d69">log_softmax</a> (const T &amp;a)</td></tr>
<tr class="memdesc:ab72ada14000f17b0cdfa0ea2d66a4d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return log of the softmax of the specified vector.  <br /></td></tr>
<tr class="separator:ab72ada14000f17b0cdfa0ea2d66a4d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b30449ff23e5fedb01ec972d06e9e89"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8b30449ff23e5fedb01ec972d06e9e89"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8b30449ff23e5fedb01ec972d06e9e89.html#a8b30449ff23e5fedb01ec972d06e9e89">log_sum_exp</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a8b30449ff23e5fedb01ec972d06e9e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the sum of the exponentiated values of the specified matrix of values.  <br /></td></tr>
<tr class="separator:a8b30449ff23e5fedb01ec972d06e9e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae68390747f8d9f5584914e8cf87ca2da"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae68390747f8d9f5584914e8cf87ca2da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae68390747f8d9f5584914e8cf87ca2da.html#gae68390747f8d9f5584914e8cf87ca2da">logistic_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gae68390747f8d9f5584914e8cf87ca2da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logistic cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gae68390747f8d9f5584914e8cf87ca2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadebd76af5a9ea78a039810c3f627ff61"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadebd76af5a9ea78a039810c3f627ff61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gadebd76af5a9ea78a039810c3f627ff61.html#gadebd76af5a9ea78a039810c3f627ff61">logistic_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gadebd76af5a9ea78a039810c3f627ff61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logistic cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gadebd76af5a9ea78a039810c3f627ff61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c7858f9b0a323ade684a1e3e51e87b"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa0c7858f9b0a323ade684a1e3e51e87b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaa0c7858f9b0a323ade684a1e3e51e87b.html#gaa0c7858f9b0a323ade684a1e3e51e87b">logistic_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gaa0c7858f9b0a323ade684a1e3e51e87b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logistic cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gaa0c7858f9b0a323ade684a1e3e51e87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7f3378444fb1fa2e05e1257d000d417"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac7f3378444fb1fa2e05e1257d000d417"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac7f3378444fb1fa2e05e1257d000d417.html#gac7f3378444fb1fa2e05e1257d000d417">logistic_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gac7f3378444fb1fa2e05e1257d000d417"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a logistic density for y with the specified location and scale parameters.  <br /></td></tr>
<tr class="separator:gac7f3378444fb1fa2e05e1257d000d417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade92ae2463a65a4572405954733abac8"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gade92ae2463a65a4572405954733abac8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gade92ae2463a65a4572405954733abac8.html#gade92ae2463a65a4572405954733abac8">lognormal_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gade92ae2463a65a4572405954733abac8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the loghormal cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gade92ae2463a65a4572405954733abac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb4348a862c0a6befed9be0c57fac8e8"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gafb4348a862c0a6befed9be0c57fac8e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gafb4348a862c0a6befed9be0c57fac8e8.html#gafb4348a862c0a6befed9be0c57fac8e8">lognormal_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gafb4348a862c0a6befed9be0c57fac8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lognormal log complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gafb4348a862c0a6befed9be0c57fac8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d9217ec565de7e187bdb359f8e2b6f"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga74d9217ec565de7e187bdb359f8e2b6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga74d9217ec565de7e187bdb359f8e2b6f.html#ga74d9217ec565de7e187bdb359f8e2b6f">lognormal_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga74d9217ec565de7e187bdb359f8e2b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lognormal log cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga74d9217ec565de7e187bdb359f8e2b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3dca7015ae3977e1fadf1e1b3a13f9e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab3dca7015ae3977e1fadf1e1b3a13f9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gab3dca7015ae3977e1fadf1e1b3a13f9e.html#gab3dca7015ae3977e1fadf1e1b3a13f9e">lognormal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gab3dca7015ae3977e1fadf1e1b3a13f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the lognormal density for the specified scalar(s) given the specified sample stan::math::size(s).  <br /></td></tr>
<tr class="separator:gab3dca7015ae3977e1fadf1e1b3a13f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973e75d07f9ffc2e65157c532d69a018"><td class="memTemplParams" colspan="2">template&lt;typename T_m , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_m &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a973e75d07f9ffc2e65157c532d69a018"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T_m &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a973e75d07f9ffc2e65157c532d69a018.html#a973e75d07f9ffc2e65157c532d69a018">matrix_power</a> (T_m &amp;&amp;M, const int n)</td></tr>
<tr class="memdesc:a973e75d07f9ffc2e65157c532d69a018"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth power of the specific matrix.  <br /></td></tr>
<tr class="separator:a973e75d07f9ffc2e65157c532d69a018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee020ca511e99f3731a1e04254f0dab4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aee020ca511e99f3731a1e04254f0dab4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aee020ca511e99f3731a1e04254f0dab4.html#aee020ca511e99f3731a1e04254f0dab4">mdivide_left_tri_low</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="memdesc:aee020ca511e99f3731a1e04254f0dab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is lower triangular.  <br /></td></tr>
<tr class="separator:aee020ca511e99f3731a1e04254f0dab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427ccff20bb7b6707c5049443ae55f5f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a427ccff20bb7b6707c5049443ae55f5f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a427ccff20bb7b6707c5049443ae55f5f.html#a427ccff20bb7b6707c5049443ae55f5f">mdivide_left_tri_low</a> (const T &amp;A)</td></tr>
<tr class="memdesc:a427ccff20bb7b6707c5049443ae55f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is triangular and b=I.  <br /></td></tr>
<tr class="separator:a427ccff20bb7b6707c5049443ae55f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa783821f96eb4830985f8ef70a2e4a5"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afa783821f96eb4830985f8ef70a2e4a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afa783821f96eb4830985f8ef70a2e4a5.html#afa783821f96eb4830985f8ef70a2e4a5">mdivide_right_tri_low</a> (const T2 &amp;b, const T1 &amp;A)</td></tr>
<tr class="memdesc:afa783821f96eb4830985f8ef70a2e4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b where A is a lower triangular matrix.  <br /></td></tr>
<tr class="separator:afa783821f96eb4830985f8ef70a2e4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fbeb8715ff44484773704d9c21b15c"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a10fbeb8715ff44484773704d9c21b15c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a10fbeb8715ff44484773704d9c21b15c.html#a10fbeb8715ff44484773704d9c21b15c">mean</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a10fbeb8715ff44484773704d9c21b15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample mean (i.e., average) of the coefficients in the specified std vector, vector, row vector, or matrix.  <br /></td></tr>
<tr class="separator:a10fbeb8715ff44484773704d9c21b15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ea5feae3e40c37cdc845d98fc222c80"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_covar_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_covar_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3ea5feae3e40c37cdc845d98fc222c80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_covar_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3ea5feae3e40c37cdc845d98fc222c80.html#ga3ea5feae3e40c37cdc845d98fc222c80">multi_normal_cholesky_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_covar_cl &amp;L)</td></tr>
<tr class="memdesc:ga3ea5feae3e40c37cdc845d98fc222c80"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the multivariate normal density for the given y, mu, and a Cholesky factor L of the variance matrix.  <br /></td></tr>
<tr class="separator:ga3ea5feae3e40c37cdc845d98fc222c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga824d3723d9c0f93302dc974faee0e8fc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:ga824d3723d9c0f93302dc974faee0e8fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga824d3723d9c0f93302dc974faee0e8fc.html#ga824d3723d9c0f93302dc974faee0e8fc">multiply</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:ga824d3723d9c0f93302dc974faee0e8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of the specified matrices with the option of specifying the triangularity of either input matrices.  <br /></td></tr>
<tr class="separator:ga824d3723d9c0f93302dc974faee0e8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9395e7e77bd7389fd699f74cef572f5e"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_a, T_b&gt;&gt; </td></tr>
<tr class="memitem:a9395e7e77bd7389fd699f74cef572f5e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_a, T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9395e7e77bd7389fd699f74cef572f5e.html#a9395e7e77bd7389fd699f74cef572f5e">operator*</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="memdesc:a9395e7e77bd7389fd699f74cef572f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiplication of two kernel generator expressions.  <br /></td></tr>
<tr class="separator:a9395e7e77bd7389fd699f74cef572f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03c648981200e8dc2bde05ceb3486a2e"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_a &gt; *  = nullptr, <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_b &gt; *  = nullptr, <a class="el" href="group__var__types_gacd1267e326cb7764f47ddfba577dabdb.html#gacd1267e326cb7764f47ddfba577dabdb">require_all_not_var_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a03c648981200e8dc2bde05ceb3486a2e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_a, T_b &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a03c648981200e8dc2bde05ceb3486a2e.html#a03c648981200e8dc2bde05ceb3486a2e">multiply</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="memdesc:a03c648981200e8dc2bde05ceb3486a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiplication of a scalar and a kernel generator expressions.  <br /></td></tr>
<tr class="separator:a03c648981200e8dc2bde05ceb3486a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdeb05a3864eec83b057c15c5343ad6c"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abdeb05a3864eec83b057c15c5343ad6c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abdeb05a3864eec83b057c15c5343ad6c.html#abdeb05a3864eec83b057c15c5343ad6c">multiply_lower_tri_self_transpose</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:abdeb05a3864eec83b057c15c5343ad6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of multiplying the lower triangular portion of the input matrix by its own transpose.  <br /></td></tr>
<tr class="separator:abdeb05a3864eec83b057c15c5343ad6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85c5d9590a8fe49a6a71e4b0894897b8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , typename T_phi_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_x_cl, T_y_cl, T_alpha_cl, T_beta_cl, T_phi_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga85c5d9590a8fe49a6a71e4b0894897b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x_cl, T_alpha_cl, T_beta_cl, T_phi_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga85c5d9590a8fe49a6a71e4b0894897b8.html#ga85c5d9590a8fe49a6a71e4b0894897b8">neg_binomial_2_log_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, const T_phi_cl &amp;phi)</td></tr>
<tr class="memdesc:ga85c5d9590a8fe49a6a71e4b0894897b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Negative-Binomial-2 distribution and log link function.  <br /></td></tr>
<tr class="separator:ga85c5d9590a8fe49a6a71e4b0894897b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70ee28a9bb35e74b0742539416b23a2a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_log_location_cl , typename T_precision_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga70ee28a9bb35e74b0742539416b23a2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_log_location_cl, T_precision_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga70ee28a9bb35e74b0742539416b23a2a.html#ga70ee28a9bb35e74b0742539416b23a2a">neg_binomial_2_log_lpmf</a> (const T_n_cl &amp;n, const T_log_location_cl &amp;eta, const T_precision_cl &amp;phi)</td></tr>
<tr class="memdesc:ga70ee28a9bb35e74b0742539416b23a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the log transformed negative binomial density for the specified scalars given the specified mean(s) and deviation(s).  <br /></td></tr>
<tr class="separator:ga70ee28a9bb35e74b0742539416b23a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24209b61d1f95246013701478577160f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_location_cl , typename T_precision_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_location_cl, T_precision_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_location_cl, T_precision_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga24209b61d1f95246013701478577160f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_location_cl, T_precision_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga24209b61d1f95246013701478577160f.html#ga24209b61d1f95246013701478577160f">neg_binomial_2_lpmf</a> (const T_n_cl &amp;n, const T_location_cl &amp;mu, const T_precision_cl &amp;phi)</td></tr>
<tr class="memdesc:ga24209b61d1f95246013701478577160f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the negative binomial density for the specified scalars given the specified mean(s) and deviation(s).  <br /></td></tr>
<tr class="separator:ga24209b61d1f95246013701478577160f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9213891b28b3707c76327cfe7c674401"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_shape_cl , typename T_inv_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9213891b28b3707c76327cfe7c674401"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n_cl, T_shape_cl, T_inv_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9213891b28b3707c76327cfe7c674401.html#ga9213891b28b3707c76327cfe7c674401">neg_binomial_lpmf</a> (const T_n_cl &amp;n, const T_shape_cl &amp;alpha, const T_inv_scale_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga9213891b28b3707c76327cfe7c674401"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the negative binomial density for the specified scalars given the specified mean(s) and deviation(s).  <br /></td></tr>
<tr class="separator:ga9213891b28b3707c76327cfe7c674401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fb1b528cffdef8f13b7640d279214e6"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6fb1b528cffdef8f13b7640d279214e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6fb1b528cffdef8f13b7640d279214e6.html#ga6fb1b528cffdef8f13b7640d279214e6">normal_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga6fb1b528cffdef8f13b7640d279214e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the normal cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga6fb1b528cffdef8f13b7640d279214e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25418219cf2e8dd541ecac94d6579ce7"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , typename T_sigma_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_x_cl, T_y_cl, T_alpha_cl, T_beta_cl, T_sigma_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga25418219cf2e8dd541ecac94d6579ce7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl, T_sigma_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga25418219cf2e8dd541ecac94d6579ce7.html#ga25418219cf2e8dd541ecac94d6579ce7">normal_id_glm_lpdf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, const T_sigma_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga25418219cf2e8dd541ecac94d6579ce7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PDF of the Generalized Linear Model (GLM) with Normal distribution and id link function.  <br /></td></tr>
<tr class="separator:ga25418219cf2e8dd541ecac94d6579ce7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfcdac87f80488a7cf40c80f353f31c1"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacfcdac87f80488a7cf40c80f353f31c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gacfcdac87f80488a7cf40c80f353f31c1.html#gacfcdac87f80488a7cf40c80f353f31c1">normal_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gacfcdac87f80488a7cf40c80f353f31c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the normal log complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gacfcdac87f80488a7cf40c80f353f31c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b8007efbb1c8d98d247403f1ab387d1"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8b8007efbb1c8d98d247403f1ab387d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga8b8007efbb1c8d98d247403f1ab387d1.html#ga8b8007efbb1c8d98d247403f1ab387d1">normal_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga8b8007efbb1c8d98d247403f1ab387d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the normal log complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga8b8007efbb1c8d98d247403f1ab387d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad305d01ff13ab2f04921def01f434ff"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaad305d01ff13ab2f04921def01f434ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaad305d01ff13ab2f04921def01f434ff.html#gaad305d01ff13ab2f04921def01f434ff">normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gaad305d01ff13ab2f04921def01f434ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the normal density for the specified scalar(s) given the specified mean(s) and deviation(s).  <br /></td></tr>
<tr class="separator:gaad305d01ff13ab2f04921def01f434ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa7728a01bd11825195a6b29802b3f5"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aefa7728a01bd11825195a6b29802b3f5"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aefa7728a01bd11825195a6b29802b3f5.html#aefa7728a01bd11825195a6b29802b3f5">num_elements</a> (const T &amp;m)</td></tr>
<tr class="memdesc:aefa7728a01bd11825195a6b29802b3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of the elements of a <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> or <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;<a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;T&gt;&gt;</code>.  <br /></td></tr>
<tr class="separator:aefa7728a01bd11825195a6b29802b3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4cebeb5b59455b65807650b71a7fe0a1"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_beta , typename T_cuts , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_x, T_beta, T_cuts &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4cebeb5b59455b65807650b71a7fe0a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_beta, T_cuts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga4cebeb5b59455b65807650b71a7fe0a1.html#ga4cebeb5b59455b65807650b71a7fe0a1">ordered_logistic_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, const T_cuts &amp;cuts)</td></tr>
<tr class="memdesc:ga4cebeb5b59455b65807650b71a7fe0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the ordinal regression Generalized Linear Model (GLM).  <br /></td></tr>
<tr class="separator:ga4cebeb5b59455b65807650b71a7fe0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc83b68972d42ac3bbf64fc0ccf454bf"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_cuts_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_cuts_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacc83b68972d42ac3bbf64fc0ccf454bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_cuts_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gacc83b68972d42ac3bbf64fc0ccf454bf.html#gacc83b68972d42ac3bbf64fc0ccf454bf">ordered_logistic_lpmf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;lambda, const T_cuts_cl &amp;cuts)</td></tr>
<tr class="memdesc:gacc83b68972d42ac3bbf64fc0ccf454bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (natural) log probability of the specified array of integers given the vector of continuous locations and specified cutpoints in an ordered logistic model.  <br /></td></tr>
<tr class="separator:gacc83b68972d42ac3bbf64fc0ccf454bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e5942c7c5a6138d96230806f6acef9"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga60e5942c7c5a6138d96230806f6acef9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga60e5942c7c5a6138d96230806f6acef9.html#ga60e5942c7c5a6138d96230806f6acef9">pareto_cdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga60e5942c7c5a6138d96230806f6acef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Pareto cumulative density function.  <br /></td></tr>
<tr class="separator:ga60e5942c7c5a6138d96230806f6acef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3266e056f6cc2b8b7e2f3f30674798ca"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3266e056f6cc2b8b7e2f3f30674798ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3266e056f6cc2b8b7e2f3f30674798ca.html#ga3266e056f6cc2b8b7e2f3f30674798ca">pareto_lccdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga3266e056f6cc2b8b7e2f3f30674798ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Pareto cumulative density function.  <br /></td></tr>
<tr class="separator:ga3266e056f6cc2b8b7e2f3f30674798ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9efb4cfe069238c77cd6616f4b2c9170"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9efb4cfe069238c77cd6616f4b2c9170"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9efb4cfe069238c77cd6616f4b2c9170.html#ga9efb4cfe069238c77cd6616f4b2c9170">pareto_lcdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga9efb4cfe069238c77cd6616f4b2c9170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Pareto cumulative density function.  <br /></td></tr>
<tr class="separator:ga9efb4cfe069238c77cd6616f4b2c9170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga787b804a23dd71fd6087363231e98339"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga787b804a23dd71fd6087363231e98339"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga787b804a23dd71fd6087363231e98339.html#ga787b804a23dd71fd6087363231e98339">pareto_lpdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;y_min, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga787b804a23dd71fd6087363231e98339"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Cauchy density for the specified scalar(s) given the specified location parameter(s) and scale parameter(s).  <br /></td></tr>
<tr class="separator:ga787b804a23dd71fd6087363231e98339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef789587dd8f528f3898006b911db0cc"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaef789587dd8f528f3898006b911db0cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaef789587dd8f528f3898006b911db0cc.html#gaef789587dd8f528f3898006b911db0cc">pareto_type_2_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:gaef789587dd8f528f3898006b911db0cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pareto type 2 cumulative density function.  <br /></td></tr>
<tr class="separator:gaef789587dd8f528f3898006b911db0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7436040baf4a148c636344039b07defc"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7436040baf4a148c636344039b07defc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga7436040baf4a148c636344039b07defc.html#ga7436040baf4a148c636344039b07defc">pareto_type_2_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga7436040baf4a148c636344039b07defc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pareto type 2 log complementaty cumulative density function.  <br /></td></tr>
<tr class="separator:ga7436040baf4a148c636344039b07defc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19c5e7e7166cb87bb0ec5bd9f513713a"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga19c5e7e7166cb87bb0ec5bd9f513713a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga19c5e7e7166cb87bb0ec5bd9f513713a.html#ga19c5e7e7166cb87bb0ec5bd9f513713a">pareto_type_2_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga19c5e7e7166cb87bb0ec5bd9f513713a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the pareto type 2 log cumulative density function.  <br /></td></tr>
<tr class="separator:ga19c5e7e7166cb87bb0ec5bd9f513713a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga702c56bfb2c74ddeafd14c3a455d356f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga702c56bfb2c74ddeafd14c3a455d356f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga702c56bfb2c74ddeafd14c3a455d356f.html#ga702c56bfb2c74ddeafd14c3a455d356f">pareto_type_2_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;lambda, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga702c56bfb2c74ddeafd14c3a455d356f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Pareto type 2 distribution.  <br /></td></tr>
<tr class="separator:ga702c56bfb2c74ddeafd14c3a455d356f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c582a0f0ff921ed988b627e8e54de47"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_x_cl , typename T_alpha_cl , typename T_beta_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_x_cl, T_alpha_cl, T_beta_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8c582a0f0ff921ed988b627e8e54de47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x_cl, T_alpha_cl, T_beta_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga8c582a0f0ff921ed988b627e8e54de47.html#ga8c582a0f0ff921ed988b627e8e54de47">poisson_log_glm_lpmf</a> (const T_y_cl &amp;y, const T_x_cl &amp;x, const T_alpha_cl &amp;alpha, const T_beta_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga8c582a0f0ff921ed988b627e8e54de47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Poisson distribution and log link function.  <br /></td></tr>
<tr class="separator:ga8c582a0f0ff921ed988b627e8e54de47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6e7e62c68ef3bf00be621c40df533f7"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_log_rate_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_log_rate_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_log_rate_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae6e7e62c68ef3bf00be621c40df533f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_log_rate_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae6e7e62c68ef3bf00be621c40df533f7.html#gae6e7e62c68ef3bf00be621c40df533f7">poisson_log_lpmf</a> (const T_n_cl &amp;n, const T_log_rate_cl &amp;alpha)</td></tr>
<tr class="memdesc:gae6e7e62c68ef3bf00be621c40df533f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Poisson log distribution.  <br /></td></tr>
<tr class="separator:gae6e7e62c68ef3bf00be621c40df533f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9553d34b32b0c23306872195462eee31"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n_cl , typename T_rate_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_n_cl, T_rate_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_n_cl, T_rate_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga9553d34b32b0c23306872195462eee31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga9553d34b32b0c23306872195462eee31.html#ga9553d34b32b0c23306872195462eee31">poisson_lpmf</a> (const T_n_cl &amp;n, const T_rate_cl &amp;lambda)</td></tr>
<tr class="memdesc:ga9553d34b32b0c23306872195462eee31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Poisson distribution.  <br /></td></tr>
<tr class="separator:ga9553d34b32b0c23306872195462eee31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f2df4ad4beccd708310fab4aeb3d20"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a48f2df4ad4beccd708310fab4aeb3d20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a48f2df4ad4beccd708310fab4aeb3d20.html#a48f2df4ad4beccd708310fab4aeb3d20">prod</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a48f2df4ad4beccd708310fab4aeb3d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates product of given kernel generator expression elements.  <br /></td></tr>
<tr class="separator:a48f2df4ad4beccd708310fab4aeb3d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2780693c029fdff1a99b174241625180"><td class="memTemplParams" colspan="2">template&lt;typename T_m , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_m &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2780693c029fdff1a99b174241625180"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2780693c029fdff1a99b174241625180.html#a2780693c029fdff1a99b174241625180">qr_Q</a> (T_m &amp;&amp;m)</td></tr>
<tr class="memdesc:a2780693c029fdff1a99b174241625180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orthogonal factor of the fat QR decomposition.  <br /></td></tr>
<tr class="separator:a2780693c029fdff1a99b174241625180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a8d3afa1afa08a5246f47a72f5e0347"><td class="memTemplParams" colspan="2">template&lt;typename T_m , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_m &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1a8d3afa1afa08a5246f47a72f5e0347"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1a8d3afa1afa08a5246f47a72f5e0347.html#a1a8d3afa1afa08a5246f47a72f5e0347">qr_R</a> (T_m &amp;&amp;m)</td></tr>
<tr class="memdesc:a1a8d3afa1afa08a5246f47a72f5e0347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orthogonal factor of the fat QR decomposition.  <br /></td></tr>
<tr class="separator:a1a8d3afa1afa08a5246f47a72f5e0347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3684e07cec93454cbcc4b84841b97825"><td class="memTemplParams" colspan="2">template&lt;typename T_m , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_m &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3684e07cec93454cbcc4b84841b97825"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3684e07cec93454cbcc4b84841b97825.html#a3684e07cec93454cbcc4b84841b97825">qr_thin_Q</a> (T_m &amp;&amp;m)</td></tr>
<tr class="memdesc:a3684e07cec93454cbcc4b84841b97825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orthogonal factor of the fat QR decomposition.  <br /></td></tr>
<tr class="separator:a3684e07cec93454cbcc4b84841b97825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15d522f70bff1dcae8c3029174cf27a"><td class="memTemplParams" colspan="2">template&lt;typename T_m , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_m &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa15d522f70bff1dcae8c3029174cf27a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa15d522f70bff1dcae8c3029174cf27a.html#aa15d522f70bff1dcae8c3029174cf27a">qr_thin_R</a> (T_m &amp;&amp;m)</td></tr>
<tr class="memdesc:aa15d522f70bff1dcae8c3029174cf27a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orthogonal factor of the thin QR decomposition.  <br /></td></tr>
<tr class="separator:aa15d522f70bff1dcae8c3029174cf27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a266242d0e44eb92a734faaa8a291fd"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4a266242d0e44eb92a734faaa8a291fd"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a266242d0e44eb92a734faaa8a291fd.html#a4a266242d0e44eb92a734faaa8a291fd">rank</a> (const T &amp;v, int s)</td></tr>
<tr class="memdesc:a4a266242d0e44eb92a734faaa8a291fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of components of v less than v[s].  <br /></td></tr>
<tr class="separator:a4a266242d0e44eb92a734faaa8a291fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24fd90c8278288b2545d7b815ce48b9a"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga24fd90c8278288b2545d7b815ce48b9a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga24fd90c8278288b2545d7b815ce48b9a.html#ga24fd90c8278288b2545d7b815ce48b9a">rayleigh_cdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga24fd90c8278288b2545d7b815ce48b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Rayleigh cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga24fd90c8278288b2545d7b815ce48b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga014dce391185d0870589394401b5e570"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga014dce391185d0870589394401b5e570"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga014dce391185d0870589394401b5e570.html#ga014dce391185d0870589394401b5e570">rayleigh_lccdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga014dce391185d0870589394401b5e570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Rayleigh log complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga014dce391185d0870589394401b5e570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c06d7aee92d4cf2da1baf6aae1a3230"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1c06d7aee92d4cf2da1baf6aae1a3230"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga1c06d7aee92d4cf2da1baf6aae1a3230.html#ga1c06d7aee92d4cf2da1baf6aae1a3230">rayleigh_lcdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga1c06d7aee92d4cf2da1baf6aae1a3230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Rayleigh log cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga1c06d7aee92d4cf2da1baf6aae1a3230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga57652d7c59a9813457f972c48aad0933"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga57652d7c59a9813457f972c48aad0933"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga57652d7c59a9813457f972c48aad0933.html#ga57652d7c59a9813457f972c48aad0933">rayleigh_lpdf</a> (const T_y_cl &amp;y, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga57652d7c59a9813457f972c48aad0933"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an Rayleigh density for y with the specified scale parameter.  <br /></td></tr>
<tr class="separator:ga57652d7c59a9813457f972c48aad0933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bbe5a508d5789497afc2cbd03f8004c"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; T &gt;, <a class="el" href="structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; T &gt;, <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3bbe5a508d5789497afc2cbd03f8004c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3bbe5a508d5789497afc2cbd03f8004c.html#ga3bbe5a508d5789497afc2cbd03f8004c">rep_array</a> (const <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="memdesc:ga3bbe5a508d5789497afc2cbd03f8004c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> representing an array by replicating the input value.  <br /></td></tr>
<tr class="separator:ga3bbe5a508d5789497afc2cbd03f8004c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e2c7f71203a6ba2b93d5372ed6cf01e"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__cl__types_gaf18202a28f3c86c16368f08c04f6532d.html#gaf18202a28f3c86c16368f08c04f6532d">require_matrix_cl_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e2c7f71203a6ba2b93d5372ed6cf01e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga5e2c7f71203a6ba2b93d5372ed6cf01e.html#ga5e2c7f71203a6ba2b93d5372ed6cf01e">rep_matrix</a> (const <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &amp;x, int n, int m)</td></tr>
<tr class="memdesc:ga5e2c7f71203a6ba2b93d5372ed6cf01e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> by replicating the given value of arithmetic type.  <br /></td></tr>
<tr class="separator:ga5e2c7f71203a6ba2b93d5372ed6cf01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f19ec991d6f0ed60695ef33003868d"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga78f19ec991d6f0ed60695ef33003868d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga78f19ec991d6f0ed60695ef33003868d.html#ga78f19ec991d6f0ed60695ef33003868d">rep_matrix</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; T &gt; &amp;x, int m)</td></tr>
<tr class="memdesc:ga78f19ec991d6f0ed60695ef33003868d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> by replicating the input vector or row_vector.  <br /></td></tr>
<tr class="separator:ga78f19ec991d6f0ed60695ef33003868d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbac6d303d27c8ee22511862dce6c565"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; T &gt;, <a class="el" href="structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; T &gt;, <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabbac6d303d27c8ee22511862dce6c565"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gabbac6d303d27c8ee22511862dce6c565.html#gabbac6d303d27c8ee22511862dce6c565">rep_row_vector</a> (const <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="memdesc:gabbac6d303d27c8ee22511862dce6c565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> representing a row vector by replicating the input value.  <br /></td></tr>
<tr class="separator:gabbac6d303d27c8ee22511862dce6c565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd9fbe441671cf2a2f88cd3e8d9b8ca8"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; T &gt;, <a class="el" href="structstan_1_1math_1_1conjunction.html">math::conjunction</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; T &gt;, <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabd9fbe441671cf2a2f88cd3e8d9b8ca8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gabd9fbe441671cf2a2f88cd3e8d9b8ca8.html#gabd9fbe441671cf2a2f88cd3e8d9b8ca8">rep_vector</a> (const <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;x, int n)</td></tr>
<tr class="memdesc:gabd9fbe441671cf2a2f88cd3e8d9b8ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> representing a vector by replicating the input value.  <br /></td></tr>
<tr class="separator:gabd9fbe441671cf2a2f88cd3e8d9b8ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab410d6bac0f13c2db48a05491f17e47c"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab410d6bac0f13c2db48a05491f17e47c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab410d6bac0f13c2db48a05491f17e47c.html#ab410d6bac0f13c2db48a05491f17e47c">reverse</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:ab410d6bac0f13c2db48a05491f17e47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reversed view into the specified vector or row vector.  <br /></td></tr>
<tr class="separator:ab410d6bac0f13c2db48a05491f17e47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80392ae5670adea53e79770aa29c816a"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:ga80392ae5670adea53e79770aa29c816a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga80392ae5670adea53e79770aa29c816a.html#ga80392ae5670adea53e79770aa29c816a">row</a> (T_x &amp;&amp;x, size_t j)</td></tr>
<tr class="memdesc:ga80392ae5670adea53e79770aa29c816a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified row of the specified kernel generator expression using start-at-1 indexing.  <br /></td></tr>
<tr class="separator:ga80392ae5670adea53e79770aa29c816a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d2a437bd1589a69547c959adda767f5"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3d2a437bd1589a69547c959adda767f5"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga3d2a437bd1589a69547c959adda767f5.html#ga3d2a437bd1589a69547c959adda767f5">rows</a> (const T_x &amp;x)</td></tr>
<tr class="memdesc:ga3d2a437bd1589a69547c959adda767f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of rows in the specified kernel generator expression.  <br /></td></tr>
<tr class="separator:ga3d2a437bd1589a69547c959adda767f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505bfc1d8164c6ab561fe30088869296"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a505bfc1d8164c6ab561fe30088869296"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a505bfc1d8164c6ab561fe30088869296.html#a505bfc1d8164c6ab561fe30088869296">rows_dot_product</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a505bfc1d8164c6ab561fe30088869296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of rows of the specified matrices.  <br /></td></tr>
<tr class="separator:a505bfc1d8164c6ab561fe30088869296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fa659f7ee2c514a95d79d5f22c337c"><td class="memTemplParams" colspan="2">template&lt;typename T_a , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_a &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a24fa659f7ee2c514a95d79d5f22c337c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a24fa659f7ee2c514a95d79d5f22c337c.html#a24fa659f7ee2c514a95d79d5f22c337c">rows_dot_self</a> (T_a &amp;&amp;a)</td></tr>
<tr class="memdesc:a24fa659f7ee2c514a95d79d5f22c337c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each row of a matrix with itself.  <br /></td></tr>
<tr class="separator:a24fa659f7ee2c514a95d79d5f22c337c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga912f7b32021ce895e66e39fd448bf613"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_dof_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_dof_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga912f7b32021ce895e66e39fd448bf613"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga912f7b32021ce895e66e39fd448bf613.html#ga912f7b32021ce895e66e39fd448bf613">scaled_inv_chi_square_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu, const T_scale_cl &amp;s)</td></tr>
<tr class="memdesc:ga912f7b32021ce895e66e39fd448bf613"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a scaled inverse chi-squared density for y with the specified degrees of freedom parameter and scale parameter.  <br /></td></tr>
<tr class="separator:ga912f7b32021ce895e66e39fd448bf613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50e43583115511ae33ca69c4b4c7ab2"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae50e43583115511ae33ca69c4b4c7ab2"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae50e43583115511ae33ca69c4b4c7ab2.html#ae50e43583115511ae33ca69c4b4c7ab2">sd</a> (const T &amp;a)</td></tr>
<tr class="memdesc:ae50e43583115511ae33ca69c4b4c7ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unbiased sample standard deviation of the coefficients in the specified std vector, column vector, row vector, or matrix.  <br /></td></tr>
<tr class="separator:ae50e43583115511ae33ca69c4b4c7ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d39ed84d314b4ac918e64818f79469"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a69d39ed84d314b4ac918e64818f79469"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a69d39ed84d314b4ac918e64818f79469.html#a69d39ed84d314b4ac918e64818f79469">segment</a> (T_x &amp;&amp;x, size_t i, size_t n)</td></tr>
<tr class="memdesc:a69d39ed84d314b4ac918e64818f79469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a row/column vector starting from the specified element - 1 of the specified row/column vector.  <br /></td></tr>
<tr class="separator:a69d39ed84d314b4ac918e64818f79469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490231ac3d0382d97667cc0711f5b3af"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a490231ac3d0382d97667cc0711f5b3af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a490231ac3d0382d97667cc0711f5b3af.html#a490231ac3d0382d97667cc0711f5b3af">sign</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a490231ac3d0382d97667cc0711f5b3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns signs of the arguments.  <br /></td></tr>
<tr class="separator:a490231ac3d0382d97667cc0711f5b3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf82cac3bdccc9b64e7a55a8bd47880a7"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf82cac3bdccc9b64e7a55a8bd47880a7"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gaf82cac3bdccc9b64e7a55a8bd47880a7.html#gaf82cac3bdccc9b64e7a55a8bd47880a7">size</a> (const T &amp;m)</td></tr>
<tr class="memdesc:gaf82cac3bdccc9b64e7a55a8bd47880a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size (number of the elements) of a <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code> or <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;<a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;T&gt;&gt;</code>.  <br /></td></tr>
<tr class="separator:gaf82cac3bdccc9b64e7a55a8bd47880a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4e2c50dc4b8dbf53e8f11b2ae50450d"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad4e2c50dc4b8dbf53e8f11b2ae50450d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gad4e2c50dc4b8dbf53e8f11b2ae50450d.html#gad4e2c50dc4b8dbf53e8f11b2ae50450d">skew_double_exponential_cdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="memdesc:gad4e2c50dc4b8dbf53e8f11b2ae50450d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the skew double exponential cumulative density function.  <br /></td></tr>
<tr class="separator:gad4e2c50dc4b8dbf53e8f11b2ae50450d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66bd3722a04acc00a36998d1f4f7d593"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga66bd3722a04acc00a36998d1f4f7d593"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga66bd3722a04acc00a36998d1f4f7d593.html#ga66bd3722a04acc00a36998d1f4f7d593">skew_double_exponential_lccdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="memdesc:ga66bd3722a04acc00a36998d1f4f7d593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the skew double exponential cumulative density function.  <br /></td></tr>
<tr class="separator:ga66bd3722a04acc00a36998d1f4f7d593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a41630a4084c4b59479102e31c20d52"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga8a41630a4084c4b59479102e31c20d52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga8a41630a4084c4b59479102e31c20d52.html#ga8a41630a4084c4b59479102e31c20d52">skew_double_exponential_lcdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="memdesc:ga8a41630a4084c4b59479102e31c20d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the skew double exponential cumulative density function.  <br /></td></tr>
<tr class="separator:ga8a41630a4084c4b59479102e31c20d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadce8c6ede664f99d533a6324ac91a3c7"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_skewness_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadce8c6ede664f99d533a6324ac91a3c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_skewness_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gadce8c6ede664f99d533a6324ac91a3c7.html#gadce8c6ede664f99d533a6324ac91a3c7">skew_double_exponential_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_skewness_cl &amp;tau)</td></tr>
<tr class="memdesc:gadce8c6ede664f99d533a6324ac91a3c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the skew double exponential distribution.  <br /></td></tr>
<tr class="separator:gadce8c6ede664f99d533a6324ac91a3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e843ba6d42af1a8ce55a11fd850972"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_loc_cl , typename T_scale_cl , typename T_shape_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga09e843ba6d42af1a8ce55a11fd850972"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_loc_cl, T_scale_cl, T_shape_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga09e843ba6d42af1a8ce55a11fd850972.html#ga09e843ba6d42af1a8ce55a11fd850972">skew_normal_lpdf</a> (const T_y_cl &amp;y, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma, const T_shape_cl &amp;alpha)</td></tr>
<tr class="memdesc:ga09e843ba6d42af1a8ce55a11fd850972"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the skew normal density for the specified scalar(s) given the specified mean(s), deviation(s) and shape(s).  <br /></td></tr>
<tr class="separator:ga09e843ba6d42af1a8ce55a11fd850972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fd55e17bb95fe0962019c5f9825a97"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a29fd55e17bb95fe0962019c5f9825a97"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a29fd55e17bb95fe0962019c5f9825a97.html#a29fd55e17bb95fe0962019c5f9825a97">softmax</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a29fd55e17bb95fe0962019c5f9825a97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the softmax of the specified vector.  <br /></td></tr>
<tr class="separator:a29fd55e17bb95fe0962019c5f9825a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd03b3243ee5064d4cf410a390963b6"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aebd03b3243ee5064d4cf410a390963b6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aebd03b3243ee5064d4cf410a390963b6.html#aebd03b3243ee5064d4cf410a390963b6">sort_asc</a> (T &amp;&amp;input)</td></tr>
<tr class="memdesc:aebd03b3243ee5064d4cf410a390963b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the (row)vector in ascending order.  <br /></td></tr>
<tr class="separator:aebd03b3243ee5064d4cf410a390963b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a286fd588e6e95c58b8156aaf8e605"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a49a286fd588e6e95c58b8156aaf8e605"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a49a286fd588e6e95c58b8156aaf8e605.html#a49a286fd588e6e95c58b8156aaf8e605">sort_desc</a> (T &amp;&amp;input)</td></tr>
<tr class="memdesc:a49a286fd588e6e95c58b8156aaf8e605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort the (row)vector in ascending order.  <br /></td></tr>
<tr class="separator:a49a286fd588e6e95c58b8156aaf8e605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6950d3d0f5cc2d11bffe95fb0214c46"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad6950d3d0f5cc2d11bffe95fb0214c46"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad6950d3d0f5cc2d11bffe95fb0214c46.html#ad6950d3d0f5cc2d11bffe95fb0214c46">squared_distance</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="memdesc:ad6950d3d0f5cc2d11bffe95fb0214c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance.  <br /></td></tr>
<tr class="separator:ad6950d3d0f5cc2d11bffe95fb0214c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6809b2ab19bb25be5d2d3996f12b41f"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf6809b2ab19bb25be5d2d3996f12b41f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaf6809b2ab19bb25be5d2d3996f12b41f.html#gaf6809b2ab19bb25be5d2d3996f12b41f">std_normal_cdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="memdesc:gaf6809b2ab19bb25be5d2d3996f12b41f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the standard normal cumulative distribution function.  <br /></td></tr>
<tr class="separator:gaf6809b2ab19bb25be5d2d3996f12b41f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabeff7263315d228431625d22ff671de7"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gabeff7263315d228431625d22ff671de7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gabeff7263315d228431625d22ff671de7.html#gabeff7263315d228431625d22ff671de7">std_normal_lccdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="memdesc:gabeff7263315d228431625d22ff671de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log standard normal complementary cumulative distribution function.  <br /></td></tr>
<tr class="separator:gabeff7263315d228431625d22ff671de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85cd9947c3408ca4344662b885b17bed"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga85cd9947c3408ca4344662b885b17bed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga85cd9947c3408ca4344662b885b17bed.html#ga85cd9947c3408ca4344662b885b17bed">std_normal_lcdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="memdesc:ga85cd9947c3408ca4344662b885b17bed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log standard normal complementary cumulative distribution function.  <br /></td></tr>
<tr class="separator:ga85cd9947c3408ca4344662b885b17bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99fe4b661e6f91ecd647d1a2fc4b91fc"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga99fe4b661e6f91ecd647d1a2fc4b91fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga99fe4b661e6f91ecd647d1a2fc4b91fc.html#ga99fe4b661e6f91ecd647d1a2fc4b91fc">std_normal_lpdf</a> (const T_y_cl &amp;y)</td></tr>
<tr class="memdesc:ga99fe4b661e6f91ecd647d1a2fc4b91fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the normal density for the specified scalar(s) given a location of 0 and a scale of 1.  <br /></td></tr>
<tr class="separator:ga99fe4b661e6f91ecd647d1a2fc4b91fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52baf62a7ad07470a7e5879144aab8fd"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_dof_cl , typename T_loc_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga52baf62a7ad07470a7e5879144aab8fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_dof_cl, T_loc_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga52baf62a7ad07470a7e5879144aab8fd.html#ga52baf62a7ad07470a7e5879144aab8fd">student_t_lpdf</a> (const T_y_cl &amp;y, const T_dof_cl &amp;nu, const T_loc_cl &amp;mu, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga52baf62a7ad07470a7e5879144aab8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Student-t density for the given y, nu, mean, and scale parameter.  <br /></td></tr>
<tr class="separator:ga52baf62a7ad07470a7e5879144aab8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab003c1d58214fbb73fab106a86dfeb7"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:aab003c1d58214fbb73fab106a86dfeb7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab003c1d58214fbb73fab106a86dfeb7.html#aab003c1d58214fbb73fab106a86dfeb7">sub_col</a> (T_x &amp;&amp;x, size_t i, size_t j, size_t nrows)</td></tr>
<tr class="memdesc:aab003c1d58214fbb73fab106a86dfeb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a 1 x ncols subrow starting at (i-1, j-1).  <br /></td></tr>
<tr class="separator:aab003c1d58214fbb73fab106a86dfeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe43aa6192833ef6d978a53453cbfb6"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_nonscalar_prim_or_rev_kernel_expression_t&lt;T_x&gt;&gt; </td></tr>
<tr class="memitem:a1fe43aa6192833ef6d978a53453cbfb6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1fe43aa6192833ef6d978a53453cbfb6.html#a1fe43aa6192833ef6d978a53453cbfb6">sub_row</a> (T_x &amp;&amp;x, size_t i, size_t j, size_t ncols)</td></tr>
<tr class="memdesc:a1fe43aa6192833ef6d978a53453cbfb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a 1 x ncols subrow starting at (i-1, j-1).  <br /></td></tr>
<tr class="separator:a1fe43aa6192833ef6d978a53453cbfb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab2f60b73ec6870212c8b4e4ceed0038"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aab2f60b73ec6870212c8b4e4ceed0038"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab2f60b73ec6870212c8b4e4ceed0038.html#aab2f60b73ec6870212c8b4e4ceed0038">symmetrize_from_lower_tri</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:aab2f60b73ec6870212c8b4e4ceed0038"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a symmetric matrix using elements from the upper triangular part of the input matrix.  <br /></td></tr>
<tr class="separator:aab2f60b73ec6870212c8b4e4ceed0038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98546423dee6fab291c2cdfcbb6be64c"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a98546423dee6fab291c2cdfcbb6be64c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a98546423dee6fab291c2cdfcbb6be64c.html#a98546423dee6fab291c2cdfcbb6be64c">symmetrize_from_upper_tri</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:a98546423dee6fab291c2cdfcbb6be64c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a symmetric matrix using elements from the lower triangular part of the input matrix.  <br /></td></tr>
<tr class="separator:a98546423dee6fab291c2cdfcbb6be64c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b9d342c24240d2459e5d661c0aa88e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a84b9d342c24240d2459e5d661c0aa88e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a84b9d342c24240d2459e5d661c0aa88e.html#a84b9d342c24240d2459e5d661c0aa88e">tail</a> (T_x &amp;&amp;x, size_t n)</td></tr>
<tr class="memdesc:a84b9d342c24240d2459e5d661c0aa88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a vector or row vector (same as input) from the back of the specified vector or row vector.  <br /></td></tr>
<tr class="separator:a84b9d342c24240d2459e5d661c0aa88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e574b023d8906e454fc0304a34855ca"><td class="memTemplParams" colspan="2">template&lt;typename T_A , typename  = require_all_kernel_expressions_and_none_scalar_t&lt;T_A&gt;&gt; </td></tr>
<tr class="memitem:a5e574b023d8906e454fc0304a34855ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; typename std::decay_t&lt; T_A &gt;::Scalar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5e574b023d8906e454fc0304a34855ca.html#a5e574b023d8906e454fc0304a34855ca">tcrossprod</a> (T_A &amp;&amp;A)</td></tr>
<tr class="memdesc:a5e574b023d8906e454fc0304a34855ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of post-multiplying a matrix by its own transpose.  <br /></td></tr>
<tr class="separator:a5e574b023d8906e454fc0304a34855ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccde2dd41ea6e10cce3f5fd53dbfa0ea"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaccde2dd41ea6e10cce3f5fd53dbfa0ea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaccde2dd41ea6e10cce3f5fd53dbfa0ea.html#gaccde2dd41ea6e10cce3f5fd53dbfa0ea">to_array_1d</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:gaccde2dd41ea6e10cce3f5fd53dbfa0ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns input matrix reshaped into a vector.  <br /></td></tr>
<tr class="separator:gaccde2dd41ea6e10cce3f5fd53dbfa0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58346dcff1afcdf893e0c0e2ab7fbe3"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae58346dcff1afcdf893e0c0e2ab7fbe3"><td class="memTemplItemLeft" align="right" valign="top">T_x&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gae58346dcff1afcdf893e0c0e2ab7fbe3.html#gae58346dcff1afcdf893e0c0e2ab7fbe3">to_array_2d</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:gae58346dcff1afcdf893e0c0e2ab7fbe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns input matrix converted into a nested std vector.  <br /></td></tr>
<tr class="separator:gae58346dcff1afcdf893e0c0e2ab7fbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aabc784b5f56edb079f21a48efdad54"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0aabc784b5f56edb079f21a48efdad54"><td class="memTemplItemLeft" align="right" valign="top">T_x&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0aabc784b5f56edb079f21a48efdad54.html#ga0aabc784b5f56edb079f21a48efdad54">to_matrix</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:ga0aabc784b5f56edb079f21a48efdad54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns input matrix.  <br /></td></tr>
<tr class="separator:ga0aabc784b5f56edb079f21a48efdad54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b7fcad13ba2082e765d6ecf6deefbc"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a28b7fcad13ba2082e765d6ecf6deefbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a28b7fcad13ba2082e765d6ecf6deefbc.html#a28b7fcad13ba2082e765d6ecf6deefbc">to_matrix</a> (const T_x &amp;x, int m, int n)</td></tr>
<tr class="memdesc:a28b7fcad13ba2082e765d6ecf6deefbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of a vector or matrix in column-major order with the specified number of rows and columns.  <br /></td></tr>
<tr class="separator:a28b7fcad13ba2082e765d6ecf6deefbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9020fbbcd9293dbf728d60c3cb7d6917"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9020fbbcd9293dbf728d60c3cb7d6917"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9020fbbcd9293dbf728d60c3cb7d6917.html#a9020fbbcd9293dbf728d60c3cb7d6917">to_matrix</a> (const T_x &amp;x, int m, int n, bool col_major) -&gt; decltype(to_matrix(x, m, n))</td></tr>
<tr class="memdesc:a9020fbbcd9293dbf728d60c3cb7d6917"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of the vector or matrix in column-major or row major order with the specified number of rows and columns.  <br /></td></tr>
<tr class="separator:a9020fbbcd9293dbf728d60c3cb7d6917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08a3715205cf6c1564a87de73c13c22a"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga08a3715205cf6c1564a87de73c13c22a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga08a3715205cf6c1564a87de73c13c22a.html#ga08a3715205cf6c1564a87de73c13c22a">to_row_vector</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:ga08a3715205cf6c1564a87de73c13c22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns input matrix reshaped into a row vector.  <br /></td></tr>
<tr class="separator:ga08a3715205cf6c1564a87de73c13c22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0026608053df548f73f9556ffa94dc03"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7effde0ee735fbb4b95bacac8bea2c78.html#ga7effde0ee735fbb4b95bacac8bea2c78">require_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0026608053df548f73f9556ffa94dc03"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0026608053df548f73f9556ffa94dc03.html#ga0026608053df548f73f9556ffa94dc03">to_vector</a> (T_x &amp;&amp;x)</td></tr>
<tr class="memdesc:ga0026608053df548f73f9556ffa94dc03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns input matrix reshaped into a vector.  <br /></td></tr>
<tr class="separator:ga0026608053df548f73f9556ffa94dc03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65be2dfbaae8fba50ce9873f4cff1647"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a65be2dfbaae8fba50ce9873f4cff1647"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a65be2dfbaae8fba50ce9873f4cff1647.html#a65be2dfbaae8fba50ce9873f4cff1647">trace</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a65be2dfbaae8fba50ce9873f4cff1647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates trace (sum of diagonal) of given kernel generator expression.  <br /></td></tr>
<tr class="separator:a65be2dfbaae8fba50ce9873f4cff1647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa57df18629a507dddf44e3c2c5fdddce"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa57df18629a507dddf44e3c2c5fdddce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaa57df18629a507dddf44e3c2c5fdddce.html#gaa57df18629a507dddf44e3c2c5fdddce">uniform_cdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gaa57df18629a507dddf44e3c2c5fdddce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the uniform cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gaa57df18629a507dddf44e3c2c5fdddce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a645c422b583574a641e7aacafdac70"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0a645c422b583574a641e7aacafdac70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0a645c422b583574a641e7aacafdac70.html#ga0a645c422b583574a641e7aacafdac70">uniform_lccdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga0a645c422b583574a641e7aacafdac70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log uniform complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga0a645c422b583574a641e7aacafdac70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62cdd868dd6647ab0ca6ea0cce3c76bc"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_low_cl , typename T_high_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga62cdd868dd6647ab0ca6ea0cce3c76bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga62cdd868dd6647ab0ca6ea0cce3c76bc.html#ga62cdd868dd6647ab0ca6ea0cce3c76bc">uniform_lcdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga62cdd868dd6647ab0ca6ea0cce3c76bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log uniform cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga62cdd868dd6647ab0ca6ea0cce3c76bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04339e808a990b203d278764668bf813"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_low_cl , typename T_high_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga04339e808a990b203d278764668bf813"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_low_cl, T_high_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga04339e808a990b203d278764668bf813.html#ga04339e808a990b203d278764668bf813">uniform_lpdf</a> (const T_y_cl &amp;y, const T_low_cl &amp;alpha, const T_high_cl &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga04339e808a990b203d278764668bf813"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a uniform density for the given y, lower, and upper bound.  <br /></td></tr>
<tr class="separator:ga04339e808a990b203d278764668bf813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3720810fa541e8a4b88e0b3f2f2b3a56"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3720810fa541e8a4b88e0b3f2f2b3a56"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3720810fa541e8a4b88e0b3f2f2b3a56.html#a3720810fa541e8a4b88e0b3f2f2b3a56">variance</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a3720810fa541e8a4b88e0b3f2f2b3a56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample variance of the <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a> matrix Raise domain error if size is not greater than zero.  <br /></td></tr>
<tr class="separator:a3720810fa541e8a4b88e0b3f2f2b3a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fe7af31180b175d4781aff1ea3d834c"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1fe7af31180b175d4781aff1ea3d834c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga1fe7af31180b175d4781aff1ea3d834c.html#ga1fe7af31180b175d4781aff1ea3d834c">weibull_cdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:ga1fe7af31180b175d4781aff1ea3d834c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weibull cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga1fe7af31180b175d4781aff1ea3d834c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac04a465e4b5185102599824a1fe96ea"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaac04a465e4b5185102599824a1fe96ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaac04a465e4b5185102599824a1fe96ea.html#gaac04a465e4b5185102599824a1fe96ea">weibull_lccdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gaac04a465e4b5185102599824a1fe96ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weibull log cumulative complementary distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gaac04a465e4b5185102599824a1fe96ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1477c0a3bc8847863337e0acb2b9cb8"><td class="memTemplParams" colspan="2">template&lt;typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac1477c0a3bc8847863337e0acb2b9cb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gac1477c0a3bc8847863337e0acb2b9cb8.html#gac1477c0a3bc8847863337e0acb2b9cb8">weibull_lcdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gac1477c0a3bc8847863337e0acb2b9cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the weibull log cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gac1477c0a3bc8847863337e0acb2b9cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8f8507ee479b6cce5492bc736a6fcc4"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y_cl , typename T_shape_cl , typename T_scale_cl , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad8f8507ee479b6cce5492bc736a6fcc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y_cl, T_shape_cl, T_scale_cl &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gad8f8507ee479b6cce5492bc736a6fcc4.html#gad8f8507ee479b6cce5492bc736a6fcc4">weibull_lpdf</a> (const T_y_cl &amp;y, const T_shape_cl &amp;alpha, const T_scale_cl &amp;sigma)</td></tr>
<tr class="memdesc:gad8f8507ee479b6cce5492bc736a6fcc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Weibull log probability density for the given location and scale.  <br /></td></tr>
<tr class="separator:gad8f8507ee479b6cce5492bc736a6fcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec09b5ad85be5223ff11bc9682bc87a"><td class="memTemplParams" colspan="2">template&lt;bool need_Q = true&gt; </td></tr>
<tr class="memitem:a9ec09b5ad85be5223ff11bc9682bc87a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ec09b5ad85be5223ff11bc9682bc87a.html#a9ec09b5ad85be5223ff11bc9682bc87a">qr_decomposition_cl</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;A, <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;Q, <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;R, int r=100)</td></tr>
<tr class="memdesc:a9ec09b5ad85be5223ff11bc9682bc87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates QR decomposition of A using the block Householder algorithm.  <br /></td></tr>
<tr class="separator:a9ec09b5ad85be5223ff11bc9682bc87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd53843003a92ff87e77dc318262f3f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1cd53843003a92ff87e77dc318262f3f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1cd53843003a92ff87e77dc318262f3f.html#a1cd53843003a92ff87e77dc318262f3f">acos</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a1cd53843003a92ff87e77dc318262f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a0225b71faa7dc05c3fd41e70dc6cc34b.html#a0225b71faa7dc05c3fd41e70dc6cc34b">acos()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt; in radians.  <br /></td></tr>
<tr class="separator:a1cd53843003a92ff87e77dc318262f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a8f4db5ffe08f8680eebe07311bdbbb"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6a8f4db5ffe08f8680eebe07311bdbbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6a8f4db5ffe08f8680eebe07311bdbbb.html#a6a8f4db5ffe08f8680eebe07311bdbbb">acosh</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a6a8f4db5ffe08f8680eebe07311bdbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a1f4aba0a2fc965c0abc4ea84508a09e3.html#a1f4aba0a2fc965c0abc4ea84508a09e3">acosh()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt; in radians.  <br /></td></tr>
<tr class="separator:a6a8f4db5ffe08f8680eebe07311bdbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc6edb6b52ed3dc3920a17744c4d92d"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5dc6edb6b52ed3dc3920a17744c4d92d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5dc6edb6b52ed3dc3920a17744c4d92d.html#a5dc6edb6b52ed3dc3920a17744c4d92d">add</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a5dc6edb6b52ed3dc3920a17744c4d92d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two reverse mode matrices and/or kernel generator expressions.  <br /></td></tr>
<tr class="separator:a5dc6edb6b52ed3dc3920a17744c4d92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1835808a69fe7b739b99fc14d948462e"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1835808a69fe7b739b99fc14d948462e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1835808a69fe7b739b99fc14d948462e.html#a1835808a69fe7b739b99fc14d948462e">operator+</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="memdesc:a1835808a69fe7b739b99fc14d948462e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition of two reverse mode matrices and/or kernel generator expressions.  <br /></td></tr>
<tr class="separator:a1835808a69fe7b739b99fc14d948462e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af574b9c824ba2da7f03a056955a9e23d"><td class="memTemplParams" colspan="2">template&lt;typename T_m , typename T_a , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_m &gt; *  = nullptr, <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_a &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_m, T_a &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af574b9c824ba2da7f03a056955a9e23d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af574b9c824ba2da7f03a056955a9e23d.html#af574b9c824ba2da7f03a056955a9e23d">add_diag</a> (const T_m &amp;mat, const T_a &amp;to_add)</td></tr>
<tr class="memdesc:af574b9c824ba2da7f03a056955a9e23d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matrix with values added along the main diagonal.  <br /></td></tr>
<tr class="separator:af574b9c824ba2da7f03a056955a9e23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a58512559de4e007a3827924271604f"><td class="memTemplParams" colspan="2">template&lt;typename... T_results&gt; </td></tr>
<tr class="memitem:a2a58512559de4e007a3827924271604f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1adjoint__results__cl.html">adjoint_results_cl</a>&lt; T_results... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2a58512559de4e007a3827924271604f.html#a2a58512559de4e007a3827924271604f">adjoint_results</a> (T_results &amp;&amp;... <a class="el" href="group__opencl__kernel__generator_ga25bbfbed551e80e97d55ca836e1f2521.html#ga25bbfbed551e80e97d55ca836e1f2521">results</a>)</td></tr>
<tr class="memdesc:a2a58512559de4e007a3827924271604f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deduces types for constructing <code><a class="el" href="classstan_1_1math_1_1adjoint__results__cl.html" title="Represents results that are adjoints of vars in kernel generrator expressions.">adjoint_results_cl</a></code> object.  <br /></td></tr>
<tr class="separator:a2a58512559de4e007a3827924271604f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed00be6d5cc7c9f8cdf3078f3f6b505d"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aed00be6d5cc7c9f8cdf3078f3f6b505d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aed00be6d5cc7c9f8cdf3078f3f6b505d.html#aed00be6d5cc7c9f8cdf3078f3f6b505d">append_col</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:aed00be6d5cc7c9f8cdf3078f3f6b505d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of appending the second argument matrix after the first argument matrix, that is, putting them side by side, with the first matrix followed by the second matrix.  <br /></td></tr>
<tr class="separator:aed00be6d5cc7c9f8cdf3078f3f6b505d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ba71da1122a44dbadb42bcb856d5d2"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a71ba71da1122a44dbadb42bcb856d5d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a71ba71da1122a44dbadb42bcb856d5d2.html#a71ba71da1122a44dbadb42bcb856d5d2">append_row</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a71ba71da1122a44dbadb42bcb856d5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking the rows of the first argument matrix on top of the second argument matrix.  <br /></td></tr>
<tr class="separator:a71ba71da1122a44dbadb42bcb856d5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95daff22a06bf3668baee75c287e92a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad95daff22a06bf3668baee75c287e92a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad95daff22a06bf3668baee75c287e92a.html#ad95daff22a06bf3668baee75c287e92a">as_column_vector_or_scalar</a> (const T &amp;m)</td></tr>
<tr class="memdesc:ad95daff22a06bf3668baee75c287e92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts kernel generator expression row or column vector to a column vector.  <br /></td></tr>
<tr class="separator:ad95daff22a06bf3668baee75c287e92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f2a1bb2756358f86655def67943df3"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa5f2a1bb2756358f86655def67943df3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa5f2a1bb2756358f86655def67943df3.html#aa5f2a1bb2756358f86655def67943df3">asin</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aa5f2a1bb2756358f86655def67943df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ad7b48158d54565231ca3a7328c11eb21.html#ad7b48158d54565231ca3a7328c11eb21">asin()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt; in radians.  <br /></td></tr>
<tr class="separator:aa5f2a1bb2756358f86655def67943df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5911dcf293fcec075e11354ad29779"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aba5911dcf293fcec075e11354ad29779"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aba5911dcf293fcec075e11354ad29779.html#aba5911dcf293fcec075e11354ad29779">asinh</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aba5911dcf293fcec075e11354ad29779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a4a1a957be54c795baae42c74c9e53149.html#a4a1a957be54c795baae42c74c9e53149">asinh()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt; in radians.  <br /></td></tr>
<tr class="separator:aba5911dcf293fcec075e11354ad29779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44f1a129713c52383bdd3491f87813ba"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a44f1a129713c52383bdd3491f87813ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a44f1a129713c52383bdd3491f87813ba.html#a44f1a129713c52383bdd3491f87813ba">atan</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a44f1a129713c52383bdd3491f87813ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a83986a2a7953042a141b6d808763bd88.html#a83986a2a7953042a141b6d808763bd88">atan()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt; in radians.  <br /></td></tr>
<tr class="separator:a44f1a129713c52383bdd3491f87813ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad540fa7b14096cc0a35e0371255926b"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aad540fa7b14096cc0a35e0371255926b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aad540fa7b14096cc0a35e0371255926b.html#aad540fa7b14096cc0a35e0371255926b">atanh</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aad540fa7b14096cc0a35e0371255926b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a2cabe7a1ea8293228faa9e77f6eb1203.html#a2cabe7a1ea8293228faa9e77f6eb1203" title="Return inverse hyperbolic tangent of specified value.">atanh()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt; in radians.  <br /></td></tr>
<tr class="separator:aad540fa7b14096cc0a35e0371255926b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c2af773527d49db469e8353dd8c0a0"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab8c2af773527d49db469e8353dd8c0a0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab8c2af773527d49db469e8353dd8c0a0.html#ab8c2af773527d49db469e8353dd8c0a0">beta</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:ab8c2af773527d49db469e8353dd8c0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise <code><a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed" title="Return fvar with the beta function applied to the specified arguments and its gradient.">beta()</a></code> on two input kernel generator expression.  <br /></td></tr>
<tr class="separator:ab8c2af773527d49db469e8353dd8c0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8754931c24e20cda18a5acf2486a53"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8d8754931c24e20cda18a5acf2486a53"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8d8754931c24e20cda18a5acf2486a53.html#a8d8754931c24e20cda18a5acf2486a53">block</a> (const T &amp;m, size_t i, size_t j, size_t nrows, size_t ncols)</td></tr>
<tr class="memdesc:a8d8754931c24e20cda18a5acf2486a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a nrows x ncols submatrix starting at (i-1, j-1).  <br /></td></tr>
<tr class="separator:a8d8754931c24e20cda18a5acf2486a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99097f3129bdb95c62c1a73d7891508c"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a99097f3129bdb95c62c1a73d7891508c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a99097f3129bdb95c62c1a73d7891508c.html#a99097f3129bdb95c62c1a73d7891508c">cbrt</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a99097f3129bdb95c62c1a73d7891508c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a6e56cfe7810faca3dd8a2326affacd26.html#a6e56cfe7810faca3dd8a2326affacd26" title="Return cube root of specified argument.">cbrt()</a></code> of the input <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;<a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;double&gt;&gt;</code>.  <br /></td></tr>
<tr class="separator:a99097f3129bdb95c62c1a73d7891508c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c52899b90beae190b7c5f6036a0313"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a86c52899b90beae190b7c5f6036a0313"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a86c52899b90beae190b7c5f6036a0313.html#a86c52899b90beae190b7c5f6036a0313">ceil</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a86c52899b90beae190b7c5f6036a0313"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ae0742bb5eb74b836b005ef099cffc502.html#ae0742bb5eb74b836b005ef099cffc502">ceil()</a></code> of the specified variable.  <br /></td></tr>
<tr class="separator:a86c52899b90beae190b7c5f6036a0313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fad2d79365bad51a5d06eefaf89adef"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7fad2d79365bad51a5d06eefaf89adef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7fad2d79365bad51a5d06eefaf89adef.html#a7fad2d79365bad51a5d06eefaf89adef">cholesky_decompose</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a7fad2d79365bad51a5d06eefaf89adef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric reverse mode matrix on the OpenCL device.  <br /></td></tr>
<tr class="separator:a7fad2d79365bad51a5d06eefaf89adef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03360c936203cb15e2d37e2f552fc542"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a03360c936203cb15e2d37e2f552fc542"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a03360c936203cb15e2d37e2f552fc542.html#a03360c936203cb15e2d37e2f552fc542">columns_dot_product</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a03360c936203cb15e2d37e2f552fc542"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of columns of the specified matrices.  <br /></td></tr>
<tr class="separator:a03360c936203cb15e2d37e2f552fc542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af781288a7f645993041441ab7635512f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af781288a7f645993041441ab7635512f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af781288a7f645993041441ab7635512f.html#af781288a7f645993041441ab7635512f">columns_dot_self</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:af781288a7f645993041441ab7635512f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each column of a matrix with itself.  <br /></td></tr>
<tr class="separator:af781288a7f645993041441ab7635512f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab431995c7f7358fa179e6c11d3b65fe"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_lb , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_x, T_lb &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_x, T_lb &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_x, T_lb &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aab431995c7f7358fa179e6c11d3b65fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab431995c7f7358fa179e6c11d3b65fe.html#aab431995c7f7358fa179e6c11d3b65fe">lb_constrain</a> (T_x &amp;&amp;x, T_lb &amp;&amp;lb)</td></tr>
<tr class="memdesc:aab431995c7f7358fa179e6c11d3b65fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-bounded value for the specified unconstrained input and specified lower bound.  <br /></td></tr>
<tr class="separator:aab431995c7f7358fa179e6c11d3b65fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7428d8b23a8a61a2bd1b051447cd0530"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_lb , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_x, T_lb &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_x, T_lb &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_x, T_lb &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7428d8b23a8a61a2bd1b051447cd0530"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7428d8b23a8a61a2bd1b051447cd0530.html#a7428d8b23a8a61a2bd1b051447cd0530">lb_constrain</a> (T_x &amp;&amp;x, T_lb &amp;&amp;lb, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;lp)</td></tr>
<tr class="memdesc:a7428d8b23a8a61a2bd1b051447cd0530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-bounded value for the specified unconstrained input and specified lower bound.  <br /></td></tr>
<tr class="separator:a7428d8b23a8a61a2bd1b051447cd0530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bfa1a4571f07a6a3456208e3ee827f"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_lb , typename T_ub , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_x, T_lb, T_ub &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_x, T_lb, T_ub &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_x, T_lb, T_ub &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a08bfa1a4571f07a6a3456208e3ee827f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a08bfa1a4571f07a6a3456208e3ee827f.html#a08bfa1a4571f07a6a3456208e3ee827f">lub_constrain</a> (T_x &amp;&amp;x, T_lb &amp;&amp;lb, T_ub &amp;&amp;ub)</td></tr>
<tr class="memdesc:a08bfa1a4571f07a6a3456208e3ee827f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bounded value for the specified unconstrained input and specified bounds.  <br /></td></tr>
<tr class="separator:a08bfa1a4571f07a6a3456208e3ee827f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ed8255380a5d0d44cc9f53f93b2387"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_lb , typename T_ub , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_x, T_lb, T_ub &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_x, T_lb, T_ub &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_x, T_lb, T_ub &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad0ed8255380a5d0d44cc9f53f93b2387"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad0ed8255380a5d0d44cc9f53f93b2387.html#ad0ed8255380a5d0d44cc9f53f93b2387">lub_constrain</a> (T_x &amp;&amp;x, T_lb &amp;&amp;lb, T_ub &amp;&amp;ub, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;lp)</td></tr>
<tr class="memdesc:ad0ed8255380a5d0d44cc9f53f93b2387"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bounded value for the specified unconstrained input and specified bounds.  <br /></td></tr>
<tr class="separator:ad0ed8255380a5d0d44cc9f53f93b2387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc8c9108098ec9ce526fa27da1f43ce"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T, M, S &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T, M, S &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T, M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1fc8c9108098ec9ce526fa27da1f43ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1fc8c9108098ec9ce526fa27da1f43ce.html#a1fc8c9108098ec9ce526fa27da1f43ce">offset_multiplier_constrain</a> (T &amp;&amp;A, M &amp;&amp;mu, S &amp;&amp;sigma)</td></tr>
<tr class="memdesc:a1fc8c9108098ec9ce526fa27da1f43ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearly transformed value for the specified unconstrained input and specified offset and multiplier.  <br /></td></tr>
<tr class="separator:a1fc8c9108098ec9ce526fa27da1f43ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471cf18ed75018a82bb0aa070e89556d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T, M, S &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T, M, S &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T, M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a471cf18ed75018a82bb0aa070e89556d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a471cf18ed75018a82bb0aa070e89556d.html#a471cf18ed75018a82bb0aa070e89556d">offset_multiplier_constrain</a> (T &amp;&amp;A, M &amp;&amp;mu, S &amp;&amp;sigma, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;lp)</td></tr>
<tr class="memdesc:a471cf18ed75018a82bb0aa070e89556d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearly transformed value for the specified unconstrained input and specified offset and multiplier.  <br /></td></tr>
<tr class="separator:a471cf18ed75018a82bb0aa070e89556d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2fd45130d112cf79cfc3f3058a000e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_ub , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_x, T_ub &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_x, T_ub &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_x, T_ub &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ace2fd45130d112cf79cfc3f3058a000e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ace2fd45130d112cf79cfc3f3058a000e.html#ace2fd45130d112cf79cfc3f3058a000e">ub_constrain</a> (T_x &amp;&amp;x, T_ub &amp;&amp;ub)</td></tr>
<tr class="memdesc:ace2fd45130d112cf79cfc3f3058a000e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper-bounded value for the specified unconstrained input and specified upper bound.  <br /></td></tr>
<tr class="separator:ace2fd45130d112cf79cfc3f3058a000e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ab7af3f0ad94323df6a073571f5233"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_ub , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_x, T_ub &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_x, T_ub &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_x, T_ub &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a91ab7af3f0ad94323df6a073571f5233"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a91ab7af3f0ad94323df6a073571f5233.html#a91ab7af3f0ad94323df6a073571f5233">ub_constrain</a> (T_x &amp;&amp;x, T_ub &amp;&amp;ub, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;lp)</td></tr>
<tr class="memdesc:a91ab7af3f0ad94323df6a073571f5233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper-bounded value for the specified unconstrained input and specified upper bound.  <br /></td></tr>
<tr class="separator:a91ab7af3f0ad94323df6a073571f5233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43d73968bcf05a119a66ddaac1408f6"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac43d73968bcf05a119a66ddaac1408f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac43d73968bcf05a119a66ddaac1408f6.html#ac43d73968bcf05a119a66ddaac1408f6">unit_vector_constrain</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ac43d73968bcf05a119a66ddaac1408f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the free vector y.  <br /></td></tr>
<tr class="separator:ac43d73968bcf05a119a66ddaac1408f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3812d15f4141e69fdbc79b50d2e6ad8b"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3812d15f4141e69fdbc79b50d2e6ad8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3812d15f4141e69fdbc79b50d2e6ad8b.html#a3812d15f4141e69fdbc79b50d2e6ad8b">unit_vector_constrain</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;lp)</td></tr>
<tr class="memdesc:a3812d15f4141e69fdbc79b50d2e6ad8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the free vector y.  <br /></td></tr>
<tr class="separator:a3812d15f4141e69fdbc79b50d2e6ad8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0789d6a3951103d547f105a799180f7d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0789d6a3951103d547f105a799180f7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0789d6a3951103d547f105a799180f7d.html#ga0789d6a3951103d547f105a799180f7d">to_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:ga0789d6a3951103d547f105a799180f7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source var containing <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrices to destination var that has data stored on the OpenCL device.  <br /></td></tr>
<tr class="separator:ga0789d6a3951103d547f105a799180f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90b584aee1b254d84f7277c0091cd774"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga90b584aee1b254d84f7277c0091cd774"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga90b584aee1b254d84f7277c0091cd774.html#ga90b584aee1b254d84f7277c0091cd774">to_matrix_cl</a> (const std::vector&lt; <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &gt; &amp;a)</td></tr>
<tr class="memdesc:ga90b584aee1b254d84f7277c0091cd774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source std::vector of vars to a destination var that has data stored on the OpenCL device.  <br /></td></tr>
<tr class="separator:ga90b584aee1b254d84f7277c0091cd774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b768c5f90ad1a392ba7311103095fc2"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6b768c5f90ad1a392ba7311103095fc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga6b768c5f90ad1a392ba7311103095fc2.html#ga6b768c5f90ad1a392ba7311103095fc2">to_matrix_cl</a> (const T &amp;src)</td></tr>
<tr class="memdesc:ga6b768c5f90ad1a392ba7311103095fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix of vars to the destination matrix that is stored on the OpenCL device.  <br /></td></tr>
<tr class="separator:ga6b768c5f90ad1a392ba7311103095fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga244b9eabd30b04007c6acaa9a0a76ef9"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga244b9eabd30b04007c6acaa9a0a76ef9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga244b9eabd30b04007c6acaa9a0a76ef9.html#ga244b9eabd30b04007c6acaa9a0a76ef9">to_matrix_cl</a> (const std::vector&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:ga244b9eabd30b04007c6acaa9a0a76ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source vector of <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrices of vars to the destination matrix that is stored on the OpenCL device.  <br /></td></tr>
<tr class="separator:ga244b9eabd30b04007c6acaa9a0a76ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedf3e76a11e9efeae4a1215bfb67c8be"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T , <a class="el" href="group__var__types_ga29fde8e89258f50345408f2d23070d60.html#ga29fde8e89258f50345408f2d23070d60">require_var_vt</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>, T_dst &gt; *  = nullptr, <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaedf3e76a11e9efeae4a1215bfb67c8be"><td class="memTemplItemLeft" align="right" valign="top">T_dst&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaedf3e76a11e9efeae4a1215bfb67c8be.html#gaedf3e76a11e9efeae4a1215bfb67c8be">from_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:gaedf3e76a11e9efeae4a1215bfb67c8be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source var that has data stored on the OpenCL device to destination var containing <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix.  <br /></td></tr>
<tr class="separator:gaedf3e76a11e9efeae4a1215bfb67c8be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga016b4e7e4fd48ee3333c5c37507e3d01"><td class="memTemplParams" colspan="2">template&lt;typename T_dst , typename T , <a class="el" href="group__std__vector__types_ga177ca10358abdf201cabb12e8bdb2e91.html#ga177ca10358abdf201cabb12e8bdb2e91">require_std_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T_dst &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_dst &gt; &gt; *  = nullptr, <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga016b4e7e4fd48ee3333c5c37507e3d01"><td class="memTemplItemLeft" align="right" valign="top">T_dst&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga016b4e7e4fd48ee3333c5c37507e3d01.html#ga016b4e7e4fd48ee3333c5c37507e3d01">from_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:ga016b4e7e4fd48ee3333c5c37507e3d01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source var that has data stored on the OpenCL device to destination <code>std::vector</code> containing vars.  <br /></td></tr>
<tr class="separator:ga016b4e7e4fd48ee3333c5c37507e3d01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeefdbbf87e96786f8460982c80c5c06f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaeefdbbf87e96786f8460982c80c5c06f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_gaeefdbbf87e96786f8460982c80c5c06f.html#gaeefdbbf87e96786f8460982c80c5c06f">from_matrix_cl</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:gaeefdbbf87e96786f8460982c80c5c06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the source var that has data stored on the OpenCL device to destination <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix containing vars.  <br /></td></tr>
<tr class="separator:gaeefdbbf87e96786f8460982c80c5c06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8bfe9807e0cf060ba792de47102dc7"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:add8bfe9807e0cf060ba792de47102dc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_add8bfe9807e0cf060ba792de47102dc7.html#add8bfe9807e0cf060ba792de47102dc7">cos</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:add8bfe9807e0cf060ba792de47102dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ab75cdb29185b7843a24c68e7dfbc3516.html#ab75cdb29185b7843a24c68e7dfbc3516">cos()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt; in radians.  <br /></td></tr>
<tr class="separator:add8bfe9807e0cf060ba792de47102dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002178014676bb40eff4bebf35726da5"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a002178014676bb40eff4bebf35726da5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a002178014676bb40eff4bebf35726da5.html#a002178014676bb40eff4bebf35726da5">cosh</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a002178014676bb40eff4bebf35726da5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a5241e24973fe1e57704814a1a5d939a4.html#a5241e24973fe1e57704814a1a5d939a4">cosh()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt; in radians.  <br /></td></tr>
<tr class="separator:a002178014676bb40eff4bebf35726da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace706bc60d19b6a4dbe782c95f415f44"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ace706bc60d19b6a4dbe782c95f415f44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ace706bc60d19b6a4dbe782c95f415f44.html#ace706bc60d19b6a4dbe782c95f415f44">crossprod</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;M)</td></tr>
<tr class="memdesc:ace706bc60d19b6a4dbe782c95f415f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of pre-multiplying a matrix by its own transpose.  <br /></td></tr>
<tr class="separator:ace706bc60d19b6a4dbe782c95f415f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be4c430b81d6fd0e4a1bd2cfd144964"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0be4c430b81d6fd0e4a1bd2cfd144964"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0be4c430b81d6fd0e4a1bd2cfd144964.html#a0be4c430b81d6fd0e4a1bd2cfd144964">cumulative_sum</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a0be4c430b81d6fd0e4a1bd2cfd144964"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cumulative sum of the specified vector.  <br /></td></tr>
<tr class="separator:a0be4c430b81d6fd0e4a1bd2cfd144964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6a8f178a9c1792c3479d37e86485c5"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aba6a8f178a9c1792c3479d37e86485c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aba6a8f178a9c1792c3479d37e86485c5.html#aba6a8f178a9c1792c3479d37e86485c5">diag_matrix</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:aba6a8f178a9c1792c3479d37e86485c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a square diagonal matrix with the specified vector of coefficients as the diagonal values.  <br /></td></tr>
<tr class="separator:aba6a8f178a9c1792c3479d37e86485c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77edb2836da7942b6d73701e046203ce"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a77edb2836da7942b6d73701e046203ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a77edb2836da7942b6d73701e046203ce.html#a77edb2836da7942b6d73701e046203ce">diag_post_multiply</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a77edb2836da7942b6d73701e046203ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of a matrix and the diagonal matrix formed from the vector or row_vector.  <br /></td></tr>
<tr class="separator:a77edb2836da7942b6d73701e046203ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb7eb2aaf309a23f8aab8fcf966268e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adbb7eb2aaf309a23f8aab8fcf966268e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adbb7eb2aaf309a23f8aab8fcf966268e.html#adbb7eb2aaf309a23f8aab8fcf966268e">diag_pre_multiply</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:adbb7eb2aaf309a23f8aab8fcf966268e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the diagonal matrix formed from the vector or row_vector and a matrix.  <br /></td></tr>
<tr class="separator:adbb7eb2aaf309a23f8aab8fcf966268e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae9561e96c572d22d78f320400e549e"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2ae9561e96c572d22d78f320400e549e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2ae9561e96c572d22d78f320400e549e.html#a2ae9561e96c572d22d78f320400e549e">diagonal</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;M)</td></tr>
<tr class="memdesc:a2ae9561e96c572d22d78f320400e549e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column vector of the diagonal elements of the specified matrix.  <br /></td></tr>
<tr class="separator:a2ae9561e96c572d22d78f320400e549e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a783c0d673dd818cacf47695d80bb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae5a783c0d673dd818cacf47695d80bb8.html#ae5a783c0d673dd818cacf47695d80bb8">digamma</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt; &amp;A)</td></tr>
<tr class="memdesc:ae5a783c0d673dd818cacf47695d80bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_af87890068b9f3e77a15eb60447ccfd77.html#af87890068b9f3e77a15eb60447ccfd77" title="Return the derivative of the log gamma function at the specified argument.">digamma()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:ae5a783c0d673dd818cacf47695d80bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6d3183a6f8bd770709baddea59ec87"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_b &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_a &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeb6d3183a6f8bd770709baddea59ec87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeb6d3183a6f8bd770709baddea59ec87.html#aeb6d3183a6f8bd770709baddea59ec87">divide</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:aeb6d3183a6f8bd770709baddea59ec87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise division of a kernel generator expression and a scalar.  <br /></td></tr>
<tr class="separator:aeb6d3183a6f8bd770709baddea59ec87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3cf0b4bd2ef470aa7fa69318c4ec3f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9c3cf0b4bd2ef470aa7fa69318c4ec3f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9c3cf0b4bd2ef470aa7fa69318c4ec3f.html#a9c3cf0b4bd2ef470aa7fa69318c4ec3f">dot_product</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a9c3cf0b4bd2ef470aa7fa69318c4ec3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product.  <br /></td></tr>
<tr class="separator:a9c3cf0b4bd2ef470aa7fa69318c4ec3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0286957300fdd1828e2cc90fd49eb12"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae0286957300fdd1828e2cc90fd49eb12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae0286957300fdd1828e2cc90fd49eb12.html#ae0286957300fdd1828e2cc90fd49eb12">dot_self</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:ae0286957300fdd1828e2cc90fd49eb12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of a vector of var with itself.  <br /></td></tr>
<tr class="separator:ae0286957300fdd1828e2cc90fd49eb12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8046fa189a91cd604119ec3bcb25d6e6"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8046fa189a91cd604119ec3bcb25d6e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8046fa189a91cd604119ec3bcb25d6e6.html#a8046fa189a91cd604119ec3bcb25d6e6">elt_divide</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a8046fa189a91cd604119ec3bcb25d6e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise division of two reverse mode matrices and/or kernel generator expressions.  <br /></td></tr>
<tr class="separator:a8046fa189a91cd604119ec3bcb25d6e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cff81cd255dea58c7d12c318ffd11ba"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4cff81cd255dea58c7d12c318ffd11ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4cff81cd255dea58c7d12c318ffd11ba.html#a4cff81cd255dea58c7d12c318ffd11ba">elt_multiply</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a4cff81cd255dea58c7d12c318ffd11ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise multiplication of two reverse mode matrices and/or kernel generator expressions.  <br /></td></tr>
<tr class="separator:a4cff81cd255dea58c7d12c318ffd11ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f690b92b4611c2491373872e8355c8"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac5f690b92b4611c2491373872e8355c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac5f690b92b4611c2491373872e8355c8.html#ac5f690b92b4611c2491373872e8355c8">erf</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ac5f690b92b4611c2491373872e8355c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a56f59c3dd3a27e81e8320083e1a0c6c1.html#a56f59c3dd3a27e81e8320083e1a0c6c1">erf()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:ac5f690b92b4611c2491373872e8355c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5094f0a530e2176d7a6fe9e76014c8"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7b5094f0a530e2176d7a6fe9e76014c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7b5094f0a530e2176d7a6fe9e76014c8.html#a7b5094f0a530e2176d7a6fe9e76014c8">erfc</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a7b5094f0a530e2176d7a6fe9e76014c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a9994e6390e4a0c155be10c882072ca34.html#a9994e6390e4a0c155be10c882072ca34">erfc()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a7b5094f0a530e2176d7a6fe9e76014c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc48bd22b7b4a568a3978850f1fc897e"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adc48bd22b7b4a568a3978850f1fc897e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adc48bd22b7b4a568a3978850f1fc897e.html#adc48bd22b7b4a568a3978850f1fc897e">exp</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:adc48bd22b7b4a568a3978850f1fc897e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_afeb02d174bb7d5c70db81fa1a9996f57.html#afeb02d174bb7d5c70db81fa1a9996f57">exp()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:adc48bd22b7b4a568a3978850f1fc897e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eb62aeba977f7feee761e6053e9d7ba"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8eb62aeba977f7feee761e6053e9d7ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8eb62aeba977f7feee761e6053e9d7ba.html#a8eb62aeba977f7feee761e6053e9d7ba">exp2</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a8eb62aeba977f7feee761e6053e9d7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a311f94ed9243524c28e9d30dce8045df.html#a311f94ed9243524c28e9d30dce8045df">exp2()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a8eb62aeba977f7feee761e6053e9d7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e3935c85ab2756924c3bc028cc57d6"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa4e3935c85ab2756924c3bc028cc57d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa4e3935c85ab2756924c3bc028cc57d6.html#aa4e3935c85ab2756924c3bc028cc57d6">expm1</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aa4e3935c85ab2756924c3bc028cc57d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a23c116678993eabfaf88ab4e92209f31.html#a23c116678993eabfaf88ab4e92209f31">expm1()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:aa4e3935c85ab2756924c3bc028cc57d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5691aa886d11f6e1efc1b46867c254"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aac5691aa886d11f6e1efc1b46867c254"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aac5691aa886d11f6e1efc1b46867c254.html#aac5691aa886d11f6e1efc1b46867c254">fabs</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aac5691aa886d11f6e1efc1b46867c254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code>fabs()</code> of the input <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;<a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;double&gt;&gt;</code>.  <br /></td></tr>
<tr class="separator:aac5691aa886d11f6e1efc1b46867c254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e42680abda6f0e828aa79c38f817cc"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a66e42680abda6f0e828aa79c38f817cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a66e42680abda6f0e828aa79c38f817cc.html#a66e42680abda6f0e828aa79c38f817cc">fdim</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a66e42680abda6f0e828aa79c38f817cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference between the first variable's the value and the second's (C99, C++11).  <br /></td></tr>
<tr class="separator:a66e42680abda6f0e828aa79c38f817cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eab3c36aa5febe85e9cebd155365c17"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3eab3c36aa5febe85e9cebd155365c17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3eab3c36aa5febe85e9cebd155365c17.html#a3eab3c36aa5febe85e9cebd155365c17">floor</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a3eab3c36aa5febe85e9cebd155365c17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aa828ed40aa78417d100d5cdeae54cd2b.html#aa828ed40aa78417d100d5cdeae54cd2b">floor()</a></code> of the input <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;<a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;double&gt;&gt;</code>.  <br /></td></tr>
<tr class="separator:a3eab3c36aa5febe85e9cebd155365c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98557d40699952be6b706ae518e77abf"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a98557d40699952be6b706ae518e77abf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a98557d40699952be6b706ae518e77abf.html#a98557d40699952be6b706ae518e77abf">fmax</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a98557d40699952be6b706ae518e77abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greater of the two specified arguments.  <br /></td></tr>
<tr class="separator:a98557d40699952be6b706ae518e77abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8f736c6801090e45b27c05f9ad13c9"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0a8f736c6801090e45b27c05f9ad13c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0a8f736c6801090e45b27c05f9ad13c9.html#a0a8f736c6801090e45b27c05f9ad13c9">fmin</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a0a8f736c6801090e45b27c05f9ad13c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lesser of the two specified arguments.  <br /></td></tr>
<tr class="separator:a0a8f736c6801090e45b27c05f9ad13c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69aa68276840b8962ebe283bfb9bf207"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a69aa68276840b8962ebe283bfb9bf207"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a69aa68276840b8962ebe283bfb9bf207.html#a69aa68276840b8962ebe283bfb9bf207">fmod</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a69aa68276840b8962ebe283bfb9bf207"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floating point remainder after dividing the first variable by the second (cmath).  <br /></td></tr>
<tr class="separator:a69aa68276840b8962ebe283bfb9bf207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22dec695eb198173799ce3dd1c7c6302"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a22dec695eb198173799ce3dd1c7c6302.html#a22dec695eb198173799ce3dd1c7c6302">grad</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;v, <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt; &amp;x, Eigen::VectorXd &amp;g)</td></tr>
<tr class="memdesc:a22dec695eb198173799ce3dd1c7c6302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate chain rule to calculate gradients starting from the specified variable.  <br /></td></tr>
<tr class="separator:a22dec695eb198173799ce3dd1c7c6302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849c494f55973cd389e0415c6e6d03d2"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a849c494f55973cd389e0415c6e6d03d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a849c494f55973cd389e0415c6e6d03d2.html#a849c494f55973cd389e0415c6e6d03d2">hypot</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a849c494f55973cd389e0415c6e6d03d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a00cd0d0044bd0b199db315a364bd20f7.html#a00cd0d0044bd0b199db315a364bd20f7" title="Return the length of the hypotenuse of a right triangle with opposite and adjacent side lengths given...">hypot()</a></code> of the input.  <br /></td></tr>
<tr class="separator:a849c494f55973cd389e0415c6e6d03d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600beb948184b92752da3d047875d6a8"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a600beb948184b92752da3d047875d6a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a600beb948184b92752da3d047875d6a8.html#a600beb948184b92752da3d047875d6a8">inv</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a600beb948184b92752da3d047875d6a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aefd273d6fda1b0a302c1032c3cf91ef7.html#aefd273d6fda1b0a302c1032c3cf91ef7">inv()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a600beb948184b92752da3d047875d6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd1b5a4ac4dea4ef9f4b98a81f142d3"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aafd1b5a4ac4dea4ef9f4b98a81f142d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aafd1b5a4ac4dea4ef9f4b98a81f142d3.html#aafd1b5a4ac4dea4ef9f4b98a81f142d3">inv_cloglog</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aafd1b5a4ac4dea4ef9f4b98a81f142d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a5bb7dcaa37a8cadd5e4ad89ff323a7d5.html#a5bb7dcaa37a8cadd5e4ad89ff323a7d5">inv_cloglog()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:aafd1b5a4ac4dea4ef9f4b98a81f142d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a780c143c196518956a00913d9ae0327a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a780c143c196518956a00913d9ae0327a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a780c143c196518956a00913d9ae0327a.html#a780c143c196518956a00913d9ae0327a">inv_logit</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a780c143c196518956a00913d9ae0327a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ae0010641b9d5d7ab95187e4a05993344.html#ae0010641b9d5d7ab95187e4a05993344" title="Returns the inverse logit function applied to the argument.">inv_logit()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a780c143c196518956a00913d9ae0327a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab94021e5b91ba5c6edd6eaacf67ba8"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6ab94021e5b91ba5c6edd6eaacf67ba8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6ab94021e5b91ba5c6edd6eaacf67ba8.html#a6ab94021e5b91ba5c6edd6eaacf67ba8">inv_Phi</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a6ab94021e5b91ba5c6edd6eaacf67ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a9f9475283849b02264ae7eb4472dabcb.html#a9f9475283849b02264ae7eb4472dabcb">inv_Phi()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a6ab94021e5b91ba5c6edd6eaacf67ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13430d1296f01c9a35fa4633727755c4"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a13430d1296f01c9a35fa4633727755c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a13430d1296f01c9a35fa4633727755c4.html#a13430d1296f01c9a35fa4633727755c4">inv_sqrt</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a13430d1296f01c9a35fa4633727755c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aedb364653df48e278a5463dcfab5345d.html#aedb364653df48e278a5463dcfab5345d">inv_sqrt()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a13430d1296f01c9a35fa4633727755c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63967ea3fd6ea06771c8c87d8e5f35a4"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a63967ea3fd6ea06771c8c87d8e5f35a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a63967ea3fd6ea06771c8c87d8e5f35a4.html#a63967ea3fd6ea06771c8c87d8e5f35a4">inv_square</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a63967ea3fd6ea06771c8c87d8e5f35a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a2e06fba4a23adac049865e0715c4a191.html#a2e06fba4a23adac049865e0715c4a191">inv_square()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a63967ea3fd6ea06771c8c87d8e5f35a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145cd3f9ec5c450897beb350e557152a"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a145cd3f9ec5c450897beb350e557152a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a145cd3f9ec5c450897beb350e557152a.html#a145cd3f9ec5c450897beb350e557152a">lbeta</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a145cd3f9ec5c450897beb350e557152a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise <code><a class="el" href="namespacestan_1_1math_a4e48d5cd0470ac716a02d368e77c8c8a.html#a4e48d5cd0470ac716a02d368e77c8c8a">lbeta()</a></code> on two input kernel generator expression.  <br /></td></tr>
<tr class="separator:a145cd3f9ec5c450897beb350e557152a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab223fd839d26d4a3ee10c6abf4137d8a"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__opencl__kernel__generator_gaca27ada59d198e78c07d1c6dcd79e835.html#gaca27ada59d198e78c07d1c6dcd79e835">require_all_kernel_expressions_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__integral__types_ga8d10ea9813909bf7fc1a2394e880165a.html#ga8d10ea9813909bf7fc1a2394e880165a">require_st_integral</a>&lt; T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab223fd839d26d4a3ee10c6abf4137d8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab223fd839d26d4a3ee10c6abf4137d8a.html#ab223fd839d26d4a3ee10c6abf4137d8a">ldexp</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T_a &gt; &amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:ab223fd839d26d4a3ee10c6abf4137d8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code>ldexp()</code> of the input <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;<a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;double&gt;&gt;</code> and kernel generator expression.  <br /></td></tr>
<tr class="separator:ab223fd839d26d4a3ee10c6abf4137d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70db697aba4b4e9eeb8eb5a1f092b9d1"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a70db697aba4b4e9eeb8eb5a1f092b9d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a70db697aba4b4e9eeb8eb5a1f092b9d1.html#a70db697aba4b4e9eeb8eb5a1f092b9d1">lgamma</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a70db697aba4b4e9eeb8eb5a1f092b9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aa888b5d6ff71fe9ab37deaee025a33bf.html#aa888b5d6ff71fe9ab37deaee025a33bf" title="Return the natural logarithm of the gamma function applied to the specified argument.">lgamma()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a70db697aba4b4e9eeb8eb5a1f092b9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1921e5a8b435189aa91b62b11639feb"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac1921e5a8b435189aa91b62b11639feb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac1921e5a8b435189aa91b62b11639feb.html#ac1921e5a8b435189aa91b62b11639feb">lmultiply</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:ac1921e5a8b435189aa91b62b11639feb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a70dc434e6485c32aac018c358c058f38.html#a70dc434e6485c32aac018c358c058f38">lmultiply()</a></code> of the input.  <br /></td></tr>
<tr class="separator:ac1921e5a8b435189aa91b62b11639feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bdf404df03aec35516a4005762bb16"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a95bdf404df03aec35516a4005762bb16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a95bdf404df03aec35516a4005762bb16.html#a95bdf404df03aec35516a4005762bb16">log</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a95bdf404df03aec35516a4005762bb16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a5494a692abff08cb3585079397b90dab.html#a5494a692abff08cb3585079397b90dab">log()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a95bdf404df03aec35516a4005762bb16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62581c08e17dd269cf61619f147024b"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa62581c08e17dd269cf61619f147024b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa62581c08e17dd269cf61619f147024b.html#aa62581c08e17dd269cf61619f147024b">log10</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aa62581c08e17dd269cf61619f147024b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aaadc90acda3e608b200fc3eb6188c486.html#aaadc90acda3e608b200fc3eb6188c486" title="Returns the natural logarithm of ten.">log10()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:aa62581c08e17dd269cf61619f147024b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ba86670f689249c1acb82f8d954cee"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a04ba86670f689249c1acb82f8d954cee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a04ba86670f689249c1acb82f8d954cee.html#a04ba86670f689249c1acb82f8d954cee">log1m</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a04ba86670f689249c1acb82f8d954cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ae426e656b1c72332aeadeaed27c5ecf4.html#ae426e656b1c72332aeadeaed27c5ecf4">log1m()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a04ba86670f689249c1acb82f8d954cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5313291763f4b27e3c945901bf1639"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1d5313291763f4b27e3c945901bf1639"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1d5313291763f4b27e3c945901bf1639.html#a1d5313291763f4b27e3c945901bf1639">log1m_exp</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a1d5313291763f4b27e3c945901bf1639"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a452e4f39f00638a425f76b27c150e8ec.html#a452e4f39f00638a425f76b27c150e8ec" title="Return the natural logarithm of one minus the exponentiation of the specified argument.">log1m_exp()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a1d5313291763f4b27e3c945901bf1639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed157518c6034e3b21ea9f28552d6a0"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeed157518c6034e3b21ea9f28552d6a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeed157518c6034e3b21ea9f28552d6a0.html#aeed157518c6034e3b21ea9f28552d6a0">log1m_inv_logit</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aeed157518c6034e3b21ea9f28552d6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aebfd796b601a6cb2b9022ddedd7b6748.html#aebfd796b601a6cb2b9022ddedd7b6748" title="Return the natural logarithm of one minus the inverse logit of the specified argument.">log1m_inv_logit()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:aeed157518c6034e3b21ea9f28552d6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed0611adc8a20c1435e958ee8892704"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abed0611adc8a20c1435e958ee8892704"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abed0611adc8a20c1435e958ee8892704.html#abed0611adc8a20c1435e958ee8892704">log1p</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:abed0611adc8a20c1435e958ee8892704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a9cb72ed892210a6a63de6e4db6c3c056.html#a9cb72ed892210a6a63de6e4db6c3c056">log1p()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:abed0611adc8a20c1435e958ee8892704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773de7ec8f687e2484607172ebb3bf7a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a773de7ec8f687e2484607172ebb3bf7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a773de7ec8f687e2484607172ebb3bf7a.html#a773de7ec8f687e2484607172ebb3bf7a">log1p_exp</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a773de7ec8f687e2484607172ebb3bf7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a7a46dfa4816b15da29603c2a13928996.html#a7a46dfa4816b15da29603c2a13928996">log1p_exp()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a773de7ec8f687e2484607172ebb3bf7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2933d02b74632fb48ab2f7bea28343a9"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2933d02b74632fb48ab2f7bea28343a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2933d02b74632fb48ab2f7bea28343a9.html#a2933d02b74632fb48ab2f7bea28343a9">log2</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a2933d02b74632fb48ab2f7bea28343a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a44eb38e5b317dadf97e8b359197902ea.html#a44eb38e5b317dadf97e8b359197902ea" title="Return natural logarithm of two.">log2()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a2933d02b74632fb48ab2f7bea28343a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa341ae5c759c33126bed177032cb4ef5"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_y , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_x, T_y &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_x, T_y &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_x, T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa341ae5c759c33126bed177032cb4ef5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa341ae5c759c33126bed177032cb4ef5.html#aa341ae5c759c33126bed177032cb4ef5">log_diff_exp</a> (T_x &amp;&amp;x, T_y &amp;&amp;y)</td></tr>
<tr class="memdesc:aa341ae5c759c33126bed177032cb4ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the difference of the natural exponentiation of x and the natural exponentiation of y.  <br /></td></tr>
<tr class="separator:aa341ae5c759c33126bed177032cb4ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fdf1ce4b20b2c794cf525625968e18"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad9fdf1ce4b20b2c794cf525625968e18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad9fdf1ce4b20b2c794cf525625968e18.html#ad9fdf1ce4b20b2c794cf525625968e18">log_inv_logit</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ad9fdf1ce4b20b2c794cf525625968e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a609450c56db01ed4b4989dc7f9dd755c.html#a609450c56db01ed4b4989dc7f9dd755c">log_inv_logit()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:ad9fdf1ce4b20b2c794cf525625968e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcf55a139c53cd777a5c0344b850aeb"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_y , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_x, T_y &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_x, T_y &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_x, T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acfcf55a139c53cd777a5c0344b850aeb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acfcf55a139c53cd777a5c0344b850aeb.html#acfcf55a139c53cd777a5c0344b850aeb">log_inv_logit_diff</a> (T_x &amp;&amp;x, T_y &amp;&amp;y)</td></tr>
<tr class="memdesc:acfcf55a139c53cd777a5c0344b850aeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the difference of the inverse logits of the specified arguments.  <br /></td></tr>
<tr class="separator:acfcf55a139c53cd777a5c0344b850aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea6b87e7c759b8d2dddd21f54ab5110"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5ea6b87e7c759b8d2dddd21f54ab5110"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5ea6b87e7c759b8d2dddd21f54ab5110.html#a5ea6b87e7c759b8d2dddd21f54ab5110">log_softmax</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a5ea6b87e7c759b8d2dddd21f54ab5110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return log of the softmax of the specified vector.  <br /></td></tr>
<tr class="separator:a5ea6b87e7c759b8d2dddd21f54ab5110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bbed3309d13b19e01cb7e3b9cf4b55"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a25bbed3309d13b19e01cb7e3b9cf4b55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a25bbed3309d13b19e01cb7e3b9cf4b55.html#a25bbed3309d13b19e01cb7e3b9cf4b55">log_sum_exp</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a25bbed3309d13b19e01cb7e3b9cf4b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the sum of the exponentiated values of the specified matrix of values.  <br /></td></tr>
<tr class="separator:a25bbed3309d13b19e01cb7e3b9cf4b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a39022069433ec4e26573c68740887"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a86a39022069433ec4e26573c68740887"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a86a39022069433ec4e26573c68740887.html#a86a39022069433ec4e26573c68740887">logit</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a86a39022069433ec4e26573c68740887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a229da97d194861a2715450b9877173c4.html#a229da97d194861a2715450b9877173c4">logit()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a86a39022069433ec4e26573c68740887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7c4e8e930a98a14999532ae640ae29"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5d7c4e8e930a98a14999532ae640ae29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5d7c4e8e930a98a14999532ae640ae29.html#a5d7c4e8e930a98a14999532ae640ae29">matrix_power</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;M, const int n)</td></tr>
<tr class="memdesc:a5d7c4e8e930a98a14999532ae640ae29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth power of the specific matrix.  <br /></td></tr>
<tr class="separator:a5d7c4e8e930a98a14999532ae640ae29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ad3d8881fe01b729b806e5a50f1c5d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a00ad3d8881fe01b729b806e5a50f1c5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a00ad3d8881fe01b729b806e5a50f1c5d.html#a00ad3d8881fe01b729b806e5a50f1c5d">mdivide_left_tri_low</a> (T1 &amp;&amp;A, T2 &amp;&amp;b)</td></tr>
<tr class="memdesc:a00ad3d8881fe01b729b806e5a50f1c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is lower triangular.  <br /></td></tr>
<tr class="separator:a00ad3d8881fe01b729b806e5a50f1c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77fb8d686ac9de0c3979a28c50b835a0"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a77fb8d686ac9de0c3979a28c50b835a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a77fb8d686ac9de0c3979a28c50b835a0.html#a77fb8d686ac9de0c3979a28c50b835a0">mdivide_left_tri_low</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a77fb8d686ac9de0c3979a28c50b835a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is triangular and b=I.  <br /></td></tr>
<tr class="separator:a77fb8d686ac9de0c3979a28c50b835a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2db1ca00fa74f078b22f0e5436b0b8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acd2db1ca00fa74f078b22f0e5436b0b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acd2db1ca00fa74f078b22f0e5436b0b8.html#acd2db1ca00fa74f078b22f0e5436b0b8">mdivide_right_tri_low</a> (T2 &amp;&amp;b, T1 &amp;&amp;A)</td></tr>
<tr class="memdesc:acd2db1ca00fa74f078b22f0e5436b0b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is lower triangular.  <br /></td></tr>
<tr class="separator:acd2db1ca00fa74f078b22f0e5436b0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c20cca427caf289a9770bd13ece1b8f"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6c20cca427caf289a9770bd13ece1b8f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6c20cca427caf289a9770bd13ece1b8f.html#a6c20cca427caf289a9770bd13ece1b8f">multiply</a> (T_a &amp;&amp;A, T_b &amp;&amp;B)</td></tr>
<tr class="memdesc:a6c20cca427caf289a9770bd13ece1b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiplication of two reverse mode matrices and/or kernel generator expressions.  <br /></td></tr>
<tr class="separator:a6c20cca427caf289a9770bd13ece1b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e3f28cfcf809bbf1ba8ac90c3acd3f"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a77e3f28cfcf809bbf1ba8ac90c3acd3f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a77e3f28cfcf809bbf1ba8ac90c3acd3f.html#a77e3f28cfcf809bbf1ba8ac90c3acd3f">operator*</a> (const T_a &amp;A, const T_b &amp;B)</td></tr>
<tr class="memdesc:a77e3f28cfcf809bbf1ba8ac90c3acd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matrix multiplication of two reverse mode matrices and/or kernel generator expressions.  <br /></td></tr>
<tr class="separator:a77e3f28cfcf809bbf1ba8ac90c3acd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf6123f0f01a7ceb2c39a08822076a6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T2 &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaaf6123f0f01a7ceb2c39a08822076a6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaaf6123f0f01a7ceb2c39a08822076a6.html#aaaf6123f0f01a7ceb2c39a08822076a6">multiply</a> (const T1 &amp;A, T2 &amp;&amp;B)</td></tr>
<tr class="memdesc:aaaf6123f0f01a7ceb2c39a08822076a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return matrix multiplied by a scalar.  <br /></td></tr>
<tr class="separator:aaaf6123f0f01a7ceb2c39a08822076a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2893c33058a11f28b8480e66863bcdb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T2 &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac2893c33058a11f28b8480e66863bcdb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac2893c33058a11f28b8480e66863bcdb.html#ac2893c33058a11f28b8480e66863bcdb">multiply</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:ac2893c33058a11f28b8480e66863bcdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return matrix multiplied by a scalar.  <br /></td></tr>
<tr class="separator:ac2893c33058a11f28b8480e66863bcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2518953b53201e785b9d8d5422dc1a7c"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2518953b53201e785b9d8d5422dc1a7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2518953b53201e785b9d8d5422dc1a7c.html#a2518953b53201e785b9d8d5422dc1a7c">multiply_log</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a2518953b53201e785b9d8d5422dc1a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a0cfad301844f8e98ce438764293c25e0.html#a0cfad301844f8e98ce438764293c25e0">multiply_log()</a></code> of the input.  <br /></td></tr>
<tr class="separator:a2518953b53201e785b9d8d5422dc1a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53ff644c56dbcf912b33fde39e6f57d"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab53ff644c56dbcf912b33fde39e6f57d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab53ff644c56dbcf912b33fde39e6f57d.html#ab53ff644c56dbcf912b33fde39e6f57d">multiply_lower_tri_self_transpose</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ab53ff644c56dbcf912b33fde39e6f57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of multiplying the lower triangular portion of the input matrix by its own transpose.  <br /></td></tr>
<tr class="separator:ab53ff644c56dbcf912b33fde39e6f57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f78e164882765ccaf6be34e8ee425a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac8f78e164882765ccaf6be34e8ee425a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac8f78e164882765ccaf6be34e8ee425a.html#ac8f78e164882765ccaf6be34e8ee425a">operator-</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;M)</td></tr>
<tr class="memdesc:ac8f78e164882765ccaf6be34e8ee425a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unary minus of the input.  <br /></td></tr>
<tr class="separator:ac8f78e164882765ccaf6be34e8ee425a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac638e90807b1a1eb852b648e1fbda93a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__types_ga29fde8e89258f50345408f2d23070d60.html#ga29fde8e89258f50345408f2d23070d60">require_var_vt</a>&lt; <a class="el" href="structstan_1_1is__kernel__expression__and__not__scalar.html">is_kernel_expression_and_not_scalar</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac638e90807b1a1eb852b648e1fbda93a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac638e90807b1a1eb852b648e1fbda93a.html#ac638e90807b1a1eb852b648e1fbda93a">operator+</a> (T &amp;&amp;M)</td></tr>
<tr class="memdesc:ac638e90807b1a1eb852b648e1fbda93a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unary plus of the input.  <br /></td></tr>
<tr class="separator:ac638e90807b1a1eb852b648e1fbda93a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26226b05ff502c456e06d02209eca611"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a26226b05ff502c456e06d02209eca611"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a26226b05ff502c456e06d02209eca611.html#a26226b05ff502c456e06d02209eca611">Phi</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a26226b05ff502c456e06d02209eca611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a8f550856f585617566096f8f129caff8.html#a8f550856f585617566096f8f129caff8">Phi()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a26226b05ff502c456e06d02209eca611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c86e895e4b8421068f473879ce5a6e"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a96c86e895e4b8421068f473879ce5a6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a96c86e895e4b8421068f473879ce5a6e.html#a96c86e895e4b8421068f473879ce5a6e">Phi_approx</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a96c86e895e4b8421068f473879ce5a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a5e969ba79729a18cbab9cf9731cced63.html#a5e969ba79729a18cbab9cf9731cced63" title="Return an approximation of the unit normal cumulative distribution function (CDF).">Phi_approx()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a96c86e895e4b8421068f473879ce5a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffd1159b69d90427150d4102f77d9c0"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acffd1159b69d90427150d4102f77d9c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acffd1159b69d90427150d4102f77d9c0.html#acffd1159b69d90427150d4102f77d9c0">pow</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:acffd1159b69d90427150d4102f77d9c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <br /></td></tr>
<tr class="separator:acffd1159b69d90427150d4102f77d9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec080f3ad157218ab928e8b1e072c38"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2ec080f3ad157218ab928e8b1e072c38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2ec080f3ad157218ab928e8b1e072c38.html#a2ec080f3ad157218ab928e8b1e072c38">prod</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a2ec080f3ad157218ab928e8b1e072c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the prod of the coefficients of the specified matrix on the OpenCL device.  <br /></td></tr>
<tr class="separator:a2ec080f3ad157218ab928e8b1e072c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52b39037e357255bda858f7ad0e3c3d4"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , <a class="el" href="group__var__types_ga29fde8e89258f50345408f2d23070d60.html#ga29fde8e89258f50345408f2d23070d60">require_var_vt</a>&lt; <a class="el" href="structstan_1_1is__matrix__cl.html">is_matrix_cl</a>, T_ret &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga52b39037e357255bda858f7ad0e3c3d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga52b39037e357255bda858f7ad0e3c3d4.html#ga52b39037e357255bda858f7ad0e3c3d4">rep_matrix</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;A, int n, int m)</td></tr>
<tr class="memdesc:ga52b39037e357255bda858f7ad0e3c3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> by replicating the given value of arithmetic type.  <br /></td></tr>
<tr class="separator:ga52b39037e357255bda858f7ad0e3c3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77d0f9106510dd46a4d9ce8b1e888795"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga77d0f9106510dd46a4d9ce8b1e888795"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga77d0f9106510dd46a4d9ce8b1e888795.html#ga77d0f9106510dd46a4d9ce8b1e888795">rep_matrix</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A, int m)</td></tr>
<tr class="memdesc:ga77d0f9106510dd46a4d9ce8b1e888795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a <a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a> by replicating the input vector or row_vector.  <br /></td></tr>
<tr class="separator:ga77d0f9106510dd46a4d9ce8b1e888795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1eeeb735647bf0b842756f4b8956d6"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6b1eeeb735647bf0b842756f4b8956d6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6b1eeeb735647bf0b842756f4b8956d6.html#a6b1eeeb735647bf0b842756f4b8956d6">reverse</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a6b1eeeb735647bf0b842756f4b8956d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return reversed view into the specified vector or row vector.  <br /></td></tr>
<tr class="separator:a6b1eeeb735647bf0b842756f4b8956d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ecef3b720c9022ae1447a26b55baf5"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a18ecef3b720c9022ae1447a26b55baf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a18ecef3b720c9022ae1447a26b55baf5.html#a18ecef3b720c9022ae1447a26b55baf5">round</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a18ecef3b720c9022ae1447a26b55baf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ac23adb89034b334771cd25cf0fa6e2e4.html#ac23adb89034b334771cd25cf0fa6e2e4" title="Return the closest integer to the specified argument, with halfway cases rounded away from zero.">round()</a></code> of the input <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;<a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;double&gt;&gt;</code>.  <br /></td></tr>
<tr class="separator:a18ecef3b720c9022ae1447a26b55baf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fb615831f4434c372977a951ac29e2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a67fb615831f4434c372977a951ac29e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a67fb615831f4434c372977a951ac29e2.html#a67fb615831f4434c372977a951ac29e2">rows_dot_product</a> (T1 &amp;&amp;v1, T2 &amp;&amp;v2)</td></tr>
<tr class="memdesc:a67fb615831f4434c372977a951ac29e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of rows of the specified matrices.  <br /></td></tr>
<tr class="separator:a67fb615831f4434c372977a951ac29e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7e0a58126a5829882328511672d26c"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3f7e0a58126a5829882328511672d26c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3f7e0a58126a5829882328511672d26c.html#a3f7e0a58126a5829882328511672d26c">rows_dot_self</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a3f7e0a58126a5829882328511672d26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each row of a matrix with itself.  <br /></td></tr>
<tr class="separator:a3f7e0a58126a5829882328511672d26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab856c561a6611fe9e71ee4cf27c999b"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aab856c561a6611fe9e71ee4cf27c999b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab856c561a6611fe9e71ee4cf27c999b.html#aab856c561a6611fe9e71ee4cf27c999b">sd</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aab856c561a6611fe9e71ee4cf27c999b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample standard deviation of the <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a> matrix.  <br /></td></tr>
<tr class="separator:aab856c561a6611fe9e71ee4cf27c999b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e1554426c9032896eec570f90ac4d0"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a16e1554426c9032896eec570f90ac4d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a16e1554426c9032896eec570f90ac4d0.html#a16e1554426c9032896eec570f90ac4d0">sin</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a16e1554426c9032896eec570f90ac4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ab75cdb29185b7843a24c68e7dfbc3516.html#ab75cdb29185b7843a24c68e7dfbc3516">cos()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt; in radians.  <br /></td></tr>
<tr class="separator:a16e1554426c9032896eec570f90ac4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaea86e0a339199e2bc9f6431ac51125"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adaea86e0a339199e2bc9f6431ac51125"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adaea86e0a339199e2bc9f6431ac51125.html#adaea86e0a339199e2bc9f6431ac51125">sinh</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:adaea86e0a339199e2bc9f6431ac51125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ab75cdb29185b7843a24c68e7dfbc3516.html#ab75cdb29185b7843a24c68e7dfbc3516">cos()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt; in radians.  <br /></td></tr>
<tr class="separator:adaea86e0a339199e2bc9f6431ac51125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27ef92f11a854f5df986ac843ee3942"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab27ef92f11a854f5df986ac843ee3942"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab27ef92f11a854f5df986ac843ee3942.html#ab27ef92f11a854f5df986ac843ee3942">softmax</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:ab27ef92f11a854f5df986ac843ee3942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns softmax of given argument.  <br /></td></tr>
<tr class="separator:ab27ef92f11a854f5df986ac843ee3942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b7fb56bb85b8d5c911ab774587a5a1"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a71b7fb56bb85b8d5c911ab774587a5a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a71b7fb56bb85b8d5c911ab774587a5a1.html#a71b7fb56bb85b8d5c911ab774587a5a1">sqrt</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a71b7fb56bb85b8d5c911ab774587a5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a81819d20047b4d6c264b58e35bb2c48d.html#a81819d20047b4d6c264b58e35bb2c48d">sqrt()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a71b7fb56bb85b8d5c911ab774587a5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320cb607b0bd89ddef293fe5001d29a0"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a320cb607b0bd89ddef293fe5001d29a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a320cb607b0bd89ddef293fe5001d29a0.html#a320cb607b0bd89ddef293fe5001d29a0">square</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a320cb607b0bd89ddef293fe5001d29a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_af94738d2bfd07182b4aaa7e18a62fb74.html#af94738d2bfd07182b4aaa7e18a62fb74">square()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a320cb607b0bd89ddef293fe5001d29a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3d84e2dec06ac43d69eb8373b2bfcb"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8c3d84e2dec06ac43d69eb8373b2bfcb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8c3d84e2dec06ac43d69eb8373b2bfcb.html#a8c3d84e2dec06ac43d69eb8373b2bfcb">squared_distance</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a8c3d84e2dec06ac43d69eb8373b2bfcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance.  <br /></td></tr>
<tr class="separator:a8c3d84e2dec06ac43d69eb8373b2bfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bbb1bb36b78e354b1aaa13384fcabd"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__prim__or__rev__kernel__expression__types_ga03ddfa21efd7d1722ff0e7333c51f209.html#ga03ddfa21efd7d1722ff0e7333c51f209">require_all_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga09c85677422e2e114002a5efa68cfc3f.html#ga09c85677422e2e114002a5efa68cfc3f">require_any_not_stan_scalar_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a64bbb1bb36b78e354b1aaa13384fcabd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a64bbb1bb36b78e354b1aaa13384fcabd.html#a64bbb1bb36b78e354b1aaa13384fcabd">subtract</a> (T_a &amp;&amp;a, T_b &amp;&amp;b)</td></tr>
<tr class="memdesc:a64bbb1bb36b78e354b1aaa13384fcabd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two reverse mode matrices and/or kernel generator expressions.  <br /></td></tr>
<tr class="separator:a64bbb1bb36b78e354b1aaa13384fcabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafad48f6bd9f872e3a45f3651ed0a33"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_gaca58d90e4acb3d445bdf708cbd6daec2.html#gaca58d90e4acb3d445bdf708cbd6daec2">require_all_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afafad48f6bd9f872e3a45f3651ed0a33"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afafad48f6bd9f872e3a45f3651ed0a33.html#afafad48f6bd9f872e3a45f3651ed0a33">operator-</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="memdesc:afafad48f6bd9f872e3a45f3651ed0a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction of two reverse mode matrices and/or kernel generator expressions.  <br /></td></tr>
<tr class="separator:afafad48f6bd9f872e3a45f3651ed0a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02baf58b0e78a95a7b8b84da2e1a911d"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a02baf58b0e78a95a7b8b84da2e1a911d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a02baf58b0e78a95a7b8b84da2e1a911d.html#a02baf58b0e78a95a7b8b84da2e1a911d">sum</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a02baf58b0e78a95a7b8b84da2e1a911d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of the coefficients of the specified matrix on the OpenCL device.  <br /></td></tr>
<tr class="separator:a02baf58b0e78a95a7b8b84da2e1a911d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e2deed6aedde623500bd7aefdeb6a5"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a90e2deed6aedde623500bd7aefdeb6a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a90e2deed6aedde623500bd7aefdeb6a5.html#a90e2deed6aedde623500bd7aefdeb6a5">symmetrize_from_lower_tri</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a90e2deed6aedde623500bd7aefdeb6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a symmetric matrix using elements from the upper triangular part of the input matrix.  <br /></td></tr>
<tr class="separator:a90e2deed6aedde623500bd7aefdeb6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbccde8900f6fe96cb859271253ff55"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9cbccde8900f6fe96cb859271253ff55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9cbccde8900f6fe96cb859271253ff55.html#a9cbccde8900f6fe96cb859271253ff55">symmetrize_from_upper_tri</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a9cbccde8900f6fe96cb859271253ff55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a symmetric matrix using elements from the upper triangular part of the input matrix.  <br /></td></tr>
<tr class="separator:a9cbccde8900f6fe96cb859271253ff55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117f2bb396cb34856121c8beed56bc06"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a117f2bb396cb34856121c8beed56bc06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a117f2bb396cb34856121c8beed56bc06.html#a117f2bb396cb34856121c8beed56bc06">tan</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a117f2bb396cb34856121c8beed56bc06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a89071e8c3d80fe0b2ac0b23c345e9a9e.html#a89071e8c3d80fe0b2ac0b23c345e9a9e">tan()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt; in radians.  <br /></td></tr>
<tr class="separator:a117f2bb396cb34856121c8beed56bc06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6872ec175ca61f82a9a45e90f2d8158d"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6872ec175ca61f82a9a45e90f2d8158d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6872ec175ca61f82a9a45e90f2d8158d.html#a6872ec175ca61f82a9a45e90f2d8158d">tanh</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a6872ec175ca61f82a9a45e90f2d8158d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ab32c5cd88becea57416c65688771a7c8.html#ab32c5cd88becea57416c65688771a7c8">tanh()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt; in radians.  <br /></td></tr>
<tr class="separator:a6872ec175ca61f82a9a45e90f2d8158d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb381a7fa45e217104960ebe611a02b"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0bb381a7fa45e217104960ebe611a02b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0bb381a7fa45e217104960ebe611a02b.html#a0bb381a7fa45e217104960ebe611a02b">tcrossprod</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;M)</td></tr>
<tr class="memdesc:a0bb381a7fa45e217104960ebe611a02b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of post-multiplying a matrix by its own transpose.  <br /></td></tr>
<tr class="separator:a0bb381a7fa45e217104960ebe611a02b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3240e016b118d4c083c1440d73285b7d"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3240e016b118d4c083c1440d73285b7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3240e016b118d4c083c1440d73285b7d.html#a3240e016b118d4c083c1440d73285b7d">tgamma</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a3240e016b118d4c083c1440d73285b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_acad338502e3115d34682603230479d41.html#acad338502e3115d34682603230479d41" title="Return the result of applying the gamma function to the specified argument.">tgamma()</a></code> of a var_value&lt;matrix_cl&lt;double&gt;&gt;.  <br /></td></tr>
<tr class="separator:a3240e016b118d4c083c1440d73285b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf9d3034b2c3baae4a547907ae52b2d"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__cl__types_gaf18202a28f3c86c16368f08c04f6532d.html#gaf18202a28f3c86c16368f08c04f6532d">require_matrix_cl_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7bf9d3034b2c3baae4a547907ae52b2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">arena_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7bf9d3034b2c3baae4a547907ae52b2d.html#a7bf9d3034b2c3baae4a547907ae52b2d">to_arena</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a7bf9d3034b2c3baae4a547907ae52b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts given argument into a type that either has any dynamic allocation on AD stack or schedules its destructor to be called when AD stack memory is recovered.  <br /></td></tr>
<tr class="separator:a7bf9d3034b2c3baae4a547907ae52b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7266e247fe6e0759583eecc8ddb6d2d7"><td class="memTemplParams" colspan="2">template&lt;typename T_x , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7266e247fe6e0759583eecc8ddb6d2d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7266e247fe6e0759583eecc8ddb6d2d7.html#a7266e247fe6e0759583eecc8ddb6d2d7">to_matrix</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T_x &gt; &amp;x, int m, int n)</td></tr>
<tr class="memdesc:a7266e247fe6e0759583eecc8ddb6d2d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of a vector or matrix in column-major order with the specified number of rows and columns.  <br /></td></tr>
<tr class="separator:a7266e247fe6e0759583eecc8ddb6d2d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fafbbd5a166667ae7dfe48e441d1a4f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2fafbbd5a166667ae7dfe48e441d1a4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2fafbbd5a166667ae7dfe48e441d1a4f.html#a2fafbbd5a166667ae7dfe48e441d1a4f">trace</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a2fafbbd5a166667ae7dfe48e441d1a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trace (sum of diagonal) of the specified matrix on the OpenCL device.  <br /></td></tr>
<tr class="separator:a2fafbbd5a166667ae7dfe48e441d1a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99eaf6cab2258d909e798de7b3f409ef"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a99eaf6cab2258d909e798de7b3f409ef"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a99eaf6cab2258d909e798de7b3f409ef.html#a99eaf6cab2258d909e798de7b3f409ef">transpose</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;M)</td></tr>
<tr class="memdesc:a99eaf6cab2258d909e798de7b3f409ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a matrix.  <br /></td></tr>
<tr class="separator:a99eaf6cab2258d909e798de7b3f409ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c33a6ab1618eb301b7dd713f630393"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a70c33a6ab1618eb301b7dd713f630393"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a70c33a6ab1618eb301b7dd713f630393.html#a70c33a6ab1618eb301b7dd713f630393">trunc</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a70c33a6ab1618eb301b7dd713f630393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_afac4060d610887434f513b38fb8457d6.html#afac4060d610887434f513b38fb8457d6" title="Return the nearest integral value that is not larger in magnitude than the specified argument.">trunc()</a></code> of the input <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;<a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a>&lt;double&gt;&gt;</code>.  <br /></td></tr>
<tr class="separator:a70c33a6ab1618eb301b7dd713f630393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bbd000b9b4558249d01c11994ddc93"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__opencl__kernel__generator_gaecc749b7850d3620ecb9f94cf94fd8a2.html#gaecc749b7850d3620ecb9f94cf94fd8a2">require_all_kernel_expressions_and_none_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a12bbd000b9b4558249d01c11994ddc93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a12bbd000b9b4558249d01c11994ddc93.html#a12bbd000b9b4558249d01c11994ddc93">variance</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a12bbd000b9b4558249d01c11994ddc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample variance of the <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a> matrix Raise domain error if size is not greater than zero.  <br /></td></tr>
<tr class="separator:a12bbd000b9b4558249d01c11994ddc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9df6723479e901d88b22325b4da6f3"><td class="memTemplParams" colspan="2">template&lt;bool need_eigenvectors = true&gt; </td></tr>
<tr class="memitem:abe9df6723479e901d88b22325b4da6f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abe9df6723479e901d88b22325b4da6f3.html#abe9df6723479e901d88b22325b4da6f3">symmetric_eigensolver</a> (const <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;A, <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;<a class="el" href="namespacestan_1_1math_af11986db9bdb58e69ef129ce90b41c66.html#af11986db9bdb58e69ef129ce90b41c66">eigenvalues</a>, <a class="el" href="classstan_1_1math_1_1matrix__cl.html">matrix_cl</a>&lt; double &gt; &amp;<a class="el" href="namespacestan_1_1math_a9ff7a5be47c0c9cb6712e00204963827.html#a9ff7a5be47c0c9cb6712e00204963827">eigenvectors</a>)</td></tr>
<tr class="separator:abe9df6723479e901d88b22325b4da6f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb82871e12b0d186640aa9b390818ad6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abb82871e12b0d186640aa9b390818ad6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a89fb6779eb99f22b6b0ce2662e630e78.html#a89fb6779eb99f22b6b0ce2662e630e78">ref_type_for_opencl_t</a>&lt; T &amp;&amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abb82871e12b0d186640aa9b390818ad6.html#abb82871e12b0d186640aa9b390818ad6">to_ref_for_opencl</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:abb82871e12b0d186640aa9b390818ad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts given <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expression into one that can be directly copied to an OpenCL device to create <code><a class="el" href="classstan_1_1math_1_1matrix__cl.html" title="Represents an arithmetic matrix on the OpenCL device.">matrix_cl</a></code>.  <br /></td></tr>
<tr class="separator:abb82871e12b0d186640aa9b390818ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0600f9f85f3b1c2424cd2e6d9a52b450"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="namespacestan_1_1math_a9528c837d04c7f4d0a92b8f9e3238925.html#a9528c837d04c7f4d0a92b8f9e3238925">matrix_cl_view</a> matrix_view = matrix_cl_view::Entire, typename T , <a class="el" href="group__matrix__cl__types_gace64828b1d0e81550a510d7ce11155e4.html#gace64828b1d0e81550a510d7ce11155e4">require_matrix_cl_st</a>&lt; std::is_floating_point, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0600f9f85f3b1c2424cd2e6d9a52b450"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__opencl_ga0600f9f85f3b1c2424cd2e6d9a52b450.html#ga0600f9f85f3b1c2424cd2e6d9a52b450">tri_inverse</a> (const T &amp;A)</td></tr>
<tr class="memdesc:ga0600f9f85f3b1c2424cd2e6d9a52b450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the inverse of a triangular matrix.  <br /></td></tr>
<tr class="separator:ga0600f9f85f3b1c2424cd2e6d9a52b450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf50e4020a959823e7035a052a1b172"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acdf50e4020a959823e7035a052a1b172"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigVec &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acdf50e4020a959823e7035a052a1b172.html#acdf50e4020a959823e7035a052a1b172">cholesky_corr_constrain</a> (const EigVec &amp;y, int K)</td></tr>
<tr class="separator:acdf50e4020a959823e7035a052a1b172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42e9a946230a806f42becb416a3b455"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad42e9a946230a806f42becb416a3b455"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigVec &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad42e9a946230a806f42becb416a3b455.html#ad42e9a946230a806f42becb416a3b455">cholesky_corr_constrain</a> (const EigVec &amp;y, int K, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigVec &gt; &amp;lp)</td></tr>
<tr class="separator:ad42e9a946230a806f42becb416a3b455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a336435c8562f3ebc68691898f1530cb7"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a336435c8562f3ebc68691898f1530cb7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a336435c8562f3ebc68691898f1530cb7.html#a336435c8562f3ebc68691898f1530cb7">cholesky_corr_constrain</a> (const T &amp;y, int K, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a336435c8562f3ebc68691898f1530cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return The cholesky of a <code>KxK</code> correlation matrix.  <br /></td></tr>
<tr class="separator:a336435c8562f3ebc68691898f1530cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac170f5d0dc6969c674af9217bc062a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2ac170f5d0dc6969c674af9217bc062a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2ac170f5d0dc6969c674af9217bc062a.html#a2ac170f5d0dc6969c674af9217bc062a">cholesky_corr_free</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a2ac170f5d0dc6969c674af9217bc062a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_a2ac170f5d0dc6969c674af9217bc062a.html#a2ac170f5d0dc6969c674af9217bc062a" title="Overload of cholesky_corr_free() to untransform each matrix in a standard vector.">cholesky_corr_free()</a></code> to untransform each matrix in a standard vector.  <br /></td></tr>
<tr class="separator:a2ac170f5d0dc6969c674af9217bc062a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b7be0f17af6b75b88d363d5103d9c37"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8b7be0f17af6b75b88d363d5103d9c37"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8b7be0f17af6b75b88d363d5103d9c37.html#a8b7be0f17af6b75b88d363d5103d9c37">cholesky_factor_constrain</a> (const T &amp;x, int M, int N)</td></tr>
<tr class="memdesc:a8b7be0f17af6b75b88d363d5103d9c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the specified size read from the specified vector.  <br /></td></tr>
<tr class="separator:a8b7be0f17af6b75b88d363d5103d9c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1382af1b2b9055be5753a5f6c24d783e"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1382af1b2b9055be5753a5f6c24d783e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1382af1b2b9055be5753a5f6c24d783e.html#a1382af1b2b9055be5753a5f6c24d783e">cholesky_factor_constrain</a> (const T &amp;x, int M, int N, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a1382af1b2b9055be5753a5f6c24d783e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the specified size read from the specified vector and increment the specified log probability reference with the log absolute Jacobian determinant adjustment of the transform.  <br /></td></tr>
<tr class="separator:a1382af1b2b9055be5753a5f6c24d783e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae206753e64823b15baa539f1fa34eacb"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae206753e64823b15baa539f1fa34eacb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae206753e64823b15baa539f1fa34eacb.html#ae206753e64823b15baa539f1fa34eacb">cholesky_factor_constrain</a> (const T &amp;x, int M, int N, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:ae206753e64823b15baa539f1fa34eacb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the specified size read from the specified vector.  <br /></td></tr>
<tr class="separator:ae206753e64823b15baa539f1fa34eacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d44e32de06b9e5f991edaec1c3f86e"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a47d44e32de06b9e5f991edaec1c3f86e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a47d44e32de06b9e5f991edaec1c3f86e.html#a47d44e32de06b9e5f991edaec1c3f86e">cholesky_factor_free</a> (const T &amp;y)</td></tr>
<tr class="memdesc:a47d44e32de06b9e5f991edaec1c3f86e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unconstrained vector of parameters corresponding to the specified Cholesky factor.  <br /></td></tr>
<tr class="separator:a47d44e32de06b9e5f991edaec1c3f86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3e3eac6538ed168d365c46fbe4d81c"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aee3e3eac6538ed168d365c46fbe4d81c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aee3e3eac6538ed168d365c46fbe4d81c.html#aee3e3eac6538ed168d365c46fbe4d81c">cholesky_factor_free</a> (const T &amp;x)</td></tr>
<tr class="memdesc:aee3e3eac6538ed168d365c46fbe4d81c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_a47d44e32de06b9e5f991edaec1c3f86e.html#a47d44e32de06b9e5f991edaec1c3f86e" title="Return the unconstrained vector of parameters corresponding to the specified Cholesky factor.">cholesky_factor_free()</a></code> to untransform each matrix in a standard vector.  <br /></td></tr>
<tr class="separator:aee3e3eac6538ed168d365c46fbe4d81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f60b6f8ce947b8aef93a29462a0a57"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad1f60b6f8ce947b8aef93a29462a0a57"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad1f60b6f8ce947b8aef93a29462a0a57.html#ad1f60b6f8ce947b8aef93a29462a0a57">corr_constrain</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ad1f60b6f8ce947b8aef93a29462a0a57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of transforming the specified scalar or container of values to have a valid correlation value between -1 and 1 (inclusive).  <br /></td></tr>
<tr class="separator:ad1f60b6f8ce947b8aef93a29462a0a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f09b7a228b46122223b3024f45f3318"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_lp &gt; </td></tr>
<tr class="memitem:a5f09b7a228b46122223b3024f45f3318"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5f09b7a228b46122223b3024f45f3318.html#a5f09b7a228b46122223b3024f45f3318">corr_constrain</a> (const T_x &amp;x, T_lp &amp;lp)</td></tr>
<tr class="memdesc:a5f09b7a228b46122223b3024f45f3318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of transforming the specified scalar or container of values to have a valid correlation value between -1 and 1 (inclusive).  <br /></td></tr>
<tr class="separator:a5f09b7a228b46122223b3024f45f3318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54ab33cad65d7075ebab9a030faa0a6"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T_x , typename T_lp &gt; </td></tr>
<tr class="memitem:aa54ab33cad65d7075ebab9a030faa0a6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa54ab33cad65d7075ebab9a030faa0a6.html#aa54ab33cad65d7075ebab9a030faa0a6">corr_constrain</a> (const T_x &amp;x, T_lp &amp;lp)</td></tr>
<tr class="memdesc:aa54ab33cad65d7075ebab9a030faa0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of transforming the specified scalar or container of values to have a valid correlation value between -1 and 1 (inclusive).  <br /></td></tr>
<tr class="separator:aa54ab33cad65d7075ebab9a030faa0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e9bd8757c3eff7092879c1ae68874a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0e9bd8757c3eff7092879c1ae68874a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab0e9bd8757c3eff7092879c1ae68874a.html#ab0e9bd8757c3eff7092879c1ae68874a">corr_free</a> (const T &amp;y)</td></tr>
<tr class="memdesc:ab0e9bd8757c3eff7092879c1ae68874a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unconstrained scalar that when transformed to a valid correlation produces the specified value.  <br /></td></tr>
<tr class="separator:ab0e9bd8757c3eff7092879c1ae68874a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f36fcdf95fc116c1d50d4d14d2110f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a64f36fcdf95fc116c1d50d4d14d2110f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a64f36fcdf95fc116c1d50d4d14d2110f.html#a64f36fcdf95fc116c1d50d4d14d2110f">corr_matrix_constrain</a> (const T &amp;x, Eigen::Index k)</td></tr>
<tr class="memdesc:a64f36fcdf95fc116c1d50d4d14d2110f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality derived from the specified vector of unconstrained values.  <br /></td></tr>
<tr class="separator:a64f36fcdf95fc116c1d50d4d14d2110f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459de08b8f35cb41a24dca583100a3fd"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a459de08b8f35cb41a24dca583100a3fd"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a459de08b8f35cb41a24dca583100a3fd.html#a459de08b8f35cb41a24dca583100a3fd">corr_matrix_constrain</a> (const T &amp;x, Eigen::Index k, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a459de08b8f35cb41a24dca583100a3fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality derived from the specified vector of unconstrained values.  <br /></td></tr>
<tr class="separator:a459de08b8f35cb41a24dca583100a3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b7a6b4c2fa77e5b291bce0761820a45"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3b7a6b4c2fa77e5b291bce0761820a45"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3b7a6b4c2fa77e5b291bce0761820a45.html#a3b7a6b4c2fa77e5b291bce0761820a45">corr_matrix_constrain</a> (const T &amp;x, Eigen::Index k, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a3b7a6b4c2fa77e5b291bce0761820a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality derived from the specified vector of unconstrained values.  <br /></td></tr>
<tr class="separator:a3b7a6b4c2fa77e5b291bce0761820a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65529c4df91a6a16123009b658fd0de"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab65529c4df91a6a16123009b658fd0de"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab65529c4df91a6a16123009b658fd0de.html#ab65529c4df91a6a16123009b658fd0de">corr_matrix_constrain</a> (const T &amp;y, int K, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:ab65529c4df91a6a16123009b658fd0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality derived from the specified vector of unconstrained values.  <br /></td></tr>
<tr class="separator:ab65529c4df91a6a16123009b658fd0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a6ad7bb8904c818940cb83db61e24d"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a61a6ad7bb8904c818940cb83db61e24d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a61a6ad7bb8904c818940cb83db61e24d.html#a61a6ad7bb8904c818940cb83db61e24d">corr_matrix_free</a> (const T &amp;y)</td></tr>
<tr class="memdesc:a61a6ad7bb8904c818940cb83db61e24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of unconstrained partial correlations that define the specified correlation matrix when transformed.  <br /></td></tr>
<tr class="separator:a61a6ad7bb8904c818940cb83db61e24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436b4931d3327185d9bdc14f6322b2d3"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a436b4931d3327185d9bdc14f6322b2d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a436b4931d3327185d9bdc14f6322b2d3.html#a436b4931d3327185d9bdc14f6322b2d3">corr_matrix_free</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a436b4931d3327185d9bdc14f6322b2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_a61a6ad7bb8904c818940cb83db61e24d.html#a61a6ad7bb8904c818940cb83db61e24d" title="Return the vector of unconstrained partial correlations that define the specified correlation matrix ...">corr_matrix_free()</a></code> to untransform each matrix in a standard vector.  <br /></td></tr>
<tr class="separator:a436b4931d3327185d9bdc14f6322b2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba80e24035dcdad84aaa7472ae259dc"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4ba80e24035dcdad84aaa7472ae259dc"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4ba80e24035dcdad84aaa7472ae259dc.html#a4ba80e24035dcdad84aaa7472ae259dc">cov_matrix_constrain</a> (const T &amp;x, Eigen::Index K)</td></tr>
<tr class="memdesc:a4ba80e24035dcdad84aaa7472ae259dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the symmetric, positive-definite matrix of dimensions K by K resulting from transforming the specified finite vector of size K plus (K choose 2).  <br /></td></tr>
<tr class="separator:a4ba80e24035dcdad84aaa7472ae259dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8998ee75d3365c55fb952c93600945"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4d8998ee75d3365c55fb952c93600945"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4d8998ee75d3365c55fb952c93600945.html#a4d8998ee75d3365c55fb952c93600945">cov_matrix_constrain</a> (const T &amp;x, Eigen::Index K, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a4d8998ee75d3365c55fb952c93600945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the symmetric, positive-definite matrix of dimensions K by K resulting from transforming the specified finite vector of size K plus (K choose 2).  <br /></td></tr>
<tr class="separator:a4d8998ee75d3365c55fb952c93600945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55def76bb303b2b7777387ecd821d2c7"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a55def76bb303b2b7777387ecd821d2c7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a55def76bb303b2b7777387ecd821d2c7.html#a55def76bb303b2b7777387ecd821d2c7">cov_matrix_constrain</a> (const T &amp;x, Eigen::Index K, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a55def76bb303b2b7777387ecd821d2c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the symmetric, positive-definite matrix of dimensions K by K resulting from transforming the specified finite vector of size K plus (K choose 2).  <br /></td></tr>
<tr class="separator:a55def76bb303b2b7777387ecd821d2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9144c27c624aa220d38a189eebb1a6f7"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9144c27c624aa220d38a189eebb1a6f7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9144c27c624aa220d38a189eebb1a6f7.html#a9144c27c624aa220d38a189eebb1a6f7">cov_matrix_constrain_lkj</a> (const T &amp;x, size_t k)</td></tr>
<tr class="memdesc:a9144c27c624aa220d38a189eebb1a6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the covariance matrix of the specified dimensionality derived from constraining the specified vector of unconstrained values.  <br /></td></tr>
<tr class="separator:a9144c27c624aa220d38a189eebb1a6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ae577c1bd9a82719c95690310b4d51"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad7ae577c1bd9a82719c95690310b4d51"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad7ae577c1bd9a82719c95690310b4d51.html#ad7ae577c1bd9a82719c95690310b4d51">cov_matrix_constrain_lkj</a> (const T &amp;x, size_t k, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:ad7ae577c1bd9a82719c95690310b4d51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the covariance matrix of the specified dimensionality derived from constraining the specified vector of unconstrained values and increment the specified log probability reference with the log absolute Jacobian determinant.  <br /></td></tr>
<tr class="separator:ad7ae577c1bd9a82719c95690310b4d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbca43eddb9d9de0e15d91633b4d2a9"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afdbca43eddb9d9de0e15d91633b4d2a9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afdbca43eddb9d9de0e15d91633b4d2a9.html#afdbca43eddb9d9de0e15d91633b4d2a9">cov_matrix_constrain_lkj</a> (const T &amp;x, size_t k, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:afdbca43eddb9d9de0e15d91633b4d2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the covariance matrix of the specified dimensionality derived from constraining the specified vector of unconstrained values.  <br /></td></tr>
<tr class="separator:afdbca43eddb9d9de0e15d91633b4d2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcc7b1b20d05cd671f66cbde76dddcd"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8bcc7b1b20d05cd671f66cbde76dddcd"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8bcc7b1b20d05cd671f66cbde76dddcd.html#a8bcc7b1b20d05cd671f66cbde76dddcd">cov_matrix_free</a> (const T &amp;y)</td></tr>
<tr class="memdesc:a8bcc7b1b20d05cd671f66cbde76dddcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The covariance matrix derived from the symmetric view of the lower-triangular view of the K by K specified matrix is freed to return a vector of size K + (K choose 2).  <br /></td></tr>
<tr class="separator:a8bcc7b1b20d05cd671f66cbde76dddcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa4663b97f2144560c7557a8b21c26bb"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afa4663b97f2144560c7557a8b21c26bb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afa4663b97f2144560c7557a8b21c26bb.html#afa4663b97f2144560c7557a8b21c26bb">cov_matrix_free</a> (const T &amp;x)</td></tr>
<tr class="memdesc:afa4663b97f2144560c7557a8b21c26bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_a8bcc7b1b20d05cd671f66cbde76dddcd.html#a8bcc7b1b20d05cd671f66cbde76dddcd" title="The covariance matrix derived from the symmetric view of the lower-triangular view of the K by K spec...">cov_matrix_free()</a></code> to untransform each matrix in a standard vector.  <br /></td></tr>
<tr class="separator:afa4663b97f2144560c7557a8b21c26bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf661fb71d2a46df248ad516485c6b22"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acf661fb71d2a46df248ad516485c6b22"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acf661fb71d2a46df248ad516485c6b22.html#acf661fb71d2a46df248ad516485c6b22">cov_matrix_free_lkj</a> (const T &amp;y)</td></tr>
<tr class="memdesc:acf661fb71d2a46df248ad516485c6b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of unconstrained partial correlations and deviations that transform to the specified covariance matrix.  <br /></td></tr>
<tr class="separator:acf661fb71d2a46df248ad516485c6b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7cdf85a78d99a3f52955b35fe78d24"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acd7cdf85a78d99a3f52955b35fe78d24"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acd7cdf85a78d99a3f52955b35fe78d24.html#acd7cdf85a78d99a3f52955b35fe78d24">cov_matrix_free_lkj</a> (const T &amp;x)</td></tr>
<tr class="memdesc:acd7cdf85a78d99a3f52955b35fe78d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_acf661fb71d2a46df248ad516485c6b22.html#acf661fb71d2a46df248ad516485c6b22" title="Return the vector of unconstrained partial correlations and deviations that transform to the specifie...">cov_matrix_free_lkj()</a></code> to untransform each matrix in a standard vector.  <br /></td></tr>
<tr class="separator:acd7cdf85a78d99a3f52955b35fe78d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaec8ce3421eae60ef5a95850908176e"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian = false, typename T , typename... Types, <a class="el" href="group__var__matrix__types_gae0f57b6105cb69165aeee0f2de2e50db.html#gae0f57b6105cb69165aeee0f2de2e50db">require_all_not_var_matrix_t</a>&lt; T, Types... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeaec8ce3421eae60ef5a95850908176e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeaec8ce3421eae60ef5a95850908176e.html#aeaec8ce3421eae60ef5a95850908176e">identity_constrain</a> (T &amp;&amp;x, Types &amp;&amp;...)</td></tr>
<tr class="memdesc:aeaec8ce3421eae60ef5a95850908176e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of applying the identity constraint transform to the input.  <br /></td></tr>
<tr class="separator:aeaec8ce3421eae60ef5a95850908176e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be3dea70cebcb8e664fcc5f049661b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Types, <a class="el" href="group__var__matrix__types_gae0f57b6105cb69165aeee0f2de2e50db.html#gae0f57b6105cb69165aeee0f2de2e50db">require_all_not_var_matrix_t</a>&lt; T, Types... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5be3dea70cebcb8e664fcc5f049661b9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5be3dea70cebcb8e664fcc5f049661b9.html#a5be3dea70cebcb8e664fcc5f049661b9">identity_free</a> (T &amp;&amp;x, Types &amp;&amp;...)</td></tr>
<tr class="memdesc:a5be3dea70cebcb8e664fcc5f049661b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of applying the inverse of the identity constraint transform to the input.  <br /></td></tr>
<tr class="separator:a5be3dea70cebcb8e664fcc5f049661b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896a60613646c7b029ec340443d9ae2d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T, L &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; T, L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a896a60613646c7b029ec340443d9ae2d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a896a60613646c7b029ec340443d9ae2d.html#a896a60613646c7b029ec340443d9ae2d">lb_constrain</a> (const T &amp;x, const L &amp;lb)</td></tr>
<tr class="memdesc:a896a60613646c7b029ec340443d9ae2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-bounded value for the specified unconstrained input and specified lower bound.  <br /></td></tr>
<tr class="separator:a896a60613646c7b029ec340443d9ae2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bec9c64e01f1f6705bd6242e2ce1525"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; L &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; T, L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7bec9c64e01f1f6705bd6242e2ce1525"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7bec9c64e01f1f6705bd6242e2ce1525.html#a7bec9c64e01f1f6705bd6242e2ce1525">lb_constrain</a> (T &amp;&amp;x, L &amp;&amp;lb)</td></tr>
<tr class="memdesc:a7bec9c64e01f1f6705bd6242e2ce1525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>lb_constrain</code> to apply a scalar lower bound elementwise to each input.  <br /></td></tr>
<tr class="separator:a7bec9c64e01f1f6705bd6242e2ce1525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1b250c33f4d005a6566ab654f9ebc7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; L &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; T, L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6b1b250c33f4d005a6566ab654f9ebc7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6b1b250c33f4d005a6566ab654f9ebc7.html#a6b1b250c33f4d005a6566ab654f9ebc7">lb_constrain</a> (const T &amp;x, const L &amp;lb, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L &gt; &amp;lp)</td></tr>
<tr class="memdesc:a6b1b250c33f4d005a6566ab654f9ebc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>lb_constrain</code> to apply a scalar lower bound elementwise to each input.  <br /></td></tr>
<tr class="separator:a6b1b250c33f4d005a6566ab654f9ebc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4d5d51badfc97f4f7da3070fdce7d9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aac4d5d51badfc97f4f7da3070fdce7d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aac4d5d51badfc97f4f7da3070fdce7d9.html#aac4d5d51badfc97f4f7da3070fdce7d9">lb_constrain</a> (const std::vector&lt; T &gt; &amp;x, const L &amp;lb)</td></tr>
<tr class="memdesc:aac4d5d51badfc97f4f7da3070fdce7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>lb_constrain</code> to apply a container of lower bounds elementwise to each input element.  <br /></td></tr>
<tr class="separator:aac4d5d51badfc97f4f7da3070fdce7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6720a1137c32b4d826dad415588be0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6a6720a1137c32b4d826dad415588be0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6a6720a1137c32b4d826dad415588be0.html#a6a6720a1137c32b4d826dad415588be0">lb_constrain</a> (const std::vector&lt; T &gt; &amp;x, const L &amp;lb, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L &gt; &amp;lp)</td></tr>
<tr class="memdesc:a6a6720a1137c32b4d826dad415588be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>lb_constrain</code> to apply a container of lower bounds elementwise to each input element.  <br /></td></tr>
<tr class="separator:a6a6720a1137c32b4d826dad415588be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1b3e146fb34b60ad7c6943fcfaf9be4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L &gt; </td></tr>
<tr class="memitem:ad1b3e146fb34b60ad7c6943fcfaf9be4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad1b3e146fb34b60ad7c6943fcfaf9be4.html#ad1b3e146fb34b60ad7c6943fcfaf9be4">lb_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; L &gt; &amp;lb)</td></tr>
<tr class="memdesc:ad1b3e146fb34b60ad7c6943fcfaf9be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>lb_constrain</code> to apply a container of lower bounds elementwise to each input element.  <br /></td></tr>
<tr class="separator:ad1b3e146fb34b60ad7c6943fcfaf9be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55951128e2c3e4c59107fe3f71b5ef9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L &gt; </td></tr>
<tr class="memitem:af55951128e2c3e4c59107fe3f71b5ef9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af55951128e2c3e4c59107fe3f71b5ef9.html#af55951128e2c3e4c59107fe3f71b5ef9">lb_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; L &gt; &amp;lb, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L &gt; &amp;lp)</td></tr>
<tr class="memdesc:af55951128e2c3e4c59107fe3f71b5ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>lb_constrain</code> to apply a container of lower bounds elementwise to each input element.  <br /></td></tr>
<tr class="separator:af55951128e2c3e4c59107fe3f71b5ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9378b127f2a5a39a6f5d1af869aad1ff"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , typename L &gt; </td></tr>
<tr class="memitem:a9378b127f2a5a39a6f5d1af869aad1ff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9378b127f2a5a39a6f5d1af869aad1ff.html#a9378b127f2a5a39a6f5d1af869aad1ff">lb_constrain</a> (const T &amp;x, const L &amp;lb, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L &gt; &amp;lp)</td></tr>
<tr class="memdesc:a9378b127f2a5a39a6f5d1af869aad1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>lb_constrain</code> to apply a container of lower bounds elementwise to each input element.  <br /></td></tr>
<tr class="separator:a9378b127f2a5a39a6f5d1af869aad1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc7caeeeac1f4ea49669263e4e28c4e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aafc7caeeeac1f4ea49669263e4e28c4e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aafc7caeeeac1f4ea49669263e4e28c4e.html#aafc7caeeeac1f4ea49669263e4e28c4e">lb_free</a> (T &amp;&amp;y, L &amp;&amp;lb)</td></tr>
<tr class="memdesc:aafc7caeeeac1f4ea49669263e4e28c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unconstrained value that produces the specified lower-bound constrained value.  <br /></td></tr>
<tr class="separator:aafc7caeeeac1f4ea49669263e4e28c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad199ccf725e964a1fafe74d49460c0d4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; T, L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad199ccf725e964a1fafe74d49460c0d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad199ccf725e964a1fafe74d49460c0d4.html#ad199ccf725e964a1fafe74d49460c0d4">lb_free</a> (T &amp;&amp;y, L &amp;&amp;lb)</td></tr>
<tr class="memdesc:ad199ccf725e964a1fafe74d49460c0d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free matrix that corresponds to the specified lower-bounded matrix with respect to the specified lower bound.  <br /></td></tr>
<tr class="separator:ad199ccf725e964a1fafe74d49460c0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea3f39e55decf6e8488990e229b5ee3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeea3f39e55decf6e8488990e229b5ee3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeea3f39e55decf6e8488990e229b5ee3.html#aeea3f39e55decf6e8488990e229b5ee3">lb_free</a> (const std::vector&lt; T &gt; y, const L &amp;lb)</td></tr>
<tr class="memdesc:aeea3f39e55decf6e8488990e229b5ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free variable that corresponds to the specified lower-bounded variable with respect to the specified lower bound.  <br /></td></tr>
<tr class="separator:aeea3f39e55decf6e8488990e229b5ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06125d727c0ad874018c05008f448be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L &gt; </td></tr>
<tr class="memitem:ae06125d727c0ad874018c05008f448be"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae06125d727c0ad874018c05008f448be.html#ae06125d727c0ad874018c05008f448be">lb_free</a> (const std::vector&lt; T &gt; y, const std::vector&lt; L &gt; &amp;lb)</td></tr>
<tr class="memdesc:ae06125d727c0ad874018c05008f448be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free variable that corresponds to the specified lower-bounded variable with respect to the specified lower bound.  <br /></td></tr>
<tr class="separator:ae06125d727c0ad874018c05008f448be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae497d37bdef3fcbba1d0be1ce5f385a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T, L, U &gt; *  = nullptr, <a class="el" href="group__var__types_ga202c72c7f8418f766eeb3e013a43e25c.html#ga202c72c7f8418f766eeb3e013a43e25c">require_not_var_t</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aae497d37bdef3fcbba1d0be1ce5f385a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aae497d37bdef3fcbba1d0be1ce5f385a.html#aae497d37bdef3fcbba1d0be1ce5f385a">lub_constrain</a> (T &amp;&amp;x, L &amp;&amp;lb, U &amp;&amp;ub)</td></tr>
<tr class="memdesc:aae497d37bdef3fcbba1d0be1ce5f385a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower and upper-bounded scalar derived by transforming the specified free scalar given the specified lower and upper bounds.  <br /></td></tr>
<tr class="separator:aae497d37bdef3fcbba1d0be1ce5f385a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae134c42fe1bca06f7f8ccacab4879f33"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T, L, U &gt; *  = nullptr, <a class="el" href="group__var__types_ga202c72c7f8418f766eeb3e013a43e25c.html#ga202c72c7f8418f766eeb3e013a43e25c">require_not_var_t</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae134c42fe1bca06f7f8ccacab4879f33"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae134c42fe1bca06f7f8ccacab4879f33.html#ae134c42fe1bca06f7f8ccacab4879f33">lub_constrain</a> (T &amp;&amp;x, L &amp;&amp;lb, U &amp;&amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:ae134c42fe1bca06f7f8ccacab4879f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower- and upper-bounded scalar derived by transforming the specified free scalar given the specified lower and upper bounds and increment the specified log density with the log absolute Jacobian determinant.  <br /></td></tr>
<tr class="separator:ae134c42fe1bca06f7f8ccacab4879f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaecad691243b07d692c104b77c238cdb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; L, U &gt; *  = nullptr, <a class="el" href="group__var__types_ga202c72c7f8418f766eeb3e013a43e25c.html#ga202c72c7f8418f766eeb3e013a43e25c">require_not_var_t</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaecad691243b07d692c104b77c238cdb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaecad691243b07d692c104b77c238cdb.html#aaecad691243b07d692c104b77c238cdb">lub_constrain</a> (const T &amp;x, const L &amp;lb, const U &amp;ub)</td></tr>
<tr class="memdesc:aaecad691243b07d692c104b77c238cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix and scalar bounds.  <br /></td></tr>
<tr class="separator:aaecad691243b07d692c104b77c238cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04174686500fae0f855f32a57a5f3447"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; L, U &gt; *  = nullptr, <a class="el" href="group__var__types_ga202c72c7f8418f766eeb3e013a43e25c.html#ga202c72c7f8418f766eeb3e013a43e25c">require_not_var_t</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a04174686500fae0f855f32a57a5f3447"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a04174686500fae0f855f32a57a5f3447.html#a04174686500fae0f855f32a57a5f3447">lub_constrain</a> (const T &amp;x, const L &amp;lb, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:a04174686500fae0f855f32a57a5f3447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix and scalar bounds plus lp.  <br /></td></tr>
<tr class="separator:a04174686500fae0f855f32a57a5f3447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab957f3a08646b760db1cab5fcb5b762d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; T, L, U &gt; *  = nullptr, <a class="el" href="group__var__types_ga202c72c7f8418f766eeb3e013a43e25c.html#ga202c72c7f8418f766eeb3e013a43e25c">require_not_var_t</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab957f3a08646b760db1cab5fcb5b762d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab957f3a08646b760db1cab5fcb5b762d.html#ab957f3a08646b760db1cab5fcb5b762d">lub_constrain</a> (const T &amp;x, const L &amp;lb, const U &amp;ub)</td></tr>
<tr class="memdesc:ab957f3a08646b760db1cab5fcb5b762d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix and matrix bounds.  <br /></td></tr>
<tr class="separator:ab957f3a08646b760db1cab5fcb5b762d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fe3b39de2d7765910a028df5fbfe51"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__std__vector__types_ga613a895eb09b0a2c56cf757f08e3b1d0.html#ga613a895eb09b0a2c56cf757f08e3b1d0">require_all_not_std_vector_t</a>&lt; L, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a15fe3b39de2d7765910a028df5fbfe51"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a15fe3b39de2d7765910a028df5fbfe51.html#a15fe3b39de2d7765910a028df5fbfe51">lub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const L &amp;lb, const U &amp;ub)</td></tr>
<tr class="memdesc:a15fe3b39de2d7765910a028df5fbfe51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and non-array lb and ub.  <br /></td></tr>
<tr class="separator:a15fe3b39de2d7765910a028df5fbfe51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a092f79b9e5b19ffa6cd8c7748e3c62a6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__std__vector__types_ga613a895eb09b0a2c56cf757f08e3b1d0.html#ga613a895eb09b0a2c56cf757f08e3b1d0">require_all_not_std_vector_t</a>&lt; L, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a092f79b9e5b19ffa6cd8c7748e3c62a6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a092f79b9e5b19ffa6cd8c7748e3c62a6.html#a092f79b9e5b19ffa6cd8c7748e3c62a6">lub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const L &amp;lb, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:a092f79b9e5b19ffa6cd8c7748e3c62a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and non-array lb and ub with lp.  <br /></td></tr>
<tr class="separator:a092f79b9e5b19ffa6cd8c7748e3c62a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbdd40aa85089a5f31e27d7aa788453"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aadbdd40aa85089a5f31e27d7aa788453"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aadbdd40aa85089a5f31e27d7aa788453.html#aadbdd40aa85089a5f31e27d7aa788453">lub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const L &amp;lb, const std::vector&lt; U &gt; &amp;ub)</td></tr>
<tr class="memdesc:aadbdd40aa85089a5f31e27d7aa788453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and ub and non-array lb.  <br /></td></tr>
<tr class="separator:aadbdd40aa85089a5f31e27d7aa788453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40e264cb3fffacaccdcae7e912702ae"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac40e264cb3fffacaccdcae7e912702ae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac40e264cb3fffacaccdcae7e912702ae.html#ac40e264cb3fffacaccdcae7e912702ae">lub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const L &amp;lb, const std::vector&lt; U &gt; &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:ac40e264cb3fffacaccdcae7e912702ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and ub and non-array lb with lp.  <br /></td></tr>
<tr class="separator:ac40e264cb3fffacaccdcae7e912702ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455e05e9fa5aeceb0b34aa2924f73f28"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a455e05e9fa5aeceb0b34aa2924f73f28"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a455e05e9fa5aeceb0b34aa2924f73f28.html#a455e05e9fa5aeceb0b34aa2924f73f28">lub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; L &gt; &amp;lb, const U &amp;ub)</td></tr>
<tr class="memdesc:a455e05e9fa5aeceb0b34aa2924f73f28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and lb and non-array ub.  <br /></td></tr>
<tr class="separator:a455e05e9fa5aeceb0b34aa2924f73f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6ea9417298dfc59aeea48423791a80"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8f6ea9417298dfc59aeea48423791a80"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8f6ea9417298dfc59aeea48423791a80.html#a8f6ea9417298dfc59aeea48423791a80">lub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; L &gt; &amp;lb, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:a8f6ea9417298dfc59aeea48423791a80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and lb and non-array ub with lp.  <br /></td></tr>
<tr class="separator:a8f6ea9417298dfc59aeea48423791a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e85e3460b32eeeb97506d24e30ea46"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:a37e85e3460b32eeeb97506d24e30ea46"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a37e85e3460b32eeeb97506d24e30ea46.html#a37e85e3460b32eeeb97506d24e30ea46">lub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; L &gt; &amp;lb, const std::vector&lt; U &gt; &amp;ub)</td></tr>
<tr class="memdesc:a37e85e3460b32eeeb97506d24e30ea46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x, lb, and ub with lp.  <br /></td></tr>
<tr class="separator:a37e85e3460b32eeeb97506d24e30ea46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3463cc493c5b235e3dc6036a26291c02"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:a3463cc493c5b235e3dc6036a26291c02"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3463cc493c5b235e3dc6036a26291c02.html#a3463cc493c5b235e3dc6036a26291c02">lub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; L &gt; &amp;lb, const std::vector&lt; U &gt; &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:a3463cc493c5b235e3dc6036a26291c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x, lb, and ub.  <br /></td></tr>
<tr class="separator:a3463cc493c5b235e3dc6036a26291c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf16b46888fe2babb597e4ab46acbe3e"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:adf16b46888fe2babb597e4ab46acbe3e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adf16b46888fe2babb597e4ab46acbe3e.html#adf16b46888fe2babb597e4ab46acbe3e">lub_constrain</a> (const T &amp;x, const L &amp;lb, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:adf16b46888fe2babb597e4ab46acbe3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower and upper-bounded scalar derived by transforming the specified free scalar given the specified lower and upper bounds.  <br /></td></tr>
<tr class="separator:adf16b46888fe2babb597e4ab46acbe3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab405e713024a371f2a994c2a62dc9cb7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ab405e713024a371f2a994c2a62dc9cb7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab405e713024a371f2a994c2a62dc9cb7.html#ab405e713024a371f2a994c2a62dc9cb7">lub_constrain</a> (const T &amp;x, const std::tuple&lt; L, U &gt; &amp;bounds)</td></tr>
<tr class="memdesc:ab405e713024a371f2a994c2a62dc9cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for tuple of bounds, simply delegates to the appropriate overload.  <br /></td></tr>
<tr class="separator:ab405e713024a371f2a994c2a62dc9cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa3887cc117847a0f84157829ff54ff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:a1aa3887cc117847a0f84157829ff54ff"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1aa3887cc117847a0f84157829ff54ff.html#a1aa3887cc117847a0f84157829ff54ff">lub_constrain</a> (const T &amp;x, const std::tuple&lt; L, U &gt; &amp;bounds, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:a1aa3887cc117847a0f84157829ff54ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for tuple of bounds, simply delegates to the appropriate overload.  <br /></td></tr>
<tr class="separator:a1aa3887cc117847a0f84157829ff54ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25e1c6be2d2d62edd7d52c8800c5d02"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:ac25e1c6be2d2d62edd7d52c8800c5d02"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac25e1c6be2d2d62edd7d52c8800c5d02.html#ac25e1c6be2d2d62edd7d52c8800c5d02">lub_constrain</a> (const T &amp;x, const std::tuple&lt; L, U &gt; &amp;bounds, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:ac25e1c6be2d2d62edd7d52c8800c5d02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for tuple of bounds, simply delegates to the appropriate overload.  <br /></td></tr>
<tr class="separator:ac25e1c6be2d2d62edd7d52c8800c5d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf991e16ddef0d7d5b980df3fe839e8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T, M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aedf991e16ddef0d7d5b980df3fe839e8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aedf991e16ddef0d7d5b980df3fe839e8.html#aedf991e16ddef0d7d5b980df3fe839e8">offset_multiplier_constrain</a> (const T &amp;x, const M &amp;mu, const S &amp;sigma)</td></tr>
<tr class="memdesc:aedf991e16ddef0d7d5b980df3fe839e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearly transformed value for the specified unconstrained input and specified offset and multiplier.  <br /></td></tr>
<tr class="separator:aedf991e16ddef0d7d5b980df3fe839e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9cced951ec4341dee8a4313a0d486a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T, M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ade9cced951ec4341dee8a4313a0d486a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade9cced951ec4341dee8a4313a0d486a.html#ade9cced951ec4341dee8a4313a0d486a">offset_multiplier_constrain</a> (const T &amp;x, const M &amp;mu, const S &amp;sigma, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, M, S &gt; &amp;lp)</td></tr>
<tr class="memdesc:ade9cced951ec4341dee8a4313a0d486a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linearly transformed value for the specified unconstrained input and specified offset and multiplier, incrementing the specified reference with the log absolute Jacobian determinant of the transform.  <br /></td></tr>
<tr class="separator:ade9cced951ec4341dee8a4313a0d486a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf97fbdb286a72b9c2001b2a735372b1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , <a class="el" href="group__std__vector__types_ga613a895eb09b0a2c56cf757f08e3b1d0.html#ga613a895eb09b0a2c56cf757f08e3b1d0">require_all_not_std_vector_t</a>&lt; M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abf97fbdb286a72b9c2001b2a735372b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abf97fbdb286a72b9c2001b2a735372b1.html#abf97fbdb286a72b9c2001b2a735372b1">offset_multiplier_constrain</a> (const std::vector&lt; T &gt; &amp;x, const M &amp;mu, const S &amp;sigma)</td></tr>
<tr class="memdesc:abf97fbdb286a72b9c2001b2a735372b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and non-array mu and sigma.  <br /></td></tr>
<tr class="separator:abf97fbdb286a72b9c2001b2a735372b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008d694d88d54a7b7a0e8abf19d775d9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , <a class="el" href="group__std__vector__types_ga613a895eb09b0a2c56cf757f08e3b1d0.html#ga613a895eb09b0a2c56cf757f08e3b1d0">require_all_not_std_vector_t</a>&lt; M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a008d694d88d54a7b7a0e8abf19d775d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a008d694d88d54a7b7a0e8abf19d775d9.html#a008d694d88d54a7b7a0e8abf19d775d9">offset_multiplier_constrain</a> (const std::vector&lt; T &gt; &amp;x, const M &amp;mu, const S &amp;sigma, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, M, S &gt; &amp;lp)</td></tr>
<tr class="memdesc:a008d694d88d54a7b7a0e8abf19d775d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and non-array mu and sigma with lp.  <br /></td></tr>
<tr class="separator:a008d694d88d54a7b7a0e8abf19d775d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420a0d37c60c7bd6d06b54585babe066"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; M &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a420a0d37c60c7bd6d06b54585babe066"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a420a0d37c60c7bd6d06b54585babe066.html#a420a0d37c60c7bd6d06b54585babe066">offset_multiplier_constrain</a> (const std::vector&lt; T &gt; &amp;x, const M &amp;mu, const std::vector&lt; S &gt; &amp;sigma)</td></tr>
<tr class="memdesc:a420a0d37c60c7bd6d06b54585babe066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and sigma and non-array mu.  <br /></td></tr>
<tr class="separator:a420a0d37c60c7bd6d06b54585babe066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b80302340e1436f422e6cc479dda19"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; M &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a03b80302340e1436f422e6cc479dda19"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a03b80302340e1436f422e6cc479dda19.html#a03b80302340e1436f422e6cc479dda19">offset_multiplier_constrain</a> (const std::vector&lt; T &gt; &amp;x, const M &amp;mu, const std::vector&lt; S &gt; &amp;sigma, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, M, S &gt; &amp;lp)</td></tr>
<tr class="memdesc:a03b80302340e1436f422e6cc479dda19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and sigma and non-array mu with lp.  <br /></td></tr>
<tr class="separator:a03b80302340e1436f422e6cc479dda19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d13ff302785c8869fffc687eec205a1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4d13ff302785c8869fffc687eec205a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4d13ff302785c8869fffc687eec205a1.html#a4d13ff302785c8869fffc687eec205a1">offset_multiplier_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; M &gt; &amp;mu, const S &amp;sigma)</td></tr>
<tr class="memdesc:a4d13ff302785c8869fffc687eec205a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and mu and non-array sigma.  <br /></td></tr>
<tr class="separator:a4d13ff302785c8869fffc687eec205a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde7904bdf92ab67581bb39e9ab318bf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afde7904bdf92ab67581bb39e9ab318bf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afde7904bdf92ab67581bb39e9ab318bf.html#afde7904bdf92ab67581bb39e9ab318bf">offset_multiplier_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; M &gt; &amp;mu, const S &amp;sigma, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, M, S &gt; &amp;lp)</td></tr>
<tr class="memdesc:afde7904bdf92ab67581bb39e9ab318bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and mu and non-array sigma with lp.  <br /></td></tr>
<tr class="separator:afde7904bdf92ab67581bb39e9ab318bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23fd4c859fe1ca5576a41f4457f3770"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S &gt; </td></tr>
<tr class="memitem:ad23fd4c859fe1ca5576a41f4457f3770"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad23fd4c859fe1ca5576a41f4457f3770.html#ad23fd4c859fe1ca5576a41f4457f3770">offset_multiplier_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; M &gt; &amp;mu, const std::vector&lt; S &gt; &amp;sigma)</td></tr>
<tr class="memdesc:ad23fd4c859fe1ca5576a41f4457f3770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x, mu, and sigma.  <br /></td></tr>
<tr class="separator:ad23fd4c859fe1ca5576a41f4457f3770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa20a66a6ae30ec1604f35596f697be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S &gt; </td></tr>
<tr class="memitem:a2fa20a66a6ae30ec1604f35596f697be"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2fa20a66a6ae30ec1604f35596f697be.html#a2fa20a66a6ae30ec1604f35596f697be">offset_multiplier_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; M &gt; &amp;mu, const std::vector&lt; S &gt; &amp;sigma, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, M, S &gt; &amp;lp)</td></tr>
<tr class="memdesc:a2fa20a66a6ae30ec1604f35596f697be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x, mu, and sigma with lp.  <br /></td></tr>
<tr class="separator:a2fa20a66a6ae30ec1604f35596f697be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d097e81ee6fa5b85a65b651cac84b1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S &gt; </td></tr>
<tr class="memitem:a67d097e81ee6fa5b85a65b651cac84b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a67d097e81ee6fa5b85a65b651cac84b1.html#a67d097e81ee6fa5b85a65b651cac84b1">offset_multiplier_free</a> (const T &amp;y, const M &amp;mu, const S &amp;sigma)</td></tr>
<tr class="memdesc:a67d097e81ee6fa5b85a65b651cac84b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unconstrained variable that transforms to the specified offset and multiplier constrained variable given the specified offset and multiplier.  <br /></td></tr>
<tr class="separator:a67d097e81ee6fa5b85a65b651cac84b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3377532ab8d2ab913af4aa86b3ba6a8e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , <a class="el" href="group__std__vector__types_ga613a895eb09b0a2c56cf757f08e3b1d0.html#ga613a895eb09b0a2c56cf757f08e3b1d0">require_all_not_std_vector_t</a>&lt; M, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3377532ab8d2ab913af4aa86b3ba6a8e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3377532ab8d2ab913af4aa86b3ba6a8e.html#a3377532ab8d2ab913af4aa86b3ba6a8e">offset_multiplier_free</a> (const std::vector&lt; T &gt; &amp;x, const M &amp;mu, const S &amp;sigma)</td></tr>
<tr class="memdesc:a3377532ab8d2ab913af4aa86b3ba6a8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and non-array mu and sigma.  <br /></td></tr>
<tr class="separator:a3377532ab8d2ab913af4aa86b3ba6a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2070af02d9160f828e0c9cc97b9536"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; M &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0f2070af02d9160f828e0c9cc97b9536"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0f2070af02d9160f828e0c9cc97b9536.html#a0f2070af02d9160f828e0c9cc97b9536">offset_multiplier_free</a> (const std::vector&lt; T &gt; &amp;x, const M &amp;mu, const std::vector&lt; S &gt; &amp;sigma)</td></tr>
<tr class="memdesc:a0f2070af02d9160f828e0c9cc97b9536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and sigma and non-array mu.  <br /></td></tr>
<tr class="separator:a0f2070af02d9160f828e0c9cc97b9536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f66a79b120f46e613ba1f5bb9faac2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a82f66a79b120f46e613ba1f5bb9faac2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a82f66a79b120f46e613ba1f5bb9faac2.html#a82f66a79b120f46e613ba1f5bb9faac2">offset_multiplier_free</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; M &gt; &amp;mu, const S &amp;sigma)</td></tr>
<tr class="memdesc:a82f66a79b120f46e613ba1f5bb9faac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x and mu and non-array sigma.  <br /></td></tr>
<tr class="separator:a82f66a79b120f46e613ba1f5bb9faac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5341d90f34ad1845cf8803b87c86b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename M , typename S &gt; </td></tr>
<tr class="memitem:a1c5341d90f34ad1845cf8803b87c86b9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c5341d90f34ad1845cf8803b87c86b9.html#a1c5341d90f34ad1845cf8803b87c86b9">offset_multiplier_free</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; M &gt; &amp;mu, const std::vector&lt; S &gt; &amp;sigma)</td></tr>
<tr class="memdesc:a1c5341d90f34ad1845cf8803b87c86b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for array of x, mu, and sigma.  <br /></td></tr>
<tr class="separator:a1c5341d90f34ad1845cf8803b87c86b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c03837ca0481bee92ac46fd853415a"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; EigVec &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab8c03837ca0481bee92ac46fd853415a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; EigVec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab8c03837ca0481bee92ac46fd853415a.html#ab8c03837ca0481bee92ac46fd853415a">ordered_constrain</a> (const EigVec &amp;x)</td></tr>
<tr class="memdesc:ab8c03837ca0481bee92ac46fd853415a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an increasing ordered vector derived from the specified free vector.  <br /></td></tr>
<tr class="separator:ab8c03837ca0481bee92ac46fd853415a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29a5524fe8df8693351838cd520bf2e"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad29a5524fe8df8693351838cd520bf2e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad29a5524fe8df8693351838cd520bf2e.html#ad29a5524fe8df8693351838cd520bf2e">ordered_constrain</a> (const EigVec &amp;x, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigVec &gt; &amp;lp)</td></tr>
<tr class="memdesc:ad29a5524fe8df8693351838cd520bf2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a positive valued, increasing ordered vector derived from the specified free vector and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <br /></td></tr>
<tr class="separator:ad29a5524fe8df8693351838cd520bf2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce3b3e7aa50a2550bf304531a571686"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4ce3b3e7aa50a2550bf304531a571686"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4ce3b3e7aa50a2550bf304531a571686.html#a4ce3b3e7aa50a2550bf304531a571686">ordered_constrain</a> (const T &amp;x, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a4ce3b3e7aa50a2550bf304531a571686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a positive valued, increasing ordered vector derived from the specified free vector.  <br /></td></tr>
<tr class="separator:a4ce3b3e7aa50a2550bf304531a571686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac515cb0244e22b23c3d81efc938630f5"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac515cb0244e22b23c3d81efc938630f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; EigVec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac515cb0244e22b23c3d81efc938630f5.html#ac515cb0244e22b23c3d81efc938630f5">ordered_free</a> (const EigVec &amp;y)</td></tr>
<tr class="memdesc:ac515cb0244e22b23c3d81efc938630f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of unconstrained scalars that transform to the specified positive ordered vector.  <br /></td></tr>
<tr class="separator:ac515cb0244e22b23c3d81efc938630f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8139d24e2b5106f36a5a9ee7e68adb2"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab8139d24e2b5106f36a5a9ee7e68adb2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab8139d24e2b5106f36a5a9ee7e68adb2.html#ab8139d24e2b5106f36a5a9ee7e68adb2">ordered_free</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ab8139d24e2b5106f36a5a9ee7e68adb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_ac515cb0244e22b23c3d81efc938630f5.html#ac515cb0244e22b23c3d81efc938630f5" title="Return the vector of unconstrained scalars that transform to the specified positive ordered vector.">ordered_free()</a></code> to untransform each <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vector in a standard vector.  <br /></td></tr>
<tr class="separator:ab8139d24e2b5106f36a5a9ee7e68adb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed63eca605a96847ceaee18f46592ffa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed63eca605a96847ceaee18f46592ffa"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aed63eca605a96847ceaee18f46592ffa.html#aed63eca605a96847ceaee18f46592ffa">positive_constrain</a> (const T &amp;x)</td></tr>
<tr class="memdesc:aed63eca605a96847ceaee18f46592ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive value for the specified unconstrained input.  <br /></td></tr>
<tr class="separator:aed63eca605a96847ceaee18f46592ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea85d57aa65b9b62108a2b2aee0e028"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:acea85d57aa65b9b62108a2b2aee0e028"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acea85d57aa65b9b62108a2b2aee0e028.html#acea85d57aa65b9b62108a2b2aee0e028">positive_constrain</a> (const T &amp;x, S &amp;lp)</td></tr>
<tr class="memdesc:acea85d57aa65b9b62108a2b2aee0e028"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive value for the specified unconstrained input, incrementing the scalar reference with the log absolute Jacobian determinant.  <br /></td></tr>
<tr class="separator:acea85d57aa65b9b62108a2b2aee0e028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e62e6476b4bd40be4f4f3d43948697d"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4e62e6476b4bd40be4f4f3d43948697d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4e62e6476b4bd40be4f4f3d43948697d.html#a4e62e6476b4bd40be4f4f3d43948697d">positive_constrain</a> (const T &amp;x, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a4e62e6476b4bd40be4f4f3d43948697d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive value for the specified unconstrained input.  <br /></td></tr>
<tr class="separator:a4e62e6476b4bd40be4f4f3d43948697d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdf39f8f4f0754f06127f6af22ea33a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adcdf39f8f4f0754f06127f6af22ea33a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adcdf39f8f4f0754f06127f6af22ea33a.html#adcdf39f8f4f0754f06127f6af22ea33a">positive_free</a> (const T &amp;y)</td></tr>
<tr class="memdesc:adcdf39f8f4f0754f06127f6af22ea33a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unconstrained value corresponding to the specified positive-constrained value.  <br /></td></tr>
<tr class="separator:adcdf39f8f4f0754f06127f6af22ea33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cf2116783272e6bac4ad1c44478d8f"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; EigVec &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa2cf2116783272e6bac4ad1c44478d8f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa2cf2116783272e6bac4ad1c44478d8f.html#aa2cf2116783272e6bac4ad1c44478d8f">positive_ordered_constrain</a> (const EigVec &amp;x)</td></tr>
<tr class="memdesc:aa2cf2116783272e6bac4ad1c44478d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an increasing positive ordered vector derived from the specified free vector.  <br /></td></tr>
<tr class="separator:aa2cf2116783272e6bac4ad1c44478d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55b4f941c0b5cd9d47f10dd9936612a"><td class="memTemplParams" colspan="2">template&lt;typename Vec , <a class="el" href="group__col__vector__types_ga58096049cb8906ec6ad5f44f1e6fe082.html#ga58096049cb8906ec6ad5f44f1e6fe082">require_col_vector_t</a>&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af55b4f941c0b5cd9d47f10dd9936612a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af55b4f941c0b5cd9d47f10dd9936612a.html#af55b4f941c0b5cd9d47f10dd9936612a">positive_ordered_constrain</a> (const Vec &amp;x, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Vec &gt; &amp;lp)</td></tr>
<tr class="memdesc:af55b4f941c0b5cd9d47f10dd9936612a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a positive valued, increasing positive ordered vector derived from the specified free vector and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <br /></td></tr>
<tr class="separator:af55b4f941c0b5cd9d47f10dd9936612a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868920c89bc9cec6609b909d7ac88bb8"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename Vec , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a868920c89bc9cec6609b909d7ac88bb8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a868920c89bc9cec6609b909d7ac88bb8.html#a868920c89bc9cec6609b909d7ac88bb8">positive_ordered_constrain</a> (const Vec &amp;x, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Vec &gt; &amp;lp)</td></tr>
<tr class="memdesc:a868920c89bc9cec6609b909d7ac88bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a positive valued, increasing positive ordered vector derived from the specified free vector.  <br /></td></tr>
<tr class="separator:a868920c89bc9cec6609b909d7ac88bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af884fb84903d7ac0ddfb89e7d2f2035b"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af884fb84903d7ac0ddfb89e7d2f2035b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af884fb84903d7ac0ddfb89e7d2f2035b.html#af884fb84903d7ac0ddfb89e7d2f2035b">positive_ordered_constrain</a> (const T &amp;x, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:af884fb84903d7ac0ddfb89e7d2f2035b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a positive valued, increasing positive ordered vector derived from the specified free vector.  <br /></td></tr>
<tr class="separator:af884fb84903d7ac0ddfb89e7d2f2035b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f7b8f690e86347454dc50312d7e20e"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a75f7b8f690e86347454dc50312d7e20e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a75f7b8f690e86347454dc50312d7e20e.html#a75f7b8f690e86347454dc50312d7e20e">positive_ordered_free</a> (const EigVec &amp;y)</td></tr>
<tr class="memdesc:a75f7b8f690e86347454dc50312d7e20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of unconstrained scalars that transform to the specified positive ordered vector.  <br /></td></tr>
<tr class="separator:a75f7b8f690e86347454dc50312d7e20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c316e7c0b3b2f26d660d9d3c29076d"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a49c316e7c0b3b2f26d660d9d3c29076d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a49c316e7c0b3b2f26d660d9d3c29076d.html#a49c316e7c0b3b2f26d660d9d3c29076d">positive_ordered_free</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a49c316e7c0b3b2f26d660d9d3c29076d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_a75f7b8f690e86347454dc50312d7e20e.html#a75f7b8f690e86347454dc50312d7e20e" title="Return the vector of unconstrained scalars that transform to the specified positive ordered vector.">positive_ordered_free()</a></code> to untransform each <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vector in a standard vector.  <br /></td></tr>
<tr class="separator:a49c316e7c0b3b2f26d660d9d3c29076d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25230814358d3c34c873c15fd632763"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae25230814358d3c34c873c15fd632763"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae25230814358d3c34c873c15fd632763.html#ae25230814358d3c34c873c15fd632763">prob_constrain</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae25230814358d3c34c873c15fd632763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a probability value constrained to fall between 0 and 1 (inclusive) for the specified free scalar.  <br /></td></tr>
<tr class="separator:ae25230814358d3c34c873c15fd632763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19d6612c8fe53619c02ff877414ca10"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af19d6612c8fe53619c02ff877414ca10"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af19d6612c8fe53619c02ff877414ca10.html#af19d6612c8fe53619c02ff877414ca10">prob_constrain</a> (const T &amp;x, T &amp;lp)</td></tr>
<tr class="memdesc:af19d6612c8fe53619c02ff877414ca10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a probability value constrained to fall between 0 and 1 (inclusive) for the specified free scalar and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <br /></td></tr>
<tr class="separator:af19d6612c8fe53619c02ff877414ca10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21533f0a7d1376831b404ce9de0e50c5"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T &gt; </td></tr>
<tr class="memitem:a21533f0a7d1376831b404ce9de0e50c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a21533f0a7d1376831b404ce9de0e50c5.html#a21533f0a7d1376831b404ce9de0e50c5">prob_constrain</a> (const T &amp;x, T &amp;lp)</td></tr>
<tr class="memdesc:a21533f0a7d1376831b404ce9de0e50c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a probability value constrained to fall between 0 and 1 (inclusive) for the specified free scalar.  <br /></td></tr>
<tr class="separator:a21533f0a7d1376831b404ce9de0e50c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9321898b01526d513e0c9ddaf9db2fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9321898b01526d513e0c9ddaf9db2fd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af9321898b01526d513e0c9ddaf9db2fd.html#af9321898b01526d513e0c9ddaf9db2fd">prob_free</a> (const T &amp;y)</td></tr>
<tr class="memdesc:af9321898b01526d513e0c9ddaf9db2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free scalar that when transformed to a probability produces the specified scalar.  <br /></td></tr>
<tr class="separator:af9321898b01526d513e0c9ddaf9db2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4a36d8966fca12a2697170a8e2bdd8"><td class="memTemplParams" colspan="2">template&lt;typename Vec , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; Vec &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adc4a36d8966fca12a2697170a8e2bdd8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; Vec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adc4a36d8966fca12a2697170a8e2bdd8.html#adc4a36d8966fca12a2697170a8e2bdd8">simplex_constrain</a> (const Vec &amp;y)</td></tr>
<tr class="memdesc:adc4a36d8966fca12a2697170a8e2bdd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the simplex corresponding to the specified free vector.  <br /></td></tr>
<tr class="separator:adc4a36d8966fca12a2697170a8e2bdd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90ef9223b753f8da9c2aa6f6677b5fa"><td class="memTemplParams" colspan="2">template&lt;typename Vec , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; Vec &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af90ef9223b753f8da9c2aa6f6677b5fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; Vec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af90ef9223b753f8da9c2aa6f6677b5fa.html#af90ef9223b753f8da9c2aa6f6677b5fa">simplex_constrain</a> (const Vec &amp;y, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; Vec &gt; &amp;lp)</td></tr>
<tr class="memdesc:af90ef9223b753f8da9c2aa6f6677b5fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the simplex corresponding to the specified free vector and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <br /></td></tr>
<tr class="separator:af90ef9223b753f8da9c2aa6f6677b5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac676f38aa01e83fe06f738b2e43b8b8d"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename Vec , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac676f38aa01e83fe06f738b2e43b8b8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; Vec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac676f38aa01e83fe06f738b2e43b8b8d.html#ac676f38aa01e83fe06f738b2e43b8b8d">simplex_constrain</a> (const Vec &amp;y, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Vec &gt; &amp;lp)</td></tr>
<tr class="memdesc:ac676f38aa01e83fe06f738b2e43b8b8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the simplex corresponding to the specified free vector.  <br /></td></tr>
<tr class="separator:ac676f38aa01e83fe06f738b2e43b8b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c1ecd3bf9c01640f9b6e19d5683ca1"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa0c1ecd3bf9c01640f9b6e19d5683ca1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa0c1ecd3bf9c01640f9b6e19d5683ca1.html#aa0c1ecd3bf9c01640f9b6e19d5683ca1">simplex_constrain</a> (const T &amp;y, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:aa0c1ecd3bf9c01640f9b6e19d5683ca1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the simplex corresponding to the specified free vector.  <br /></td></tr>
<tr class="separator:aa0c1ecd3bf9c01640f9b6e19d5683ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b346b8733badc9722dded2fb363474"><td class="memTemplParams" colspan="2">template&lt;typename Vec , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a54b346b8733badc9722dded2fb363474"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; Vec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a54b346b8733badc9722dded2fb363474.html#a54b346b8733badc9722dded2fb363474">simplex_free</a> (const Vec &amp;x)</td></tr>
<tr class="memdesc:a54b346b8733badc9722dded2fb363474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unconstrained vector that when transformed produces the specified simplex.  <br /></td></tr>
<tr class="separator:a54b346b8733badc9722dded2fb363474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad150fb4477b2de04e654a826c2d29fda"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad150fb4477b2de04e654a826c2d29fda"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad150fb4477b2de04e654a826c2d29fda.html#ad150fb4477b2de04e654a826c2d29fda">simplex_free</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ad150fb4477b2de04e654a826c2d29fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_a54b346b8733badc9722dded2fb363474.html#a54b346b8733badc9722dded2fb363474" title="Return an unconstrained vector that when transformed produces the specified simplex.">simplex_free()</a></code> to untransform each <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vector in a standard vector.  <br /></td></tr>
<tr class="separator:ad150fb4477b2de04e654a826c2d29fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a62a1473e4c270d63c67306380a1466"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6a62a1473e4c270d63c67306380a1466"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; Mat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6a62a1473e4c270d63c67306380a1466.html#a6a62a1473e4c270d63c67306380a1466">stochastic_column_constrain</a> (const Mat &amp;y)</td></tr>
<tr class="memdesc:a6a62a1473e4c270d63c67306380a1466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column stochastic matrix.  <br /></td></tr>
<tr class="separator:a6a62a1473e4c270d63c67306380a1466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6336413adbee10eed0884d4f867f9bc"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab6336413adbee10eed0884d4f867f9bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; Mat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab6336413adbee10eed0884d4f867f9bc.html#ab6336413adbee10eed0884d4f867f9bc">stochastic_column_constrain</a> (const Mat &amp;y, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; Mat &gt; &amp;lp)</td></tr>
<tr class="memdesc:ab6336413adbee10eed0884d4f867f9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column stochastic matrix and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <br /></td></tr>
<tr class="separator:ab6336413adbee10eed0884d4f867f9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b8b9a3a70b56fe139f95465a10bbd5"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename Mat , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a95b8b9a3a70b56fe139f95465a10bbd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; Mat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a95b8b9a3a70b56fe139f95465a10bbd5.html#a95b8b9a3a70b56fe139f95465a10bbd5">stochastic_column_constrain</a> (const Mat &amp;y, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Mat &gt; &amp;lp)</td></tr>
<tr class="memdesc:a95b8b9a3a70b56fe139f95465a10bbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column stochastic matrix.  <br /></td></tr>
<tr class="separator:a95b8b9a3a70b56fe139f95465a10bbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7728c520fcbb4523d2d8920032c0c77"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab7728c520fcbb4523d2d8920032c0c77"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab7728c520fcbb4523d2d8920032c0c77.html#ab7728c520fcbb4523d2d8920032c0c77">stochastic_column_constrain</a> (const T &amp;y, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:ab7728c520fcbb4523d2d8920032c0c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of column stochastic matrices.  <br /></td></tr>
<tr class="separator:ab7728c520fcbb4523d2d8920032c0c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8202de413590a285f8836ede2cee1837"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8202de413590a285f8836ede2cee1837"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; Mat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8202de413590a285f8836ede2cee1837.html#a8202de413590a285f8836ede2cee1837">stochastic_column_free</a> (const Mat &amp;y)</td></tr>
<tr class="memdesc:a8202de413590a285f8836ede2cee1837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unconstrained matrix that when transformed produces the specified columnwise stochastic matrix.  <br /></td></tr>
<tr class="separator:a8202de413590a285f8836ede2cee1837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f22f95e2683c551e68edcd9f025b39"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a30f22f95e2683c551e68edcd9f025b39"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a30f22f95e2683c551e68edcd9f025b39.html#a30f22f95e2683c551e68edcd9f025b39">stochastic_column_free</a> (const T &amp;y)</td></tr>
<tr class="memdesc:a30f22f95e2683c551e68edcd9f025b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that untransforms each <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix in a standard vector.  <br /></td></tr>
<tr class="separator:a30f22f95e2683c551e68edcd9f025b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4c0a3655f6adc25955110252b9ae9c"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2e4c0a3655f6adc25955110252b9ae9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; Mat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2e4c0a3655f6adc25955110252b9ae9c.html#a2e4c0a3655f6adc25955110252b9ae9c">stochastic_row_constrain</a> (const Mat &amp;y)</td></tr>
<tr class="memdesc:a2e4c0a3655f6adc25955110252b9ae9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row stochastic matrix.  <br /></td></tr>
<tr class="separator:a2e4c0a3655f6adc25955110252b9ae9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f28cfa6bf438e8e04813c3becf4c3bc"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2f28cfa6bf438e8e04813c3becf4c3bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; Mat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f28cfa6bf438e8e04813c3becf4c3bc.html#a2f28cfa6bf438e8e04813c3becf4c3bc">stochastic_row_constrain</a> (const Mat &amp;y, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; Mat &gt; &amp;lp)</td></tr>
<tr class="memdesc:a2f28cfa6bf438e8e04813c3becf4c3bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row stochastic matrix.  <br /></td></tr>
<tr class="separator:a2f28cfa6bf438e8e04813c3becf4c3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9beed507ced2ed6d8d9a3eb92f170b"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename Mat , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aca9beed507ced2ed6d8d9a3eb92f170b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; Mat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aca9beed507ced2ed6d8d9a3eb92f170b.html#aca9beed507ced2ed6d8d9a3eb92f170b">stochastic_row_constrain</a> (const Mat &amp;y, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Mat &gt; &amp;lp)</td></tr>
<tr class="memdesc:aca9beed507ced2ed6d8d9a3eb92f170b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row stochastic matrix.  <br /></td></tr>
<tr class="separator:aca9beed507ced2ed6d8d9a3eb92f170b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f21ec8a1a867ee309f03e7b55694919"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6f21ec8a1a867ee309f03e7b55694919"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6f21ec8a1a867ee309f03e7b55694919.html#a6f21ec8a1a867ee309f03e7b55694919">stochastic_row_constrain</a> (const T &amp;y, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a6f21ec8a1a867ee309f03e7b55694919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row stochastic matrix.  <br /></td></tr>
<tr class="separator:a6f21ec8a1a867ee309f03e7b55694919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b460b22d036ba1bd2665d311ec2843"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a45b460b22d036ba1bd2665d311ec2843"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; Mat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a45b460b22d036ba1bd2665d311ec2843.html#a45b460b22d036ba1bd2665d311ec2843">stochastic_row_free</a> (const Mat &amp;y)</td></tr>
<tr class="memdesc:a45b460b22d036ba1bd2665d311ec2843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unconstrained matrix that when transformed produces the specified simplex matrix.  <br /></td></tr>
<tr class="separator:a45b460b22d036ba1bd2665d311ec2843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22738a29ea48154c9bcf15aafc34d4d7"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a22738a29ea48154c9bcf15aafc34d4d7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a22738a29ea48154c9bcf15aafc34d4d7.html#a22738a29ea48154c9bcf15aafc34d4d7">stochastic_row_free</a> (const T &amp;y)</td></tr>
<tr class="memdesc:a22738a29ea48154c9bcf15aafc34d4d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload that untransforms each <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix in a standard vector.  <br /></td></tr>
<tr class="separator:a22738a29ea48154c9bcf15aafc34d4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978484567ee8e0ac36fc062478b0c4d0"><td class="memTemplParams" colspan="2">template&lt;typename Vec , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; Vec &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a978484567ee8e0ac36fc062478b0c4d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; Vec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a978484567ee8e0ac36fc062478b0c4d0.html#a978484567ee8e0ac36fc062478b0c4d0">sum_to_zero_constrain</a> (const Vec &amp;y)</td></tr>
<tr class="memdesc:a978484567ee8e0ac36fc062478b0c4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector with sum zero corresponding to the specified free vector.  <br /></td></tr>
<tr class="separator:a978484567ee8e0ac36fc062478b0c4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4576e04b5021ddb22f9143f179fa4e"><td class="memTemplParams" colspan="2">template&lt;typename Vec , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; Vec &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2a4576e04b5021ddb22f9143f179fa4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; Vec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2a4576e04b5021ddb22f9143f179fa4e.html#a2a4576e04b5021ddb22f9143f179fa4e">sum_to_zero_constrain</a> (const Vec &amp;y, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; Vec &gt; &amp;lp)</td></tr>
<tr class="memdesc:a2a4576e04b5021ddb22f9143f179fa4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector with sum zero corresponding to the specified free vector.  <br /></td></tr>
<tr class="separator:a2a4576e04b5021ddb22f9143f179fa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb7c97963e3113fa077acd2396bc422"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename Vec , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6bb7c97963e3113fa077acd2396bc422"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; Vec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6bb7c97963e3113fa077acd2396bc422.html#a6bb7c97963e3113fa077acd2396bc422">sum_to_zero_constrain</a> (const Vec &amp;y, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Vec &gt; &amp;lp)</td></tr>
<tr class="memdesc:a6bb7c97963e3113fa077acd2396bc422"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector with sum zero corresponding to the specified free vector.  <br /></td></tr>
<tr class="separator:a6bb7c97963e3113fa077acd2396bc422"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fa0c7872b6c4dea96e39701c992d6e"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab4fa0c7872b6c4dea96e39701c992d6e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab4fa0c7872b6c4dea96e39701c992d6e.html#ab4fa0c7872b6c4dea96e39701c992d6e">sum_to_zero_constrain</a> (const T &amp;y, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:ab4fa0c7872b6c4dea96e39701c992d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector with sum zero corresponding to the specified free vector.  <br /></td></tr>
<tr class="separator:ab4fa0c7872b6c4dea96e39701c992d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405b30403d1d6ce98803351c0f1f6259"><td class="memTemplParams" colspan="2">template&lt;typename Vec , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a405b30403d1d6ce98803351c0f1f6259"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; Vec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a405b30403d1d6ce98803351c0f1f6259.html#a405b30403d1d6ce98803351c0f1f6259">sum_to_zero_free</a> (const Vec &amp;z)</td></tr>
<tr class="memdesc:a405b30403d1d6ce98803351c0f1f6259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an unconstrained vector.  <br /></td></tr>
<tr class="separator:a405b30403d1d6ce98803351c0f1f6259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a086443840545ff94a1a263d6543f812f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a086443840545ff94a1a263d6543f812f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a086443840545ff94a1a263d6543f812f.html#a086443840545ff94a1a263d6543f812f">sum_to_zero_free</a> (const T &amp;z)</td></tr>
<tr class="memdesc:a086443840545ff94a1a263d6543f812f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_a405b30403d1d6ce98803351c0f1f6259.html#a405b30403d1d6ce98803351c0f1f6259" title="Return an unconstrained vector.">sum_to_zero_free()</a></code> to untransform each <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vector in a standard vector.  <br /></td></tr>
<tr class="separator:a086443840545ff94a1a263d6543f812f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666f5bf87f93b1af9a38ec74db82a306"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T, U &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; T, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a666f5bf87f93b1af9a38ec74db82a306"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a666f5bf87f93b1af9a38ec74db82a306.html#a666f5bf87f93b1af9a38ec74db82a306">ub_constrain</a> (const T &amp;x, const U &amp;ub)</td></tr>
<tr class="memdesc:a666f5bf87f93b1af9a38ec74db82a306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper-bounded value for the specified unconstrained matrix and upper bound.  <br /></td></tr>
<tr class="separator:a666f5bf87f93b1af9a38ec74db82a306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6675b7dce9dea3ac56b0e94e515e6f08"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T, U &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; T, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6675b7dce9dea3ac56b0e94e515e6f08"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6675b7dce9dea3ac56b0e94e515e6f08.html#a6675b7dce9dea3ac56b0e94e515e6f08">ub_constrain</a> (const T &amp;x, const U &amp;ub, std::decay_t&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, U &gt; &gt; &amp;lp)</td></tr>
<tr class="memdesc:a6675b7dce9dea3ac56b0e94e515e6f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the upper-bounded value for the specified unconstrained scalar and upper bound and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <br /></td></tr>
<tr class="separator:a6675b7dce9dea3ac56b0e94e515e6f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2303e293a67f40dc322920d6dec977"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; U &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; T, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1c2303e293a67f40dc322920d6dec977"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c2303e293a67f40dc322920d6dec977.html#a1c2303e293a67f40dc322920d6dec977">ub_constrain</a> (const T &amp;x, const U &amp;ub)</td></tr>
<tr class="memdesc:a1c2303e293a67f40dc322920d6dec977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>ub_constrain</code> to apply a scalar upper bound elementwise to each input.  <br /></td></tr>
<tr class="separator:a1c2303e293a67f40dc322920d6dec977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ce8b1fd5ab1d141f414d3f93f5ca04"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; U &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; T, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a07ce8b1fd5ab1d141f414d3f93f5ca04"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a07ce8b1fd5ab1d141f414d3f93f5ca04.html#a07ce8b1fd5ab1d141f414d3f93f5ca04">ub_constrain</a> (const T &amp;x, const U &amp;ub, std::decay_t&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, U &gt; &gt; &amp;lp)</td></tr>
<tr class="memdesc:a07ce8b1fd5ab1d141f414d3f93f5ca04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>ub_constrain</code> to apply a scalar upper bound elementwise to each input.  <br /></td></tr>
<tr class="separator:a07ce8b1fd5ab1d141f414d3f93f5ca04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ac7e19032e4502a5478be859881dbb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af7ac7e19032e4502a5478be859881dbb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af7ac7e19032e4502a5478be859881dbb.html#af7ac7e19032e4502a5478be859881dbb">ub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const U &amp;ub)</td></tr>
<tr class="memdesc:af7ac7e19032e4502a5478be859881dbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>ub_constrain</code> to apply a scalar upper bound elementwise to each input element.  <br /></td></tr>
<tr class="separator:af7ac7e19032e4502a5478be859881dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e60eeb19caa5c6072ca5dff1adf2c74"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9e60eeb19caa5c6072ca5dff1adf2c74"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9e60eeb19caa5c6072ca5dff1adf2c74.html#a9e60eeb19caa5c6072ca5dff1adf2c74">ub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:a9e60eeb19caa5c6072ca5dff1adf2c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>ub_constrain</code> to apply a scalar upper bound elementwise to each input element.  <br /></td></tr>
<tr class="separator:a9e60eeb19caa5c6072ca5dff1adf2c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae474e7fa4f18fe7384f24e206640aa31"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae474e7fa4f18fe7384f24e206640aa31"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae474e7fa4f18fe7384f24e206640aa31.html#ae474e7fa4f18fe7384f24e206640aa31">ub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; U &gt; &amp;ub)</td></tr>
<tr class="memdesc:ae474e7fa4f18fe7384f24e206640aa31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>ub_constrain</code> to apply a container of upper bounds elementwise to each input element.  <br /></td></tr>
<tr class="separator:ae474e7fa4f18fe7384f24e206640aa31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf661ccd6745adbac3940b0faee75208"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:acf661ccd6745adbac3940b0faee75208"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acf661ccd6745adbac3940b0faee75208.html#acf661ccd6745adbac3940b0faee75208">ub_constrain</a> (const std::vector&lt; T &gt; &amp;x, const std::vector&lt; U &gt; &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:acf661ccd6745adbac3940b0faee75208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>ub_constrain</code> to apply a container of upper bounds elementwise to each input element.  <br /></td></tr>
<tr class="separator:acf661ccd6745adbac3940b0faee75208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899ee13b8e9448f30833fe4d23849d52"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , typename U &gt; </td></tr>
<tr class="memitem:a899ee13b8e9448f30833fe4d23849d52"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a899ee13b8e9448f30833fe4d23849d52.html#a899ee13b8e9448f30833fe4d23849d52">ub_constrain</a> (const T &amp;x, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:a899ee13b8e9448f30833fe4d23849d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>ub_constrain</code> to apply a container of upper bounds elementwise to each input element.  <br /></td></tr>
<tr class="separator:a899ee13b8e9448f30833fe4d23849d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd887af855dafd1c0c1ee5155fbbe45"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8dd887af855dafd1c0c1ee5155fbbe45"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8dd887af855dafd1c0c1ee5155fbbe45.html#a8dd887af855dafd1c0c1ee5155fbbe45">ub_free</a> (T &amp;&amp;y, U &amp;&amp;ub)</td></tr>
<tr class="memdesc:a8dd887af855dafd1c0c1ee5155fbbe45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free scalar that corresponds to the specified upper-bounded value with respect to the specified upper bound.  <br /></td></tr>
<tr class="separator:a8dd887af855dafd1c0c1ee5155fbbe45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c1eaf483574499f7817d12b654b90a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; T, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac0c1eaf483574499f7817d12b654b90a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac0c1eaf483574499f7817d12b654b90a.html#ac0c1eaf483574499f7817d12b654b90a">ub_free</a> (T &amp;&amp;y, U &amp;&amp;ub)</td></tr>
<tr class="memdesc:ac0c1eaf483574499f7817d12b654b90a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free matrix that corresponds to the specified upper-bounded matrix with respect to the specified upper bound.  <br /></td></tr>
<tr class="separator:ac0c1eaf483574499f7817d12b654b90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5352791751a23470cee51da867b2914a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5352791751a23470cee51da867b2914a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5352791751a23470cee51da867b2914a.html#a5352791751a23470cee51da867b2914a">ub_free</a> (const std::vector&lt; T &gt; y, const U &amp;ub)</td></tr>
<tr class="memdesc:a5352791751a23470cee51da867b2914a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free variable that corresponds to the specified upper-bounded variable with respect to the specified upper bound.  <br /></td></tr>
<tr class="separator:a5352791751a23470cee51da867b2914a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9485fee45feb064415cb66467891d2d8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a9485fee45feb064415cb66467891d2d8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9485fee45feb064415cb66467891d2d8.html#a9485fee45feb064415cb66467891d2d8">ub_free</a> (const std::vector&lt; T &gt; y, const std::vector&lt; U &gt; &amp;ub)</td></tr>
<tr class="memdesc:a9485fee45feb064415cb66467891d2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the free variable that corresponds to the specified upper-bounded variable with respect to the specified upper bound.  <br /></td></tr>
<tr class="separator:a9485fee45feb064415cb66467891d2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18e3acd6642e37f84eeebf6a3af32e00"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__autodiff__types_ga3d4ce7e2eb4fc700d81bd5f082a1bae9.html#ga3d4ce7e2eb4fc700d81bd5f082a1bae9">require_not_vt_autodiff</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a18e3acd6642e37f84eeebf6a3af32e00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a18e3acd6642e37f84eeebf6a3af32e00.html#a18e3acd6642e37f84eeebf6a3af32e00">unit_vector_constrain</a> (const T &amp;y)</td></tr>
<tr class="memdesc:a18e3acd6642e37f84eeebf6a3af32e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the free vector y.  <br /></td></tr>
<tr class="separator:a18e3acd6642e37f84eeebf6a3af32e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad492c5c7025b329d734939844c698e19"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__autodiff__types_ga93acf9a608eec9a14494f60ffd9f5349.html#ga93acf9a608eec9a14494f60ffd9f5349">require_all_not_vt_autodiff</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad492c5c7025b329d734939844c698e19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad492c5c7025b329d734939844c698e19.html#ad492c5c7025b329d734939844c698e19">unit_vector_constrain</a> (const T1 &amp;y, T2 &amp;lp)</td></tr>
<tr class="memdesc:ad492c5c7025b329d734939844c698e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the free vector y.  <br /></td></tr>
<tr class="separator:ad492c5c7025b329d734939844c698e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc19ec92cfbdaaa96ee9f2921347ad3"><td class="memTemplParams" colspan="2">template&lt;bool Jacobian, typename T , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afdc19ec92cfbdaaa96ee9f2921347ad3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afdc19ec92cfbdaaa96ee9f2921347ad3.html#afdc19ec92cfbdaaa96ee9f2921347ad3">unit_vector_constrain</a> (const T &amp;y, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:afdc19ec92cfbdaaa96ee9f2921347ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the free vector y.  <br /></td></tr>
<tr class="separator:afdc19ec92cfbdaaa96ee9f2921347ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69fba3e6524e671b4db41ba42769689"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa69fba3e6524e671b4db41ba42769689"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa69fba3e6524e671b4db41ba42769689.html#aa69fba3e6524e671b4db41ba42769689">unit_vector_free</a> (EigVec &amp;&amp;x)</td></tr>
<tr class="memdesc:aa69fba3e6524e671b4db41ba42769689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformation of a unit length vector to a "free" vector However, we are just fixing the unidentified radius to 1.  <br /></td></tr>
<tr class="separator:aa69fba3e6524e671b4db41ba42769689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ef9f1e782bc7f7a0f2f91e806b338b"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab8ef9f1e782bc7f7a0f2f91e806b338b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab8ef9f1e782bc7f7a0f2f91e806b338b.html#ab8ef9f1e782bc7f7a0f2f91e806b338b">unit_vector_free</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ab8ef9f1e782bc7f7a0f2f91e806b338b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of <code><a class="el" href="namespacestan_1_1math_aa69fba3e6524e671b4db41ba42769689.html#aa69fba3e6524e671b4db41ba42769689" title="Transformation of a unit length vector to a &quot;free&quot; vector However, we are just fixing the unidentifie...">unit_vector_free()</a></code> to untransform each <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vector in a standard vector.  <br /></td></tr>
<tr class="separator:ab8ef9f1e782bc7f7a0f2f91e806b338b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3522b9dd5363aa36a443427bfe2b43ae"><td class="memItemLeft" align="right" valign="top">tbb::task_arena &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3522b9dd5363aa36a443427bfe2b43ae.html#a3522b9dd5363aa36a443427bfe2b43ae">init_threadpool_tbb</a> (int n_threads=0)</td></tr>
<tr class="memdesc:a3522b9dd5363aa36a443427bfe2b43ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the Intel TBB threadpool and global scheduler through the tbb::task_arena object.  <br /></td></tr>
<tr class="separator:a3522b9dd5363aa36a443427bfe2b43ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff54c0903532bf5e407e84d00a3a0b9"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeff54c0903532bf5e407e84d00a3a0b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeff54c0903532bf5e407e84d00a3a0b9.html#aeff54c0903532bf5e407e84d00a3a0b9">operator+</a> (const std::complex&lt; U &gt; &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:aeff54c0903532bf5e407e84d00a3a0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the arguments.  <br /></td></tr>
<tr class="separator:aeff54c0903532bf5e407e84d00a3a0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e75c024ac7a42abaf1d89223f3a62a3"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3e75c024ac7a42abaf1d89223f3a62a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3e75c024ac7a42abaf1d89223f3a62a3.html#a3e75c024ac7a42abaf1d89223f3a62a3">operator+</a> (const std::complex&lt; U &gt; &amp;x, const V &amp;y)</td></tr>
<tr class="memdesc:a3e75c024ac7a42abaf1d89223f3a62a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the arguments.  <br /></td></tr>
<tr class="separator:a3e75c024ac7a42abaf1d89223f3a62a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33decc665c837092ea0f8e80d41c4861"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a33decc665c837092ea0f8e80d41c4861"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a33decc665c837092ea0f8e80d41c4861.html#a33decc665c837092ea0f8e80d41c4861">operator+</a> (const U &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a33decc665c837092ea0f8e80d41c4861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the arguments.  <br /></td></tr>
<tr class="separator:a33decc665c837092ea0f8e80d41c4861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb05dc88a8b0f671a382d61fb0f30162"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afb05dc88a8b0f671a382d61fb0f30162"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afb05dc88a8b0f671a382d61fb0f30162.html#afb05dc88a8b0f671a382d61fb0f30162">operator/</a> (const std::complex&lt; U &gt; &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:afb05dc88a8b0f671a382d61fb0f30162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quotient of the arguments.  <br /></td></tr>
<tr class="separator:afb05dc88a8b0f671a382d61fb0f30162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd45ba81dd5f8bd34ea13a4f633e82c"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1dd45ba81dd5f8bd34ea13a4f633e82c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1dd45ba81dd5f8bd34ea13a4f633e82c.html#a1dd45ba81dd5f8bd34ea13a4f633e82c">operator/</a> (const std::complex&lt; U &gt; &amp;x, const V &amp;y)</td></tr>
<tr class="memdesc:a1dd45ba81dd5f8bd34ea13a4f633e82c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quotient of the arguments.  <br /></td></tr>
<tr class="separator:a1dd45ba81dd5f8bd34ea13a4f633e82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7068d29f551f39cdeffb37de62ad089d"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7068d29f551f39cdeffb37de62ad089d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7068d29f551f39cdeffb37de62ad089d.html#a7068d29f551f39cdeffb37de62ad089d">operator/</a> (const U &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a7068d29f551f39cdeffb37de62ad089d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quotient of the arguments.  <br /></td></tr>
<tr class="separator:a7068d29f551f39cdeffb37de62ad089d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195f15fbf20fbc98a2d2f57121159077"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , typename  = require_any_autodiff_t&lt;U, V&gt;&gt; </td></tr>
<tr class="memitem:a195f15fbf20fbc98a2d2f57121159077"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a195f15fbf20fbc98a2d2f57121159077.html#a195f15fbf20fbc98a2d2f57121159077">operator==</a> (const std::complex&lt; U &gt; &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a195f15fbf20fbc98a2d2f57121159077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the complex numbers have equal imaginary and complex parts.  <br /></td></tr>
<tr class="separator:a195f15fbf20fbc98a2d2f57121159077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e199182f935e870d4cf241650deb6c"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , typename  = require_any_autodiff_t&lt;U, V&gt;&gt; </td></tr>
<tr class="memitem:af5e199182f935e870d4cf241650deb6c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af5e199182f935e870d4cf241650deb6c.html#af5e199182f935e870d4cf241650deb6c">operator==</a> (const std::complex&lt; U &gt; &amp;x, const V &amp;y)</td></tr>
<tr class="memdesc:af5e199182f935e870d4cf241650deb6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the first argument's real part is equal to the second argument and the first argument's imaginary part is zero.  <br /></td></tr>
<tr class="separator:af5e199182f935e870d4cf241650deb6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a741f95136b479057bf320dd30d2a0c75"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , typename  = require_any_autodiff_t&lt;U, V&gt;&gt; </td></tr>
<tr class="memitem:a741f95136b479057bf320dd30d2a0c75"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a741f95136b479057bf320dd30d2a0c75.html#a741f95136b479057bf320dd30d2a0c75">operator==</a> (const U &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a741f95136b479057bf320dd30d2a0c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the first argument is equal to the real part of the second argument and the imaginary part of the second argument is zero.  <br /></td></tr>
<tr class="separator:a741f95136b479057bf320dd30d2a0c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab3df0c448874e3544ba082ab6503ce"><td class="memTemplParams" colspan="2">template&lt;typename U , <a class="el" href="group__autodiff__types_ga9c0ebeb539d0429f2cbceb0fdb24c2d6.html#ga9c0ebeb539d0429f2cbceb0fdb24c2d6">require_autodiff_t</a>&lt; U &gt; &gt; </td></tr>
<tr class="memitem:afab3df0c448874e3544ba082ab6503ce"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afab3df0c448874e3544ba082ab6503ce.html#afab3df0c448874e3544ba082ab6503ce">operator-</a> (const std::complex&lt; U &gt; &amp;x)</td></tr>
<tr class="memdesc:afab3df0c448874e3544ba082ab6503ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negation of the argument.  <br /></td></tr>
<tr class="separator:afab3df0c448874e3544ba082ab6503ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ced51fd02718432d52faf979e524702"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0ced51fd02718432d52faf979e524702"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0ced51fd02718432d52faf979e524702.html#a0ced51fd02718432d52faf979e524702">operator*</a> (const std::complex&lt; U &gt; &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a0ced51fd02718432d52faf979e524702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the arguments.  <br /></td></tr>
<tr class="separator:a0ced51fd02718432d52faf979e524702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef46b01b88a49261b2a24be964b75476"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aef46b01b88a49261b2a24be964b75476"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aef46b01b88a49261b2a24be964b75476.html#aef46b01b88a49261b2a24be964b75476">operator*</a> (const std::complex&lt; U &gt; &amp;x, const V &amp;y)</td></tr>
<tr class="memdesc:aef46b01b88a49261b2a24be964b75476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the arguments.  <br /></td></tr>
<tr class="separator:aef46b01b88a49261b2a24be964b75476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70eed062ae832846c2322593c192e360"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a70eed062ae832846c2322593c192e360"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a70eed062ae832846c2322593c192e360.html#a70eed062ae832846c2322593c192e360">operator*</a> (const U &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a70eed062ae832846c2322593c192e360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the arguments.  <br /></td></tr>
<tr class="separator:a70eed062ae832846c2322593c192e360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae989ec3ea8ef118937939696a28086d4"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , typename  = require_any_autodiff_t&lt;U, V&gt;&gt; </td></tr>
<tr class="memitem:ae989ec3ea8ef118937939696a28086d4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae989ec3ea8ef118937939696a28086d4.html#ae989ec3ea8ef118937939696a28086d4">operator!=</a> (const std::complex&lt; U &gt; &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:ae989ec3ea8ef118937939696a28086d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the complex numbers have unequal imaginary or complex parts.  <br /></td></tr>
<tr class="separator:ae989ec3ea8ef118937939696a28086d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0a408d5c595e9e8f866affd1484cfe"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , typename  = require_any_autodiff_t&lt;U, V&gt;&gt; </td></tr>
<tr class="memitem:a0f0a408d5c595e9e8f866affd1484cfe"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0f0a408d5c595e9e8f866affd1484cfe.html#a0f0a408d5c595e9e8f866affd1484cfe">operator!=</a> (const std::complex&lt; U &gt; &amp;x, const V &amp;y)</td></tr>
<tr class="memdesc:a0f0a408d5c595e9e8f866affd1484cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the first argument's real part is unequal to the second argument or the first argument's imaginary part is unequal to zero.  <br /></td></tr>
<tr class="separator:a0f0a408d5c595e9e8f866affd1484cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0f07626698e5b8b1aaffb5aaed36a5"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , typename  = require_any_autodiff_t&lt;U, V&gt;&gt; </td></tr>
<tr class="memitem:a3f0f07626698e5b8b1aaffb5aaed36a5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3f0f07626698e5b8b1aaffb5aaed36a5.html#a3f0f07626698e5b8b1aaffb5aaed36a5">operator!=</a> (const U &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a3f0f07626698e5b8b1aaffb5aaed36a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the first argument is unequal to the real part of the second argument or the imaginary part of the second argument is nonzero.  <br /></td></tr>
<tr class="separator:a3f0f07626698e5b8b1aaffb5aaed36a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128909c1de733dea464f823ee1e3fe41"><td class="memTemplParams" colspan="2">template&lt;typename U , <a class="el" href="group__autodiff__types_ga9c0ebeb539d0429f2cbceb0fdb24c2d6.html#ga9c0ebeb539d0429f2cbceb0fdb24c2d6">require_autodiff_t</a>&lt; U &gt; &gt; </td></tr>
<tr class="memitem:a128909c1de733dea464f823ee1e3fe41"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a128909c1de733dea464f823ee1e3fe41.html#a128909c1de733dea464f823ee1e3fe41">operator+</a> (const std::complex&lt; U &gt; &amp;x)</td></tr>
<tr class="memdesc:a128909c1de733dea464f823ee1e3fe41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the argument.  <br /></td></tr>
<tr class="separator:a128909c1de733dea464f823ee1e3fe41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd26976360f67c83f3121c9c7188baea"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acd26976360f67c83f3121c9c7188baea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acd26976360f67c83f3121c9c7188baea.html#acd26976360f67c83f3121c9c7188baea">operator-</a> (const std::complex&lt; U &gt; &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:acd26976360f67c83f3121c9c7188baea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of the arguments.  <br /></td></tr>
<tr class="separator:acd26976360f67c83f3121c9c7188baea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76130e175f11d442d96b83b65bd29f1c"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a76130e175f11d442d96b83b65bd29f1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a76130e175f11d442d96b83b65bd29f1c.html#a76130e175f11d442d96b83b65bd29f1c">operator-</a> (const std::complex&lt; U &gt; &amp;x, const V &amp;y)</td></tr>
<tr class="memdesc:a76130e175f11d442d96b83b65bd29f1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of the arguments.  <br /></td></tr>
<tr class="separator:a76130e175f11d442d96b83b65bd29f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b476c64480b35e113e137deede6891f"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6b476c64480b35e113e137deede6891f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; U, V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6b476c64480b35e113e137deede6891f.html#a6b476c64480b35e113e137deede6891f">operator-</a> (const U &amp;x, const std::complex&lt; V &gt; &amp;y)</td></tr>
<tr class="memdesc:a6b476c64480b35e113e137deede6891f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference of the arguments.  <br /></td></tr>
<tr class="separator:a6b476c64480b35e113e137deede6891f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6af9d11f53a6f29c046f6115aa590df"><td class="memTemplParams" colspan="2">template&lt;typename T_a1 , typename T_a2 , typename T_b1 , typename T_z &gt; </td></tr>
<tr class="memitem:ac6af9d11f53a6f29c046f6115aa590df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac6af9d11f53a6f29c046f6115aa590df.html#ac6af9d11f53a6f29c046f6115aa590df">check_2F1_converges</a> (const char *function, const T_a1 &amp;a1, const T_a2 &amp;a2, const T_b1 &amp;b1, const T_z &amp;z)</td></tr>
<tr class="memdesc:ac6af9d11f53a6f29c046f6115aa590df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the hypergeometric function (2F1) called with supplied arguments will converge, assuming arguments are finite values.  <br /></td></tr>
<tr class="separator:ac6af9d11f53a6f29c046f6115aa590df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22116acf47af3e2218f3be543a4ca12a"><td class="memTemplParams" colspan="2">template&lt;typename T_a1 , typename T_a2 , typename T_a3 , typename T_b1 , typename T_b2 , typename T_z &gt; </td></tr>
<tr class="memitem:a22116acf47af3e2218f3be543a4ca12a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a22116acf47af3e2218f3be543a4ca12a.html#a22116acf47af3e2218f3be543a4ca12a">check_3F2_converges</a> (const char *function, const T_a1 &amp;a1, const T_a2 &amp;a2, const T_a3 &amp;a3, const T_b1 &amp;b1, const T_b2 &amp;b2, const T_z &amp;z)</td></tr>
<tr class="memdesc:a22116acf47af3e2218f3be543a4ca12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the hypergeometric function (3F2) called with supplied arguments will converge, assuming arguments are finite values.  <br /></td></tr>
<tr class="separator:a22116acf47af3e2218f3be543a4ca12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34458c3e7913f9144a493b53f2ae115c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:a34458c3e7913f9144a493b53f2ae115c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a34458c3e7913f9144a493b53f2ae115c.html#a34458c3e7913f9144a493b53f2ae115c">check_bounded</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low, const T_high &amp;high)</td></tr>
<tr class="memdesc:a34458c3e7913f9144a493b53f2ae115c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the value is between the low and high values, inclusively.  <br /></td></tr>
<tr class="separator:a34458c3e7913f9144a493b53f2ae115c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeaa2aa71151491e1e3f19831b6bd8f8"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abeaa2aa71151491e1e3f19831b6bd8f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abeaa2aa71151491e1e3f19831b6bd8f8.html#abeaa2aa71151491e1e3f19831b6bd8f8">check_cholesky_factor</a> (const char *function, const char *name, const Mat &amp;y)</td></tr>
<tr class="memdesc:abeaa2aa71151491e1e3f19831b6bd8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a valid Cholesky factor.  <br /></td></tr>
<tr class="separator:abeaa2aa71151491e1e3f19831b6bd8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85764c1169b4d0e2baba67e62236914a"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a85764c1169b4d0e2baba67e62236914a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a85764c1169b4d0e2baba67e62236914a.html#a85764c1169b4d0e2baba67e62236914a">check_cholesky_factor</a> (const char *function, const char *name, const StdVec &amp;y)</td></tr>
<tr class="memdesc:a85764c1169b4d0e2baba67e62236914a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a valid Cholesky factor.  <br /></td></tr>
<tr class="separator:a85764c1169b4d0e2baba67e62236914a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a7068a0736e3f680a8c122ae34c78e"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a40a7068a0736e3f680a8c122ae34c78e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a40a7068a0736e3f680a8c122ae34c78e.html#a40a7068a0736e3f680a8c122ae34c78e">check_cholesky_factor_corr</a> (const char *function, const char *name, const Mat &amp;y)</td></tr>
<tr class="memdesc:a40a7068a0736e3f680a8c122ae34c78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a valid Cholesky factor of a correlation matrix.  <br /></td></tr>
<tr class="separator:a40a7068a0736e3f680a8c122ae34c78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d48f388adc59a512ae1d87e69c6a3db"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5d48f388adc59a512ae1d87e69c6a3db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5d48f388adc59a512ae1d87e69c6a3db.html#a5d48f388adc59a512ae1d87e69c6a3db">check_cholesky_factor_corr</a> (const char *function, const char *name, const StdVec &amp;y)</td></tr>
<tr class="memdesc:a5d48f388adc59a512ae1d87e69c6a3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a valid Cholesky factor of a correlation matrix.  <br /></td></tr>
<tr class="separator:a5d48f388adc59a512ae1d87e69c6a3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3ef7efe82fd0f280dbf50c08ef2b00"><td class="memTemplParams" colspan="2">template&lt;typename T_y , <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>&lt; T_y &gt;, <a class="el" href="structstan_1_1is__prim__or__rev__kernel__expression.html">is_prim_or_rev_kernel_expression</a>&lt; T_y &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9a3ef7efe82fd0f280dbf50c08ef2b00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9a3ef7efe82fd0f280dbf50c08ef2b00.html#a9a3ef7efe82fd0f280dbf50c08ef2b00">check_column_index</a> (const char *function, const char *name, const T_y &amp;y, size_t i)</td></tr>
<tr class="memdesc:a9a3ef7efe82fd0f280dbf50c08ef2b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified index is a valid column of the matrix.  <br /></td></tr>
<tr class="separator:a9a3ef7efe82fd0f280dbf50c08ef2b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef521f8fa317b4a0d987968f27705af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4ef521f8fa317b4a0d987968f27705af"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4ef521f8fa317b4a0d987968f27705af.html#a4ef521f8fa317b4a0d987968f27705af">check_consistent_size</a> (const char *function, const char *name, const T &amp;x, size_t expected_size)</td></tr>
<tr class="memdesc:a4ef521f8fa317b4a0d987968f27705af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>x</code> is consistent with size <code>expected_size</code>.  <br /></td></tr>
<tr class="separator:a4ef521f8fa317b4a0d987968f27705af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db1371ee167e2c301cef8e504efe8e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7db1371ee167e2c301cef8e504efe8e8.html#a7db1371ee167e2c301cef8e504efe8e8">check_consistent_sizes</a> (const char *)</td></tr>
<tr class="memdesc:a7db1371ee167e2c301cef8e504efe8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial no input case, this function is a no-op.  <br /></td></tr>
<tr class="separator:a7db1371ee167e2c301cef8e504efe8e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f3e6fa8b71cef479e1f2d762513951"><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr class="memitem:a92f3e6fa8b71cef479e1f2d762513951"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a92f3e6fa8b71cef479e1f2d762513951.html#a92f3e6fa8b71cef479e1f2d762513951">check_consistent_sizes</a> (const char *, const char *, const T1 &amp;)</td></tr>
<tr class="memdesc:a92f3e6fa8b71cef479e1f2d762513951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base case of recursion, this function is a no-op.  <br /></td></tr>
<tr class="separator:a92f3e6fa8b71cef479e1f2d762513951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c7d015bdbb6657725165263c95d1ed"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename... Ts&gt; </td></tr>
<tr class="memitem:a63c7d015bdbb6657725165263c95d1ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a63c7d015bdbb6657725165263c95d1ed.html#a63c7d015bdbb6657725165263c95d1ed">check_consistent_sizes</a> (const char *function, const char *name1, const T1 &amp;x1, const char *name2, const T2 &amp;x2, const Ts &amp;... names_and_xs)</td></tr>
<tr class="memdesc:a63c7d015bdbb6657725165263c95d1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the inputs are of consistent size.  <br /></td></tr>
<tr class="separator:a63c7d015bdbb6657725165263c95d1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cefb1de2214e2898471e0ef2ab47d08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4cefb1de2214e2898471e0ef2ab47d08.html#a4cefb1de2214e2898471e0ef2ab47d08">check_consistent_sizes_mvt</a> (const char *)</td></tr>
<tr class="memdesc:a4cefb1de2214e2898471e0ef2ab47d08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial no input case, this function is a no-op.  <br /></td></tr>
<tr class="separator:a4cefb1de2214e2898471e0ef2ab47d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3a5611179f5e3b05141f629f03e88d"><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr class="memitem:aea3a5611179f5e3b05141f629f03e88d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aea3a5611179f5e3b05141f629f03e88d.html#aea3a5611179f5e3b05141f629f03e88d">check_consistent_sizes_mvt</a> (const char *, const char *, const T1 &amp;)</td></tr>
<tr class="memdesc:aea3a5611179f5e3b05141f629f03e88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base case of recursion, this function is a no-op.  <br /></td></tr>
<tr class="separator:aea3a5611179f5e3b05141f629f03e88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f7c6b17f763de357860ac814f16a74"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename... Ts&gt; </td></tr>
<tr class="memitem:a02f7c6b17f763de357860ac814f16a74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a02f7c6b17f763de357860ac814f16a74.html#a02f7c6b17f763de357860ac814f16a74">check_consistent_sizes_mvt</a> (const char *function, const char *name1, const T1 &amp;x1, const char *name2, const T2 &amp;x2, const Ts &amp;... names_and_xs)</td></tr>
<tr class="memdesc:a02f7c6b17f763de357860ac814f16a74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the provided multivariate inputs are of consistent size with each other.  <br /></td></tr>
<tr class="separator:a02f7c6b17f763de357860ac814f16a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289210bdbeec6c0cf6433157488dcafe"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a289210bdbeec6c0cf6433157488dcafe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a289210bdbeec6c0cf6433157488dcafe.html#a289210bdbeec6c0cf6433157488dcafe">check_corr_matrix</a> (const char *function, const char *name, const Mat &amp;y)</td></tr>
<tr class="memdesc:a289210bdbeec6c0cf6433157488dcafe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a valid correlation matrix.  <br /></td></tr>
<tr class="separator:a289210bdbeec6c0cf6433157488dcafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45db96b659f82150a91f778505e2f353"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a45db96b659f82150a91f778505e2f353"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a45db96b659f82150a91f778505e2f353.html#a45db96b659f82150a91f778505e2f353">check_corr_matrix</a> (const char *function, const char *name, const StdVec &amp;y)</td></tr>
<tr class="memdesc:a45db96b659f82150a91f778505e2f353"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a valid correlation matrix.  <br /></td></tr>
<tr class="separator:a45db96b659f82150a91f778505e2f353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82c3dc057cd933677de364ffaada0f8"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa82c3dc057cd933677de364ffaada0f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa82c3dc057cd933677de364ffaada0f8.html#aa82c3dc057cd933677de364ffaada0f8">check_cov_matrix</a> (const char *function, const char *name, const Mat &amp;y)</td></tr>
<tr class="memdesc:aa82c3dc057cd933677de364ffaada0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a valid covariance matrix.  <br /></td></tr>
<tr class="separator:aa82c3dc057cd933677de364ffaada0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0e0ceeb3451c42005ac13f515e9a4f"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acc0e0ceeb3451c42005ac13f515e9a4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acc0e0ceeb3451c42005ac13f515e9a4f.html#acc0e0ceeb3451c42005ac13f515e9a4f">check_cov_matrix</a> (const char *function, const char *name, const StdVec &amp;y)</td></tr>
<tr class="memdesc:acc0e0ceeb3451c42005ac13f515e9a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a valid covariance matrix.  <br /></td></tr>
<tr class="separator:acc0e0ceeb3451c42005ac13f515e9a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c784e47c32e15cf4f1fa56c017e211"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:aa4c784e47c32e15cf4f1fa56c017e211"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa4c784e47c32e15cf4f1fa56c017e211.html#aa4c784e47c32e15cf4f1fa56c017e211">check_finite</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:aa4c784e47c32e15cf4f1fa56c017e211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if all values in <code>y</code> are finite.  <br /></td></tr>
<tr class="separator:aa4c784e47c32e15cf4f1fa56c017e211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3756749c378935c16900b14dc2842e"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::string, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f3756749c378935c16900b14dc2842e.html#a2f3756749c378935c16900b14dc2842e">cvodes_flag_msg</a> (int flag)</td></tr>
<tr class="memdesc:a2f3756749c378935c16900b14dc2842e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map cvodes error flag to acutally error msg.  <br /></td></tr>
<tr class="separator:a2f3756749c378935c16900b14dc2842e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a189a6f9f65509a96a398f5cbb9feb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8a189a6f9f65509a96a398f5cbb9feb3.html#a8a189a6f9f65509a96a398f5cbb9feb3">cvodes_check</a> (int flag, const char *func_name)</td></tr>
<tr class="memdesc:a8a189a6f9f65509a96a398f5cbb9feb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws a std::domain_error exception when a Sundial function fails (i.e.  <br /></td></tr>
<tr class="separator:a8a189a6f9f65509a96a398f5cbb9feb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e812588c0352442cb1e1170b368d26"><td class="memItemLeft" align="right" valign="top">std::array&lt; std::string, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a07e812588c0352442cb1e1170b368d26.html#a07e812588c0352442cb1e1170b368d26">idas_flag_msg</a> (int flag)</td></tr>
<tr class="separator:a07e812588c0352442cb1e1170b368d26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7b82dfbef07fb24f6439779517c636"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7a7b82dfbef07fb24f6439779517c636.html#a7a7b82dfbef07fb24f6439779517c636">idas_check</a> (int flag, const char *func_name)</td></tr>
<tr class="separator:a7a7b82dfbef07fb24f6439779517c636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cfb35c1d6c9d2b09f6bc76dc8778cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae5cfb35c1d6c9d2b09f6bc76dc8778cb.html#ae5cfb35c1d6c9d2b09f6bc76dc8778cb">kinsol_check</a> (int flag, const char *func_name)</td></tr>
<tr class="memdesc:ae5cfb35c1d6c9d2b09f6bc76dc8778cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws an exception message when the functions in KINSOL fails.  <br /></td></tr>
<tr class="separator:ae5cfb35c1d6c9d2b09f6bc76dc8778cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8414d0b66b586bd9cbe2dc2f54905d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad8414d0b66b586bd9cbe2dc2f54905d0.html#ad8414d0b66b586bd9cbe2dc2f54905d0">kinsol_check</a> (int flag, const char *func_name, long int max_num_steps)</td></tr>
<tr class="memdesc:ad8414d0b66b586bd9cbe2dc2f54905d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throws an exception message when the KINSol() call fails.  <br /></td></tr>
<tr class="separator:ad8414d0b66b586bd9cbe2dc2f54905d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7b33ead3d2e8fa165f48e8029b6c5a"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T_y, T_low &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:aec7b33ead3d2e8fa165f48e8029b6c5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aec7b33ead3d2e8fa165f48e8029b6c5a.html#aec7b33ead3d2e8fa165f48e8029b6c5a">check_greater</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low, Idxs... idxs)</td></tr>
<tr class="memdesc:aec7b33ead3d2e8fa165f48e8029b6c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not strictly greater than <code>low</code>.  <br /></td></tr>
<tr class="separator:aec7b33ead3d2e8fa165f48e8029b6c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af344c2eef90d9a1820ee583c2fcb7052"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_y &gt; *  = nullptr, <a class="el" href="group__vector__types_ga49bbe2450e11ac6a02210ab0dcde62bb.html#ga49bbe2450e11ac6a02210ab0dcde62bb">require_vector_t</a>&lt; T_low &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga46e43fa0e91d1b0d0dfa7e1982b9fc0e.html#ga46e43fa0e91d1b0d0dfa7e1982b9fc0e">require_not_std_vector_vt</a>&lt; <a class="el" href="namespacestan_a64ebeeecefb495fe40b1111a2fe68fa0.html#a64ebeeecefb495fe40b1111a2fe68fa0">is_container_or_var_matrix</a>, T_low &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:af344c2eef90d9a1820ee583c2fcb7052"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af344c2eef90d9a1820ee583c2fcb7052.html#af344c2eef90d9a1820ee583c2fcb7052">check_greater</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low, Idxs... idxs)</td></tr>
<tr class="memdesc:af344c2eef90d9a1820ee583c2fcb7052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not strictly greater than each element of <code>low</code>.  <br /></td></tr>
<tr class="separator:af344c2eef90d9a1820ee583c2fcb7052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf22dcca757704f99564b57793e997ed"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_y &gt; *  = nullptr, <a class="el" href="group__dense__dynamic__types_gacc6ef15ef129c59966a6861f428b17ea.html#gacc6ef15ef129c59966a6861f428b17ea">require_dense_dynamic_t</a>&lt; T_low &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:adf22dcca757704f99564b57793e997ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adf22dcca757704f99564b57793e997ed.html#adf22dcca757704f99564b57793e997ed">check_greater</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low, Idxs... idxs)</td></tr>
<tr class="memdesc:adf22dcca757704f99564b57793e997ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not strictly greater than each element of <code>low</code>.  <br /></td></tr>
<tr class="separator:adf22dcca757704f99564b57793e997ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79080c1879ec04f4080745175b057cfe"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T_y, T_low &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:a79080c1879ec04f4080745175b057cfe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a79080c1879ec04f4080745175b057cfe.html#a79080c1879ec04f4080745175b057cfe">check_greater_or_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low, Idxs... idxs)</td></tr>
<tr class="memdesc:a79080c1879ec04f4080745175b057cfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not greater or equal than <code>low</code>.  <br /></td></tr>
<tr class="separator:a79080c1879ec04f4080745175b057cfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23634f18ecf38b127b984052e8914776"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_y &gt; *  = nullptr, <a class="el" href="group__vector__types_ga49bbe2450e11ac6a02210ab0dcde62bb.html#ga49bbe2450e11ac6a02210ab0dcde62bb">require_vector_t</a>&lt; T_low &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga46e43fa0e91d1b0d0dfa7e1982b9fc0e.html#ga46e43fa0e91d1b0d0dfa7e1982b9fc0e">require_not_std_vector_vt</a>&lt; <a class="el" href="namespacestan_a64ebeeecefb495fe40b1111a2fe68fa0.html#a64ebeeecefb495fe40b1111a2fe68fa0">is_container_or_var_matrix</a>, T_low &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:a23634f18ecf38b127b984052e8914776"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a23634f18ecf38b127b984052e8914776.html#a23634f18ecf38b127b984052e8914776">check_greater_or_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low, Idxs... idxs)</td></tr>
<tr class="memdesc:a23634f18ecf38b127b984052e8914776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not greater or equal than each element of <code>low</code>.  <br /></td></tr>
<tr class="separator:a23634f18ecf38b127b984052e8914776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f5f261e00d79dd6c6c2590be188c0d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_y &gt; *  = nullptr, <a class="el" href="group__dense__dynamic__types_gacc6ef15ef129c59966a6861f428b17ea.html#gacc6ef15ef129c59966a6861f428b17ea">require_dense_dynamic_t</a>&lt; T_low &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:a27f5f261e00d79dd6c6c2590be188c0d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a27f5f261e00d79dd6c6c2590be188c0d.html#a27f5f261e00d79dd6c6c2590be188c0d">check_greater_or_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_low &amp;low, Idxs... idxs)</td></tr>
<tr class="memdesc:a27f5f261e00d79dd6c6c2590be188c0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not greater or equal than each element of <code>low</code>.  <br /></td></tr>
<tr class="separator:a27f5f261e00d79dd6c6c2590be188c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa540aa6dc103b789e700523514ba18db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa540aa6dc103b789e700523514ba18db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa540aa6dc103b789e700523514ba18db.html#aa540aa6dc103b789e700523514ba18db">check_ldlt_factor</a> (const char *function, const char *name, <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aa540aa6dc103b789e700523514ba18db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Raise domain error if the specified LDLT factor is invalid.  <br /></td></tr>
<tr class="separator:aa540aa6dc103b789e700523514ba18db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfbdcf963962d1aff5d424d9868a5ce9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T_y, T_high &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:adfbdcf963962d1aff5d424d9868a5ce9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adfbdcf963962d1aff5d424d9868a5ce9.html#adfbdcf963962d1aff5d424d9868a5ce9">check_less</a> (const char *function, const char *name, const T_y &amp;y, const T_high &amp;high, Idxs... idxs)</td></tr>
<tr class="memdesc:adfbdcf963962d1aff5d424d9868a5ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not strictly less than <code>high</code>.  <br /></td></tr>
<tr class="separator:adfbdcf963962d1aff5d424d9868a5ce9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4767c5f3e1c7b7453358fbe913b17a30"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_y &gt; *  = nullptr, <a class="el" href="group__vector__types_ga49bbe2450e11ac6a02210ab0dcde62bb.html#ga49bbe2450e11ac6a02210ab0dcde62bb">require_vector_t</a>&lt; T_high &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga46e43fa0e91d1b0d0dfa7e1982b9fc0e.html#ga46e43fa0e91d1b0d0dfa7e1982b9fc0e">require_not_std_vector_vt</a>&lt; <a class="el" href="namespacestan_a64ebeeecefb495fe40b1111a2fe68fa0.html#a64ebeeecefb495fe40b1111a2fe68fa0">is_container_or_var_matrix</a>, T_high &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:a4767c5f3e1c7b7453358fbe913b17a30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4767c5f3e1c7b7453358fbe913b17a30.html#a4767c5f3e1c7b7453358fbe913b17a30">check_less</a> (const char *function, const char *name, const T_y &amp;y, const T_high &amp;high, Idxs... idxs)</td></tr>
<tr class="memdesc:a4767c5f3e1c7b7453358fbe913b17a30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not strictly less than each element of <code>high</code>.  <br /></td></tr>
<tr class="separator:a4767c5f3e1c7b7453358fbe913b17a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17983b17bfff0b43a0ed526971decc9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_y &gt; *  = nullptr, <a class="el" href="group__dense__dynamic__types_gacc6ef15ef129c59966a6861f428b17ea.html#gacc6ef15ef129c59966a6861f428b17ea">require_dense_dynamic_t</a>&lt; T_high &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:aa17983b17bfff0b43a0ed526971decc9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa17983b17bfff0b43a0ed526971decc9.html#aa17983b17bfff0b43a0ed526971decc9">check_less</a> (const char *function, const char *name, const T_y &amp;y, const T_high &amp;high, Idxs... idxs)</td></tr>
<tr class="memdesc:aa17983b17bfff0b43a0ed526971decc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not strictly less than each element of <code>high</code>.  <br /></td></tr>
<tr class="separator:aa17983b17bfff0b43a0ed526971decc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098e29ee53a15aeaf276ddc8969708bb"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T_y, T_high &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:a098e29ee53a15aeaf276ddc8969708bb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a098e29ee53a15aeaf276ddc8969708bb.html#a098e29ee53a15aeaf276ddc8969708bb">check_less_or_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_high &amp;high, Idxs... idxs)</td></tr>
<tr class="memdesc:a098e29ee53a15aeaf276ddc8969708bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not less than <code>high</code>.  <br /></td></tr>
<tr class="separator:a098e29ee53a15aeaf276ddc8969708bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ecf5297a3b509b8c32484bb22e0446"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_y &gt; *  = nullptr, <a class="el" href="group__vector__types_ga49bbe2450e11ac6a02210ab0dcde62bb.html#ga49bbe2450e11ac6a02210ab0dcde62bb">require_vector_t</a>&lt; T_high &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga46e43fa0e91d1b0d0dfa7e1982b9fc0e.html#ga46e43fa0e91d1b0d0dfa7e1982b9fc0e">require_not_std_vector_vt</a>&lt; <a class="el" href="namespacestan_a64ebeeecefb495fe40b1111a2fe68fa0.html#a64ebeeecefb495fe40b1111a2fe68fa0">is_container_or_var_matrix</a>, T_high &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:ae2ecf5297a3b509b8c32484bb22e0446"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae2ecf5297a3b509b8c32484bb22e0446.html#ae2ecf5297a3b509b8c32484bb22e0446">check_less_or_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_high &amp;high, Idxs... idxs)</td></tr>
<tr class="memdesc:ae2ecf5297a3b509b8c32484bb22e0446"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not less than each element of <code>high</code>.  <br /></td></tr>
<tr class="separator:ae2ecf5297a3b509b8c32484bb22e0446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b71290d36f2cf80b26cbffded281df3"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_y &gt; *  = nullptr, <a class="el" href="group__dense__dynamic__types_gacc6ef15ef129c59966a6861f428b17ea.html#gacc6ef15ef129c59966a6861f428b17ea">require_dense_dynamic_t</a>&lt; T_high &gt; *  = nullptr, typename... Idxs&gt; </td></tr>
<tr class="memitem:a9b71290d36f2cf80b26cbffded281df3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9b71290d36f2cf80b26cbffded281df3.html#a9b71290d36f2cf80b26cbffded281df3">check_less_or_equal</a> (const char *function, const char *name, const T_y &amp;y, const T_high &amp;high, Idxs... idxs)</td></tr>
<tr class="memdesc:a9b71290d36f2cf80b26cbffded281df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if <code>y</code> is not less than each element of <code>high</code>.  <br /></td></tr>
<tr class="separator:a9b71290d36f2cf80b26cbffded281df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80f3ad0788da11a47219300bd99c96f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae80f3ad0788da11a47219300bd99c96f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae80f3ad0788da11a47219300bd99c96f.html#ae80f3ad0788da11a47219300bd99c96f">check_lower_triangular</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:ae80f3ad0788da11a47219300bd99c96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified matrix is lower triangular.  <br /></td></tr>
<tr class="separator:ae80f3ad0788da11a47219300bd99c96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c7e3cfd234ccbfede7d785c4955e81"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__matrix__types_gad74341babe2d2bbac91a7205c6d0b142.html#gad74341babe2d2bbac91a7205c6d0b142">require_all_not_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a72c7e3cfd234ccbfede7d785c4955e81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a72c7e3cfd234ccbfede7d785c4955e81.html#a72c7e3cfd234ccbfede7d785c4955e81">check_matching_dims</a> (const char *function, const char *name1, const T1 &amp;y1, const char *name2, const T2 &amp;y2)</td></tr>
<tr class="memdesc:a72c7e3cfd234ccbfede7d785c4955e81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the two containers have the same dimensions.  <br /></td></tr>
<tr class="separator:a72c7e3cfd234ccbfede7d785c4955e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1c74b68967574a4ca09238967292ab"><td class="memTemplParams" colspan="2">template&lt;bool check_compile, typename Mat1 , typename Mat2 , typename  = require_all_eigen_t&lt;Mat1, Mat2&gt;&gt; </td></tr>
<tr class="memitem:a2c1c74b68967574a4ca09238967292ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2c1c74b68967574a4ca09238967292ab.html#a2c1c74b68967574a4ca09238967292ab">check_matching_dims</a> (const char *function, const char *name1, const Mat1 &amp;y1, const char *name2, const Mat2 &amp;y2)</td></tr>
<tr class="memdesc:a2c1c74b68967574a4ca09238967292ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the two matrices are of the same size.  <br /></td></tr>
<tr class="separator:a2c1c74b68967574a4ca09238967292ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2be3873d1e10f865a00e5eab361913"><td class="memTemplParams" colspan="2">template&lt;typename T_y1 , typename T_y2 &gt; </td></tr>
<tr class="memitem:a7b2be3873d1e10f865a00e5eab361913"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7b2be3873d1e10f865a00e5eab361913.html#a7b2be3873d1e10f865a00e5eab361913">check_matching_sizes</a> (const char *function, const char *name1, const T_y1 &amp;y1, const char *name2, const T_y2 &amp;y2)</td></tr>
<tr class="memdesc:a7b2be3873d1e10f865a00e5eab361913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two structures at the same size.  <br /></td></tr>
<tr class="separator:a7b2be3873d1e10f865a00e5eab361913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2faef6c23d17402e88aa758bd7b04c82"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a2faef6c23d17402e88aa758bd7b04c82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2faef6c23d17402e88aa758bd7b04c82.html#a2faef6c23d17402e88aa758bd7b04c82">check_multiplicable</a> (const char *function, const char *name1, const T1 &amp;y1, const char *name2, const T2 &amp;y2)</td></tr>
<tr class="memdesc:a2faef6c23d17402e88aa758bd7b04c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the matrices can be multiplied.  <br /></td></tr>
<tr class="separator:a2faef6c23d17402e88aa758bd7b04c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275a219041e4baa51d8ea4c415d5297e"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a275a219041e4baa51d8ea4c415d5297e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a275a219041e4baa51d8ea4c415d5297e.html#a275a219041e4baa51d8ea4c415d5297e">check_nonnegative</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:a275a219041e4baa51d8ea4c415d5297e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>y</code> is non-negative.  <br /></td></tr>
<tr class="separator:a275a219041e4baa51d8ea4c415d5297e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7df68f2df1ee2432e7ffd5935f974c"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:abf7df68f2df1ee2432e7ffd5935f974c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abf7df68f2df1ee2432e7ffd5935f974c.html#abf7df68f2df1ee2432e7ffd5935f974c">check_nonzero_size</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:abf7df68f2df1ee2432e7ffd5935f974c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified matrix/vector is of non-zero size.  <br /></td></tr>
<tr class="separator:abf7df68f2df1ee2432e7ffd5935f974c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab61c29fb78bd02ac380156c065beefe"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:aab61c29fb78bd02ac380156c065beefe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab61c29fb78bd02ac380156c065beefe.html#aab61c29fb78bd02ac380156c065beefe">check_not_nan</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:aab61c29fb78bd02ac380156c065beefe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>y</code> is not <code>NaN</code>.  <br /></td></tr>
<tr class="separator:aab61c29fb78bd02ac380156c065beefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9027241b2af63e33791267e79982d2a"><td class="memTemplParams" colspan="2">template&lt;typename T_y , <a class="el" href="group__vector__types_ga49bbe2450e11ac6a02210ab0dcde62bb.html#ga49bbe2450e11ac6a02210ab0dcde62bb">require_vector_t</a>&lt; T_y &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad9027241b2af63e33791267e79982d2a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad9027241b2af63e33791267e79982d2a.html#ad9027241b2af63e33791267e79982d2a">check_ordered</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:ad9027241b2af63e33791267e79982d2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified vector is not sorted into strictly increasing order.  <br /></td></tr>
<tr class="separator:ad9027241b2af63e33791267e79982d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a593be410033a216c0a4b649ca8fb3a1b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , <a class="el" href="group__std__vector__types_ga177ca10358abdf201cabb12e8bdb2e91.html#ga177ca10358abdf201cabb12e8bdb2e91">require_std_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>, T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a593be410033a216c0a4b649ca8fb3a1b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a593be410033a216c0a4b649ca8fb3a1b.html#a593be410033a216c0a4b649ca8fb3a1b">check_ordered</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:a593be410033a216c0a4b649ca8fb3a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified vector is not sorted into strictly increasing order.  <br /></td></tr>
<tr class="separator:a593be410033a216c0a4b649ca8fb3a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5942cb9fb5c93f58161490a2dfe5db39"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5942cb9fb5c93f58161490a2dfe5db39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5942cb9fb5c93f58161490a2dfe5db39.html#a5942cb9fb5c93f58161490a2dfe5db39">check_pos_definite</a> (const char *function, const char *name, const EigMat &amp;y)</td></tr>
<tr class="memdesc:a5942cb9fb5c93f58161490a2dfe5db39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified square, symmetric matrix is positive definite.  <br /></td></tr>
<tr class="separator:a5942cb9fb5c93f58161490a2dfe5db39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72abfa604ccb66c78756223c58139143"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a72abfa604ccb66c78756223c58139143"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a72abfa604ccb66c78756223c58139143.html#a72abfa604ccb66c78756223c58139143">check_pos_definite</a> (const char *function, const char *name, const Eigen::LDLT&lt; Derived &gt; &amp;cholesky)</td></tr>
<tr class="memdesc:a72abfa604ccb66c78756223c58139143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified LDLT decomposition of a matrix is positive definite.  <br /></td></tr>
<tr class="separator:a72abfa604ccb66c78756223c58139143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f502596899ce08b68992f1798800a0a"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1f502596899ce08b68992f1798800a0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1f502596899ce08b68992f1798800a0a.html#a1f502596899ce08b68992f1798800a0a">check_pos_definite</a> (const char *function, const char *name, const Eigen::LLT&lt; Derived &gt; &amp;cholesky)</td></tr>
<tr class="memdesc:a1f502596899ce08b68992f1798800a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified LLT decomposition was successful.  <br /></td></tr>
<tr class="separator:a1f502596899ce08b68992f1798800a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d7a60e23b3572f9a6f38978e73aa41"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a36d7a60e23b3572f9a6f38978e73aa41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a36d7a60e23b3572f9a6f38978e73aa41.html#a36d7a60e23b3572f9a6f38978e73aa41">check_pos_semidefinite</a> (const char *function, const char *name, const EigMat &amp;y)</td></tr>
<tr class="memdesc:a36d7a60e23b3572f9a6f38978e73aa41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified matrix is positive definite.  <br /></td></tr>
<tr class="separator:a36d7a60e23b3572f9a6f38978e73aa41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fdab2383f63a63688b771d9996dff2e"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1fdab2383f63a63688b771d9996dff2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1fdab2383f63a63688b771d9996dff2e.html#a1fdab2383f63a63688b771d9996dff2e">check_pos_semidefinite</a> (const char *function, const char *name, const Eigen::LDLT&lt; Derived &gt; &amp;cholesky)</td></tr>
<tr class="memdesc:a1fdab2383f63a63688b771d9996dff2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified matrix is positive semidefinite.  <br /></td></tr>
<tr class="separator:a1fdab2383f63a63688b771d9996dff2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac089cbbe398dec189a188017c61ee154"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:ac089cbbe398dec189a188017c61ee154"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac089cbbe398dec189a188017c61ee154.html#ac089cbbe398dec189a188017c61ee154">check_positive</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:ac089cbbe398dec189a188017c61ee154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>y</code> is positive.  <br /></td></tr>
<tr class="separator:ac089cbbe398dec189a188017c61ee154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89de6a3f7f216285d4ce46fd9efe76b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae89de6a3f7f216285d4ce46fd9efe76b.html#ae89de6a3f7f216285d4ce46fd9efe76b">check_positive</a> (const char *function, const char *name, const char *expr, int <a class="el" href="group__type__trait_gaf82cac3bdccc9b64e7a55a8bd47880a7.html#gaf82cac3bdccc9b64e7a55a8bd47880a7">size</a>)</td></tr>
<tr class="memdesc:ae89de6a3f7f216285d4ce46fd9efe76b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>size</code> is positive.  <br /></td></tr>
<tr class="separator:ae89de6a3f7f216285d4ce46fd9efe76b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12b463f25bbf05264cc9361ad484eec"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:af12b463f25bbf05264cc9361ad484eec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af12b463f25bbf05264cc9361ad484eec.html#af12b463f25bbf05264cc9361ad484eec">check_positive_finite</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:af12b463f25bbf05264cc9361ad484eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if <code>y</code> is positive and finite.  <br /></td></tr>
<tr class="separator:af12b463f25bbf05264cc9361ad484eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08d2fecce959317ff652e1cb20f15ee1"><td class="memTemplParams" colspan="2">template&lt;typename Vec , <a class="el" href="group__vector__types_ga49bbe2450e11ac6a02210ab0dcde62bb.html#ga49bbe2450e11ac6a02210ab0dcde62bb">require_vector_t</a>&lt; Vec &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a08d2fecce959317ff652e1cb20f15ee1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a08d2fecce959317ff652e1cb20f15ee1.html#a08d2fecce959317ff652e1cb20f15ee1">check_positive_ordered</a> (const char *function, const char *name, const Vec &amp;y)</td></tr>
<tr class="memdesc:a08d2fecce959317ff652e1cb20f15ee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified the vector contains negative values or is not sorted into strictly increasing order.  <br /></td></tr>
<tr class="separator:a08d2fecce959317ff652e1cb20f15ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad590546f446ae73eb8e982cb15c0b081"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad590546f446ae73eb8e982cb15c0b081"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad590546f446ae73eb8e982cb15c0b081.html#ad590546f446ae73eb8e982cb15c0b081">check_positive_ordered</a> (const char *function, const char *name, const StdVec &amp;y)</td></tr>
<tr class="memdesc:ad590546f446ae73eb8e982cb15c0b081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if any of the vectors in a standard vector contains negative values or is not sorted into strictly increasing order.  <br /></td></tr>
<tr class="separator:ad590546f446ae73eb8e982cb15c0b081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaacd79b85845a32f656187bfe47332f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adaacd79b85845a32f656187bfe47332f.html#adaacd79b85845a32f656187bfe47332f">check_range</a> (const char *function, const char *name, int <a class="el" href="namespacestan_1_1math_a79b5e7fd8ad5d82b06906917a4393c67.html#a79b5e7fd8ad5d82b06906917a4393c67">max</a>, int index, int nested_level, const char *error_msg)</td></tr>
<tr class="memdesc:adaacd79b85845a32f656187bfe47332f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if specified index is within range.  <br /></td></tr>
<tr class="separator:adaacd79b85845a32f656187bfe47332f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0241a8524dc37b8b04280c2e93f9d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aff0241a8524dc37b8b04280c2e93f9d0.html#aff0241a8524dc37b8b04280c2e93f9d0">check_range</a> (const char *function, const char *name, int <a class="el" href="namespacestan_1_1math_a79b5e7fd8ad5d82b06906917a4393c67.html#a79b5e7fd8ad5d82b06906917a4393c67">max</a>, int index, const char *error_msg)</td></tr>
<tr class="memdesc:aff0241a8524dc37b8b04280c2e93f9d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if specified index is within range.  <br /></td></tr>
<tr class="separator:aff0241a8524dc37b8b04280c2e93f9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4229825590b1a0f35df380b9e44b829a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4229825590b1a0f35df380b9e44b829a.html#a4229825590b1a0f35df380b9e44b829a">check_range</a> (const char *function, const char *name, int <a class="el" href="namespacestan_1_1math_a79b5e7fd8ad5d82b06906917a4393c67.html#a79b5e7fd8ad5d82b06906917a4393c67">max</a>, int index)</td></tr>
<tr class="memdesc:a4229825590b1a0f35df380b9e44b829a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if specified index is within range.  <br /></td></tr>
<tr class="separator:a4229825590b1a0f35df380b9e44b829a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bdab326874d0654d6972019bb5f987e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename  = require_matrix_t&lt;T_y&gt;&gt; </td></tr>
<tr class="memitem:a2bdab326874d0654d6972019bb5f987e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2bdab326874d0654d6972019bb5f987e.html#a2bdab326874d0654d6972019bb5f987e">check_row_index</a> (const char *function, const char *name, const T_y &amp;y, size_t i)</td></tr>
<tr class="memdesc:a2bdab326874d0654d6972019bb5f987e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified index is a valid row of the matrix This check is 1-indexed by default.  <br /></td></tr>
<tr class="separator:a2bdab326874d0654d6972019bb5f987e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8834d287c248a6895057711fb4582cfa"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8834d287c248a6895057711fb4582cfa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8834d287c248a6895057711fb4582cfa.html#a8834d287c248a6895057711fb4582cfa">check_simplex</a> (const char *function, const char *name, const T &amp;theta)</td></tr>
<tr class="memdesc:a8834d287c248a6895057711fb4582cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified vector is not a simplex.  <br /></td></tr>
<tr class="separator:a8834d287c248a6895057711fb4582cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf85220664649c7ba7c9c893e013c20a"><td class="memTemplParams" colspan="2">template&lt;typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:adf85220664649c7ba7c9c893e013c20a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adf85220664649c7ba7c9c893e013c20a.html#adf85220664649c7ba7c9c893e013c20a">check_size_match</a> (const char *function, const char *name_i, T_size1 i, const char *name_j, T_size2 j)</td></tr>
<tr class="memdesc:adf85220664649c7ba7c9c893e013c20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the provided sizes match.  <br /></td></tr>
<tr class="separator:adf85220664649c7ba7c9c893e013c20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b84e9fbd00dbc41f75290f7292930b"><td class="memTemplParams" colspan="2">template&lt;typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:ad8b84e9fbd00dbc41f75290f7292930b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad8b84e9fbd00dbc41f75290f7292930b.html#ad8b84e9fbd00dbc41f75290f7292930b">check_size_match</a> (const char *function, const char *expr_i, const char *name_i, T_size1 i, const char *expr_j, const char *name_j, T_size2 j)</td></tr>
<tr class="memdesc:ad8b84e9fbd00dbc41f75290f7292930b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the provided sizes match.  <br /></td></tr>
<tr class="separator:ad8b84e9fbd00dbc41f75290f7292930b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73586e43b125a5a563e184c637c3b56"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac73586e43b125a5a563e184c637c3b56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac73586e43b125a5a563e184c637c3b56.html#ac73586e43b125a5a563e184c637c3b56">check_sorted</a> (const char *function, const char *name, const EigVec &amp;y)</td></tr>
<tr class="memdesc:ac73586e43b125a5a563e184c637c3b56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified vector is sorted into increasing order (repeated values are okay).  <br /></td></tr>
<tr class="separator:ac73586e43b125a5a563e184c637c3b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a695a2405a12d74f294585898d4d610"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a6a695a2405a12d74f294585898d4d610"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6a695a2405a12d74f294585898d4d610.html#a6a695a2405a12d74f294585898d4d610">check_sorted</a> (const char *function, const char *name, const std::vector&lt; T_y &gt; &amp;y)</td></tr>
<tr class="memdesc:a6a695a2405a12d74f294585898d4d610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified vector is sorted into increasing order (repeated values are okay).  <br /></td></tr>
<tr class="separator:a6a695a2405a12d74f294585898d4d610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220c970623ee44ebe8d9b1d7a0765988"><td class="memTemplParams" colspan="2">template&lt;typename T_y , <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>&lt; T_y &gt;, <a class="el" href="structstan_1_1is__prim__or__rev__kernel__expression.html">is_prim_or_rev_kernel_expression</a>&lt; T_y &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a220c970623ee44ebe8d9b1d7a0765988"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a220c970623ee44ebe8d9b1d7a0765988.html#a220c970623ee44ebe8d9b1d7a0765988">check_square</a> (const char *function, const char *name, const T_y &amp;y)</td></tr>
<tr class="memdesc:a220c970623ee44ebe8d9b1d7a0765988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified matrix is square.  <br /></td></tr>
<tr class="separator:a220c970623ee44ebe8d9b1d7a0765988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab244b2c1234824cd1775482124e0f199"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab244b2c1234824cd1775482124e0f199"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab244b2c1234824cd1775482124e0f199.html#ab244b2c1234824cd1775482124e0f199">check_std_vector_index</a> (const char *function, const char *name, const std::vector&lt; T &gt; &amp;y, int i)</td></tr>
<tr class="memdesc:ab244b2c1234824cd1775482124e0f199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified index is valid in std vector This check is 1-indexed by default.  <br /></td></tr>
<tr class="separator:ab244b2c1234824cd1775482124e0f199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842072da5abd2070f1983b70ec13d860"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a842072da5abd2070f1983b70ec13d860"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a842072da5abd2070f1983b70ec13d860.html#a842072da5abd2070f1983b70ec13d860">check_stochastic_column</a> (const char *function, const char *name, const T &amp;theta)</td></tr>
<tr class="memdesc:a842072da5abd2070f1983b70ec13d860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a column stochastic matrix.  <br /></td></tr>
<tr class="separator:a842072da5abd2070f1983b70ec13d860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccf6bbf7f954ae34ec60d455dac50f8"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6ccf6bbf7f954ae34ec60d455dac50f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6ccf6bbf7f954ae34ec60d455dac50f8.html#a6ccf6bbf7f954ae34ec60d455dac50f8">check_stochastic_row</a> (const char *function, const char *name, const T &amp;theta)</td></tr>
<tr class="memdesc:a6ccf6bbf7f954ae34ec60d455dac50f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified matrix is not a row stochastic matrix.  <br /></td></tr>
<tr class="separator:a6ccf6bbf7f954ae34ec60d455dac50f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5758aa5aae18a318064f3af7c6b1c21f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5758aa5aae18a318064f3af7c6b1c21f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5758aa5aae18a318064f3af7c6b1c21f.html#a5758aa5aae18a318064f3af7c6b1c21f">check_sum_to_zero</a> (const char *function, const char *name, const T &amp;theta)</td></tr>
<tr class="memdesc:a5758aa5aae18a318064f3af7c6b1c21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified vector does not sum to 0.  <br /></td></tr>
<tr class="separator:a5758aa5aae18a318064f3af7c6b1c21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d7fdfe43e28dc099680e9b9307cf53"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a95d7fdfe43e28dc099680e9b9307cf53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a95d7fdfe43e28dc099680e9b9307cf53.html#a95d7fdfe43e28dc099680e9b9307cf53">check_symmetric</a> (const char *function, const char *name, const EigMat &amp;y)</td></tr>
<tr class="memdesc:a95d7fdfe43e28dc099680e9b9307cf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified matrix is symmetric.  <br /></td></tr>
<tr class="separator:a95d7fdfe43e28dc099680e9b9307cf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247c2f25b04b848181f1f2440630a6a9"><td class="memTemplParams" colspan="2">template&lt;typename Vec , <a class="el" href="group__vector__types_ga49bbe2450e11ac6a02210ab0dcde62bb.html#ga49bbe2450e11ac6a02210ab0dcde62bb">require_vector_t</a>&lt; Vec &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a247c2f25b04b848181f1f2440630a6a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a247c2f25b04b848181f1f2440630a6a9.html#a247c2f25b04b848181f1f2440630a6a9">check_unit_vector</a> (const char *function, const char *name, const Vec &amp;theta)</td></tr>
<tr class="memdesc:a247c2f25b04b848181f1f2440630a6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the specified vector does not have unit Euclidiean length.  <br /></td></tr>
<tr class="separator:a247c2f25b04b848181f1f2440630a6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabc68dd678bb36922d47631f2a8aa4e"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acabc68dd678bb36922d47631f2a8aa4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acabc68dd678bb36922d47631f2a8aa4e.html#acabc68dd678bb36922d47631f2a8aa4e">check_unit_vector</a> (const char *function, const char *name, const StdVec &amp;theta)</td></tr>
<tr class="memdesc:acabc68dd678bb36922d47631f2a8aa4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an exception if the each element in a standard vector does not have unit Euclidiean length.  <br /></td></tr>
<tr class="separator:acabc68dd678bb36922d47631f2a8aa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54cc69726215f6f8f0559a938948f199"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__matrix.html">is_matrix</a>&lt; Mat &gt;, <a class="el" href="structstan_1_1is__prim__or__rev__kernel__expression.html">is_prim_or_rev_kernel_expression</a>&lt; Mat &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a54cc69726215f6f8f0559a938948f199"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a54cc69726215f6f8f0559a938948f199.html#a54cc69726215f6f8f0559a938948f199">check_vector</a> (const char *function, const char *name, const Mat &amp;x)</td></tr>
<tr class="memdesc:a54cc69726215f6f8f0559a938948f199"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check the input is either a row vector or column vector or a matrix with a single row or column.  <br /></td></tr>
<tr class="separator:a54cc69726215f6f8f0559a938948f199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4c490bd9d17e3f9c3908a3ab7c3f0d"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1is__vector.html">is_vector</a>&lt; T &gt;, <a class="el" href="structstan_1_1is__prim__or__rev__kernel__expression.html">is_prim_or_rev_kernel_expression</a>&lt; T &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0d4c490bd9d17e3f9c3908a3ab7c3f0d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0d4c490bd9d17e3f9c3908a3ab7c3f0d.html#a0d4c490bd9d17e3f9c3908a3ab7c3f0d">check_vector_index</a> (const char *function, const char *name, const T &amp;y, size_t i)</td></tr>
<tr class="memdesc:a0d4c490bd9d17e3f9c3908a3ab7c3f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified index is a valid element of the row or column vector This check is 1-indexed by default.  <br /></td></tr>
<tr class="separator:a0d4c490bd9d17e3f9c3908a3ab7c3f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebafad688145fc64353e4f455d014bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeebafad688145fc64353e4f455d014bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeebafad688145fc64353e4f455d014bd.html#aeebafad688145fc64353e4f455d014bd">domain_error</a> (const char *function, const char *name, const T &amp;y, const char *msg1, const char *msg2)</td></tr>
<tr class="separator:aeebafad688145fc64353e4f455d014bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108d489a4a749c8e429b519d9e26c157"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a108d489a4a749c8e429b519d9e26c157"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a108d489a4a749c8e429b519d9e26c157.html#a108d489a4a749c8e429b519d9e26c157">domain_error</a> (const char *function, const char *name, const T &amp;y, const char *msg1)</td></tr>
<tr class="separator:a108d489a4a749c8e429b519d9e26c157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25639b3c27a227e1606ca917267c05c8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a25639b3c27a227e1606ca917267c05c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a25639b3c27a227e1606ca917267c05c8.html#a25639b3c27a227e1606ca917267c05c8">domain_error_vec</a> (const char *function, const char *name, const T &amp;y, size_t i, const char *msg1, const char *msg2)</td></tr>
<tr class="separator:a25639b3c27a227e1606ca917267c05c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2202974eb2454de5028673d5f5bee3c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2202974eb2454de5028673d5f5bee3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad2202974eb2454de5028673d5f5bee3c.html#ad2202974eb2454de5028673d5f5bee3c">domain_error_vec</a> (const char *function, const char *name, const T &amp;y, size_t i, const char *msg1)</td></tr>
<tr class="separator:ad2202974eb2454de5028673d5f5bee3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2470c81512e623b9316a51310a97b661"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... Indexings, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2470c81512e623b9316a51310a97b661"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2470c81512e623b9316a51310a97b661.html#a2470c81512e623b9316a51310a97b661">elementwise_check</a> (const F &amp;is_good, const char *function, const char *name, const T &amp;x, const char *must_be, const Indexings &amp;... indexings)</td></tr>
<tr class="memdesc:a2470c81512e623b9316a51310a97b661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the predicate holds for the value of <code>x</code>.  <br /></td></tr>
<tr class="separator:a2470c81512e623b9316a51310a97b661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2554ade8de85253b7d1a233ef5c055f8"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... Indexings, <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr, std::enable_if_t&lt;(Eigen::internal::traits&lt; T &gt;::Flags &amp;Eigen::LinearAccessBit)||T::IsVectorAtCompileTime &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2554ade8de85253b7d1a233ef5c055f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2554ade8de85253b7d1a233ef5c055f8.html#a2554ade8de85253b7d1a233ef5c055f8">elementwise_check</a> (const F &amp;is_good, const char *function, const char *name, const T &amp;x, const char *must_be, const Indexings &amp;... indexings)</td></tr>
<tr class="memdesc:a2554ade8de85253b7d1a233ef5c055f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the predicate holds for all elements of the value of <code>x</code>.  <br /></td></tr>
<tr class="separator:a2554ade8de85253b7d1a233ef5c055f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86d43ff9f966275e35193a884b3d6bd"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:ae86d43ff9f966275e35193a884b3d6bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae86d43ff9f966275e35193a884b3d6bd.html#ae86d43ff9f966275e35193a884b3d6bd">elementwise_is</a> (const F &amp;is_good, const T &amp;x)</td></tr>
<tr class="memdesc:ae86d43ff9f966275e35193a884b3d6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that the predicate holds for the value of <code>x</code>, working elementwise on containers.  <br /></td></tr>
<tr class="separator:ae86d43ff9f966275e35193a884b3d6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd0fcf9983d0e2b18a0770263e552f0"><td class="memTemplParams" colspan="2">template&lt;typename T_omega , typename T_Gamma , typename T_rho , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; T_omega, T_Gamma &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_rho &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5dd0fcf9983d0e2b18a0770263e552f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5dd0fcf9983d0e2b18a0770263e552f0.html#a5dd0fcf9983d0e2b18a0770263e552f0">hmm_check</a> (const T_omega &amp;log_omegas, const T_Gamma &amp;Gamma, const T_rho &amp;rho, const char *function)</td></tr>
<tr class="memdesc:a5dd0fcf9983d0e2b18a0770263e552f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check arguments for hidden Markov model functions with a discrete latent state (lpdf, rng for latent states, and marginal probabilities for latent sates).  <br /></td></tr>
<tr class="separator:a5dd0fcf9983d0e2b18a0770263e552f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcb1af5657f92ccadf5204fc43377fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bcb1af5657f92ccadf5204fc43377fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9bcb1af5657f92ccadf5204fc43377fd.html#a9bcb1af5657f92ccadf5204fc43377fd">invalid_argument</a> (const char *function, const char *name, const T &amp;y, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:a9bcb1af5657f92ccadf5204fc43377fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an invalid_argument exception with a consistently formatted message.  <br /></td></tr>
<tr class="separator:a9bcb1af5657f92ccadf5204fc43377fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf5709c614035ef60053a348e18554c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aacf5709c614035ef60053a348e18554c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aacf5709c614035ef60053a348e18554c.html#aacf5709c614035ef60053a348e18554c">invalid_argument</a> (const char *function, const char *name, const T &amp;y, const char *msg1)</td></tr>
<tr class="memdesc:aacf5709c614035ef60053a348e18554c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an invalid_argument exception with a consistently formatted message.  <br /></td></tr>
<tr class="separator:aacf5709c614035ef60053a348e18554c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209852214945630472cc47bf3343aed6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a209852214945630472cc47bf3343aed6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a209852214945630472cc47bf3343aed6.html#a209852214945630472cc47bf3343aed6">invalid_argument_vec</a> (const char *function, const char *name, const T &amp;y, size_t i, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:a209852214945630472cc47bf3343aed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an invalid argument exception with a consistently formatted message.  <br /></td></tr>
<tr class="separator:a209852214945630472cc47bf3343aed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c23881a8bf6f759b5b3ae828a29174"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a10c23881a8bf6f759b5b3ae828a29174"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a10c23881a8bf6f759b5b3ae828a29174.html#a10c23881a8bf6f759b5b3ae828a29174">invalid_argument_vec</a> (const char *function, const char *name, const T &amp;y, size_t i, const char *msg)</td></tr>
<tr class="memdesc:a10c23881a8bf6f759b5b3ae828a29174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an invalid argument exception with a consistently formatted message.  <br /></td></tr>
<tr class="separator:a10c23881a8bf6f759b5b3ae828a29174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53c6253d8f01c64ab5297abc3f6d5cf"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae53c6253d8f01c64ab5297abc3f6d5cf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae53c6253d8f01c64ab5297abc3f6d5cf.html#ae53c6253d8f01c64ab5297abc3f6d5cf">is_cholesky_factor</a> (const EigMat &amp;y)</td></tr>
<tr class="memdesc:ae53c6253d8f01c64ab5297abc3f6d5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if y is a valid Cholesky factor, if number of rows is not less than the number of columns, if there are no 0 columns, and no element in matrix is <code>NaN</code>.  <br /></td></tr>
<tr class="separator:ae53c6253d8f01c64ab5297abc3f6d5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05185216846e8217c1eb775d0da64df6"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a05185216846e8217c1eb775d0da64df6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a05185216846e8217c1eb775d0da64df6.html#a05185216846e8217c1eb775d0da64df6">is_cholesky_factor_corr</a> (const EigMat &amp;y)</td></tr>
<tr class="memdesc:a05185216846e8217c1eb775d0da64df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if y is a valid Cholesky factor, if the number of rows is not less than the number of columns, if there are no zero columns, and no element in matrix is <code>NaN</code>.  <br /></td></tr>
<tr class="separator:a05185216846e8217c1eb775d0da64df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabaf856f95d85b217e9d2b3a02a62ad5"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aabaf856f95d85b217e9d2b3a02a62ad5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aabaf856f95d85b217e9d2b3a02a62ad5.html#aabaf856f95d85b217e9d2b3a02a62ad5">is_column_index</a> (const EigMat &amp;y, size_t i)</td></tr>
<tr class="memdesc:aabaf856f95d85b217e9d2b3a02a62ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if column index is in bounds.  <br /></td></tr>
<tr class="separator:aabaf856f95d85b217e9d2b3a02a62ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b6b0e3fd8a1ff1aa6de5f7c5cf163e4"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3b6b0e3fd8a1ff1aa6de5f7c5cf163e4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3b6b0e3fd8a1ff1aa6de5f7c5cf163e4.html#a3b6b0e3fd8a1ff1aa6de5f7c5cf163e4">is_corr_matrix</a> (const EigMat &amp;y)</td></tr>
<tr class="memdesc:a3b6b0e3fd8a1ff1aa6de5f7c5cf163e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the matrix is square and not 0x0, if the matrix is symmetric, diagonals are near 1, positive definite, and no elements are <code>NaN</code> A valid correlation matrix is symmetric, has a unit diagonal (all 1 values), and has all values between -1 and 1 (inclusive).  <br /></td></tr>
<tr class="separator:a3b6b0e3fd8a1ff1aa6de5f7c5cf163e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca158bca2a5b85725322415d3bb8ba51"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca158bca2a5b85725322415d3bb8ba51"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aca158bca2a5b85725322415d3bb8ba51.html#aca158bca2a5b85725322415d3bb8ba51">is_ldlt_factor</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aca158bca2a5b85725322415d3bb8ba51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified LDLT factor is invalid.  <br /></td></tr>
<tr class="separator:aca158bca2a5b85725322415d3bb8ba51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10ba2a92f57f7eb363bcd19cdbfc787"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_high &gt; </td></tr>
<tr class="memitem:ab10ba2a92f57f7eb363bcd19cdbfc787"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab10ba2a92f57f7eb363bcd19cdbfc787.html#ab10ba2a92f57f7eb363bcd19cdbfc787">is_less_or_equal</a> (const T_y &amp;y, const T_high &amp;high)</td></tr>
<tr class="memdesc:ab10ba2a92f57f7eb363bcd19cdbfc787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is less or equal to <code>high</code>.  <br /></td></tr>
<tr class="separator:ab10ba2a92f57f7eb363bcd19cdbfc787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05fb017de750ad730599ebd773e66f9e"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a05fb017de750ad730599ebd773e66f9e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a05fb017de750ad730599ebd773e66f9e.html#a05fb017de750ad730599ebd773e66f9e">is_lower_triangular</a> (const EigMat &amp;y)</td></tr>
<tr class="memdesc:a05fb017de750ad730599ebd773e66f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> is matrix is lower triangular.  <br /></td></tr>
<tr class="separator:a05fb017de750ad730599ebd773e66f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba95167c5f88966d693fb184834aa348"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aba95167c5f88966d693fb184834aa348"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aba95167c5f88966d693fb184834aa348.html#aba95167c5f88966d693fb184834aa348">is_mat_finite</a> (const EigMat &amp;y)</td></tr>
<tr class="memdesc:aba95167c5f88966d693fb184834aa348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> is the specified matrix is finite.  <br /></td></tr>
<tr class="separator:aba95167c5f88966d693fb184834aa348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cc752292974b72118a947ed3de43b9"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a86cc752292974b72118a947ed3de43b9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a86cc752292974b72118a947ed3de43b9.html#a86cc752292974b72118a947ed3de43b9">is_matching_dims</a> (const EigMat1 &amp;y1, const EigMat2 &amp;y2)</td></tr>
<tr class="memdesc:a86cc752292974b72118a947ed3de43b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the two matrices are of the same size.  <br /></td></tr>
<tr class="separator:a86cc752292974b72118a947ed3de43b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f459940fac3b35996b1300b421c5d6"><td class="memTemplParams" colspan="2">template&lt;bool check_compile, typename EigMat1 , typename EigMat2 , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a57f459940fac3b35996b1300b421c5d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a57f459940fac3b35996b1300b421c5d6.html#a57f459940fac3b35996b1300b421c5d6">is_matching_dims</a> (const EigMat1 &amp;y1, const EigMat2 &amp;y2)</td></tr>
<tr class="memdesc:a57f459940fac3b35996b1300b421c5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the two matrices are of the same size.  <br /></td></tr>
<tr class="separator:a57f459940fac3b35996b1300b421c5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d7452b15202e5ce4b827cf9134d6f6"><td class="memTemplParams" colspan="2">template&lt;typename T_y1 , typename T_y2 &gt; </td></tr>
<tr class="memitem:ac6d7452b15202e5ce4b827cf9134d6f6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac6d7452b15202e5ce4b827cf9134d6f6.html#ac6d7452b15202e5ce4b827cf9134d6f6">is_matching_size</a> (const T_y1 &amp;y1, const T_y2 &amp;y2)</td></tr>
<tr class="memdesc:ac6d7452b15202e5ce4b827cf9134d6f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if two structures are the same size.  <br /></td></tr>
<tr class="separator:ac6d7452b15202e5ce4b827cf9134d6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2baf0164adba5ea75db788fcedf860b1"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a2baf0164adba5ea75db788fcedf860b1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2baf0164adba5ea75db788fcedf860b1.html#a2baf0164adba5ea75db788fcedf860b1">is_nonzero_size</a> (const T_y &amp;y)</td></tr>
<tr class="memdesc:a2baf0164adba5ea75db788fcedf860b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the specified matrix/vector is size nonzero.  <br /></td></tr>
<tr class="separator:a2baf0164adba5ea75db788fcedf860b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c311652e0937cd84b11ba88d8dbd240"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a5c311652e0937cd84b11ba88d8dbd240"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5c311652e0937cd84b11ba88d8dbd240.html#a5c311652e0937cd84b11ba88d8dbd240">is_not_nan</a> (const T_y &amp;y)</td></tr>
<tr class="memdesc:a5c311652e0937cd84b11ba88d8dbd240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is not <code>NaN</code>.  <br /></td></tr>
<tr class="separator:a5c311652e0937cd84b11ba88d8dbd240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86254326bddb7f24566e72378f275854"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a86254326bddb7f24566e72378f275854"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a86254326bddb7f24566e72378f275854.html#a86254326bddb7f24566e72378f275854">is_ordered</a> (const std::vector&lt; T_y &gt; &amp;y)</td></tr>
<tr class="memdesc:a86254326bddb7f24566e72378f275854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the vector is sorted into strictly increasing order.  <br /></td></tr>
<tr class="separator:a86254326bddb7f24566e72378f275854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4876270d9070852f35f8afca5835c4"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b4876270d9070852f35f8afca5835c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4b4876270d9070852f35f8afca5835c4.html#a4b4876270d9070852f35f8afca5835c4">is_pos_definite</a> (const EigMat &amp;y)</td></tr>
<tr class="memdesc:a4b4876270d9070852f35f8afca5835c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the matrix is square or if the matrix has non-zero size, or if the matrix is symmetric, or if it is positive definite, or if no element is <code>NaN</code>.  <br /></td></tr>
<tr class="separator:a4b4876270d9070852f35f8afca5835c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b82c4cdfa68f929e71f1e8bc8c10722"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4b82c4cdfa68f929e71f1e8bc8c10722"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4b82c4cdfa68f929e71f1e8bc8c10722.html#a4b82c4cdfa68f929e71f1e8bc8c10722">is_pos_definite</a> (const Eigen::LDLT&lt; Derived &gt; &amp;cholesky)</td></tr>
<tr class="memdesc:a4b82c4cdfa68f929e71f1e8bc8c10722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the matrix is positive definite.  <br /></td></tr>
<tr class="separator:a4b82c4cdfa68f929e71f1e8bc8c10722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac927547ad8dbc285bbd19ac3988f2b6f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ac927547ad8dbc285bbd19ac3988f2b6f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac927547ad8dbc285bbd19ac3988f2b6f.html#ac927547ad8dbc285bbd19ac3988f2b6f">is_pos_definite</a> (const Eigen::LLT&lt; Derived &gt; &amp;cholesky)</td></tr>
<tr class="memdesc:ac927547ad8dbc285bbd19ac3988f2b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if diagonal of the L matrix is positive.  <br /></td></tr>
<tr class="separator:ac927547ad8dbc285bbd19ac3988f2b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ad78d848a53f979c6e4d8d951e9292"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a10ad78d848a53f979c6e4d8d951e9292"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a10ad78d848a53f979c6e4d8d951e9292.html#a10ad78d848a53f979c6e4d8d951e9292">is_positive</a> (const T_y &amp;y)</td></tr>
<tr class="memdesc:a10ad78d848a53f979c6e4d8d951e9292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is positive.  <br /></td></tr>
<tr class="separator:a10ad78d848a53f979c6e4d8d951e9292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c592ebba72cdd2e46f30626023fe6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a38c592ebba72cdd2e46f30626023fe6d.html#a38c592ebba72cdd2e46f30626023fe6d">is_positive</a> (int <a class="el" href="group__type__trait_gaf82cac3bdccc9b64e7a55a8bd47880a7.html#gaf82cac3bdccc9b64e7a55a8bd47880a7">size</a>)</td></tr>
<tr class="memdesc:a38c592ebba72cdd2e46f30626023fe6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>size</code> is positive.  <br /></td></tr>
<tr class="separator:a38c592ebba72cdd2e46f30626023fe6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d702502d965415bbb987eccd72125a2"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a7d702502d965415bbb987eccd72125a2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7d702502d965415bbb987eccd72125a2.html#a7d702502d965415bbb987eccd72125a2">is_scal_finite</a> (const T_y &amp;y)</td></tr>
<tr class="memdesc:a7d702502d965415bbb987eccd72125a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if <code>y</code> is finite.  <br /></td></tr>
<tr class="separator:a7d702502d965415bbb987eccd72125a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a56f8ba229dcc646d363dcdf1263fd1"><td class="memTemplParams" colspan="2">template&lt;typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:a0a56f8ba229dcc646d363dcdf1263fd1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0a56f8ba229dcc646d363dcdf1263fd1.html#a0a56f8ba229dcc646d363dcdf1263fd1">is_size_match</a> (T_size1 i, T_size2 j)</td></tr>
<tr class="memdesc:a0a56f8ba229dcc646d363dcdf1263fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the provided sizes match.  <br /></td></tr>
<tr class="separator:a0a56f8ba229dcc646d363dcdf1263fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61d8b9b7d80a5e5a54d50350a97484a"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa61d8b9b7d80a5e5a54d50350a97484a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa61d8b9b7d80a5e5a54d50350a97484a.html#aa61d8b9b7d80a5e5a54d50350a97484a">is_square</a> (const EigMat &amp;y)</td></tr>
<tr class="memdesc:aa61d8b9b7d80a5e5a54d50350a97484a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the matrix is square.  <br /></td></tr>
<tr class="separator:aa61d8b9b7d80a5e5a54d50350a97484a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad398e9ef773c65631be32dc4c1783858"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad398e9ef773c65631be32dc4c1783858"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad398e9ef773c65631be32dc4c1783858.html#ad398e9ef773c65631be32dc4c1783858">is_symmetric</a> (const EigMat &amp;y)</td></tr>
<tr class="memdesc:ad398e9ef773c65631be32dc4c1783858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the matrix is square, and no element not on the main diagonal is <code>NaN</code>.  <br /></td></tr>
<tr class="separator:ad398e9ef773c65631be32dc4c1783858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2175afacde47ea5df67a1825070eb40"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac2175afacde47ea5df67a1825070eb40"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac2175afacde47ea5df67a1825070eb40.html#ac2175afacde47ea5df67a1825070eb40">is_unit_vector</a> (const EigVec &amp;theta)</td></tr>
<tr class="memdesc:ac2175afacde47ea5df67a1825070eb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the vector is not a unit vector or if any element is <code>NaN</code>.  <br /></td></tr>
<tr class="separator:ac2175afacde47ea5df67a1825070eb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa602fa10662532ef73edfa70ed3add15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa602fa10662532ef73edfa70ed3add15.html#aa602fa10662532ef73edfa70ed3add15">out_of_range</a> (const char *function, int <a class="el" href="namespacestan_1_1math_a79b5e7fd8ad5d82b06906917a4393c67.html#a79b5e7fd8ad5d82b06906917a4393c67">max</a>, int index, const char *msg1=&quot;&quot;, const char *msg2=&quot;&quot;)</td></tr>
<tr class="memdesc:aa602fa10662532ef73edfa70ed3add15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw an out_of_range exception with a consistently formatted message.  <br /></td></tr>
<tr class="separator:aa602fa10662532ef73edfa70ed3add15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2cc1d83b9b3fb48327fe40c2351748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aad2cc1d83b9b3fb48327fe40c2351748.html#aad2cc1d83b9b3fb48327fe40c2351748">system_error</a> (const char *function, const char *name, const int &amp;y, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:aad2cc1d83b9b3fb48327fe40c2351748"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a system error with a consistently formatted message.  <br /></td></tr>
<tr class="separator:aad2cc1d83b9b3fb48327fe40c2351748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f1f064431dcb4830a8eba52c91984c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac9f1f064431dcb4830a8eba52c91984c.html#ac9f1f064431dcb4830a8eba52c91984c">system_error</a> (const char *function, const char *name, const int &amp;y, const char *msg1)</td></tr>
<tr class="memdesc:ac9f1f064431dcb4830a8eba52c91984c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a system error with a consistently formatted message.  <br /></td></tr>
<tr class="separator:ac9f1f064431dcb4830a8eba52c91984c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6557b18ff1a176110eaf2bb8525cfd79"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6557b18ff1a176110eaf2bb8525cfd79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6557b18ff1a176110eaf2bb8525cfd79.html#a6557b18ff1a176110eaf2bb8525cfd79">throw_domain_error</a> (const char *function, const char *name, const T &amp;y, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:a6557b18ff1a176110eaf2bb8525cfd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message.  <br /></td></tr>
<tr class="separator:a6557b18ff1a176110eaf2bb8525cfd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fdf72914cfd30bf02bee182e91a3a4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a35fdf72914cfd30bf02bee182e91a3a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a35fdf72914cfd30bf02bee182e91a3a4.html#a35fdf72914cfd30bf02bee182e91a3a4">throw_domain_error</a> (const char *function, const char *name, const T &amp;y, const char *msg1)</td></tr>
<tr class="memdesc:a35fdf72914cfd30bf02bee182e91a3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message.  <br /></td></tr>
<tr class="separator:a35fdf72914cfd30bf02bee182e91a3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2ad924a3b27fdab414ab0d16933263"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaa2ad924a3b27fdab414ab0d16933263"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaa2ad924a3b27fdab414ab0d16933263.html#aaa2ad924a3b27fdab414ab0d16933263">throw_domain_error_mat</a> (const char *function, const char *name, const T &amp;y, size_t i, size_t j, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:aaa2ad924a3b27fdab414ab0d16933263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message for matrices.  <br /></td></tr>
<tr class="separator:aaa2ad924a3b27fdab414ab0d16933263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84268e48d0b96aa703552cd03a3d443"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa84268e48d0b96aa703552cd03a3d443"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa84268e48d0b96aa703552cd03a3d443.html#aa84268e48d0b96aa703552cd03a3d443">throw_domain_error_mat</a> (const char *function, const char *name, const T &amp;y, size_t i, size_t j, const char *msg)</td></tr>
<tr class="memdesc:aa84268e48d0b96aa703552cd03a3d443"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message for matrices.  <br /></td></tr>
<tr class="separator:aa84268e48d0b96aa703552cd03a3d443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5e893a0678c908c5a1e86a63210c84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d5e893a0678c908c5a1e86a63210c84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6d5e893a0678c908c5a1e86a63210c84.html#a6d5e893a0678c908c5a1e86a63210c84">throw_domain_error_vec</a> (const char *function, const char *name, const T &amp;y, size_t i, const char *msg1, const char *msg2)</td></tr>
<tr class="memdesc:a6d5e893a0678c908c5a1e86a63210c84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message.  <br /></td></tr>
<tr class="separator:a6d5e893a0678c908c5a1e86a63210c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac793a7337c8524d9dec12628a3c80c5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac793a7337c8524d9dec12628a3c80c5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac793a7337c8524d9dec12628a3c80c5a.html#ac793a7337c8524d9dec12628a3c80c5a">throw_domain_error_vec</a> (const char *function, const char *name, const T &amp;y, size_t i, const char *msg)</td></tr>
<tr class="memdesc:ac793a7337c8524d9dec12628a3c80c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain error with a consistently formatted message.  <br /></td></tr>
<tr class="separator:ac793a7337c8524d9dec12628a3c80c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb591fca3d88d2a5d587ce6172b62bf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abb591fca3d88d2a5d587ce6172b62bf4.html#abb591fca3d88d2a5d587ce6172b62bf4">validate_non_negative_index</a> (const char *var_name, const char *expr, int val)</td></tr>
<tr class="separator:abb591fca3d88d2a5d587ce6172b62bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff3e5c89073f1d7c03662a819c2c5ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaff3e5c89073f1d7c03662a819c2c5ed.html#aaff3e5c89073f1d7c03662a819c2c5ed">validate_positive_index</a> (const char *var_name, const char *expr, int val)</td></tr>
<tr class="memdesc:aaff3e5c89073f1d7c03662a819c2c5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that simplex is at least size 1.  <br /></td></tr>
<tr class="separator:aaff3e5c89073f1d7c03662a819c2c5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54dbb8756693eaa5fea075f2fabc58be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a54dbb8756693eaa5fea075f2fabc58be.html#a54dbb8756693eaa5fea075f2fabc58be">validate_unit_vector_index</a> (const char *var_name, const char *expr, int val)</td></tr>
<tr class="memdesc:a54dbb8756693eaa5fea075f2fabc58be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that unit vector is at least size 2.  <br /></td></tr>
<tr class="separator:a54dbb8756693eaa5fea075f2fabc58be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519418e20b7c5246f9e3e5d59eb86303"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a519418e20b7c5246f9e3e5d59eb86303"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a519418e20b7c5246f9e3e5d59eb86303.html#a519418e20b7c5246f9e3e5d59eb86303">abs</a> (T x)</td></tr>
<tr class="memdesc:a519418e20b7c5246f9e3e5d59eb86303"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute value of the specified arithmetic argument.  <br /></td></tr>
<tr class="separator:a519418e20b7c5246f9e3e5d59eb86303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202d2bb838b566a1fe623915816ad474"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__complex__types_ga2c903fceb2dfd2cea898b67c57383a48.html#ga2c903fceb2dfd2cea898b67c57383a48">require_complex_bt</a>&lt; std::is_arithmetic, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a202d2bb838b566a1fe623915816ad474"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a202d2bb838b566a1fe623915816ad474.html#a202d2bb838b566a1fe623915816ad474">abs</a> (T x)</td></tr>
<tr class="memdesc:a202d2bb838b566a1fe623915816ad474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute value (also known as the norm, modulus, or magnitude) of the specified complex argument.  <br /></td></tr>
<tr class="separator:a202d2bb838b566a1fe623915816ad474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa978affc4b1834c9b2dc8104ff9c629b"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa978affc4b1834c9b2dc8104ff9c629b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa978affc4b1834c9b2dc8104ff9c629b.html#aa978affc4b1834c9b2dc8104ff9c629b">abs</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:aa978affc4b1834c9b2dc8104ff9c629b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a07668d449deca145c19b0feaf564f789.html#a07668d449deca145c19b0feaf564f789">abs()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:aa978affc4b1834c9b2dc8104ff9c629b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aacff4e5da314d687af206b7495da59"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9aacff4e5da314d687af206b7495da59"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9aacff4e5da314d687af206b7495da59.html#a9aacff4e5da314d687af206b7495da59">acos</a> (const T x)</td></tr>
<tr class="memdesc:a9aacff4e5da314d687af206b7495da59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arc cosine of the arithmetic argument.  <br /></td></tr>
<tr class="separator:a9aacff4e5da314d687af206b7495da59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac600a0f0bcec739358becbc52c5ce71b"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac600a0f0bcec739358becbc52c5ce71b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac600a0f0bcec739358becbc52c5ce71b.html#ac600a0f0bcec739358becbc52c5ce71b">acos</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ac600a0f0bcec739358becbc52c5ce71b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a0225b71faa7dc05c3fd41e70dc6cc34b.html#a0225b71faa7dc05c3fd41e70dc6cc34b">acos()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:ac600a0f0bcec739358becbc52c5ce71b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8737321b0374c774ada597f350f35a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4a8737321b0374c774ada597f350f35a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a8737321b0374c774ada597f350f35a.html#a4a8737321b0374c774ada597f350f35a">acosh</a> (const T x)</td></tr>
<tr class="memdesc:a4a8737321b0374c774ada597f350f35a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse hyperbolic cosine of the specified value.  <br /></td></tr>
<tr class="separator:a4a8737321b0374c774ada597f350f35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0e7bca61ff936dc53792e8ea3069bc"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__complex__types_ga2c903fceb2dfd2cea898b67c57383a48.html#ga2c903fceb2dfd2cea898b67c57383a48">require_complex_bt</a>&lt; std::is_arithmetic, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2f0e7bca61ff936dc53792e8ea3069bc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f0e7bca61ff936dc53792e8ea3069bc.html#a2f0e7bca61ff936dc53792e8ea3069bc">acosh</a> (const T x)</td></tr>
<tr class="memdesc:a2f0e7bca61ff936dc53792e8ea3069bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse hyperbolic cosine of the specified value.  <br /></td></tr>
<tr class="separator:a2f0e7bca61ff936dc53792e8ea3069bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354a61c6ba585bbf8301f628a8e900da"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a354a61c6ba585bbf8301f628a8e900da"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a354a61c6ba585bbf8301f628a8e900da.html#a354a61c6ba585bbf8301f628a8e900da">acosh</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a354a61c6ba585bbf8301f628a8e900da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a1f4aba0a2fc965c0abc4ea84508a09e3.html#a1f4aba0a2fc965c0abc4ea84508a09e3">acosh()</a></code> to specified argument container.  <br /></td></tr>
<tr class="separator:a354a61c6ba585bbf8301f628a8e900da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947a9b8a012a0497095f82f02be8ebee"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga846e5c75f0e49887b255adb8e56e1a7e.html#ga846e5c75f0e49887b255adb8e56e1a7e">require_container_bt</a>&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a947a9b8a012a0497095f82f02be8ebee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a947a9b8a012a0497095f82f02be8ebee.html#a947a9b8a012a0497095f82f02be8ebee">acosh</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a947a9b8a012a0497095f82f02be8ebee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a1f4aba0a2fc965c0abc4ea84508a09e3.html#a1f4aba0a2fc965c0abc4ea84508a09e3">acosh()</a></code> to specified argument container.  <br /></td></tr>
<tr class="separator:a947a9b8a012a0497095f82f02be8ebee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f6542a886357c6279ce4a3d743a1955"><td class="memTemplParams" colspan="2">template&lt;typename ScalarA , typename ScalarB , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; ScalarA, ScalarB &gt; *  = nullptr, <a class="el" href="group__var__types_gacd1267e326cb7764f47ddfba577dabdb.html#gacd1267e326cb7764f47ddfba577dabdb">require_all_not_var_t</a>&lt; ScalarA, ScalarB &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7f6542a886357c6279ce4a3d743a1955"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; ScalarA, ScalarB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7f6542a886357c6279ce4a3d743a1955.html#a7f6542a886357c6279ce4a3d743a1955">add</a> (const ScalarA &amp;a, const ScalarB &amp;b)</td></tr>
<tr class="memdesc:a7f6542a886357c6279ce4a3d743a1955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified scalars.  <br /></td></tr>
<tr class="separator:a7f6542a886357c6279ce4a3d743a1955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7279e3b054d2f3d7135d4ceeb2f8cc6f"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7279e3b054d2f3d7135d4ceeb2f8cc6f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7279e3b054d2f3d7135d4ceeb2f8cc6f.html#a7279e3b054d2f3d7135d4ceeb2f8cc6f">add</a> (const Mat1 &amp;m1, const Mat2 &amp;m2)</td></tr>
<tr class="memdesc:a7279e3b054d2f3d7135d4ceeb2f8cc6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified matrices.  <br /></td></tr>
<tr class="separator:a7279e3b054d2f3d7135d4ceeb2f8cc6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74920b4f0a49580341bf01614081c2af"><td class="memTemplParams" colspan="2">template&lt;typename Mat , typename Scal , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; Mat, Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a74920b4f0a49580341bf01614081c2af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a74920b4f0a49580341bf01614081c2af.html#a74920b4f0a49580341bf01614081c2af">add</a> (const Mat &amp;m, const Scal c)</td></tr>
<tr class="memdesc:a74920b4f0a49580341bf01614081c2af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified matrix and specified scalar.  <br /></td></tr>
<tr class="separator:a74920b4f0a49580341bf01614081c2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642c0a40cebcd708b737eaacae63333a"><td class="memTemplParams" colspan="2">template&lt;typename Scal , typename Mat , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; Scal, Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a642c0a40cebcd708b737eaacae63333a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a642c0a40cebcd708b737eaacae63333a.html#a642c0a40cebcd708b737eaacae63333a">add</a> (const Scal c, const Mat &amp;m)</td></tr>
<tr class="memdesc:a642c0a40cebcd708b737eaacae63333a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the specified scalar and specified matrix.  <br /></td></tr>
<tr class="separator:a642c0a40cebcd708b737eaacae63333a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2508284477e8970aac5bacda02dbf099"><td class="memTemplParams" colspan="2">template&lt;typename T_m , typename T_a , typename  = require_eigen_t&lt;T_m&gt;, typename  = require_any_t&lt;is_eigen_vector&lt;T_a&gt;, is_stan_scalar&lt;T_a&gt;&gt;&gt; </td></tr>
<tr class="memitem:a2508284477e8970aac5bacda02dbf099"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_m, T_a &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2508284477e8970aac5bacda02dbf099.html#a2508284477e8970aac5bacda02dbf099">add_diag</a> (const T_m &amp;mat, const T_a &amp;to_add)</td></tr>
<tr class="memdesc:a2508284477e8970aac5bacda02dbf099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matrix with values added along the main diagonal.  <br /></td></tr>
<tr class="separator:a2508284477e8970aac5bacda02dbf099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f80dde472aeacc51fdb9eecc3050773"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_convertible&lt; T, bool &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2f80dde472aeacc51fdb9eecc3050773"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f80dde472aeacc51fdb9eecc3050773.html#a2f80dde472aeacc51fdb9eecc3050773">all</a> (T x)</td></tr>
<tr class="memdesc:a2f80dde472aeacc51fdb9eecc3050773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all values in the input are true.  <br /></td></tr>
<tr class="separator:a2f80dde472aeacc51fdb9eecc3050773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa416540d787d80828aead658116b6f"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , <a class="el" href="group__eigen__types_ga51f433bbb5e3f53af4ef6dc9bc84b7af.html#ga51f433bbb5e3f53af4ef6dc9bc84b7af">require_eigen_st</a>&lt; std::is_integral, ContainerT &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8fa416540d787d80828aead658116b6f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8fa416540d787d80828aead658116b6f.html#a8fa416540d787d80828aead658116b6f">all</a> (const ContainerT &amp;x)</td></tr>
<tr class="memdesc:a8fa416540d787d80828aead658116b6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all values in the input are true.  <br /></td></tr>
<tr class="separator:a8fa416540d787d80828aead658116b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade9bf2380554fa60f80cce447722555"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:aade9bf2380554fa60f80cce447722555"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aade9bf2380554fa60f80cce447722555.html#aade9bf2380554fa60f80cce447722555">all</a> (const std::tuple&lt; Types... &gt; &amp;x)</td></tr>
<tr class="memdesc:aade9bf2380554fa60f80cce447722555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all values in the input are true.  <br /></td></tr>
<tr class="separator:aade9bf2380554fa60f80cce447722555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69a02d85bfafb2c401877ba9139f999"><td class="memTemplParams" colspan="2">template&lt;typename InnerT &gt; </td></tr>
<tr class="memitem:ac69a02d85bfafb2c401877ba9139f999"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac69a02d85bfafb2c401877ba9139f999.html#ac69a02d85bfafb2c401877ba9139f999">all</a> (const std::vector&lt; InnerT &gt; &amp;x)</td></tr>
<tr class="memdesc:ac69a02d85bfafb2c401877ba9139f999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if all values in the input are true.  <br /></td></tr>
<tr class="separator:ac69a02d85bfafb2c401877ba9139f999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472fe358aa11abf08e43d512328b566e"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_convertible&lt; T, bool &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a472fe358aa11abf08e43d512328b566e"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a472fe358aa11abf08e43d512328b566e.html#a472fe358aa11abf08e43d512328b566e">any</a> (T x)</td></tr>
<tr class="memdesc:a472fe358aa11abf08e43d512328b566e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any values in the input are true.  <br /></td></tr>
<tr class="separator:a472fe358aa11abf08e43d512328b566e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f861c56e417fd0d1950c6c70c2bea9f"><td class="memTemplParams" colspan="2">template&lt;typename ContainerT , <a class="el" href="group__eigen__types_ga51f433bbb5e3f53af4ef6dc9bc84b7af.html#ga51f433bbb5e3f53af4ef6dc9bc84b7af">require_eigen_st</a>&lt; std::is_integral, ContainerT &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7f861c56e417fd0d1950c6c70c2bea9f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7f861c56e417fd0d1950c6c70c2bea9f.html#a7f861c56e417fd0d1950c6c70c2bea9f">any</a> (const ContainerT &amp;x)</td></tr>
<tr class="memdesc:a7f861c56e417fd0d1950c6c70c2bea9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any values in the input are true.  <br /></td></tr>
<tr class="separator:a7f861c56e417fd0d1950c6c70c2bea9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e3b9da68a29c07b729c2f18c698dd9"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a09e3b9da68a29c07b729c2f18c698dd9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a09e3b9da68a29c07b729c2f18c698dd9.html#a09e3b9da68a29c07b729c2f18c698dd9">any</a> (const std::tuple&lt; Types... &gt; &amp;x)</td></tr>
<tr class="memdesc:a09e3b9da68a29c07b729c2f18c698dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any values in the input are true.  <br /></td></tr>
<tr class="separator:a09e3b9da68a29c07b729c2f18c698dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33db72af7b18a413762d2064967536c3"><td class="memTemplParams" colspan="2">template&lt;typename InnerT &gt; </td></tr>
<tr class="memitem:a33db72af7b18a413762d2064967536c3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a33db72af7b18a413762d2064967536c3.html#a33db72af7b18a413762d2064967536c3">any</a> (const std::vector&lt; InnerT &gt; &amp;x)</td></tr>
<tr class="memdesc:a33db72af7b18a413762d2064967536c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any values in the input are true.  <br /></td></tr>
<tr class="separator:a33db72af7b18a413762d2064967536c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8d05f99cac7d60d84dd02896288651"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:adf8d05f99cac7d60d84dd02896288651"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1append__return__type.html">append_return_type</a>&lt; std::vector&lt; T1 &gt;, std::vector&lt; T2 &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adf8d05f99cac7d60d84dd02896288651.html#adf8d05f99cac7d60d84dd02896288651">append_array</a> (const std::vector&lt; T1 &gt; &amp;x, const std::vector&lt; T2 &gt; &amp;y)</td></tr>
<tr class="memdesc:adf8d05f99cac7d60d84dd02896288651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the concatenation of two specified vectors in the order of the arguments.  <br /></td></tr>
<tr class="separator:adf8d05f99cac7d60d84dd02896288651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af298c16922e9dd2a0c9a7276dbfaef"><td class="memTemplParams" colspan="2">template&lt;typename T1 &gt; </td></tr>
<tr class="memitem:a6af298c16922e9dd2a0c9a7276dbfaef"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6af298c16922e9dd2a0c9a7276dbfaef.html#a6af298c16922e9dd2a0c9a7276dbfaef">append_array</a> (const std::vector&lt; T1 &gt; &amp;x, const std::vector&lt; T1 &gt; &amp;y)</td></tr>
<tr class="memdesc:a6af298c16922e9dd2a0c9a7276dbfaef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the concatenation of two specified vectors in the order of the arguments.  <br /></td></tr>
<tr class="separator:a6af298c16922e9dd2a0c9a7276dbfaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e15d49d5577954a54aacf4b7a4a92a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = require_all_eigen_t&lt;T1, T2&gt;&gt; </td></tr>
<tr class="memitem:a38e15d49d5577954a54aacf4b7a4a92a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a38e15d49d5577954a54aacf4b7a4a92a.html#a38e15d49d5577954a54aacf4b7a4a92a">append_col</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:a38e15d49d5577954a54aacf4b7a4a92a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of appending the second argument matrix after the first argument matrix, that is, putting them side by side, with the first matrix followed by the second matrix.  <br /></td></tr>
<tr class="separator:a38e15d49d5577954a54aacf4b7a4a92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37e49650f05523fc4b3f252e51c315b"><td class="memTemplParams" colspan="2">template&lt;typename Scal , typename RowVec , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal &gt; *  = nullptr, <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__row__vector.html">is_eigen_row_vector</a>&lt; RowVec &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af37e49650f05523fc4b3f252e51c315b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Scal, RowVec &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af37e49650f05523fc4b3f252e51c315b.html#af37e49650f05523fc4b3f252e51c315b">append_col</a> (const Scal &amp;A, const RowVec &amp;B)</td></tr>
<tr class="memdesc:af37e49650f05523fc4b3f252e51c315b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking an scalar on top of the a row vector, with the result being a row vector.  <br /></td></tr>
<tr class="separator:af37e49650f05523fc4b3f252e51c315b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874accf98c0c8550c159035351703753"><td class="memTemplParams" colspan="2">template&lt;typename RowVec , typename Scal , <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__row__vector.html">is_eigen_row_vector</a>&lt; RowVec &gt; &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a874accf98c0c8550c159035351703753"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; RowVec, Scal &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a874accf98c0c8550c159035351703753.html#a874accf98c0c8550c159035351703753">append_col</a> (const RowVec &amp;A, const Scal &amp;B)</td></tr>
<tr class="memdesc:a874accf98c0c8550c159035351703753"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking a row vector on top of the an scalar, with the result being a row vector.  <br /></td></tr>
<tr class="separator:a874accf98c0c8550c159035351703753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728b7a3f1a99f8bded1c0c65e4d234b6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a728b7a3f1a99f8bded1c0c65e4d234b6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a728b7a3f1a99f8bded1c0c65e4d234b6.html#a728b7a3f1a99f8bded1c0c65e4d234b6">append_row</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:a728b7a3f1a99f8bded1c0c65e4d234b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking the rows of the first argument matrix on top of the second argument matrix.  <br /></td></tr>
<tr class="separator:a728b7a3f1a99f8bded1c0c65e4d234b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7838a9167f822c948b86dc1cb56b15"><td class="memTemplParams" colspan="2">template&lt;typename Scal , typename ColVec , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal &gt; *  = nullptr, <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__col__vector.html">is_eigen_col_vector</a>&lt; ColVec &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afb7838a9167f822c948b86dc1cb56b15"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Scal, ColVec &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afb7838a9167f822c948b86dc1cb56b15.html#afb7838a9167f822c948b86dc1cb56b15">append_row</a> (const Scal &amp;A, const ColVec &amp;B)</td></tr>
<tr class="memdesc:afb7838a9167f822c948b86dc1cb56b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking an scalar on top of the a vector, with the result being a vector.  <br /></td></tr>
<tr class="separator:afb7838a9167f822c948b86dc1cb56b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee8489ccc3ad5ff30514efdecb41b57"><td class="memTemplParams" colspan="2">template&lt;typename ColVec , typename Scal , <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__col__vector.html">is_eigen_col_vector</a>&lt; ColVec &gt; &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9ee8489ccc3ad5ff30514efdecb41b57"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; ColVec, Scal &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ee8489ccc3ad5ff30514efdecb41b57.html#a9ee8489ccc3ad5ff30514efdecb41b57">append_row</a> (const ColVec &amp;A, const Scal &amp;B)</td></tr>
<tr class="memdesc:a9ee8489ccc3ad5ff30514efdecb41b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking a vector on top of the an scalar, with the result being a vector.  <br /></td></tr>
<tr class="separator:a9ee8489ccc3ad5ff30514efdecb41b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78a36dbb7b8d0024c7c9e94c86f0da7"><td class="memTemplParams" colspan="2">template&lt;typename V , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa78a36dbb7b8d0024c7c9e94c86f0da7"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa78a36dbb7b8d0024c7c9e94c86f0da7.html#aa78a36dbb7b8d0024c7c9e94c86f0da7">arg</a> (const std::complex&lt; V &gt; &amp;z)</td></tr>
<tr class="memdesc:aa78a36dbb7b8d0024c7c9e94c86f0da7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the phase angle of the complex argument.  <br /></td></tr>
<tr class="separator:aa78a36dbb7b8d0024c7c9e94c86f0da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d68c4271b3143131e6526963c3ebde"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a24d68c4271b3143131e6526963c3ebde"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a24d68c4271b3143131e6526963c3ebde.html#a24d68c4271b3143131e6526963c3ebde">as_array_or_scalar</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:a24d68c4271b3143131e6526963c3ebde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns specified input value.  <br /></td></tr>
<tr class="separator:a24d68c4271b3143131e6526963c3ebde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552e1bfc92a06817b3f7f59bc82b6101"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a552e1bfc92a06817b3f7f59bc82b6101"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a552e1bfc92a06817b3f7f59bc82b6101.html#a552e1bfc92a06817b3f7f59bc82b6101">as_array_or_scalar</a> (T &amp;v)</td></tr>
<tr class="memdesc:a552e1bfc92a06817b3f7f59bc82b6101"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to rvalue specified input value.  <br /></td></tr>
<tr class="separator:a552e1bfc92a06817b3f7f59bc82b6101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d0af937ab5e14191ba11b00bb4d937"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_eigen_t&lt;T&gt;, <a class="el" href="group__eigen__array__types_gade1b91fc653c360446d9636e416bf259.html#gade1b91fc653c360446d9636e416bf259">require_not_eigen_array_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac5d0af937ab5e14191ba11b00bb4d937"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac5d0af937ab5e14191ba11b00bb4d937.html#ac5d0af937ab5e14191ba11b00bb4d937">as_array_or_scalar</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:ac5d0af937ab5e14191ba11b00bb4d937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a matrix type to an array.  <br /></td></tr>
<tr class="separator:ac5d0af937ab5e14191ba11b00bb4d937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54acb5711b02ac0e6fcc604101453174"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a54acb5711b02ac0e6fcc604101453174"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a54acb5711b02ac0e6fcc604101453174.html#a54acb5711b02ac0e6fcc604101453174">as_bool</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a54acb5711b02ac0e6fcc604101453174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the argument is not equal to zero (in the <code>!=</code> operator sense) and false otherwise.  <br /></td></tr>
<tr class="separator:a54acb5711b02ac0e6fcc604101453174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9cd6c829a22e39e5b937e20efcb808"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acb9cd6c829a22e39e5b937e20efcb808"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acb9cd6c829a22e39e5b937e20efcb808.html#acb9cd6c829a22e39e5b937e20efcb808">as_column_vector_or_scalar</a> (const T &amp;a)</td></tr>
<tr class="memdesc:acb9cd6c829a22e39e5b937e20efcb808"><td class="mdescLeft">&#160;</td><td class="mdescRight">no-op that passes the scalar  <br /></td></tr>
<tr class="separator:acb9cd6c829a22e39e5b937e20efcb808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507e0cfd47660745cb44db2a798b85f6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:a507e0cfd47660745cb44db2a798b85f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">internal::empty_broadcast_array</a>&lt; T, S, void &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a507e0cfd47660745cb44db2a798b85f6.html#a507e0cfd47660745cb44db2a798b85f6">as_column_vector_or_scalar</a> (<a class="el" href="classstan_1_1math_1_1internal_1_1empty__broadcast__array.html">internal::empty_broadcast_array</a>&lt; T, S, void &gt; &amp;a)</td></tr>
<tr class="memdesc:a507e0cfd47660745cb44db2a798b85f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-op used when working with operands and partials.  <br /></td></tr>
<tr class="separator:a507e0cfd47660745cb44db2a798b85f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613945c688b70c158184142c48238e03"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a613945c688b70c158184142c48238e03"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a613945c688b70c158184142c48238e03.html#a613945c688b70c158184142c48238e03">as_column_vector_or_scalar</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a613945c688b70c158184142c48238e03"><td class="mdescLeft">&#160;</td><td class="mdescRight">no-op that returns a column vector.  <br /></td></tr>
<tr class="separator:a613945c688b70c158184142c48238e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9826957b0a219361ed809e1f33beec62"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__row__vector__types_ga2aff7daad297cba7bc223382ac23d8ff.html#ga2aff7daad297cba7bc223382ac23d8ff">require_eigen_row_vector_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga76e63e3ea85c77800e3a4cda6aed0357.html#ga76e63e3ea85c77800e3a4cda6aed0357">require_not_eigen_col_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9826957b0a219361ed809e1f33beec62"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9826957b0a219361ed809e1f33beec62.html#a9826957b0a219361ed809e1f33beec62">as_column_vector_or_scalar</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a9826957b0a219361ed809e1f33beec62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a row vector to an eigen column vector.  <br /></td></tr>
<tr class="separator:a9826957b0a219361ed809e1f33beec62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ce84bcf144e49cdd2acc52b890609f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae1ce84bcf144e49cdd2acc52b890609f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae1ce84bcf144e49cdd2acc52b890609f.html#ae1ce84bcf144e49cdd2acc52b890609f">as_value_array_or_scalar</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:ae1ce84bcf144e49cdd2acc52b890609f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the value from an object.  <br /></td></tr>
<tr class="separator:ae1ce84bcf144e49cdd2acc52b890609f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bcf09bcc2f0aca1ddaf667bd2c8c7c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7bcf09bcc2f0aca1ddaf667bd2c8c7c9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7bcf09bcc2f0aca1ddaf667bd2c8c7c9.html#a7bcf09bcc2f0aca1ddaf667bd2c8c7c9">as_value_column_array_or_scalar</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a7bcf09bcc2f0aca1ddaf667bd2c8c7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the value from an object and for eigen vectors and <code>std::vectors</code> convert to an eigen column array and for scalars return a scalar.  <br /></td></tr>
<tr class="separator:a7bcf09bcc2f0aca1ddaf667bd2c8c7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae722b5cc0e6f35fb93ab35349d9a01e5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae722b5cc0e6f35fb93ab35349d9a01e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae722b5cc0e6f35fb93ab35349d9a01e5.html#ae722b5cc0e6f35fb93ab35349d9a01e5">as_value_column_vector_or_scalar</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ae722b5cc0e6f35fb93ab35349d9a01e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract values from input argument and transform to a column vector.  <br /></td></tr>
<tr class="separator:ae722b5cc0e6f35fb93ab35349d9a01e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adddc6368e1008990010476659e2b27f2"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adddc6368e1008990010476659e2b27f2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adddc6368e1008990010476659e2b27f2.html#adddc6368e1008990010476659e2b27f2">asin</a> (const T x)</td></tr>
<tr class="memdesc:adddc6368e1008990010476659e2b27f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arc sine of the arithmetic argument.  <br /></td></tr>
<tr class="separator:adddc6368e1008990010476659e2b27f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a414186b19197138e9fd7349f90510bc4"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a414186b19197138e9fd7349f90510bc4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a414186b19197138e9fd7349f90510bc4.html#a414186b19197138e9fd7349f90510bc4">asin</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a414186b19197138e9fd7349f90510bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ad7b48158d54565231ca3a7328c11eb21.html#ad7b48158d54565231ca3a7328c11eb21">asin()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:a414186b19197138e9fd7349f90510bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0dcc286559ef48bc80f645d0b949c5"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3b0dcc286559ef48bc80f645d0b949c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3b0dcc286559ef48bc80f645d0b949c5.html#a3b0dcc286559ef48bc80f645d0b949c5">asinh</a> (const T x)</td></tr>
<tr class="memdesc:a3b0dcc286559ef48bc80f645d0b949c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arc sine of the arithmetic argument.  <br /></td></tr>
<tr class="separator:a3b0dcc286559ef48bc80f645d0b949c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f7461ea910b165bdf6fba80284a20a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a36f7461ea910b165bdf6fba80284a20a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a36f7461ea910b165bdf6fba80284a20a.html#a36f7461ea910b165bdf6fba80284a20a">asinh</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a36f7461ea910b165bdf6fba80284a20a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a4a1a957be54c795baae42c74c9e53149.html#a4a1a957be54c795baae42c74c9e53149">asinh()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:a36f7461ea910b165bdf6fba80284a20a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d19a8c79b568d01fb05ab8e74deebc"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga846e5c75f0e49887b255adb8e56e1a7e.html#ga846e5c75f0e49887b255adb8e56e1a7e">require_container_bt</a>&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad6d19a8c79b568d01fb05ab8e74deebc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad6d19a8c79b568d01fb05ab8e74deebc.html#ad6d19a8c79b568d01fb05ab8e74deebc">asinh</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ad6d19a8c79b568d01fb05ab8e74deebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a4a1a957be54c795baae42c74c9e53149.html#a4a1a957be54c795baae42c74c9e53149">asinh()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:ad6d19a8c79b568d01fb05ab8e74deebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5cdc003ece270393c367aba1f09b749"><td class="memTemplParams" colspan="2">template&lt;int N&gt; </td></tr>
<tr class="memitem:af5cdc003ece270393c367aba1f09b749"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af5cdc003ece270393c367aba1f09b749.html#af5cdc003ece270393c367aba1f09b749">print_mat_size</a> (std::ostream &amp;o)</td></tr>
<tr class="memdesc:af5cdc003ece270393c367aba1f09b749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to return the matrix size as either "dynamic" or "1".  <br /></td></tr>
<tr class="separator:af5cdc003ece270393c367aba1f09b749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e46ec6cfc6f6fecad8e2b9847cc64d"><td class="memTemplParams" colspan="2">template&lt;typename T_lhs , typename T_rhs , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T_lhs, T_rhs &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a16e46ec6cfc6f6fecad8e2b9847cc64d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a16e46ec6cfc6f6fecad8e2b9847cc64d.html#a16e46ec6cfc6f6fecad8e2b9847cc64d">assign</a> (T_lhs &amp;x, const T_rhs &amp;y)</td></tr>
<tr class="memdesc:a16e46ec6cfc6f6fecad8e2b9847cc64d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <br /></td></tr>
<tr class="separator:a16e46ec6cfc6f6fecad8e2b9847cc64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7560afa1d2eb67c656e3eba06af0ab1e"><td class="memTemplParams" colspan="2">template&lt;typename T_lhs , typename T_rhs , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; T_lhs, T_rhs &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7560afa1d2eb67c656e3eba06af0ab1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7560afa1d2eb67c656e3eba06af0ab1e.html#a7560afa1d2eb67c656e3eba06af0ab1e">assign</a> (T_lhs &amp;&amp;x, const T_rhs &amp;y)</td></tr>
<tr class="memdesc:a7560afa1d2eb67c656e3eba06af0ab1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <br /></td></tr>
<tr class="separator:a7560afa1d2eb67c656e3eba06af0ab1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a097bc5818c82364e91167bfe757f4418"><td class="memTemplParams" colspan="2">template&lt;typename T_lhs , typename T_rhs &gt; </td></tr>
<tr class="memitem:a097bc5818c82364e91167bfe757f4418"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a097bc5818c82364e91167bfe757f4418.html#a097bc5818c82364e91167bfe757f4418">assign</a> (std::vector&lt; T_lhs &gt; &amp;x, const std::vector&lt; T_rhs &gt; &amp;y)</td></tr>
<tr class="memdesc:a097bc5818c82364e91167bfe757f4418"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the right-hand side's value to the left-hand side variable.  <br /></td></tr>
<tr class="separator:a097bc5818c82364e91167bfe757f4418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06fa9144477a75d6d52464d3f0b9db3"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab06fa9144477a75d6d52464d3f0b9db3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab06fa9144477a75d6d52464d3f0b9db3.html#ab06fa9144477a75d6d52464d3f0b9db3">atan</a> (const T x)</td></tr>
<tr class="memdesc:ab06fa9144477a75d6d52464d3f0b9db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arc tangent of the arithmetic argument.  <br /></td></tr>
<tr class="separator:ab06fa9144477a75d6d52464d3f0b9db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691f3ae86b778c0ee01a013bbafa9dcb"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a691f3ae86b778c0ee01a013bbafa9dcb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a691f3ae86b778c0ee01a013bbafa9dcb.html#a691f3ae86b778c0ee01a013bbafa9dcb">atan</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a691f3ae86b778c0ee01a013bbafa9dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a83986a2a7953042a141b6d808763bd88.html#a83986a2a7953042a141b6d808763bd88">atan()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:a691f3ae86b778c0ee01a013bbafa9dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426e7dc185ddbee64526d44f47f5cd7b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a426e7dc185ddbee64526d44f47f5cd7b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a426e7dc185ddbee64526d44f47f5cd7b.html#a426e7dc185ddbee64526d44f47f5cd7b">atan2</a> (T1 y, T2 x)</td></tr>
<tr class="memdesc:a426e7dc185ddbee64526d44f47f5cd7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the arc tangent of y/x using the signs of arguments to determine the correct quadrant.  <br /></td></tr>
<tr class="separator:a426e7dc185ddbee64526d44f47f5cd7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ede3b3d1b5036606c91f438d6cbe54d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_gae0f57b6105cb69165aeee0f2de2e50db.html#gae0f57b6105cb69165aeee0f2de2e50db">require_all_not_var_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4ede3b3d1b5036606c91f438d6cbe54d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4ede3b3d1b5036606c91f438d6cbe54d.html#a4ede3b3d1b5036606c91f438d6cbe54d">atan2</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a4ede3b3d1b5036606c91f438d6cbe54d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the atan2 function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:a4ede3b3d1b5036606c91f438d6cbe54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1655f70c28748b56e796c63055068d00"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1655f70c28748b56e796c63055068d00"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1655f70c28748b56e796c63055068d00.html#a1655f70c28748b56e796c63055068d00">atanh</a> (const T x)</td></tr>
<tr class="memdesc:a1655f70c28748b56e796c63055068d00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse hyperbolic tangent of the specified value.  <br /></td></tr>
<tr class="separator:a1655f70c28748b56e796c63055068d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44bfc227aaf1a6aa2f73561157d6e5d"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__complex__types_ga2c903fceb2dfd2cea898b67c57383a48.html#ga2c903fceb2dfd2cea898b67c57383a48">require_complex_bt</a>&lt; std::is_arithmetic, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae44bfc227aaf1a6aa2f73561157d6e5d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae44bfc227aaf1a6aa2f73561157d6e5d.html#ae44bfc227aaf1a6aa2f73561157d6e5d">atanh</a> (const T x)</td></tr>
<tr class="memdesc:ae44bfc227aaf1a6aa2f73561157d6e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse hyperbolic tangent of the specified value.  <br /></td></tr>
<tr class="separator:ae44bfc227aaf1a6aa2f73561157d6e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3e0d5da4975b32b1fd7a80fc87d3914"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa3e0d5da4975b32b1fd7a80fc87d3914"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa3e0d5da4975b32b1fd7a80fc87d3914.html#aa3e0d5da4975b32b1fd7a80fc87d3914">atanh</a> (const T &amp;x)</td></tr>
<tr class="memdesc:aa3e0d5da4975b32b1fd7a80fc87d3914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a2cabe7a1ea8293228faa9e77f6eb1203.html#a2cabe7a1ea8293228faa9e77f6eb1203" title="Return inverse hyperbolic tangent of specified value.">atanh()</a></code> to specified argument container.  <br /></td></tr>
<tr class="separator:aa3e0d5da4975b32b1fd7a80fc87d3914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae666c9d1b99cb393fb31ebc51f3695"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga846e5c75f0e49887b255adb8e56e1a7e.html#ga846e5c75f0e49887b255adb8e56e1a7e">require_container_bt</a>&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abae666c9d1b99cb393fb31ebc51f3695"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abae666c9d1b99cb393fb31ebc51f3695.html#abae666c9d1b99cb393fb31ebc51f3695">atanh</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:abae666c9d1b99cb393fb31ebc51f3695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a2cabe7a1ea8293228faa9e77f6eb1203.html#a2cabe7a1ea8293228faa9e77f6eb1203" title="Return inverse hyperbolic tangent of specified value.">atanh()</a></code> to specified argument container.  <br /></td></tr>
<tr class="separator:abae666c9d1b99cb393fb31ebc51f3695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7c65ea100e48abc72f3c1e96fcdbe9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd7c65ea100e48abc72f3c1e96fcdbe9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afd7c65ea100e48abc72f3c1e96fcdbe9.html#afd7c65ea100e48abc72f3c1e96fcdbe9">autocorrelation</a> (const std::vector&lt; T &gt; &amp;y, std::vector&lt; T &gt; &amp;ac, Eigen::FFT&lt; T &gt; &amp;<a class="el" href="namespacestan_1_1math_a8dbd6877b180af8eef1db0c167b08b55.html#a8dbd6877b180af8eef1db0c167b08b55">fft</a>)</td></tr>
<tr class="memdesc:afd7c65ea100e48abc72f3c1e96fcdbe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocorrelation estimates for every lag for the specified input sequence into the specified result using the specified FFT engine.  <br /></td></tr>
<tr class="separator:afd7c65ea100e48abc72f3c1e96fcdbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedea144e2c485e558eb949cca99e8c77"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:aedea144e2c485e558eb949cca99e8c77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aedea144e2c485e558eb949cca99e8c77.html#aedea144e2c485e558eb949cca99e8c77">autocorrelation</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;y, Eigen::MatrixBase&lt; DerivedB &gt; &amp;ac, Eigen::FFT&lt; T &gt; &amp;<a class="el" href="namespacestan_1_1math_a8dbd6877b180af8eef1db0c167b08b55.html#a8dbd6877b180af8eef1db0c167b08b55">fft</a>)</td></tr>
<tr class="memdesc:aedea144e2c485e558eb949cca99e8c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocorrelation estimates for every lag for the specified input sequence into the specified result using the specified FFT engine.  <br /></td></tr>
<tr class="separator:aedea144e2c485e558eb949cca99e8c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999404b2520dcd466c62c6ba3ca61f89"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a999404b2520dcd466c62c6ba3ca61f89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a999404b2520dcd466c62c6ba3ca61f89.html#a999404b2520dcd466c62c6ba3ca61f89">autocorrelation</a> (const std::vector&lt; T &gt; &amp;y, std::vector&lt; T &gt; &amp;ac)</td></tr>
<tr class="memdesc:a999404b2520dcd466c62c6ba3ca61f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocorrelation estimates for every lag for the specified input sequence into the specified result.  <br /></td></tr>
<tr class="separator:a999404b2520dcd466c62c6ba3ca61f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf836199717572fdda79720523b1d42"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:aeaf836199717572fdda79720523b1d42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeaf836199717572fdda79720523b1d42.html#aeaf836199717572fdda79720523b1d42">autocorrelation</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;y, Eigen::MatrixBase&lt; DerivedB &gt; &amp;ac)</td></tr>
<tr class="memdesc:aeaf836199717572fdda79720523b1d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocorrelation estimates for every lag for the specified input sequence into the specified result.  <br /></td></tr>
<tr class="separator:aeaf836199717572fdda79720523b1d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab515e37311a3070dbc66e69d31359a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aab515e37311a3070dbc66e69d31359a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab515e37311a3070dbc66e69d31359a5.html#aab515e37311a3070dbc66e69d31359a5">autocovariance</a> (const std::vector&lt; T &gt; &amp;y, std::vector&lt; T &gt; &amp;acov, Eigen::FFT&lt; T &gt; &amp;<a class="el" href="namespacestan_1_1math_a8dbd6877b180af8eef1db0c167b08b55.html#a8dbd6877b180af8eef1db0c167b08b55">fft</a>)</td></tr>
<tr class="memdesc:aab515e37311a3070dbc66e69d31359a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocovariance estimates for every lag for the specified input sequence into the specified result using the specified FFT engine.  <br /></td></tr>
<tr class="separator:aab515e37311a3070dbc66e69d31359a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141ceb38cf2fad0a49c99af720ffc4d2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:a141ceb38cf2fad0a49c99af720ffc4d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a141ceb38cf2fad0a49c99af720ffc4d2.html#a141ceb38cf2fad0a49c99af720ffc4d2">autocovariance</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;y, Eigen::MatrixBase&lt; DerivedB &gt; &amp;acov, Eigen::FFT&lt; T &gt; &amp;<a class="el" href="namespacestan_1_1math_a8dbd6877b180af8eef1db0c167b08b55.html#a8dbd6877b180af8eef1db0c167b08b55">fft</a>)</td></tr>
<tr class="memdesc:a141ceb38cf2fad0a49c99af720ffc4d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocovariance estimates for every lag for the specified input sequence into the specified result using the specified FFT engine.  <br /></td></tr>
<tr class="separator:a141ceb38cf2fad0a49c99af720ffc4d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdfe56505f9cbe96a18fc00f76fe79fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acdfe56505f9cbe96a18fc00f76fe79fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acdfe56505f9cbe96a18fc00f76fe79fd.html#acdfe56505f9cbe96a18fc00f76fe79fd">autocovariance</a> (const std::vector&lt; T &gt; &amp;y, std::vector&lt; T &gt; &amp;acov)</td></tr>
<tr class="memdesc:acdfe56505f9cbe96a18fc00f76fe79fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocovariance estimates for every lag for the specified input sequence into the specified result.  <br /></td></tr>
<tr class="separator:acdfe56505f9cbe96a18fc00f76fe79fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba016ad24cda70a732fccad2cd0abf8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename DerivedA , typename DerivedB &gt; </td></tr>
<tr class="memitem:abba016ad24cda70a732fccad2cd0abf8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abba016ad24cda70a732fccad2cd0abf8.html#abba016ad24cda70a732fccad2cd0abf8">autocovariance</a> (const Eigen::MatrixBase&lt; DerivedA &gt; &amp;y, Eigen::MatrixBase&lt; DerivedB &gt; &amp;acov)</td></tr>
<tr class="memdesc:abba016ad24cda70a732fccad2cd0abf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write autocovariance estimates for every lag for the specified input sequence into the specified result.  <br /></td></tr>
<tr class="separator:abba016ad24cda70a732fccad2cd0abf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f66e5165eed5fc69926e5545e81d55c"><td class="memTemplParams" colspan="2">template&lt;typename T2 , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6f66e5165eed5fc69926e5545e81d55c"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6f66e5165eed5fc69926e5545e81d55c.html#a6f66e5165eed5fc69926e5545e81d55c">bessel_first_kind</a> (int v, const T2 z)</td></tr>
<tr class="separator:a6f66e5165eed5fc69926e5545e81d55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa642040393baf26c0560573b0d497d8d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa642040393baf26c0560573b0d497d8d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa642040393baf26c0560573b0d497d8d.html#aa642040393baf26c0560573b0d497d8d">bessel_first_kind</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:aa642040393baf26c0560573b0d497d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the bessel first kind function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:aa642040393baf26c0560573b0d497d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab462d0d4b2e1d74769156563802ab23"><td class="memTemplParams" colspan="2">template&lt;typename T2 , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aab462d0d4b2e1d74769156563802ab23"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab462d0d4b2e1d74769156563802ab23.html#aab462d0d4b2e1d74769156563802ab23">bessel_second_kind</a> (int v, const T2 z)</td></tr>
<tr class="separator:aab462d0d4b2e1d74769156563802ab23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362f9cb7bd515c0b315b99fe39f25c91"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a362f9cb7bd515c0b315b99fe39f25c91"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a362f9cb7bd515c0b315b99fe39f25c91.html#a362f9cb7bd515c0b315b99fe39f25c91">bessel_second_kind</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a362f9cb7bd515c0b315b99fe39f25c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the bessel second kind function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:a362f9cb7bd515c0b315b99fe39f25c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fc8b1beabe85c044aee6768b3a72f9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a20fc8b1beabe85c044aee6768b3a72f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a20fc8b1beabe85c044aee6768b3a72f9.html#a20fc8b1beabe85c044aee6768b3a72f9">beta</a> (const T1 a, const T2 b)</td></tr>
<tr class="memdesc:a20fc8b1beabe85c044aee6768b3a72f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the beta function applied to the specified arguments.  <br /></td></tr>
<tr class="separator:a20fc8b1beabe85c044aee6768b3a72f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924e1e727e97def79c4fbdbfe2052623"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_gae0f57b6105cb69165aeee0f2de2e50db.html#gae0f57b6105cb69165aeee0f2de2e50db">require_all_not_var_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a924e1e727e97def79c4fbdbfe2052623"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a924e1e727e97def79c4fbdbfe2052623.html#a924e1e727e97def79c4fbdbfe2052623">beta</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a924e1e727e97def79c4fbdbfe2052623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the beta function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:a924e1e727e97def79c4fbdbfe2052623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0838fc113de27636f1be3c4183e0b36"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa0838fc113de27636f1be3c4183e0b36"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa0838fc113de27636f1be3c4183e0b36.html#aa0838fc113de27636f1be3c4183e0b36">binary_log_loss</a> (int y, const T &amp;y_hat)</td></tr>
<tr class="memdesc:aa0838fc113de27636f1be3c4183e0b36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log loss function for binary classification with specified reference and response values.  <br /></td></tr>
<tr class="separator:aa0838fc113de27636f1be3c4183e0b36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1d2ef4e3e5e5ccff976cc57f6f362d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4e1d2ef4e3e5e5ccff976cc57f6f362d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4e1d2ef4e3e5e5ccff976cc57f6f362d.html#a4e1d2ef4e3e5e5ccff976cc57f6f362d">binary_log_loss</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a4e1d2ef4e3e5e5ccff976cc57f6f362d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the binary log loss function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:a4e1d2ef4e3e5e5ccff976cc57f6f362d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acceb9f2cb35c5564537ae5471f4ef380"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_k , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T_n, T_k &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acceb9f2cb35c5564537ae5471f4ef380"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_n, T_k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acceb9f2cb35c5564537ae5471f4ef380.html#acceb9f2cb35c5564537ae5471f4ef380">binomial_coefficient_log</a> (const T_n n, const T_k k)</td></tr>
<tr class="memdesc:acceb9f2cb35c5564537ae5471f4ef380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the binomial coefficient for the specified arguments.  <br /></td></tr>
<tr class="separator:acceb9f2cb35c5564537ae5471f4ef380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8617588af9e9bf173b1ef5ab4a724f4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac8617588af9e9bf173b1ef5ab4a724f4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac8617588af9e9bf173b1ef5ab4a724f4.html#ac8617588af9e9bf173b1ef5ab4a724f4">binomial_coefficient_log</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ac8617588af9e9bf173b1ef5ab4a724f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the binomial coefficient log function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:ac8617588af9e9bf173b1ef5ab4a724f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02a2af29800cfd98de4d5e6bd401517"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae02a2af29800cfd98de4d5e6bd401517"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae02a2af29800cfd98de4d5e6bd401517.html#ae02a2af29800cfd98de4d5e6bd401517">block</a> (const T &amp;m, size_t i, size_t j, size_t nrows, size_t ncols)</td></tr>
<tr class="memdesc:ae02a2af29800cfd98de4d5e6bd401517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a nrows x ncols submatrix starting at (i-1, j-1).  <br /></td></tr>
<tr class="separator:ae02a2af29800cfd98de4d5e6bd401517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5fbf40d8568ff9470ac4d43e580efc"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adf5fbf40d8568ff9470ac4d43e580efc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adf5fbf40d8568ff9470ac4d43e580efc.html#adf5fbf40d8568ff9470ac4d43e580efc">cbrt</a> (const T &amp;x)</td></tr>
<tr class="memdesc:adf5fbf40d8568ff9470ac4d43e580efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a6e56cfe7810faca3dd8a2326affacd26.html#a6e56cfe7810faca3dd8a2326affacd26" title="Return cube root of specified argument.">cbrt()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:adf5fbf40d8568ff9470ac4d43e580efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d245dddcfd6f06addb3e64f75dc9c6"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga1b135bb62a0729e31b4233e370170a53.html#ga1b135bb62a0729e31b4233e370170a53">require_not_container_st</a>&lt; std::is_arithmetic, Container &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae0d245dddcfd6f06addb3e64f75dc9c6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae0d245dddcfd6f06addb3e64f75dc9c6.html#ae0d245dddcfd6f06addb3e64f75dc9c6">ceil</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ae0d245dddcfd6f06addb3e64f75dc9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ae0742bb5eb74b836b005ef099cffc502.html#ae0742bb5eb74b836b005ef099cffc502">ceil()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:ae0d245dddcfd6f06addb3e64f75dc9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0719da5ca32ce091dd6331f89cfa829"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac0719da5ca32ce091dd6331f89cfa829"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac0719da5ca32ce091dd6331f89cfa829.html#ac0719da5ca32ce091dd6331f89cfa829">chol2inv</a> (const T &amp;L)</td></tr>
<tr class="memdesc:ac0719da5ca32ce091dd6331f89cfa829"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of the matrix whose Cholesky factor is L.  <br /></td></tr>
<tr class="separator:ac0719da5ca32ce091dd6331f89cfa829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3747bb36815896d9728d6174e3b91948"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga93918b2590606552cac973a4397ab38a.html#ga93918b2590606552cac973a4397ab38a">require_not_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3747bb36815896d9728d6174e3b91948"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, EigMat::RowsAtCompileTime, EigMat::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3747bb36815896d9728d6174e3b91948.html#a3747bb36815896d9728d6174e3b91948">cholesky_decompose</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a3747bb36815896d9728d6174e3b91948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-triangular Cholesky factor (i.e., matrix square root) of the specified square, symmetric matrix.  <br /></td></tr>
<tr class="separator:a3747bb36815896d9728d6174e3b91948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660f7e5239385475db0bc58a0803ab07"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a660f7e5239385475db0bc58a0803ab07.html#a660f7e5239385475db0bc58a0803ab07">choose</a> (int n, int k)</td></tr>
<tr class="memdesc:a660f7e5239385475db0bc58a0803ab07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the binomial coefficient for the specified integer arguments.  <br /></td></tr>
<tr class="separator:a660f7e5239385475db0bc58a0803ab07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f76b4ab65565378fde5270f078b840"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa8f76b4ab65565378fde5270f078b840"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa8f76b4ab65565378fde5270f078b840.html#aa8f76b4ab65565378fde5270f078b840">choose</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:aa8f76b4ab65565378fde5270f078b840"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the binomial coefficient function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:aa8f76b4ab65565378fde5270f078b840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0790d26b4eba96a0bc1261dd80fa22"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeb0790d26b4eba96a0bc1261dd80fa22"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeb0790d26b4eba96a0bc1261dd80fa22.html#aeb0790d26b4eba96a0bc1261dd80fa22">col</a> (const T &amp;m, size_t j)</td></tr>
<tr class="memdesc:aeb0790d26b4eba96a0bc1261dd80fa22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified column of the specified matrix using start-at-1 indexing.  <br /></td></tr>
<tr class="separator:aeb0790d26b4eba96a0bc1261dd80fa22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13e85c430d8ef086d6590d85a0f91e9"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab13e85c430d8ef086d6590d85a0f91e9"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab13e85c430d8ef086d6590d85a0f91e9.html#ab13e85c430d8ef086d6590d85a0f91e9">cols</a> (const T &amp;m)</td></tr>
<tr class="memdesc:ab13e85c430d8ef086d6590d85a0f91e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of columns in the specified matrix, vector, or row vector.  <br /></td></tr>
<tr class="separator:ab13e85c430d8ef086d6590d85a0f91e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91b5c6bb55c9da736211b7a220e89ca7"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="group__eigen__types_gac30da5b4d9bf217de273208379b7b92e.html#gac30da5b4d9bf217de273208379b7b92e">require_all_not_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a91b5c6bb55c9da736211b7a220e89ca7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Mat1, Mat2 &gt;, 1, Mat1::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a91b5c6bb55c9da736211b7a220e89ca7.html#a91b5c6bb55c9da736211b7a220e89ca7">columns_dot_product</a> (const Mat1 &amp;v1, const Mat2 &amp;v2)</td></tr>
<tr class="memdesc:a91b5c6bb55c9da736211b7a220e89ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of columns of the specified matrices.  <br /></td></tr>
<tr class="separator:a91b5c6bb55c9da736211b7a220e89ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040e80987ebdcb8d18ea5d8339533345"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga93918b2590606552cac973a4397ab38a.html#ga93918b2590606552cac973a4397ab38a">require_not_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a040e80987ebdcb8d18ea5d8339533345"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, 1, T::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a040e80987ebdcb8d18ea5d8339533345.html#a040e80987ebdcb8d18ea5d8339533345">columns_dot_self</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a040e80987ebdcb8d18ea5d8339533345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each column of a matrix with itself.  <br /></td></tr>
<tr class="separator:a040e80987ebdcb8d18ea5d8339533345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c47de1ae8a2b501daa1b228c375bf70"><td class="memTemplParams" colspan="2">template&lt;typename M , <a class="el" href="group__eigen__dense__dynamic__types_ga7b9ea2ce30eb6b679b63ac5630027d95.html#ga7b9ea2ce30eb6b679b63ac5630027d95">require_eigen_dense_dynamic_t</a>&lt; M &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6c47de1ae8a2b501daa1b228c375bf70"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; M &gt; &gt;, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6c47de1ae8a2b501daa1b228c375bf70.html#a6c47de1ae8a2b501daa1b228c375bf70">complex_schur_decompose_u</a> (const M &amp;m)</td></tr>
<tr class="memdesc:a6c47de1ae8a2b501daa1b228c375bf70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unitary matrix of the complex Schur decomposition of the specified square matrix.  <br /></td></tr>
<tr class="separator:a6c47de1ae8a2b501daa1b228c375bf70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd575f1bdd7476c57c895976c8e5b5d7"><td class="memTemplParams" colspan="2">template&lt;typename M , <a class="el" href="group__eigen__dense__dynamic__types_ga7b9ea2ce30eb6b679b63ac5630027d95.html#ga7b9ea2ce30eb6b679b63ac5630027d95">require_eigen_dense_dynamic_t</a>&lt; M &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abd575f1bdd7476c57c895976c8e5b5d7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; M &gt; &gt;, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abd575f1bdd7476c57c895976c8e5b5d7.html#abd575f1bdd7476c57c895976c8e5b5d7">complex_schur_decompose_t</a> (const M &amp;m)</td></tr>
<tr class="memdesc:abd575f1bdd7476c57c895976c8e5b5d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Schur form matrix of the complex Schur decomposition of the specified square matrix.  <br /></td></tr>
<tr class="separator:abd575f1bdd7476c57c895976c8e5b5d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a0f971f717dd1701ade49219e6db1a"><td class="memTemplParams" colspan="2">template&lt;typename M , <a class="el" href="group__eigen__dense__dynamic__types_ga7b9ea2ce30eb6b679b63ac5630027d95.html#ga7b9ea2ce30eb6b679b63ac5630027d95">require_eigen_dense_dynamic_t</a>&lt; M &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a58a0f971f717dd1701ade49219e6db1a"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; M &gt; &gt;, -1, -1 &gt;, Eigen::Matrix&lt; <a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; M &gt; &gt;, -1, -1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a58a0f971f717dd1701ade49219e6db1a.html#a58a0f971f717dd1701ade49219e6db1a">complex_schur_decompose</a> (const M &amp;m)</td></tr>
<tr class="memdesc:a58a0f971f717dd1701ade49219e6db1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the complex Schur decomposition of the specified square matrix.  <br /></td></tr>
<tr class="separator:a58a0f971f717dd1701ade49219e6db1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ced474e69e3b3842be1fc286ffd667"><td class="memTemplParams" colspan="2">template&lt;typename V , <a class="el" href="group__complex__types_ga2c903fceb2dfd2cea898b67c57383a48.html#ga2c903fceb2dfd2cea898b67c57383a48">require_complex_bt</a>&lt; std::is_arithmetic, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac8ced474e69e3b3842be1fc286ffd667"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac8ced474e69e3b3842be1fc286ffd667.html#ac8ced474e69e3b3842be1fc286ffd667">conj</a> (const V &amp;z)</td></tr>
<tr class="memdesc:ac8ced474e69e3b3842be1fc286ffd667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the complex conjugate the complex argument.  <br /></td></tr>
<tr class="separator:ac8ced474e69e3b3842be1fc286ffd667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61dbaa809a37cadb7c458fe3278240b7"><td class="memTemplParams" colspan="2">template&lt;typename V , <a class="el" href="group__complex__types_ga2c903fceb2dfd2cea898b67c57383a48.html#ga2c903fceb2dfd2cea898b67c57383a48">require_complex_bt</a>&lt; <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a61dbaa809a37cadb7c458fe3278240b7"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a61dbaa809a37cadb7c458fe3278240b7.html#a61dbaa809a37cadb7c458fe3278240b7">conj</a> (const V &amp;z)</td></tr>
<tr class="memdesc:a61dbaa809a37cadb7c458fe3278240b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the complex conjugate the complex argument.  <br /></td></tr>
<tr class="separator:a61dbaa809a37cadb7c458fe3278240b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818198c67d4ab2ffc8fb5159f7e0e2fd"><td class="memTemplParams" colspan="2">template&lt;typename Eig , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>, Eig &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a818198c67d4ab2ffc8fb5159f7e0e2fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a818198c67d4ab2ffc8fb5159f7e0e2fd.html#a818198c67d4ab2ffc8fb5159f7e0e2fd">conj</a> (Eig &amp;&amp;z)</td></tr>
<tr class="memdesc:a818198c67d4ab2ffc8fb5159f7e0e2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the complex conjugate the <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> object.  <br /></td></tr>
<tr class="separator:a818198c67d4ab2ffc8fb5159f7e0e2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc9077a0fc91e15a66749d251c2480c"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , <a class="el" href="group__std__vector__types_ga513b41fcdff562ebb8bc2cd5e3ea8faa.html#ga513b41fcdff562ebb8bc2cd5e3ea8faa">require_std_vector_st</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>, StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8fc9077a0fc91e15a66749d251c2480c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8fc9077a0fc91e15a66749d251c2480c.html#a8fc9077a0fc91e15a66749d251c2480c">conj</a> (const StdVec &amp;z)</td></tr>
<tr class="memdesc:a8fc9077a0fc91e15a66749d251c2480c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the complex conjugate the vector with complex scalar components.  <br /></td></tr>
<tr class="separator:a8fc9077a0fc91e15a66749d251c2480c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7127a28f51e5042f0bc4301409dd2f"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a> ()</td></tr>
<tr class="memdesc:a3a7127a28f51e5042f0bc4301409dd2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base of the natural logarithm.  <br /></td></tr>
<tr class="separator:a3a7127a28f51e5042f0bc4301409dd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34f4bd29068f15850660695c8d3c6a9"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad34f4bd29068f15850660695c8d3c6a9.html#ad34f4bd29068f15850660695c8d3c6a9">egamma</a> ()</td></tr>
<tr class="memdesc:ad34f4bd29068f15850660695c8d3c6a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Euler's gamma constant.  <br /></td></tr>
<tr class="separator:ad34f4bd29068f15850660695c8d3c6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30268675d705278387b7019a50431a9"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac30268675d705278387b7019a50431a9.html#ac30268675d705278387b7019a50431a9">pi</a> ()</td></tr>
<tr class="memdesc:ac30268675d705278387b7019a50431a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of pi.  <br /></td></tr>
<tr class="separator:ac30268675d705278387b7019a50431a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2fd43f776374fd4637cb484765e3d1"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1f2fd43f776374fd4637cb484765e3d1.html#a1f2fd43f776374fd4637cb484765e3d1">positive_infinity</a> ()</td></tr>
<tr class="memdesc:a1f2fd43f776374fd4637cb484765e3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return positive infinity.  <br /></td></tr>
<tr class="separator:a1f2fd43f776374fd4637cb484765e3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c927d2a7364efe3190f1cc18f1b4ff0"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0c927d2a7364efe3190f1cc18f1b4ff0.html#a0c927d2a7364efe3190f1cc18f1b4ff0">negative_infinity</a> ()</td></tr>
<tr class="memdesc:a0c927d2a7364efe3190f1cc18f1b4ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return negative infinity.  <br /></td></tr>
<tr class="separator:a0c927d2a7364efe3190f1cc18f1b4ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b72006d415b528fb08d0d3b25576a0"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a47b72006d415b528fb08d0d3b25576a0.html#a47b72006d415b528fb08d0d3b25576a0">not_a_number</a> ()</td></tr>
<tr class="memdesc:a47b72006d415b528fb08d0d3b25576a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return (quiet) not-a-number.  <br /></td></tr>
<tr class="separator:a47b72006d415b528fb08d0d3b25576a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d4cbc42c67843660d461872731ced4"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a61d4cbc42c67843660d461872731ced4.html#a61d4cbc42c67843660d461872731ced4">machine_precision</a> ()</td></tr>
<tr class="memdesc:a61d4cbc42c67843660d461872731ced4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the difference between 1.0 and the next value representable.  <br /></td></tr>
<tr class="separator:a61d4cbc42c67843660d461872731ced4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaadc90acda3e608b200fc3eb6188c486"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaadc90acda3e608b200fc3eb6188c486.html#aaadc90acda3e608b200fc3eb6188c486">log10</a> ()</td></tr>
<tr class="memdesc:aaadc90acda3e608b200fc3eb6188c486"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of ten.  <br /></td></tr>
<tr class="separator:aaadc90acda3e608b200fc3eb6188c486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60490076953c38e94eb3f414efea7689"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a60490076953c38e94eb3f414efea7689.html#a60490076953c38e94eb3f414efea7689">sqrt2</a> ()</td></tr>
<tr class="memdesc:a60490076953c38e94eb3f414efea7689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the square root of two.  <br /></td></tr>
<tr class="separator:a60490076953c38e94eb3f414efea7689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae967a11a7998af790caf8432f9e1d13c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae967a11a7998af790caf8432f9e1d13c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae967a11a7998af790caf8432f9e1d13c.html#ae967a11a7998af790caf8432f9e1d13c">copysign</a> (const T &amp;x, const U &amp;y)</td></tr>
<tr class="memdesc:ae967a11a7998af790caf8432f9e1d13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negation of the first argument if the first and second argument have different signs, otherwise return a copy of the first argument.  <br /></td></tr>
<tr class="separator:ae967a11a7998af790caf8432f9e1d13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41d7a0277d65992621cedd9147afb78"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae41d7a0277d65992621cedd9147afb78"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae41d7a0277d65992621cedd9147afb78.html#ae41d7a0277d65992621cedd9147afb78">copysign_non_zero</a> (const T &amp;x, const U &amp;y)</td></tr>
<tr class="memdesc:ae41d7a0277d65992621cedd9147afb78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negation of the first argument if the first and second arguments have different signs and the first argument is not zero, otherwise return a copy of the first argument.  <br /></td></tr>
<tr class="separator:ae41d7a0277d65992621cedd9147afb78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8d552c4289e510df7c8d4a4185749a3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ae8d552c4289e510df7c8d4a4185749a3"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae8d552c4289e510df7c8d4a4185749a3.html#ae8d552c4289e510df7c8d4a4185749a3">copysign</a> (const std::complex&lt; T &gt; &amp;x, const std::complex&lt; U &gt; &amp;y)</td></tr>
<tr class="memdesc:ae8d552c4289e510df7c8d4a4185749a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the complex number composed of the real and complex parts with signs copied from the real and complex parts of the first arguments to the real and complex parts of the second.  <br /></td></tr>
<tr class="separator:ae8d552c4289e510df7c8d4a4185749a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbdfc4d3736a0ad1b37e7f2bd2f5f48"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aadbdfc4d3736a0ad1b37e7f2bd2f5f48"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aadbdfc4d3736a0ad1b37e7f2bd2f5f48.html#aadbdfc4d3736a0ad1b37e7f2bd2f5f48">cos</a> (const T x)</td></tr>
<tr class="memdesc:aadbdfc4d3736a0ad1b37e7f2bd2f5f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cosine of the arithmetic argument.  <br /></td></tr>
<tr class="separator:aadbdfc4d3736a0ad1b37e7f2bd2f5f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c03ba9024e3e7013d26a23a38157592"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1c03ba9024e3e7013d26a23a38157592"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c03ba9024e3e7013d26a23a38157592.html#a1c03ba9024e3e7013d26a23a38157592">cos</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a1c03ba9024e3e7013d26a23a38157592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ab75cdb29185b7843a24c68e7dfbc3516.html#ab75cdb29185b7843a24c68e7dfbc3516">cos()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:a1c03ba9024e3e7013d26a23a38157592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df561de9d68c1d57b05e3fb2641cd88"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0df561de9d68c1d57b05e3fb2641cd88"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0df561de9d68c1d57b05e3fb2641cd88.html#a0df561de9d68c1d57b05e3fb2641cd88">cosh</a> (const T x)</td></tr>
<tr class="memdesc:a0df561de9d68c1d57b05e3fb2641cd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic cosine of the arithmetic argument.  <br /></td></tr>
<tr class="separator:a0df561de9d68c1d57b05e3fb2641cd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6295934fc1ca551047eb78d1845d685"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae6295934fc1ca551047eb78d1845d685"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae6295934fc1ca551047eb78d1845d685.html#ae6295934fc1ca551047eb78d1845d685">cosh</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ae6295934fc1ca551047eb78d1845d685"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a5241e24973fe1e57704814a1a5d939a4.html#a5241e24973fe1e57704814a1a5d939a4">cosh()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:ae6295934fc1ca551047eb78d1845d685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb60abb6c0f9fe10497f4c33203ee75"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , typename T_l &gt; </td></tr>
<tr class="memitem:a6fb60abb6c0f9fe10497f4c33203ee75"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_sigma, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6fb60abb6c0f9fe10497f4c33203ee75.html#a6fb60abb6c0f9fe10497f4c33203ee75">cov_exp_quad</a> (const std::vector&lt; T_x &gt; &amp;x, const T_sigma &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="separator:a6fb60abb6c0f9fe10497f4c33203ee75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae75abe293f33dcc587ea138165656b"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , typename T_l &gt; </td></tr>
<tr class="memitem:a3ae75abe293f33dcc587ea138165656b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_sigma, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3ae75abe293f33dcc587ea138165656b.html#a3ae75abe293f33dcc587ea138165656b">cov_exp_quad</a> (const std::vector&lt; T_x &gt; &amp;x, const T_sigma &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="separator:a3ae75abe293f33dcc587ea138165656b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3f911752c78f054b45f6f8ee34360b"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_sigma , typename T_l &gt; </td></tr>
<tr class="memitem:a5a3f911752c78f054b45f6f8ee34360b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_sigma, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5a3f911752c78f054b45f6f8ee34360b.html#a5a3f911752c78f054b45f6f8ee34360b">cov_exp_quad</a> (const std::vector&lt; T_x1 &gt; &amp;x1, const std::vector&lt; T_x2 &gt; &amp;x2, const T_sigma &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="separator:a5a3f911752c78f054b45f6f8ee34360b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7f6899d90fc5728a3fdb3554859f7a"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_sigma , typename T_l &gt; </td></tr>
<tr class="memitem:a7b7f6899d90fc5728a3fdb3554859f7a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_sigma, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7b7f6899d90fc5728a3fdb3554859f7a.html#a7b7f6899d90fc5728a3fdb3554859f7a">cov_exp_quad</a> (const std::vector&lt; T_x1 &gt; &amp;x1, const std::vector&lt; T_x2 &gt; &amp;x2, const T_sigma &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="separator:a7b7f6899d90fc5728a3fdb3554859f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b31a929a9bd689de9060838976303b"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a57b31a929a9bd689de9060838976303b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a57b31a929a9bd689de9060838976303b.html#a57b31a929a9bd689de9060838976303b">crossprod</a> (const EigMat &amp;M)</td></tr>
<tr class="memdesc:a57b31a929a9bd689de9060838976303b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of pre-multiplying a matrix by its own transpose.  <br /></td></tr>
<tr class="separator:a57b31a929a9bd689de9060838976303b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38570451198ec23a9801a5d1caaf0451"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga38570451198ec23a9801a5d1caaf0451"><td class="memTemplItemLeft" align="right" valign="top">const std::tuple&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;, std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csr__format_ga38570451198ec23a9801a5d1caaf0451.html#ga38570451198ec23a9801a5d1caaf0451">csr_extract</a> (const Eigen::SparseMatrix&lt; T, Eigen::RowMajor &gt; &amp;A)</td></tr>
<tr class="memdesc:ga38570451198ec23a9801a5d1caaf0451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the non-zero values, column indexes for non-zero values, and the NZE index for each entry from a sparse matrix.  <br /></td></tr>
<tr class="separator:ga38570451198ec23a9801a5d1caaf0451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c73a90c01085ff57cf5f0f4ddeb8361"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__dense__base__types_ga832fc80ea0f3c9c728c1fefd681be76d.html#ga832fc80ea0f3c9c728c1fefd681be76d">require_eigen_dense_base_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3c73a90c01085ff57cf5f0f4ddeb8361"><td class="memTemplItemLeft" align="right" valign="top">const std::tuple&lt; Eigen::Matrix&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt;, Eigen::Dynamic, 1 &gt;, std::vector&lt; int &gt;, std::vector&lt; int &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csr__format_ga3c73a90c01085ff57cf5f0f4ddeb8361.html#ga3c73a90c01085ff57cf5f0f4ddeb8361">csr_extract</a> (const T &amp;A)</td></tr>
<tr class="separator:ga3c73a90c01085ff57cf5f0f4ddeb8361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99d962478c402489af6a46029361ec2c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga99d962478c402489af6a46029361ec2c"><td class="memTemplItemLeft" align="right" valign="top">const std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csr__format_ga99d962478c402489af6a46029361ec2c.html#ga99d962478c402489af6a46029361ec2c">csr_extract_u</a> (const Eigen::SparseMatrix&lt; T, Eigen::RowMajor &gt; &amp;A)</td></tr>
<tr class="memdesc:ga99d962478c402489af6a46029361ec2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the NZE index for each entry from a sparse matrix.  <br /></td></tr>
<tr class="separator:ga99d962478c402489af6a46029361ec2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68d084817d3c4e758b24ca6fdb4798c1"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__dense__base__types_ga832fc80ea0f3c9c728c1fefd681be76d.html#ga832fc80ea0f3c9c728c1fefd681be76d">require_eigen_dense_base_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga68d084817d3c4e758b24ca6fdb4798c1"><td class="memTemplItemLeft" align="right" valign="top">const std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csr__format_ga68d084817d3c4e758b24ca6fdb4798c1.html#ga68d084817d3c4e758b24ca6fdb4798c1">csr_extract_u</a> (const T &amp;A)</td></tr>
<tr class="memdesc:ga68d084817d3c4e758b24ca6fdb4798c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the NZE index for each entry from a sparse matrix.  <br /></td></tr>
<tr class="separator:ga68d084817d3c4e758b24ca6fdb4798c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf40c79da3f3ba1cc8577860bc03f0b77"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf40c79da3f3ba1cc8577860bc03f0b77"><td class="memTemplItemLeft" align="right" valign="top">const std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csr__format_gaf40c79da3f3ba1cc8577860bc03f0b77.html#gaf40c79da3f3ba1cc8577860bc03f0b77">csr_extract_v</a> (const Eigen::SparseMatrix&lt; T, Eigen::RowMajor &gt; &amp;A)</td></tr>
<tr class="memdesc:gaf40c79da3f3ba1cc8577860bc03f0b77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the column indexes for non-zero value from a sparse matrix.  <br /></td></tr>
<tr class="separator:gaf40c79da3f3ba1cc8577860bc03f0b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e8c7d228645785bafd35e27834dd394"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__dense__base__types_ga832fc80ea0f3c9c728c1fefd681be76d.html#ga832fc80ea0f3c9c728c1fefd681be76d">require_eigen_dense_base_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7e8c7d228645785bafd35e27834dd394"><td class="memTemplItemLeft" align="right" valign="top">const std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csr__format_ga7e8c7d228645785bafd35e27834dd394.html#ga7e8c7d228645785bafd35e27834dd394">csr_extract_v</a> (const T &amp;A)</td></tr>
<tr class="memdesc:ga7e8c7d228645785bafd35e27834dd394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the column indexes for non-zero values from a dense matrix by converting to sparse and calling the sparse matrix extractor.  <br /></td></tr>
<tr class="separator:ga7e8c7d228645785bafd35e27834dd394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac35f0f282108a6802402a4db2d396401"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gac35f0f282108a6802402a4db2d396401"><td class="memTemplItemLeft" align="right" valign="top">const Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csr__format_gac35f0f282108a6802402a4db2d396401.html#gac35f0f282108a6802402a4db2d396401">csr_extract_w</a> (const Eigen::SparseMatrix&lt; T, Eigen::RowMajor &gt; &amp;A)</td></tr>
<tr class="separator:gac35f0f282108a6802402a4db2d396401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7598cf82790334daaf6cc7afceeb040"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__dense__base__types_ga832fc80ea0f3c9c728c1fefd681be76d.html#ga832fc80ea0f3c9c728c1fefd681be76d">require_eigen_dense_base_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gad7598cf82790334daaf6cc7afceeb040"><td class="memTemplItemLeft" align="right" valign="top">const Eigen::Matrix&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csr__format_gad7598cf82790334daaf6cc7afceeb040.html#gad7598cf82790334daaf6cc7afceeb040">csr_extract_w</a> (const T &amp;A)</td></tr>
<tr class="separator:gad7598cf82790334daaf6cc7afceeb040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea1facea3ca0db6050d210917e565480"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__rev__matrix__types_ga25731d78a40a9cd73951067cafc79fc3.html#ga25731d78a40a9cd73951067cafc79fc3">require_all_not_rev_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aea1facea3ca0db6050d210917e565480"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aea1facea3ca0db6050d210917e565480.html#aea1facea3ca0db6050d210917e565480">csr_matrix_times_vector</a> (int m, int n, const T1 &amp;w, const std::vector&lt; int &gt; &amp;v, const std::vector&lt; int &gt; &amp;u, const T2 &amp;b)</td></tr>
<tr class="separator:aea1facea3ca0db6050d210917e565480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fe0f12f4ce5d84833695d8c56833406"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3fe0f12f4ce5d84833695d8c56833406"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__csr__format_ga3fe0f12f4ce5d84833695d8c56833406.html#ga3fe0f12f4ce5d84833695d8c56833406">csr_to_dense_matrix</a> (int m, int n, const T &amp;w, const std::vector&lt; int &gt; &amp;v, const std::vector&lt; int &gt; &amp;u)</td></tr>
<tr class="memdesc:ga3fe0f12f4ce5d84833695d8c56833406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a dense <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix from the CSR format components.  <br /></td></tr>
<tr class="separator:ga3fe0f12f4ce5d84833695d8c56833406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e1bf7c971d0b9eb931654ea309a2bf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__csr__format_gaf4e1bf7c971d0b9eb931654ea309a2bf.html#gaf4e1bf7c971d0b9eb931654ea309a2bf">csr_u_to_z</a> (const std::vector&lt; int &gt; &amp;u, int i)</td></tr>
<tr class="memdesc:gaf4e1bf7c971d0b9eb931654ea309a2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the z vector computed from the specified u vector at the index for the z vector.  <br /></td></tr>
<tr class="separator:gaf4e1bf7c971d0b9eb931654ea309a2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7edae5e21ed370f9aa2795575ed350f5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7edae5e21ed370f9aa2795575ed350f5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7edae5e21ed370f9aa2795575ed350f5.html#a7edae5e21ed370f9aa2795575ed350f5">cumulative_sum</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a7edae5e21ed370f9aa2795575ed350f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cumulative sum of the specified vector.  <br /></td></tr>
<tr class="separator:a7edae5e21ed370f9aa2795575ed350f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6268ac0dc45da2fc6db09f16a193010"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; EigVec &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab6268ac0dc45da2fc6db09f16a193010"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab6268ac0dc45da2fc6db09f16a193010.html#ab6268ac0dc45da2fc6db09f16a193010">cumulative_sum</a> (const EigVec &amp;m)</td></tr>
<tr class="memdesc:ab6268ac0dc45da2fc6db09f16a193010"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cumulative sum of the specified vector.  <br /></td></tr>
<tr class="separator:ab6268ac0dc45da2fc6db09f16a193010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80de94e3099d7d2d1e7255a0f9de46b5"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; std::is_arithmetic, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a80de94e3099d7d2d1e7255a0f9de46b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a80de94e3099d7d2d1e7255a0f9de46b5.html#a80de94e3099d7d2d1e7255a0f9de46b5">determinant</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a80de94e3099d7d2d1e7255a0f9de46b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the determinant of the specified square matrix.  <br /></td></tr>
<tr class="separator:a80de94e3099d7d2d1e7255a0f9de46b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623af920c3036452b0b252236e509243"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a623af920c3036452b0b252236e509243"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigVec &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a623af920c3036452b0b252236e509243.html#a623af920c3036452b0b252236e509243">diag_matrix</a> (const EigVec &amp;v)</td></tr>
<tr class="memdesc:a623af920c3036452b0b252236e509243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a square diagonal matrix with the specified vector of coefficients as the diagonal values.  <br /></td></tr>
<tr class="separator:a623af920c3036452b0b252236e509243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ef527eaeba71a77857bd000a9afa91"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T2 &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a23ef527eaeba71a77857bd000a9afa91"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a23ef527eaeba71a77857bd000a9afa91.html#a23ef527eaeba71a77857bd000a9afa91">diag_post_multiply</a> (const T1 &amp;m1, const T2 &amp;m2)</td></tr>
<tr class="memdesc:a23ef527eaeba71a77857bd000a9afa91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the matrix and the diagonal matrix formed from the vector or row_vector.  <br /></td></tr>
<tr class="separator:a23ef527eaeba71a77857bd000a9afa91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e95b1d74d4bdd6f8818769c0cdb6aa0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T2 &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0e95b1d74d4bdd6f8818769c0cdb6aa0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0e95b1d74d4bdd6f8818769c0cdb6aa0.html#a0e95b1d74d4bdd6f8818769c0cdb6aa0">diag_pre_multiply</a> (const T1 &amp;m1, const T2 &amp;m2)</td></tr>
<tr class="memdesc:a0e95b1d74d4bdd6f8818769c0cdb6aa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the diagonal matrix formed from the vector or row_vector and a matrix.  <br /></td></tr>
<tr class="separator:a0e95b1d74d4bdd6f8818769c0cdb6aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53985a3f02de2d737ce7dec24570b2e0"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a53985a3f02de2d737ce7dec24570b2e0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a53985a3f02de2d737ce7dec24570b2e0.html#a53985a3f02de2d737ce7dec24570b2e0">diagonal</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a53985a3f02de2d737ce7dec24570b2e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column vector of the diagonal elements of the specified matrix.  <br /></td></tr>
<tr class="separator:a53985a3f02de2d737ce7dec24570b2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb54ce92709046c6d168e851d2481c7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5eb54ce92709046c6d168e851d2481c7.html#a5eb54ce92709046c6d168e851d2481c7">digamma</a> (double x)</td></tr>
<tr class="memdesc:a5eb54ce92709046c6d168e851d2481c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the derivative of the log gamma function at the specified value.  <br /></td></tr>
<tr class="separator:a5eb54ce92709046c6d168e851d2481c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1eee5e3089a975168788ce273b9d012"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga55c0f71f335505ceeac88af143771e88.html#ga55c0f71f335505ceeac88af143771e88">require_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad1eee5e3089a975168788ce273b9d012"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad1eee5e3089a975168788ce273b9d012.html#ad1eee5e3089a975168788ce273b9d012">digamma</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ad1eee5e3089a975168788ce273b9d012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_af87890068b9f3e77a15eb60447ccfd77.html#af87890068b9f3e77a15eb60447ccfd77" title="Return the derivative of the log gamma function at the specified argument.">digamma()</a>.  <br /></td></tr>
<tr class="separator:ad1eee5e3089a975168788ce273b9d012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb33bfd47d4df471d4abad9b090fc79a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acb33bfd47d4df471d4abad9b090fc79a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acb33bfd47d4df471d4abad9b090fc79a.html#acb33bfd47d4df471d4abad9b090fc79a">dims</a> (const T &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="memdesc:acb33bfd47d4df471d4abad9b090fc79a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes dimensions of given argument into given result vector.  <br /></td></tr>
<tr class="separator:acb33bfd47d4df471d4abad9b090fc79a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0650159b7274f5001be98ff417ee9de"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Alloc &gt; </td></tr>
<tr class="memitem:ac0650159b7274f5001be98ff417ee9de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac0650159b7274f5001be98ff417ee9de.html#ac0650159b7274f5001be98ff417ee9de">dims</a> (const std::vector&lt; T, Alloc &gt; &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="memdesc:ac0650159b7274f5001be98ff417ee9de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes dimensions of given argument into given result vector.  <br /></td></tr>
<tr class="separator:ac0650159b7274f5001be98ff417ee9de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6864dee11ec3a436a77c97c39924fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d6864dee11ec3a436a77c97c39924fe"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1d6864dee11ec3a436a77c97c39924fe.html#a1d6864dee11ec3a436a77c97c39924fe">dims</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a1d6864dee11ec3a436a77c97c39924fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines dimensions of an argument.  <br /></td></tr>
<tr class="separator:a1d6864dee11ec3a436a77c97c39924fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8236d7207fe3b5c29d0520c861b22dc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af8236d7207fe3b5c29d0520c861b22dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af8236d7207fe3b5c29d0520c861b22dc.html#af8236d7207fe3b5c29d0520c861b22dc">distance</a> (const T1 &amp;x1, const T2 &amp;x2)</td></tr>
<tr class="memdesc:af8236d7207fe3b5c29d0520c861b22dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the distance between two scalars.  <br /></td></tr>
<tr class="separator:af8236d7207fe3b5c29d0520c861b22dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c628ce25218726985441a9feda810e6"><td class="memTemplParams" colspan="2">template&lt;typename Scal1 , typename Scal2 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; Scal1, Scal2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7c628ce25218726985441a9feda810e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Scal1, Scal2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7c628ce25218726985441a9feda810e6.html#a7c628ce25218726985441a9feda810e6">divide</a> (const Scal1 &amp;x, const Scal2 &amp;y)</td></tr>
<tr class="memdesc:a7c628ce25218726985441a9feda810e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the division of the first scalar by the second scalar.  <br /></td></tr>
<tr class="separator:a7c628ce25218726985441a9feda810e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1e1b387939d34b8dc29e6d062530e8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1d1e1b387939d34b8dc29e6d062530e8.html#a1d1e1b387939d34b8dc29e6d062530e8">divide</a> (int x, int y)</td></tr>
<tr class="separator:a1d1e1b387939d34b8dc29e6d062530e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb611f1fe008351a5e57bd8bbd7e4187"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__eigen__types_ga251d4f37bdda3638307d8d2b2abfe76e.html#ga251d4f37bdda3638307d8d2b2abfe76e">require_any_eigen_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adb611f1fe008351a5e57bd8bbd7e4187"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adb611f1fe008351a5e57bd8bbd7e4187.html#adb611f1fe008351a5e57bd8bbd7e4187">divide</a> (const T1 &amp;m, const T2 &amp;c)</td></tr>
<tr class="memdesc:adb611f1fe008351a5e57bd8bbd7e4187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return matrix divided by scalar.  <br /></td></tr>
<tr class="separator:adb611f1fe008351a5e57bd8bbd7e4187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d853ceca71d760dfb4b58880963233"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_v &gt; </td></tr>
<tr class="memitem:a66d853ceca71d760dfb4b58880963233"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_v, double &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a66d853ceca71d760dfb4b58880963233.html#a66d853ceca71d760dfb4b58880963233">divide_columns</a> (const std::vector&lt; Eigen::Matrix&lt; T_x, Eigen::Dynamic, 1 &gt; &gt; &amp;x, const std::vector&lt; T_v &gt; &amp;vec)</td></tr>
<tr class="memdesc:a66d853ceca71d760dfb4b58880963233"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes Stan data type vector[n] x[D] and divides column vector in x element-wise by the values in vec.  <br /></td></tr>
<tr class="separator:a66d853ceca71d760dfb4b58880963233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3b73319bd8df9dad1d3902997d8e89"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afd3b73319bd8df9dad1d3902997d8e89.html#afd3b73319bd8df9dad1d3902997d8e89">dot</a> (const std::vector&lt; double &gt; &amp;x, const std::vector&lt; double &gt; &amp;y)</td></tr>
<tr class="separator:afd3b73319bd8df9dad1d3902997d8e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de31eb86abc14bc55329668faef12d9"><td class="memTemplParams" colspan="2">template&lt;typename Vec1 , typename Vec2 , <a class="el" href="group__eigen__vector__types_gaf8c3e4d9b301746f5374ae7237eeab66.html#gaf8c3e4d9b301746f5374ae7237eeab66">require_all_eigen_vector_t</a>&lt; Vec1, Vec2 &gt; *  = nullptr, <a class="el" href="group__var__types_ga202c72c7f8418f766eeb3e013a43e25c.html#ga202c72c7f8418f766eeb3e013a43e25c">require_not_var_t</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Vec1, Vec2 &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4de31eb86abc14bc55329668faef12d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4de31eb86abc14bc55329668faef12d9.html#a4de31eb86abc14bc55329668faef12d9">dot_product</a> (const Vec1 &amp;v1, const Vec2 &amp;v2)</td></tr>
<tr class="memdesc:a4de31eb86abc14bc55329668faef12d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified vectors.  <br /></td></tr>
<tr class="separator:a4de31eb86abc14bc55329668faef12d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0847bcd2ea9599de5e091222e8aea48a"><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; Scalar1, Scalar2 &gt; *  = nullptr, <a class="el" href="group__var__types_gacd1267e326cb7764f47ddfba577dabdb.html#gacd1267e326cb7764f47ddfba577dabdb">require_all_not_var_t</a>&lt; Scalar1, Scalar2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0847bcd2ea9599de5e091222e8aea48a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0847bcd2ea9599de5e091222e8aea48a.html#a0847bcd2ea9599de5e091222e8aea48a">dot_product</a> (const Scalar1 *v1, const Scalar2 *v2, size_t length)</td></tr>
<tr class="memdesc:a0847bcd2ea9599de5e091222e8aea48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified arrays.  <br /></td></tr>
<tr class="separator:a0847bcd2ea9599de5e091222e8aea48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f628bd15c8b6f349c8fb5768ad8dde"><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 , typename Alloc1 , typename Alloc2 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; Scalar1, Scalar2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a52f628bd15c8b6f349c8fb5768ad8dde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Scalar1, Scalar2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a52f628bd15c8b6f349c8fb5768ad8dde.html#a52f628bd15c8b6f349c8fb5768ad8dde">dot_product</a> (const std::vector&lt; Scalar1, Alloc1 &gt; &amp;v1, const std::vector&lt; Scalar2, Alloc2 &gt; &amp;v2)</td></tr>
<tr class="memdesc:a52f628bd15c8b6f349c8fb5768ad8dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of the specified arrays.  <br /></td></tr>
<tr class="separator:a52f628bd15c8b6f349c8fb5768ad8dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6a4ef7c701db7984297d153580c8d4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8a6a4ef7c701db7984297d153580c8d4.html#a8a6a4ef7c701db7984297d153580c8d4">dot_self</a> (const std::vector&lt; double &gt; &amp;x)</td></tr>
<tr class="separator:a8a6a4ef7c701db7984297d153580c8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ab632c77cd1b721450f1456681b258"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga93918b2590606552cac973a4397ab38a.html#ga93918b2590606552cac973a4397ab38a">require_not_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a96ab632c77cd1b721450f1456681b258"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a96ab632c77cd1b721450f1456681b258.html#a96ab632c77cd1b721450f1456681b258">dot_self</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a96ab632c77cd1b721450f1456681b258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns squared norm of a vector or matrix.  <br /></td></tr>
<tr class="separator:a96ab632c77cd1b721450f1456681b258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455d128c299b5d3f05a2059bfea4e4c8"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__eigen__types_ga251d4f37bdda3638307d8d2b2abfe76e.html#ga251d4f37bdda3638307d8d2b2abfe76e">require_any_eigen_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__autodiff__types_ga6616a05cabec4f81562db410ade4d2a5.html#ga6616a05cabec4f81562db410ade4d2a5">require_any_st_autodiff</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__same__types_ga2b9b312b4f31cd3817e63d6c03ab68a4.html#ga2b9b312b4f31cd3817e63d6c03ab68a4">require_not_st_same</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a455d128c299b5d3f05a2059bfea4e4c8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a455d128c299b5d3f05a2059bfea4e4c8.html#a455d128c299b5d3f05a2059bfea4e4c8">operator&lt;</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:a455d128c299b5d3f05a2059bfea4e4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285412b12de2a0dbfca8b55769dd609f"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__eigen__types_ga251d4f37bdda3638307d8d2b2abfe76e.html#ga251d4f37bdda3638307d8d2b2abfe76e">require_any_eigen_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__autodiff__types_ga6616a05cabec4f81562db410ade4d2a5.html#ga6616a05cabec4f81562db410ade4d2a5">require_any_st_autodiff</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__same__types_ga2b9b312b4f31cd3817e63d6c03ab68a4.html#ga2b9b312b4f31cd3817e63d6c03ab68a4">require_not_st_same</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a285412b12de2a0dbfca8b55769dd609f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a285412b12de2a0dbfca8b55769dd609f.html#a285412b12de2a0dbfca8b55769dd609f">operator&lt;=</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:a285412b12de2a0dbfca8b55769dd609f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bf925369261729a0aa9cfc0188c766"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__eigen__types_ga251d4f37bdda3638307d8d2b2abfe76e.html#ga251d4f37bdda3638307d8d2b2abfe76e">require_any_eigen_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__autodiff__types_ga6616a05cabec4f81562db410ade4d2a5.html#ga6616a05cabec4f81562db410ade4d2a5">require_any_st_autodiff</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__same__types_ga2b9b312b4f31cd3817e63d6c03ab68a4.html#ga2b9b312b4f31cd3817e63d6c03ab68a4">require_not_st_same</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae1bf925369261729a0aa9cfc0188c766"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae1bf925369261729a0aa9cfc0188c766.html#ae1bf925369261729a0aa9cfc0188c766">operator&gt;</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:ae1bf925369261729a0aa9cfc0188c766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5be855ba2abf476e627a889d1780979"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__eigen__types_ga251d4f37bdda3638307d8d2b2abfe76e.html#ga251d4f37bdda3638307d8d2b2abfe76e">require_any_eigen_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__autodiff__types_ga6616a05cabec4f81562db410ade4d2a5.html#ga6616a05cabec4f81562db410ade4d2a5">require_any_st_autodiff</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__same__types_ga2b9b312b4f31cd3817e63d6c03ab68a4.html#ga2b9b312b4f31cd3817e63d6c03ab68a4">require_not_st_same</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac5be855ba2abf476e627a889d1780979"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac5be855ba2abf476e627a889d1780979.html#ac5be855ba2abf476e627a889d1780979">operator&gt;=</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:ac5be855ba2abf476e627a889d1780979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315cb73b27c5043e63957dca3e98dfab"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__eigen__types_ga251d4f37bdda3638307d8d2b2abfe76e.html#ga251d4f37bdda3638307d8d2b2abfe76e">require_any_eigen_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__autodiff__types_ga6616a05cabec4f81562db410ade4d2a5.html#ga6616a05cabec4f81562db410ade4d2a5">require_any_st_autodiff</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__same__types_ga2b9b312b4f31cd3817e63d6c03ab68a4.html#ga2b9b312b4f31cd3817e63d6c03ab68a4">require_not_st_same</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a315cb73b27c5043e63957dca3e98dfab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a315cb73b27c5043e63957dca3e98dfab.html#a315cb73b27c5043e63957dca3e98dfab">operator==</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:a315cb73b27c5043e63957dca3e98dfab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e8d772959e81830b0314afff76fbcb"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__eigen__types_ga251d4f37bdda3638307d8d2b2abfe76e.html#ga251d4f37bdda3638307d8d2b2abfe76e">require_any_eigen_t</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__autodiff__types_ga6616a05cabec4f81562db410ade4d2a5.html#ga6616a05cabec4f81562db410ade4d2a5">require_any_st_autodiff</a>&lt; T_a, T_b &gt; *  = nullptr, <a class="el" href="group__same__types_ga2b9b312b4f31cd3817e63d6c03ab68a4.html#ga2b9b312b4f31cd3817e63d6c03ab68a4">require_not_st_same</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a52e8d772959e81830b0314afff76fbcb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a52e8d772959e81830b0314afff76fbcb.html#a52e8d772959e81830b0314afff76fbcb">operator!=</a> (const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:a52e8d772959e81830b0314afff76fbcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748d9af371d553c4d86f363ec873a306"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__complex__types_ga97088f55325ec04904868db4312bf537.html#ga97088f55325ec04904868db4312bf537">require_not_vt_complex</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a748d9af371d553c4d86f363ec873a306"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt; &gt;, -1, -1 &gt;, Eigen::Matrix&lt; <a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt; &gt;, -1, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a748d9af371d553c4d86f363ec873a306.html#a748d9af371d553c4d86f363ec873a306">eigendecompose</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a748d9af371d553c4d86f363ec873a306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eigendecomposition of a (real-valued) matrix.  <br /></td></tr>
<tr class="separator:a748d9af371d553c4d86f363ec873a306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574c1bb53e14170318eb26e79aab2e6a"><td class="memTemplParams" colspan="2">template&lt;typename EigCplxMat , <a class="el" href="group__eigen__matrix__dynamic__types_gae725537ef0b9f4ef9857fa1b28bd1076.html#gae725537ef0b9f4ef9857fa1b28bd1076">require_eigen_matrix_dynamic_vt</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>, EigCplxMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a574c1bb53e14170318eb26e79aab2e6a"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigCplxMat &gt; &gt;, -1, -1 &gt;, Eigen::Matrix&lt; <a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigCplxMat &gt; &gt;, -1, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a574c1bb53e14170318eb26e79aab2e6a.html#a574c1bb53e14170318eb26e79aab2e6a">eigendecompose</a> (const EigCplxMat &amp;m)</td></tr>
<tr class="memdesc:a574c1bb53e14170318eb26e79aab2e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eigendecomposition of a (complex-valued) matrix.  <br /></td></tr>
<tr class="separator:a574c1bb53e14170318eb26e79aab2e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac087f72e1f01c05da5e551ff93afdd0f"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac087f72e1f01c05da5e551ff93afdd0f"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, -1, -1 &gt;, Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, -1, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac087f72e1f01c05da5e551ff93afdd0f.html#ac087f72e1f01c05da5e551ff93afdd0f">eigendecompose_sym</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:ac087f72e1f01c05da5e551ff93afdd0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eigendecomposition of the specified symmetric matrix.  <br /></td></tr>
<tr class="separator:ac087f72e1f01c05da5e551ff93afdd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11986db9bdb58e69ef129ce90b41c66"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__complex__types_ga97088f55325ec04904868db4312bf537.html#ga97088f55325ec04904868db4312bf537">require_not_vt_complex</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af11986db9bdb58e69ef129ce90b41c66"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt; &gt;, -1, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af11986db9bdb58e69ef129ce90b41c66.html#af11986db9bdb58e69ef129ce90b41c66">eigenvalues</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:af11986db9bdb58e69ef129ce90b41c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eigenvalues of a (real-valued) matrix.  <br /></td></tr>
<tr class="separator:af11986db9bdb58e69ef129ce90b41c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635a0354ec9a9bf4473017318731b6f2"><td class="memTemplParams" colspan="2">template&lt;typename EigCplxMat , <a class="el" href="group__eigen__matrix__dynamic__types_gae725537ef0b9f4ef9857fa1b28bd1076.html#gae725537ef0b9f4ef9857fa1b28bd1076">require_eigen_matrix_dynamic_vt</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>, EigCplxMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a635a0354ec9a9bf4473017318731b6f2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigCplxMat &gt; &gt;, -1, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a635a0354ec9a9bf4473017318731b6f2.html#a635a0354ec9a9bf4473017318731b6f2">eigenvalues</a> (const EigCplxMat &amp;m)</td></tr>
<tr class="memdesc:a635a0354ec9a9bf4473017318731b6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eigenvalues of a (complex-valued) matrix.  <br /></td></tr>
<tr class="separator:a635a0354ec9a9bf4473017318731b6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1bb7bf4b0e64a3ec04b5a0ee5934d8"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ada1bb7bf4b0e64a3ec04b5a0ee5934d8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, -1, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ada1bb7bf4b0e64a3ec04b5a0ee5934d8.html#ada1bb7bf4b0e64a3ec04b5a0ee5934d8">eigenvalues_sym</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:ada1bb7bf4b0e64a3ec04b5a0ee5934d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eigenvalues of the specified symmetric matrix in ascending order of magnitude.  <br /></td></tr>
<tr class="separator:ada1bb7bf4b0e64a3ec04b5a0ee5934d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff7a5be47c0c9cb6712e00204963827"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__complex__types_ga97088f55325ec04904868db4312bf537.html#ga97088f55325ec04904868db4312bf537">require_not_vt_complex</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9ff7a5be47c0c9cb6712e00204963827"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt; &gt;, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ff7a5be47c0c9cb6712e00204963827.html#a9ff7a5be47c0c9cb6712e00204963827">eigenvectors</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a9ff7a5be47c0c9cb6712e00204963827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eigenvectors of a (real-valued) matrix.  <br /></td></tr>
<tr class="separator:a9ff7a5be47c0c9cb6712e00204963827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9095626a702311fb7d6c2923a6363b"><td class="memTemplParams" colspan="2">template&lt;typename EigCplxMat , <a class="el" href="group__eigen__matrix__dynamic__types_gae725537ef0b9f4ef9857fa1b28bd1076.html#gae725537ef0b9f4ef9857fa1b28bd1076">require_eigen_matrix_dynamic_vt</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>, EigCplxMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adb9095626a702311fb7d6c2923a6363b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gaf21bb3c3ca46c48bb58c33a5260b74c7.html#gaf21bb3c3ca46c48bb58c33a5260b74c7">complex_return_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigCplxMat &gt; &gt;, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adb9095626a702311fb7d6c2923a6363b.html#adb9095626a702311fb7d6c2923a6363b">eigenvectors</a> (const EigCplxMat &amp;m)</td></tr>
<tr class="memdesc:adb9095626a702311fb7d6c2923a6363b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eigenvectors of a (complex-valued) matrix.  <br /></td></tr>
<tr class="separator:adb9095626a702311fb7d6c2923a6363b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a55a169e6abfe0af7eeb8c80e14c3d"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae9a55a169e6abfe0af7eeb8c80e14c3d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae9a55a169e6abfe0af7eeb8c80e14c3d.html#ae9a55a169e6abfe0af7eeb8c80e14c3d">eigenvectors_sym</a> (const EigMat &amp;m)</td></tr>
<tr class="separator:ae9a55a169e6abfe0af7eeb8c80e14c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af798bd8a0d1384220c1bfb6e8f35293c"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af798bd8a0d1384220c1bfb6e8f35293c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af798bd8a0d1384220c1bfb6e8f35293c.html#af798bd8a0d1384220c1bfb6e8f35293c">elt_divide</a> (const Mat1 &amp;m1, const Mat2 &amp;m2)</td></tr>
<tr class="memdesc:af798bd8a0d1384220c1bfb6e8f35293c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise division of the specified matrices.  <br /></td></tr>
<tr class="separator:af798bd8a0d1384220c1bfb6e8f35293c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb896efcf46a2f21ebe31a38c1c0d253"><td class="memTemplParams" colspan="2">template&lt;typename Mat , typename Scal , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afb896efcf46a2f21ebe31a38c1c0d253"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afb896efcf46a2f21ebe31a38c1c0d253.html#afb896efcf46a2f21ebe31a38c1c0d253">elt_divide</a> (const Mat &amp;m, Scal s)</td></tr>
<tr class="memdesc:afb896efcf46a2f21ebe31a38c1c0d253"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise division of the specified matrix by the specified scalar.  <br /></td></tr>
<tr class="separator:afb896efcf46a2f21ebe31a38c1c0d253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25b002811703a438a39fd72b610315b5"><td class="memTemplParams" colspan="2">template&lt;typename Scal , typename Mat , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a25b002811703a438a39fd72b610315b5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a25b002811703a438a39fd72b610315b5.html#a25b002811703a438a39fd72b610315b5">elt_divide</a> (Scal s, const Mat &amp;m)</td></tr>
<tr class="memdesc:a25b002811703a438a39fd72b610315b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise division of the specified scalar by the specified matrix.  <br /></td></tr>
<tr class="separator:a25b002811703a438a39fd72b610315b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060c31d15cbc2bb6006581766481ed4c"><td class="memTemplParams" colspan="2">template&lt;typename Scal1 , typename Scal2 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; Scal1, Scal2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a060c31d15cbc2bb6006581766481ed4c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a060c31d15cbc2bb6006581766481ed4c.html#a060c31d15cbc2bb6006581766481ed4c">elt_divide</a> (Scal1 s1, Scal2 s2)</td></tr>
<tr class="separator:a060c31d15cbc2bb6006581766481ed4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44ba8ada7e65086532ffa28ad8631cf"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac44ba8ada7e65086532ffa28ad8631cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac44ba8ada7e65086532ffa28ad8631cf.html#ac44ba8ada7e65086532ffa28ad8631cf">elt_multiply</a> (const Mat1 &amp;m1, const Mat2 &amp;m2)</td></tr>
<tr class="memdesc:ac44ba8ada7e65086532ffa28ad8631cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise multiplication of the specified matrices.  <br /></td></tr>
<tr class="separator:ac44ba8ada7e65086532ffa28ad8631cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7edc12e3efb6f9bb1ce1e3bb76d2342"><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; Scalar1, Scalar2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab7edc12e3efb6f9bb1ce1e3bb76d2342"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab7edc12e3efb6f9bb1ce1e3bb76d2342.html#ab7edc12e3efb6f9bb1ce1e3bb76d2342">elt_multiply</a> (const Scalar1 &amp;a, const Scalar2 &amp;b)</td></tr>
<tr class="memdesc:ab7edc12e3efb6f9bb1ce1e3bb76d2342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise multiplication of the specified scalars.  <br /></td></tr>
<tr class="separator:ab7edc12e3efb6f9bb1ce1e3bb76d2342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e71b0b782cf7aa5ebb24077387e599"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__matrix__types_ga1922331b5c670c8a19b234064e174cf9.html#ga1922331b5c670c8a19b234064e174cf9">require_any_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga538634dc8f8389f2986205f6098c04a2.html#ga538634dc8f8389f2986205f6098c04a2">require_any_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a44e71b0b782cf7aa5ebb24077387e599"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a44e71b0b782cf7aa5ebb24077387e599.html#a44e71b0b782cf7aa5ebb24077387e599">elt_multiply</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:a44e71b0b782cf7aa5ebb24077387e599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified matrix multiplied by specified scalar.  <br /></td></tr>
<tr class="separator:a44e71b0b782cf7aa5ebb24077387e599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1165ca04ac1e214a053e049ad165d2"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaa1165ca04ac1e214a053e049ad165d2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaa1165ca04ac1e214a053e049ad165d2.html#aaa1165ca04ac1e214a053e049ad165d2">erf</a> (const T &amp;x)</td></tr>
<tr class="memdesc:aaa1165ca04ac1e214a053e049ad165d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a56f59c3dd3a27e81e8320083e1a0c6c1.html#a56f59c3dd3a27e81e8320083e1a0c6c1">erf()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:aaa1165ca04ac1e214a053e049ad165d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898c619f12c33793034f7c38940a181c"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a898c619f12c33793034f7c38940a181c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a898c619f12c33793034f7c38940a181c.html#a898c619f12c33793034f7c38940a181c">erfc</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a898c619f12c33793034f7c38940a181c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_a9994e6390e4a0c155be10c882072ca34.html#a9994e6390e4a0c155be10c882072ca34">erfc()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:a898c619f12c33793034f7c38940a181c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5144e07da75ff5357c4338a9a6f0faae"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__same__types_ga29595127b6ba2b597e5723c80dee1b61.html#ga29595127b6ba2b597e5723c80dee1b61">require_same_t</a>&lt; std::decay_t&lt; T &gt;, <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5144e07da75ff5357c4338a9a6f0faae"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5144e07da75ff5357c4338a9a6f0faae.html#a5144e07da75ff5357c4338a9a6f0faae">eval</a> (T &amp;&amp;<a class="el" href="namespacestan_1_1math_a500fda68d64f44323202b69ffa804f5f.html#a500fda68d64f44323202b69ffa804f5f">arg</a>)</td></tr>
<tr class="memdesc:a5144e07da75ff5357c4338a9a6f0faae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inputs which have a <a class="el" href="structstan_1_1plain__type.html" title="Determines plain (non expression) type associated with T.">plain_type</a> equal to the own time are forwarded unmodified (for <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expressions these types are different)  <br /></td></tr>
<tr class="separator:a5144e07da75ff5357c4338a9a6f0faae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8d32a5bccb457978ba478e2660cb6e"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__same__types_ga151adb676402a791de98a5d743d7a10d.html#ga151adb676402a791de98a5d743d7a10d">require_not_same_t</a>&lt; std::decay_t&lt; T &gt;, <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4d8d32a5bccb457978ba478e2660cb6e"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4d8d32a5bccb457978ba478e2660cb6e.html#a4d8d32a5bccb457978ba478e2660cb6e">eval</a> (const T &amp;<a class="el" href="namespacestan_1_1math_a500fda68d64f44323202b69ffa804f5f.html#a500fda68d64f44323202b69ffa804f5f">arg</a>)</td></tr>
<tr class="memdesc:a4d8d32a5bccb457978ba478e2660cb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inputs which have a <a class="el" href="structstan_1_1plain__type.html" title="Determines plain (non expression) type associated with T.">plain_type</a> different from their own type are Eval'd (this catches <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expressions)  <br /></td></tr>
<tr class="separator:a4d8d32a5bccb457978ba478e2660cb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d1791f099452b96a1e09f2e5c79173"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac5d1791f099452b96a1e09f2e5c79173"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac5d1791f099452b96a1e09f2e5c79173.html#ac5d1791f099452b96a1e09f2e5c79173">exp</a> (const T x)</td></tr>
<tr class="memdesc:ac5d1791f099452b96a1e09f2e5c79173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural (base e) exponentiation of the specified complex argument.  <br /></td></tr>
<tr class="separator:ac5d1791f099452b96a1e09f2e5c79173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978fcebcb29a07aa69fd567891132b9a"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a978fcebcb29a07aa69fd567891132b9a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a978fcebcb29a07aa69fd567891132b9a.html#a978fcebcb29a07aa69fd567891132b9a">exp</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a978fcebcb29a07aa69fd567891132b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise <code><a class="el" href="namespacestan_1_1math_afeb02d174bb7d5c70db81fa1a9996f57.html#afeb02d174bb7d5c70db81fa1a9996f57">exp()</a></code> of the specified argument, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:a978fcebcb29a07aa69fd567891132b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29009bb8a9bd673d0fd3d8fa463abcb"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae29009bb8a9bd673d0fd3d8fa463abcb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae29009bb8a9bd673d0fd3d8fa463abcb.html#ae29009bb8a9bd673d0fd3d8fa463abcb">exp2</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae29009bb8a9bd673d0fd3d8fa463abcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise <code><a class="el" href="namespacestan_1_1math_a311f94ed9243524c28e9d30dce8045df.html#a311f94ed9243524c28e9d30dce8045df">exp2()</a></code> of the specified argument, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:ae29009bb8a9bd673d0fd3d8fa463abcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493ba56fe5b6b4d10a4f92dd1006f8ba"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a493ba56fe5b6b4d10a4f92dd1006f8ba"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a493ba56fe5b6b4d10a4f92dd1006f8ba.html#a493ba56fe5b6b4d10a4f92dd1006f8ba">expm1</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a493ba56fe5b6b4d10a4f92dd1006f8ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise <code><a class="el" href="namespacestan_1_1math_a23c116678993eabfaf88ab4e92209f31.html#a23c116678993eabfaf88ab4e92209f31">expm1()</a></code> of the specified argument, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:a493ba56fe5b6b4d10a4f92dd1006f8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985dffb3a6c8b6226b38e70e4e00b976"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a985dffb3a6c8b6226b38e70e4e00b976"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a985dffb3a6c8b6226b38e70e4e00b976.html#a985dffb3a6c8b6226b38e70e4e00b976">fabs</a> (T x)</td></tr>
<tr class="separator:a985dffb3a6c8b6226b38e70e4e00b976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359ae820a6117251c8e1851acf192a47"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga1b135bb62a0729e31b4233e370170a53.html#ga1b135bb62a0729e31b4233e370170a53">require_not_container_st</a>&lt; std::is_arithmetic, Container &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; Container &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; Container &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga8e2ecf4866780c76833f71cd4d28e3cf.html#ga8e2ecf4866780c76833f71cd4d28e3cf">require_not_stan_scalar_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a359ae820a6117251c8e1851acf192a47"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a359ae820a6117251c8e1851acf192a47.html#a359ae820a6117251c8e1851acf192a47">fabs</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a359ae820a6117251c8e1851acf192a47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code>fabs()</code> of the input, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:a359ae820a6117251c8e1851acf192a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa58b6f5a871fc1ed32f78ad2b60d30"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga7bc6670ad3273187c8b6fff5c86288ae.html#ga7bc6670ad3273187c8b6fff5c86288ae">require_container_st</a>&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0aa58b6f5a871fc1ed32f78ad2b60d30"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0aa58b6f5a871fc1ed32f78ad2b60d30.html#a0aa58b6f5a871fc1ed32f78ad2b60d30">fabs</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a0aa58b6f5a871fc1ed32f78ad2b60d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code>fabs()</code> that accepts std::vectors, <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <br /></td></tr>
<tr class="separator:a0aa58b6f5a871fc1ed32f78ad2b60d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3c9360de8944183df51fa64611bd88"><td class="memTemplParams" colspan="2">template&lt;typename T_Sigma , typename T_CPCs , typename T_sds , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T_Sigma &gt; *  = nullptr, <a class="el" href="group__eigen__vector__types_gaf8c3e4d9b301746f5374ae7237eeab66.html#gaf8c3e4d9b301746f5374ae7237eeab66">require_all_eigen_vector_t</a>&lt; T_CPCs, T_sds &gt; *  = nullptr, <a class="el" href="group__same__types_gafc6c66ae3d249abb30aaa0140c8d080c.html#gafc6c66ae3d249abb30aaa0140c8d080c">require_all_vt_same</a>&lt; T_Sigma, T_CPCs, T_sds &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aef3c9360de8944183df51fa64611bd88"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aef3c9360de8944183df51fa64611bd88.html#aef3c9360de8944183df51fa64611bd88">factor_cov_matrix</a> (const T_Sigma &amp;Sigma, T_CPCs &amp;&amp;CPCs, T_sds &amp;&amp;sds)</td></tr>
<tr class="memdesc:aef3c9360de8944183df51fa64611bd88"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is intended to make starting values, given a covariance matrix Sigma.  <br /></td></tr>
<tr class="separator:aef3c9360de8944183df51fa64611bd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9fec4106ac49aaf2c27e2cce85d3cc"><td class="memTemplParams" colspan="2">template&lt;typename T_U , typename T_CPCs , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T_U &gt; *  = nullptr, <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T_CPCs &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; T_U, T_CPCs &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adb9fec4106ac49aaf2c27e2cce85d3cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adb9fec4106ac49aaf2c27e2cce85d3cc.html#adb9fec4106ac49aaf2c27e2cce85d3cc">factor_U</a> (const T_U &amp;U, T_CPCs &amp;&amp;CPCs)</td></tr>
<tr class="memdesc:adb9fec4106ac49aaf2c27e2cce85d3cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is intended to make starting values, given a unit upper-triangular matrix U such that U'DU is a correlation matrix.  <br /></td></tr>
<tr class="separator:adb9fec4106ac49aaf2c27e2cce85d3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101c0a426817307cde0506e8f8294e1a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a101c0a426817307cde0506e8f8294e1a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a101c0a426817307cde0506e8f8294e1a.html#a101c0a426817307cde0506e8f8294e1a">falling_factorial</a> (const T &amp;x, int n)</td></tr>
<tr class="memdesc:a101c0a426817307cde0506e8f8294e1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the falling factorial function evaluated at the inputs.  <br /></td></tr>
<tr class="separator:a101c0a426817307cde0506e8f8294e1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e536af3bcaad2b9c4bc2d469cf3dfe4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_gae0f57b6105cb69165aeee0f2de2e50db.html#gae0f57b6105cb69165aeee0f2de2e50db">require_all_not_var_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5e536af3bcaad2b9c4bc2d469cf3dfe4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5e536af3bcaad2b9c4bc2d469cf3dfe4.html#a5e536af3bcaad2b9c4bc2d469cf3dfe4">falling_factorial</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a5e536af3bcaad2b9c4bc2d469cf3dfe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the falling factorial function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:a5e536af3bcaad2b9c4bc2d469cf3dfe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8902257303d9b187e0e47d4bf87f3a1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae8902257303d9b187e0e47d4bf87f3a1"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae8902257303d9b187e0e47d4bf87f3a1.html#ae8902257303d9b187e0e47d4bf87f3a1">fdim</a> (T1 x, T2 y)</td></tr>
<tr class="memdesc:ae8902257303d9b187e0e47d4bf87f3a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference of the specified values (C++11).  <br /></td></tr>
<tr class="separator:ae8902257303d9b187e0e47d4bf87f3a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae735132ce46b1fd85de7716bf278e0f6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae735132ce46b1fd85de7716bf278e0f6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae735132ce46b1fd85de7716bf278e0f6.html#ae735132ce46b1fd85de7716bf278e0f6">fdim</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ae735132ce46b1fd85de7716bf278e0f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the fdim function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:ae735132ce46b1fd85de7716bf278e0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbd6877b180af8eef1db0c167b08b55"><td class="memTemplParams" colspan="2">template&lt;typename V , <a class="el" href="group__eigen__vector__types_ga896401ad33967867f49cd60ca10d990e.html#ga896401ad33967867f49cd60ca10d990e">require_eigen_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>, V &gt; *  = nullptr, <a class="el" href="group__var__types_ga202c72c7f8418f766eeb3e013a43e25c.html#ga202c72c7f8418f766eeb3e013a43e25c">require_not_var_t</a>&lt; <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; V &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8dbd6877b180af8eef1db0c167b08b55"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; V &gt;, -1, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8dbd6877b180af8eef1db0c167b08b55.html#a8dbd6877b180af8eef1db0c167b08b55">fft</a> (const V &amp;x)</td></tr>
<tr class="memdesc:a8dbd6877b180af8eef1db0c167b08b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the discrete Fourier transform of the specified complex vector.  <br /></td></tr>
<tr class="separator:a8dbd6877b180af8eef1db0c167b08b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae55f892518a11a7aa437bcf22cea8209"><td class="memTemplParams" colspan="2">template&lt;typename V , <a class="el" href="group__eigen__vector__types_ga896401ad33967867f49cd60ca10d990e.html#ga896401ad33967867f49cd60ca10d990e">require_eigen_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>, V &gt; *  = nullptr, <a class="el" href="group__var__types_ga202c72c7f8418f766eeb3e013a43e25c.html#ga202c72c7f8418f766eeb3e013a43e25c">require_not_var_t</a>&lt; <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; V &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae55f892518a11a7aa437bcf22cea8209"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; V &gt;, -1, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae55f892518a11a7aa437bcf22cea8209.html#ae55f892518a11a7aa437bcf22cea8209">inv_fft</a> (const V &amp;y)</td></tr>
<tr class="memdesc:ae55f892518a11a7aa437bcf22cea8209"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse discrete Fourier transform of the specified complex vector.  <br /></td></tr>
<tr class="separator:ae55f892518a11a7aa437bcf22cea8209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063a3b3fd88818e48525bf8874e7829d"><td class="memTemplParams" colspan="2">template&lt;typename M , <a class="el" href="group__eigen__dense__dynamic__types_ga36cbcf4b98f8305631d3ddc70ffc8565.html#ga36cbcf4b98f8305631d3ddc70ffc8565">require_eigen_dense_dynamic_vt</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>, M &gt; *  = nullptr, <a class="el" href="group__var__types_ga202c72c7f8418f766eeb3e013a43e25c.html#ga202c72c7f8418f766eeb3e013a43e25c">require_not_var_t</a>&lt; <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; M &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a063a3b3fd88818e48525bf8874e7829d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; M &gt;, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a063a3b3fd88818e48525bf8874e7829d.html#a063a3b3fd88818e48525bf8874e7829d">fft2</a> (const M &amp;x)</td></tr>
<tr class="memdesc:a063a3b3fd88818e48525bf8874e7829d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the two-dimensional discrete Fourier transform of the specified complex matrix.  <br /></td></tr>
<tr class="separator:a063a3b3fd88818e48525bf8874e7829d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7f076a1b0a3557bed259a3e9c8062f"><td class="memTemplParams" colspan="2">template&lt;typename M , <a class="el" href="group__eigen__dense__dynamic__types_ga36cbcf4b98f8305631d3ddc70ffc8565.html#ga36cbcf4b98f8305631d3ddc70ffc8565">require_eigen_dense_dynamic_vt</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>, M &gt; *  = nullptr, <a class="el" href="group__var__types_ga202c72c7f8418f766eeb3e013a43e25c.html#ga202c72c7f8418f766eeb3e013a43e25c">require_not_var_t</a>&lt; <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; M &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afc7f076a1b0a3557bed259a3e9c8062f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; M &gt;, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afc7f076a1b0a3557bed259a3e9c8062f.html#afc7f076a1b0a3557bed259a3e9c8062f">inv_fft2</a> (const M &amp;y)</td></tr>
<tr class="memdesc:afc7f076a1b0a3557bed259a3e9c8062f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the two-dimensional inverse discrete Fourier transform of the specified complex matrix.  <br /></td></tr>
<tr class="separator:afc7f076a1b0a3557bed259a3e9c8062f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab101ab077529ae9bc7e2e5c8b929aaee"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename S , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab101ab077529ae9bc7e2e5c8b929aaee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab101ab077529ae9bc7e2e5c8b929aaee.html#ab101ab077529ae9bc7e2e5c8b929aaee">fill</a> (EigMat &amp;x, const S &amp;y)</td></tr>
<tr class="memdesc:ab101ab077529ae9bc7e2e5c8b929aaee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <br /></td></tr>
<tr class="separator:ab101ab077529ae9bc7e2e5c8b929aaee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040edecf84519bad9ef221cd298698d9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S , <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_assignable&lt; std::decay_t&lt; T &gt; &amp;, std::decay_t&lt; S &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a040edecf84519bad9ef221cd298698d9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a040edecf84519bad9ef221cd298698d9.html#a040edecf84519bad9ef221cd298698d9">fill</a> (T &amp;x, S &amp;&amp;y)</td></tr>
<tr class="memdesc:a040edecf84519bad9ef221cd298698d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <br /></td></tr>
<tr class="separator:a040edecf84519bad9ef221cd298698d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c3453d61943d7aef89d0d2e192a5308"><td class="memTemplParams" colspan="2">template&lt;typename Vec , typename S , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3c3453d61943d7aef89d0d2e192a5308"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3c3453d61943d7aef89d0d2e192a5308.html#a3c3453d61943d7aef89d0d2e192a5308">fill</a> (Vec &amp;x, S &amp;&amp;y)</td></tr>
<tr class="memdesc:a3c3453d61943d7aef89d0d2e192a5308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <br /></td></tr>
<tr class="separator:a3c3453d61943d7aef89d0d2e192a5308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71ff021ea506f2b8df0a1be3ee6411e8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a71ff021ea506f2b8df0a1be3ee6411e8.html#a71ff021ea506f2b8df0a1be3ee6411e8">finite_diff_stepsize</a> (double u)</td></tr>
<tr class="memdesc:a71ff021ea506f2b8df0a1be3ee6411e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the stepsize for finite difference evaluations at the specified scalar.  <br /></td></tr>
<tr class="separator:a71ff021ea506f2b8df0a1be3ee6411e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a3b483d8ada391fcc17b4fa10ab4f4"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a52a3b483d8ada391fcc17b4fa10ab4f4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a52a3b483d8ada391fcc17b4fa10ab4f4.html#a52a3b483d8ada391fcc17b4fa10ab4f4">floor</a> (const T x)</td></tr>
<tr class="separator:a52a3b483d8ada391fcc17b4fa10ab4f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6c1200c7f833df78a6eea628ff5b9a"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aef6c1200c7f833df78a6eea628ff5b9a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aef6c1200c7f833df78a6eea628ff5b9a.html#aef6c1200c7f833df78a6eea628ff5b9a">floor</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:aef6c1200c7f833df78a6eea628ff5b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aa828ed40aa78417d100d5cdeae54cd2b.html#aa828ed40aa78417d100d5cdeae54cd2b">floor()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:aef6c1200c7f833df78a6eea628ff5b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63f8f82d7e81c99f2c8672696f82f55"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga846e5c75f0e49887b255adb8e56e1a7e.html#ga846e5c75f0e49887b255adb8e56e1a7e">require_container_bt</a>&lt; std::is_arithmetic, Container &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa63f8f82d7e81c99f2c8672696f82f55"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa63f8f82d7e81c99f2c8672696f82f55.html#aa63f8f82d7e81c99f2c8672696f82f55">floor</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:aa63f8f82d7e81c99f2c8672696f82f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_aa828ed40aa78417d100d5cdeae54cd2b.html#aa828ed40aa78417d100d5cdeae54cd2b">floor()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <br /></td></tr>
<tr class="separator:aa63f8f82d7e81c99f2c8672696f82f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ca413a0f1c9bc970344412e39749b8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af0ca413a0f1c9bc970344412e39749b8"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af0ca413a0f1c9bc970344412e39749b8.html#af0ca413a0f1c9bc970344412e39749b8">fma</a> (T1 x, T2 y, T3 z)</td></tr>
<tr class="memdesc:af0ca413a0f1c9bc970344412e39749b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the first two arguments plus the third argument.  <br /></td></tr>
<tr class="separator:af0ca413a0f1c9bc970344412e39749b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d88c89edeb8a27deaa52879f729ced"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__matrix__types_ga1922331b5c670c8a19b234064e174cf9.html#ga1922331b5c670c8a19b234064e174cf9">require_any_matrix_t</a>&lt; T1, T2, T3 &gt; *  = nullptr, <a class="el" href="group__var__types_ga202c72c7f8418f766eeb3e013a43e25c.html#ga202c72c7f8418f766eeb3e013a43e25c">require_not_var_t</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa6d88c89edeb8a27deaa52879f729ced"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa6d88c89edeb8a27deaa52879f729ced.html#aa6d88c89edeb8a27deaa52879f729ced">fma</a> (T1 &amp;&amp;x, T2 &amp;&amp;y, T3 &amp;&amp;z)</td></tr>
<tr class="separator:aa6d88c89edeb8a27deaa52879f729ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6beecb4381062d93549455104aa698ab"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6beecb4381062d93549455104aa698ab"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6beecb4381062d93549455104aa698ab.html#a6beecb4381062d93549455104aa698ab">fmax</a> (T1 x, T2 y)</td></tr>
<tr class="memdesc:a6beecb4381062d93549455104aa698ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the greater of the two specified arguments.  <br /></td></tr>
<tr class="separator:a6beecb4381062d93549455104aa698ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d52789ee6d4867ff1180087c5f50b3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a29d52789ee6d4867ff1180087c5f50b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a29d52789ee6d4867ff1180087c5f50b3.html#a29d52789ee6d4867ff1180087c5f50b3">fmax</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a29d52789ee6d4867ff1180087c5f50b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the fmax function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:a29d52789ee6d4867ff1180087c5f50b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4406c1b978a23bc9d2940632dcf1d613"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4406c1b978a23bc9d2940632dcf1d613"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4406c1b978a23bc9d2940632dcf1d613.html#a4406c1b978a23bc9d2940632dcf1d613">fmin</a> (T1 x, T2 y)</td></tr>
<tr class="memdesc:a4406c1b978a23bc9d2940632dcf1d613"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lesser of the two specified arguments.  <br /></td></tr>
<tr class="separator:a4406c1b978a23bc9d2940632dcf1d613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b241336e4945206f6dad0fcf98d875"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a95b241336e4945206f6dad0fcf98d875"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a95b241336e4945206f6dad0fcf98d875.html#a95b241336e4945206f6dad0fcf98d875">fmin</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a95b241336e4945206f6dad0fcf98d875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the fmin function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:a95b241336e4945206f6dad0fcf98d875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44bdcf20489a07bda6ea92f95f08576"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af44bdcf20489a07bda6ea92f95f08576"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af44bdcf20489a07bda6ea92f95f08576.html#af44bdcf20489a07bda6ea92f95f08576">fmod</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:af44bdcf20489a07bda6ea92f95f08576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the floating-point remainder of numerator/denominator (rounded towards zero).  <br /></td></tr>
<tr class="separator:af44bdcf20489a07bda6ea92f95f08576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e9113faf5e002823324ad8156dd88ce"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3e9113faf5e002823324ad8156dd88ce"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3e9113faf5e002823324ad8156dd88ce.html#a3e9113faf5e002823324ad8156dd88ce">fmod</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a3e9113faf5e002823324ad8156dd88ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the fmod function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:a3e9113faf5e002823324ad8156dd88ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4192f083082e99157fdfdd79af442b41"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4192f083082e99157fdfdd79af442b41.html#a4192f083082e99157fdfdd79af442b41">gamma_p</a> (double z, double a)</td></tr>
<tr class="memdesc:a4192f083082e99157fdfdd79af442b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the normalized, lower-incomplete gamma function applied to the specified argument.  <br /></td></tr>
<tr class="separator:a4192f083082e99157fdfdd79af442b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56bf829d0cbfa257df15c0e9f9b3fac"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae56bf829d0cbfa257df15c0e9f9b3fac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae56bf829d0cbfa257df15c0e9f9b3fac.html#ae56bf829d0cbfa257df15c0e9f9b3fac">gamma_p</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ae56bf829d0cbfa257df15c0e9f9b3fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the gamma_p function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:ae56bf829d0cbfa257df15c0e9f9b3fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0830ba049b81bc98ea9fbcf1eb7b4bd6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0830ba049b81bc98ea9fbcf1eb7b4bd6.html#a0830ba049b81bc98ea9fbcf1eb7b4bd6">gamma_q</a> (double x, double a)</td></tr>
<tr class="separator:a0830ba049b81bc98ea9fbcf1eb7b4bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362c0d49d7d0642f2df338d86abdef84"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a362c0d49d7d0642f2df338d86abdef84"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a362c0d49d7d0642f2df338d86abdef84.html#a362c0d49d7d0642f2df338d86abdef84">gamma_q</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a362c0d49d7d0642f2df338d86abdef84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the gamma_q function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:a362c0d49d7d0642f2df338d86abdef84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea5ab7f30b6150316599a0d22ffee7e"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__var__types_ga49bd546c64ba1da0a583715b7162c898.html#ga49bd546c64ba1da0a583715b7162c898">require_not_vt_var</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7ea5ab7f30b6150316599a0d22ffee7e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, EigMat::ColsAtCompileTime, EigMat::RowsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7ea5ab7f30b6150316599a0d22ffee7e.html#a7ea5ab7f30b6150316599a0d22ffee7e">generalized_inverse</a> (const EigMat &amp;G)</td></tr>
<tr class="memdesc:a7ea5ab7f30b6150316599a0d22ffee7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Moore-Penrose generalized inverse of the specified matrix.  <br /></td></tr>
<tr class="separator:a7ea5ab7f30b6150316599a0d22ffee7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9218925fcc0ebae0b0e259c6d92b5dd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af9218925fcc0ebae0b0e259c6d92b5dd"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af9218925fcc0ebae0b0e259c6d92b5dd.html#af9218925fcc0ebae0b0e259c6d92b5dd">get_base1</a> (const std::vector&lt; T &gt; &amp;x, size_t i, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:af9218925fcc0ebae0b0e259c6d92b5dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one index.  <br /></td></tr>
<tr class="separator:af9218925fcc0ebae0b0e259c6d92b5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38935ef11ac72e5a0164fb61d64e0ef4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38935ef11ac72e5a0164fb61d64e0ef4"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a38935ef11ac72e5a0164fb61d64e0ef4.html#a38935ef11ac72e5a0164fb61d64e0ef4">get_base1</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, size_t i1, size_t i2, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a38935ef11ac72e5a0164fb61d64e0ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <br /></td></tr>
<tr class="separator:a38935ef11ac72e5a0164fb61d64e0ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7153a76313bf2bb10db61e380310478"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af7153a76313bf2bb10db61e380310478"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af7153a76313bf2bb10db61e380310478.html#af7153a76313bf2bb10db61e380310478">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:af7153a76313bf2bb10db61e380310478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <br /></td></tr>
<tr class="separator:af7153a76313bf2bb10db61e380310478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ae620bf4469e793467f4d7a4b5e6118"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ae620bf4469e793467f4d7a4b5e6118"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ae620bf4469e793467f4d7a4b5e6118.html#a9ae620bf4469e793467f4d7a4b5e6118">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a9ae620bf4469e793467f4d7a4b5e6118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <br /></td></tr>
<tr class="separator:a9ae620bf4469e793467f4d7a4b5e6118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108fc04f851b50c8298bf42fec831a2e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a108fc04f851b50c8298bf42fec831a2e"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a108fc04f851b50c8298bf42fec831a2e.html#a108fc04f851b50c8298bf42fec831a2e">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a108fc04f851b50c8298bf42fec831a2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <br /></td></tr>
<tr class="separator:a108fc04f851b50c8298bf42fec831a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa377dcd69c8ccb837ed795b76529d916"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa377dcd69c8ccb837ed795b76529d916"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa377dcd69c8ccb837ed795b76529d916.html#aa377dcd69c8ccb837ed795b76529d916">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:aa377dcd69c8ccb837ed795b76529d916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <br /></td></tr>
<tr class="separator:aa377dcd69c8ccb837ed795b76529d916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883a08f3ff65f1f49e52493ab2b141cf"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a883a08f3ff65f1f49e52493ab2b141cf"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a883a08f3ff65f1f49e52493ab2b141cf.html#a883a08f3ff65f1f49e52493ab2b141cf">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a883a08f3ff65f1f49e52493ab2b141cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <br /></td></tr>
<tr class="separator:a883a08f3ff65f1f49e52493ab2b141cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf4bad379d873ecf7ed3d80ad98baba"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0bf4bad379d873ecf7ed3d80ad98baba"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0bf4bad379d873ecf7ed3d80ad98baba.html#a0bf4bad379d873ecf7ed3d80ad98baba">get_base1</a> (const std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, size_t i8, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a0bf4bad379d873ecf7ed3d80ad98baba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <br /></td></tr>
<tr class="separator:a0bf4bad379d873ecf7ed3d80ad98baba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564a8882fe58afb85b584a695b1b9da2"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__eigen__vector__types_ga96346a2dd6e69cd00862a734ed66532d.html#ga96346a2dd6e69cd00862a734ed66532d">require_not_eigen_vector_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a564a8882fe58afb85b584a695b1b9da2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a564a8882fe58afb85b584a695b1b9da2.html#a564a8882fe58afb85b584a695b1b9da2">get_base1</a> (const EigMat &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a564a8882fe58afb85b584a695b1b9da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the row of the specified matrix at the specified base-one row index.  <br /></td></tr>
<tr class="separator:a564a8882fe58afb85b584a695b1b9da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8dcefe550efcdb38c9ad1f4d3851760"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad8dcefe550efcdb38c9ad1f4d3851760"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad8dcefe550efcdb38c9ad1f4d3851760.html#ad8dcefe550efcdb38c9ad1f4d3851760">get_base1</a> (const EigMat &amp;x, size_t m, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:ad8dcefe550efcdb38c9ad1f4d3851760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified matrix at the specified base-one row and column indexes.  <br /></td></tr>
<tr class="separator:ad8dcefe550efcdb38c9ad1f4d3851760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9824065c9d6e640a65d4d3003edba266"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9824065c9d6e640a65d4d3003edba266"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigVec &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9824065c9d6e640a65d4d3003edba266.html#a9824065c9d6e640a65d4d3003edba266">get_base1</a> (const EigVec &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a9824065c9d6e640a65d4d3003edba266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vector at the specified base-one index.  <br /></td></tr>
<tr class="separator:a9824065c9d6e640a65d4d3003edba266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1d77c9d9560ff83787841e423c8b9d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7f1d77c9d9560ff83787841e423c8b9d"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7f1d77c9d9560ff83787841e423c8b9d.html#a7f1d77c9d9560ff83787841e423c8b9d">get_base1_lhs</a> (std::vector&lt; T &gt; &amp;x, size_t i, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a7f1d77c9d9560ff83787841e423c8b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one index.  <br /></td></tr>
<tr class="separator:a7f1d77c9d9560ff83787841e423c8b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7891f73d0b4aed55ec05c873f22358"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b7891f73d0b4aed55ec05c873f22358"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1b7891f73d0b4aed55ec05c873f22358.html#a1b7891f73d0b4aed55ec05c873f22358">get_base1_lhs</a> (std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x, size_t i1, size_t i2, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a1b7891f73d0b4aed55ec05c873f22358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <br /></td></tr>
<tr class="separator:a1b7891f73d0b4aed55ec05c873f22358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579e7ce0a9365b51754a6ed79dc8429d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a579e7ce0a9365b51754a6ed79dc8429d"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a579e7ce0a9365b51754a6ed79dc8429d.html#a579e7ce0a9365b51754a6ed79dc8429d">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a579e7ce0a9365b51754a6ed79dc8429d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <br /></td></tr>
<tr class="separator:a579e7ce0a9365b51754a6ed79dc8429d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66767c5e5efc101282a0adc1a075bf53"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a66767c5e5efc101282a0adc1a075bf53"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a66767c5e5efc101282a0adc1a075bf53.html#a66767c5e5efc101282a0adc1a075bf53">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a66767c5e5efc101282a0adc1a075bf53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <br /></td></tr>
<tr class="separator:a66767c5e5efc101282a0adc1a075bf53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a51a937beb169941e46feaa70ce338"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af4a51a937beb169941e46feaa70ce338"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af4a51a937beb169941e46feaa70ce338.html#af4a51a937beb169941e46feaa70ce338">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:af4a51a937beb169941e46feaa70ce338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <br /></td></tr>
<tr class="separator:af4a51a937beb169941e46feaa70ce338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c10ce161ef10a344db9c205dd0b1016"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0c10ce161ef10a344db9c205dd0b1016"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0c10ce161ef10a344db9c205dd0b1016.html#a0c10ce161ef10a344db9c205dd0b1016">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a0c10ce161ef10a344db9c205dd0b1016"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <br /></td></tr>
<tr class="separator:a0c10ce161ef10a344db9c205dd0b1016"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae97cd717cbd8893a73b2860cecb918f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae97cd717cbd8893a73b2860cecb918f9"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae97cd717cbd8893a73b2860cecb918f9.html#ae97cd717cbd8893a73b2860cecb918f9">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:ae97cd717cbd8893a73b2860cecb918f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <br /></td></tr>
<tr class="separator:ae97cd717cbd8893a73b2860cecb918f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984e39457efc98173e5bfd587306de8b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a984e39457efc98173e5bfd587306de8b"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a984e39457efc98173e5bfd587306de8b.html#a984e39457efc98173e5bfd587306de8b">get_base1_lhs</a> (std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; std::vector&lt; T &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &amp;x, size_t i1, size_t i2, size_t i3, size_t i4, size_t i5, size_t i6, size_t i7, size_t i8, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a984e39457efc98173e5bfd587306de8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified vector at the specified base-one indexes.  <br /></td></tr>
<tr class="separator:a984e39457efc98173e5bfd587306de8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fafdc7e00d3476eda1da9980cff102a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7fafdc7e00d3476eda1da9980cff102a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Block&lt; Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7fafdc7e00d3476eda1da9980cff102a.html#a7fafdc7e00d3476eda1da9980cff102a">get_base1_lhs</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a7fafdc7e00d3476eda1da9980cff102a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the row of the specified vector at the specified base-one row index.  <br /></td></tr>
<tr class="separator:a7fafdc7e00d3476eda1da9980cff102a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcff44b7f19306d5dfe5f192a9c4206e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abcff44b7f19306d5dfe5f192a9c4206e"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abcff44b7f19306d5dfe5f192a9c4206e.html#abcff44b7f19306d5dfe5f192a9c4206e">get_base1_lhs</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;x, size_t m, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:abcff44b7f19306d5dfe5f192a9c4206e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified matrix at the specified base-one row and column indexes.  <br /></td></tr>
<tr class="separator:abcff44b7f19306d5dfe5f192a9c4206e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f69b413cc74e7f7b2308d564997485e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f69b413cc74e7f7b2308d564997485e"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8f69b413cc74e7f7b2308d564997485e.html#a8f69b413cc74e7f7b2308d564997485e">get_base1_lhs</a> (Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt; &amp;x, size_t m, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a8f69b413cc74e7f7b2308d564997485e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified column vector at the specified base-one index.  <br /></td></tr>
<tr class="separator:a8f69b413cc74e7f7b2308d564997485e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6855eefc3b3100c236c12f1a51cc5f70"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6855eefc3b3100c236c12f1a51cc5f70"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6855eefc3b3100c236c12f1a51cc5f70.html#a6855eefc3b3100c236c12f1a51cc5f70">get_base1_lhs</a> (Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &amp;x, size_t n, const char *error_msg, size_t idx)</td></tr>
<tr class="memdesc:a6855eefc3b3100c236c12f1a51cc5f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to the value of the specified row vector at the specified base-one index.  <br /></td></tr>
<tr class="separator:a6855eefc3b3100c236c12f1a51cc5f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02b841d1e9260d3ae5f78a0edbc7bf19"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02b841d1e9260d3ae5f78a0edbc7bf19"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a02b841d1e9260d3ae5f78a0edbc7bf19.html#a02b841d1e9260d3ae5f78a0edbc7bf19">get_imag</a> (const std::complex&lt; T &gt; &amp;z)</td></tr>
<tr class="memdesc:a02b841d1e9260d3ae5f78a0edbc7bf19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the imaginary component of the complex argument.  <br /></td></tr>
<tr class="separator:a02b841d1e9260d3ae5f78a0edbc7bf19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e8fe4691725d4a94c6b11b4176d518"><td class="memTemplParams" colspan="2">template&lt;typename Eig , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>, Eig &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a82e8fe4691725d4a94c6b11b4176d518"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a82e8fe4691725d4a94c6b11b4176d518.html#a82e8fe4691725d4a94c6b11b4176d518">get_imag</a> (const Eig &amp;z)</td></tr>
<tr class="memdesc:a82e8fe4691725d4a94c6b11b4176d518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the real component of the complex argument.  <br /></td></tr>
<tr class="separator:a82e8fe4691725d4a94c6b11b4176d518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ecc541e99127df3f97e6af6f1ac16b"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , <a class="el" href="group__std__vector__types_ga513b41fcdff562ebb8bc2cd5e3ea8faa.html#ga513b41fcdff562ebb8bc2cd5e3ea8faa">require_std_vector_st</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>, StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac1ecc541e99127df3f97e6af6f1ac16b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac1ecc541e99127df3f97e6af6f1ac16b.html#ac1ecc541e99127df3f97e6af6f1ac16b">get_imag</a> (const StdVec &amp;z)</td></tr>
<tr class="memdesc:ac1ecc541e99127df3f97e6af6f1ac16b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the real component of the complex argument.  <br /></td></tr>
<tr class="separator:ac1ecc541e99127df3f97e6af6f1ac16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a220b598e729ee4b93598d2cc2d098edd"><td class="memTemplParams" colspan="2">template&lt;typename T_lp , typename T_lp_accum &gt; </td></tr>
<tr class="memitem:a220b598e729ee4b93598d2cc2d098edd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_lp, T_lp_accum &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a220b598e729ee4b93598d2cc2d098edd.html#a220b598e729ee4b93598d2cc2d098edd">get_lp</a> (const T_lp &amp;lp, const <a class="el" href="classstan_1_1math_1_1accumulator.html">accumulator</a>&lt; T_lp_accum &gt; &amp;lp_accum)</td></tr>
<tr class="separator:a220b598e729ee4b93598d2cc2d098edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51418e2763101683588225852b978bb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa51418e2763101683588225852b978bb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa51418e2763101683588225852b978bb.html#aa51418e2763101683588225852b978bb">get_real</a> (const std::complex&lt; T &gt; &amp;z)</td></tr>
<tr class="memdesc:aa51418e2763101683588225852b978bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the real component of the complex argument.  <br /></td></tr>
<tr class="separator:aa51418e2763101683588225852b978bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9f467ed61fb93c1882093eaddd850c"><td class="memTemplParams" colspan="2">template&lt;typename Eig , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>, Eig &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afb9f467ed61fb93c1882093eaddd850c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afb9f467ed61fb93c1882093eaddd850c.html#afb9f467ed61fb93c1882093eaddd850c">get_real</a> (const Eig &amp;z)</td></tr>
<tr class="memdesc:afb9f467ed61fb93c1882093eaddd850c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the real component of the complex argument.  <br /></td></tr>
<tr class="separator:afb9f467ed61fb93c1882093eaddd850c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab18014ed76673cb0afd8715e91bda69d"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , <a class="el" href="group__std__vector__types_ga513b41fcdff562ebb8bc2cd5e3ea8faa.html#ga513b41fcdff562ebb8bc2cd5e3ea8faa">require_std_vector_st</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>, StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab18014ed76673cb0afd8715e91bda69d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab18014ed76673cb0afd8715e91bda69d.html#ab18014ed76673cb0afd8715e91bda69d">get_real</a> (const StdVec &amp;z)</td></tr>
<tr class="memdesc:ab18014ed76673cb0afd8715e91bda69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the real component of the complex argument.  <br /></td></tr>
<tr class="separator:ab18014ed76673cb0afd8715e91bda69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a91ce6e6ad7e479615d324f52d6dde"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma &gt; </td></tr>
<tr class="memitem:ac3a91ce6e6ad7e479615d324f52d6dde"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_sigma &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac3a91ce6e6ad7e479615d324f52d6dde.html#ac3a91ce6e6ad7e479615d324f52d6dde">gp_dot_prod_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x, Eigen::Dynamic, 1 &gt; &gt; &amp;x, const T_sigma &amp;sigma)</td></tr>
<tr class="memdesc:ac3a91ce6e6ad7e479615d324f52d6dde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a dot product covariance matrix.  <br /></td></tr>
<tr class="separator:ac3a91ce6e6ad7e479615d324f52d6dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80573cbe962c8978d8a85e90a3029ecc"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma &gt; </td></tr>
<tr class="memitem:a80573cbe962c8978d8a85e90a3029ecc"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_sigma &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a80573cbe962c8978d8a85e90a3029ecc.html#a80573cbe962c8978d8a85e90a3029ecc">gp_dot_prod_cov</a> (const std::vector&lt; T_x &gt; &amp;x, const T_sigma &amp;sigma)</td></tr>
<tr class="memdesc:a80573cbe962c8978d8a85e90a3029ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a dot product covariance matrix.  <br /></td></tr>
<tr class="separator:a80573cbe962c8978d8a85e90a3029ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad737cc2b8670e01c158188f45d465a"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_sigma &gt; </td></tr>
<tr class="memitem:a8ad737cc2b8670e01c158188f45d465a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_sigma &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8ad737cc2b8670e01c158188f45d465a.html#a8ad737cc2b8670e01c158188f45d465a">gp_dot_prod_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x1, Eigen::Dynamic, 1 &gt; &gt; &amp;x1, const std::vector&lt; Eigen::Matrix&lt; T_x2, Eigen::Dynamic, 1 &gt; &gt; &amp;x2, const T_sigma &amp;sigma)</td></tr>
<tr class="memdesc:a8ad737cc2b8670e01c158188f45d465a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a dot product covariance matrix of differing x's.  <br /></td></tr>
<tr class="separator:a8ad737cc2b8670e01c158188f45d465a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4707bd61c29f7fa65f1276c7cfac19fe"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_sigma &gt; </td></tr>
<tr class="memitem:a4707bd61c29f7fa65f1276c7cfac19fe"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_sigma &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4707bd61c29f7fa65f1276c7cfac19fe.html#a4707bd61c29f7fa65f1276c7cfac19fe">gp_dot_prod_cov</a> (const std::vector&lt; T_x1 &gt; &amp;x1, const std::vector&lt; T_x2 &gt; &amp;x2, const T_sigma &amp;sigma)</td></tr>
<tr class="memdesc:a4707bd61c29f7fa65f1276c7cfac19fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a dot product covariance matrix of differing x's.  <br /></td></tr>
<tr class="separator:a4707bd61c29f7fa65f1276c7cfac19fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9c3d25096c81e98aa3b26a2f522f3e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , typename T_l &gt; </td></tr>
<tr class="memitem:a9e9c3d25096c81e98aa3b26a2f522f3e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_sigma, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9e9c3d25096c81e98aa3b26a2f522f3e.html#a9e9c3d25096c81e98aa3b26a2f522f3e">gp_exp_quad_cov</a> (const std::vector&lt; T_x &gt; &amp;x, const T_sigma &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="memdesc:a9e9c3d25096c81e98aa3b26a2f522f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a squared exponential kernel.  <br /></td></tr>
<tr class="separator:a9e9c3d25096c81e98aa3b26a2f522f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06f85eda72bac978957252a4f88c0be"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , typename T_l &gt; </td></tr>
<tr class="memitem:aa06f85eda72bac978957252a4f88c0be"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_sigma, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa06f85eda72bac978957252a4f88c0be.html#aa06f85eda72bac978957252a4f88c0be">gp_exp_quad_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x, -1, 1 &gt; &gt; &amp;x, const T_sigma &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="memdesc:aa06f85eda72bac978957252a4f88c0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a squared exponential kernel.  <br /></td></tr>
<tr class="separator:aa06f85eda72bac978957252a4f88c0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ffce4f863a63eabb623880361cb24e6"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_sigma , typename T_l &gt; </td></tr>
<tr class="memitem:a6ffce4f863a63eabb623880361cb24e6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_sigma, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6ffce4f863a63eabb623880361cb24e6.html#a6ffce4f863a63eabb623880361cb24e6">gp_exp_quad_cov</a> (const std::vector&lt; T_x1 &gt; &amp;x1, const std::vector&lt; T_x2 &gt; &amp;x2, const T_sigma &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="memdesc:a6ffce4f863a63eabb623880361cb24e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a squared exponential kernel.  <br /></td></tr>
<tr class="separator:a6ffce4f863a63eabb623880361cb24e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4183f2de2273dd5f6a170c43bff4de92"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:a4183f2de2273dd5f6a170c43bff4de92"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4183f2de2273dd5f6a170c43bff4de92.html#a4183f2de2273dd5f6a170c43bff4de92">gp_exp_quad_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x1, -1, 1 &gt; &gt; &amp;x1, const std::vector&lt; Eigen::Matrix&lt; T_x2, -1, 1 &gt; &gt; &amp;x2, const T_s &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="memdesc:a4183f2de2273dd5f6a170c43bff4de92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a squared exponential kernel.  <br /></td></tr>
<tr class="separator:a4183f2de2273dd5f6a170c43bff4de92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80deaf7a2015f7a8d1ede43bfcc6b0d0"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:a80deaf7a2015f7a8d1ede43bfcc6b0d0"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a80deaf7a2015f7a8d1ede43bfcc6b0d0.html#a80deaf7a2015f7a8d1ede43bfcc6b0d0">gp_exponential_cov</a> (const std::vector&lt; T_x &gt; &amp;x, const T_s &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="memdesc:a80deaf7a2015f7a8d1ede43bfcc6b0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern exponential covariance Matrix.  <br /></td></tr>
<tr class="separator:a80deaf7a2015f7a8d1ede43bfcc6b0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3357a300bc41225c426d457940cd6ab4"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:a3357a300bc41225c426d457940cd6ab4"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3357a300bc41225c426d457940cd6ab4.html#a3357a300bc41225c426d457940cd6ab4">gp_exponential_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x, -1, 1 &gt; &gt; &amp;x, const T_s &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="memdesc:a3357a300bc41225c426d457940cd6ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern exponential covariance matrix.  <br /></td></tr>
<tr class="separator:a3357a300bc41225c426d457940cd6ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae15bf194f79e604768c243a1da53b3aa"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:ae15bf194f79e604768c243a1da53b3aa"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae15bf194f79e604768c243a1da53b3aa.html#ae15bf194f79e604768c243a1da53b3aa">gp_exponential_cov</a> (const std::vector&lt; T_x1 &gt; &amp;x1, const std::vector&lt; T_x2 &gt; &amp;x2, const T_s &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="memdesc:ae15bf194f79e604768c243a1da53b3aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern exponential cross covariance matrix.  <br /></td></tr>
<tr class="separator:ae15bf194f79e604768c243a1da53b3aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cf67617ae0571948a89fd29413b4e3"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:a37cf67617ae0571948a89fd29413b4e3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a37cf67617ae0571948a89fd29413b4e3.html#a37cf67617ae0571948a89fd29413b4e3">gp_exponential_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x1, -1, 1 &gt; &gt; &amp;x1, const std::vector&lt; Eigen::Matrix&lt; T_x2, -1, 1 &gt; &gt; &amp;x2, const T_s &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="memdesc:a37cf67617ae0571948a89fd29413b4e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern exponential cross covariance matrix.  <br /></td></tr>
<tr class="separator:a37cf67617ae0571948a89fd29413b4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35749924fd7a3e8db330ca32980e88f5"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:a35749924fd7a3e8db330ca32980e88f5"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a35749924fd7a3e8db330ca32980e88f5.html#a35749924fd7a3e8db330ca32980e88f5">gp_matern32_cov</a> (const std::vector&lt; T_x &gt; &amp;x, const T_s &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="memdesc:a35749924fd7a3e8db330ca32980e88f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern 3/2 covariance matrix.  <br /></td></tr>
<tr class="separator:a35749924fd7a3e8db330ca32980e88f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1eadf899e8cc78fee84e62c31fd68c"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:a5e1eadf899e8cc78fee84e62c31fd68c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5e1eadf899e8cc78fee84e62c31fd68c.html#a5e1eadf899e8cc78fee84e62c31fd68c">gp_matern32_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x, -1, 1 &gt; &gt; &amp;x, const T_s &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="memdesc:a5e1eadf899e8cc78fee84e62c31fd68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern 3/2 covariance matrix.  <br /></td></tr>
<tr class="separator:a5e1eadf899e8cc78fee84e62c31fd68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256725023a1144344f14f6ec162f3802"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:a256725023a1144344f14f6ec162f3802"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a256725023a1144344f14f6ec162f3802.html#a256725023a1144344f14f6ec162f3802">gp_matern32_cov</a> (const std::vector&lt; T_x1 &gt; &amp;x1, const std::vector&lt; T_x2 &gt; &amp;x2, const T_s &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="memdesc:a256725023a1144344f14f6ec162f3802"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern 3/2 cross covariance matrix.  <br /></td></tr>
<tr class="separator:a256725023a1144344f14f6ec162f3802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68b67a7a32256f67e5bcfac91525997"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:aa68b67a7a32256f67e5bcfac91525997"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa68b67a7a32256f67e5bcfac91525997.html#aa68b67a7a32256f67e5bcfac91525997">gp_matern32_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x1, -1, 1 &gt; &gt; &amp;x1, const std::vector&lt; Eigen::Matrix&lt; T_x2, -1, 1 &gt; &gt; &amp;x2, const T_s &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="memdesc:aa68b67a7a32256f67e5bcfac91525997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern 3/2 cross covariance matrix.  <br /></td></tr>
<tr class="separator:aa68b67a7a32256f67e5bcfac91525997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735e9d7b18dba7b4482c747d50630d0d"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:a735e9d7b18dba7b4482c747d50630d0d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a735e9d7b18dba7b4482c747d50630d0d.html#a735e9d7b18dba7b4482c747d50630d0d">gp_matern52_cov</a> (const std::vector&lt; T_x &gt; &amp;x, const T_s &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="memdesc:a735e9d7b18dba7b4482c747d50630d0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern 5/2 covariance matrix with one input vector.  <br /></td></tr>
<tr class="separator:a735e9d7b18dba7b4482c747d50630d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7609250ac7527252b4b3709bfaa75d77"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:a7609250ac7527252b4b3709bfaa75d77"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7609250ac7527252b4b3709bfaa75d77.html#a7609250ac7527252b4b3709bfaa75d77">gp_matern52_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x, Eigen::Dynamic, 1 &gt; &gt; &amp;x, const T_s &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="memdesc:a7609250ac7527252b4b3709bfaa75d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern 5/2 covariance matrix with one input vector with automatic relevance determination (ARD).  <br /></td></tr>
<tr class="separator:a7609250ac7527252b4b3709bfaa75d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a97464914df29b4549726094bbd2cb2"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:a5a97464914df29b4549726094bbd2cb2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5a97464914df29b4549726094bbd2cb2.html#a5a97464914df29b4549726094bbd2cb2">gp_matern52_cov</a> (const std::vector&lt; T_x1 &gt; &amp;x1, const std::vector&lt; T_x2 &gt; &amp;x2, const T_s &amp;sigma, const T_l &amp;length_scale)</td></tr>
<tr class="memdesc:a5a97464914df29b4549726094bbd2cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern 5/2 covariance matrix with two different input vectors.  <br /></td></tr>
<tr class="separator:a5a97464914df29b4549726094bbd2cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f7c55e55e3198760259958e7f60b2d"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_s , typename T_l &gt; </td></tr>
<tr class="memitem:ae5f7c55e55e3198760259958e7f60b2d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_s, T_l &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae5f7c55e55e3198760259958e7f60b2d.html#ae5f7c55e55e3198760259958e7f60b2d">gp_matern52_cov</a> (const std::vector&lt; Eigen::Matrix&lt; T_x1, Eigen::Dynamic, 1 &gt; &gt; &amp;x1, const std::vector&lt; Eigen::Matrix&lt; T_x2, Eigen::Dynamic, 1 &gt; &gt; &amp;x2, const T_s &amp;sigma, const std::vector&lt; T_l &gt; &amp;length_scale)</td></tr>
<tr class="memdesc:ae5f7c55e55e3198760259958e7f60b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a Matern 5/2 covariance matrix with two input vectors with automatic relevance determination (ARD).  <br /></td></tr>
<tr class="separator:ae5f7c55e55e3198760259958e7f60b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbfc57f9d6adac725c1e05ee7ea09fe"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , typename T_l , typename T_p &gt; </td></tr>
<tr class="memitem:aafbfc57f9d6adac725c1e05ee7ea09fe"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_sigma, T_l, T_p &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aafbfc57f9d6adac725c1e05ee7ea09fe.html#aafbfc57f9d6adac725c1e05ee7ea09fe">gp_periodic_cov</a> (const std::vector&lt; T_x &gt; &amp;x, const T_sigma &amp;sigma, const T_l &amp;l, const T_p &amp;p)</td></tr>
<tr class="memdesc:aafbfc57f9d6adac725c1e05ee7ea09fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a periodic covariance matrix \( \mathbf{K} \) using the input \(
\mathbf{X} \).  <br /></td></tr>
<tr class="separator:aafbfc57f9d6adac725c1e05ee7ea09fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ff1013b089f5bb095e677772810c45"><td class="memTemplParams" colspan="2">template&lt;typename T_x1 , typename T_x2 , typename T_sigma , typename T_l , typename T_p &gt; </td></tr>
<tr class="memitem:a42ff1013b089f5bb095e677772810c45"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x1, T_x2, T_sigma, T_l, T_p &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a42ff1013b089f5bb095e677772810c45.html#a42ff1013b089f5bb095e677772810c45">gp_periodic_cov</a> (const std::vector&lt; T_x1 &gt; &amp;x1, const std::vector&lt; T_x2 &gt; &amp;x2, const T_sigma &amp;sigma, const T_l &amp;l, const T_p &amp;p)</td></tr>
<tr class="memdesc:a42ff1013b089f5bb095e677772810c45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a periodic covariance matrix \( \mathbf{K} \) using inputs \( \mathbf{X}_1 \) and \( \mathbf{X}_2 \).  <br /></td></tr>
<tr class="separator:a42ff1013b089f5bb095e677772810c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1c4494fbd30a9556c2ae46ba525f4c"><td class="memTemplParams" colspan="2">template&lt;bool ReturnSameT, typename T1 , typename T2 , typename T3 , typename T_z , <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; std::integral_constant&lt; bool, ReturnSameT &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afb1c4494fbd30a9556c2ae46ba525f4c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afb1c4494fbd30a9556c2ae46ba525f4c.html#afb1c4494fbd30a9556c2ae46ba525f4c">grad_2F1</a> (const T1 &amp;a1, const T2 &amp;a2, const T3 &amp;b1, const T_z &amp;z, double precision=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-14, int max_steps=1e6)</td></tr>
<tr class="memdesc:afb1c4494fbd30a9556c2ae46ba525f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the gradients of the hypergeometric function (2F1) as the power series stopping when the series converges to within <code>precision</code> or throwing when the function takes <code>max_steps</code> steps.  <br /></td></tr>
<tr class="separator:afb1c4494fbd30a9556c2ae46ba525f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04b4d834ce9de8f3e841f8c2c31e2e1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , typename T_z &gt; </td></tr>
<tr class="memitem:aa04b4d834ce9de8f3e841f8c2c31e2e1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa04b4d834ce9de8f3e841f8c2c31e2e1.html#aa04b4d834ce9de8f3e841f8c2c31e2e1">grad_2F1</a> (const T1 &amp;a1, const T2 &amp;a2, const T3 &amp;b1, const T_z &amp;z, double precision=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-14, int max_steps=1e6)</td></tr>
<tr class="memdesc:aa04b4d834ce9de8f3e841f8c2c31e2e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the gradients of the hypergeometric function (2F1) as the power series stopping when the series converges to within <code>precision</code> or throwing when the function takes <code>max_steps</code> steps.  <br /></td></tr>
<tr class="separator:aa04b4d834ce9de8f3e841f8c2c31e2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a62583bd1015caf2d113e27fac82a45"><td class="memTemplParams" colspan="2">template&lt;bool grad_a1 = true, bool grad_a2 = true, bool grad_a3 = true, bool grad_b1 = true, bool grad_b2 = true, bool grad_z = true, typename T1 , typename T2 , typename T3 , typename T4 , typename T5 , typename T6 , typename T7 , typename T8  = double&gt; </td></tr>
<tr class="memitem:a4a62583bd1015caf2d113e27fac82a45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a62583bd1015caf2d113e27fac82a45.html#a4a62583bd1015caf2d113e27fac82a45">grad_F32</a> (T1 *g, const T2 &amp;a1, const T3 &amp;a2, const T4 &amp;a3, const T5 &amp;b1, const T6 &amp;b2, const T7 &amp;z, const T8 &amp;precision=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-6, int max_steps=1e5)</td></tr>
<tr class="memdesc:a4a62583bd1015caf2d113e27fac82a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradients of the hypergeometric function, 3F2.  <br /></td></tr>
<tr class="separator:a4a62583bd1015caf2d113e27fac82a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cb272bd839945c13d7b41058c35c51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a33cb272bd839945c13d7b41058c35c51.html#a33cb272bd839945c13d7b41058c35c51">grad_inc_beta</a> (double &amp;g1, double &amp;g2, double a, double b, double z)</td></tr>
<tr class="separator:a33cb272bd839945c13d7b41058c35c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2da02affbc7c876331988b15b43b406"><td class="memTemplParams" colspan="2">template&lt;bool calc_a = true, bool calc_b = true, bool calc_z = true, typename TpFq , typename Ta , typename Tb , typename Tz , typename T_Rtn  = return_type_t&lt;Ta, Tb, Tz&gt;, typename Ta_Rtn  = promote_scalar_t&lt;T_Rtn, plain_type_t&lt;Ta&gt;&gt;, typename Tb_Rtn  = promote_scalar_t&lt;T_Rtn, plain_type_t&lt;Tb&gt;&gt;&gt; </td></tr>
<tr class="memitem:ae2da02affbc7c876331988b15b43b406"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; Ta_Rtn, Tb_Rtn, T_Rtn &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae2da02affbc7c876331988b15b43b406.html#ae2da02affbc7c876331988b15b43b406">grad_pFq</a> (const TpFq &amp;pfq_val, const Ta &amp;a, const Tb &amp;b, const Tz &amp;z, double precision=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-14, int max_steps=1e6)</td></tr>
<tr class="memdesc:ae2da02affbc7c876331988b15b43b406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the gradient of generalized hypergeometric function wrt to the input arguments: \( _pF_q(a_1,...,a_p;b_1,...,b_q;z) \).  <br /></td></tr>
<tr class="separator:ae2da02affbc7c876331988b15b43b406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b73820cb81a7b6701149d78606ed6e8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b73820cb81a7b6701149d78606ed6e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5b73820cb81a7b6701149d78606ed6e8.html#a5b73820cb81a7b6701149d78606ed6e8">grad_reg_inc_beta</a> (T &amp;g1, T &amp;g2, const T &amp;a, const T &amp;b, const T &amp;z, const T &amp;digammaA, const T &amp;digammaB, const T &amp;digammaSum, const T &amp;betaAB)</td></tr>
<tr class="memdesc:a5b73820cb81a7b6701149d78606ed6e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gradients of the regularized incomplete beta function.  <br /></td></tr>
<tr class="separator:a5b73820cb81a7b6701149d78606ed6e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7076052d3d28135e69e58879c7117a4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aa7076052d3d28135e69e58879c7117a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa7076052d3d28135e69e58879c7117a4.html#aa7076052d3d28135e69e58879c7117a4">grad_reg_inc_gamma</a> (T1 a, T2 z, T1 g, T1 dig, double precision=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-6, int max_steps=1e5)</td></tr>
<tr class="memdesc:aa7076052d3d28135e69e58879c7117a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradient of the regularized incomplete gamma functions igamma(a, z)  <br /></td></tr>
<tr class="separator:aa7076052d3d28135e69e58879c7117a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6ed1d1dc571bed0cf3a123cccab1e0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aea6ed1d1dc571bed0cf3a123cccab1e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aea6ed1d1dc571bed0cf3a123cccab1e0.html#aea6ed1d1dc571bed0cf3a123cccab1e0">grad_reg_lower_inc_gamma</a> (const T1 &amp;a, const T2 &amp;z, double precision=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-10, int max_steps=1e5)</td></tr>
<tr class="memdesc:aea6ed1d1dc571bed0cf3a123cccab1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the gradient of the lower regularized incomplete gamma function.  <br /></td></tr>
<tr class="separator:aea6ed1d1dc571bed0cf3a123cccab1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628f51eb7526cedbf71f9dce433c8581"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__vector__types_ga49bbe2450e11ac6a02210ab0dcde62bb.html#ga49bbe2450e11ac6a02210ab0dcde62bb">require_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a628f51eb7526cedbf71f9dce433c8581"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a628f51eb7526cedbf71f9dce433c8581.html#a628f51eb7526cedbf71f9dce433c8581">head</a> (const T &amp;v, size_t n)</td></tr>
<tr class="memdesc:a628f51eb7526cedbf71f9dce433c8581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a vector or row vector (same as input) from the front of the specified vector or row vector.  <br /></td></tr>
<tr class="separator:a628f51eb7526cedbf71f9dce433c8581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c68e7cc2cc6c466721bb3e5a3268f5f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6c68e7cc2cc6c466721bb3e5a3268f5f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6c68e7cc2cc6c466721bb3e5a3268f5f.html#a6c68e7cc2cc6c466721bb3e5a3268f5f">head</a> (const std::vector&lt; T &gt; &amp;sv, size_t n)</td></tr>
<tr class="memdesc:a6c68e7cc2cc6c466721bb3e5a3268f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a standard vector from the front of the specified standard vector.  <br /></td></tr>
<tr class="separator:a6c68e7cc2cc6c466721bb3e5a3268f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc500315f6cc7dfe19598c59aad06c09"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tz , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; Ta, Tz &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afc500315f6cc7dfe19598c59aad06c09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Ta, Tz &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afc500315f6cc7dfe19598c59aad06c09.html#afc500315f6cc7dfe19598c59aad06c09">hypergeometric_1f0</a> (const Ta &amp;a, const Tz &amp;z)</td></tr>
<tr class="memdesc:afc500315f6cc7dfe19598c59aad06c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Hypergeometric 1F0 function applied to the input arguments: \( _1F_0(a;;z) = \sum_{k=1}^{\infty}\frac{\left(a\right)_kz^k}{k!}\).  <br /></td></tr>
<tr class="separator:afc500315f6cc7dfe19598c59aad06c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a311742b503ad5f6189ef0d005b3d1"><td class="memTemplParams" colspan="2">template&lt;typename Ta1 , typename Ta2 , typename Tb , typename Tz , typename ScalarT  = return_type_t&lt;Ta1, Ta1, Tb, Tz&gt;, typename OptT  = boost::optional&lt;ScalarT&gt;, <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; Ta1, Ta2, Tb, Tz &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a12a311742b503ad5f6189ef0d005b3d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Ta1, Ta1, Tb, Tz &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a12a311742b503ad5f6189ef0d005b3d1.html#a12a311742b503ad5f6189ef0d005b3d1">hypergeometric_2F1</a> (const Ta1 &amp;a1, const Ta2 &amp;a2, const Tb &amp;b, const Tz &amp;z)</td></tr>
<tr class="memdesc:a12a311742b503ad5f6189ef0d005b3d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gauss hypergeometric function applied to the input arguments: \(_2F_1(a_1,a_2;b;z)\).  <br /></td></tr>
<tr class="separator:a12a311742b503ad5f6189ef0d005b3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c65d6186b82bcac332df082216303e3"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , typename Tz , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; Ta, Tb &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Tz &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6c65d6186b82bcac332df082216303e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Ta, Tb, Tz &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6c65d6186b82bcac332df082216303e3.html#a6c65d6186b82bcac332df082216303e3">hypergeometric_2F2</a> (const Ta &amp;a, const Tb &amp;b, const Tz &amp;z)</td></tr>
<tr class="memdesc:a6c65d6186b82bcac332df082216303e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the generalized hypergeometric function applied to the input arguments: \(_2F_2(a_1,a_2;b_1,b_2;z)\).  <br /></td></tr>
<tr class="separator:a6c65d6186b82bcac332df082216303e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d08d078ae29b8e2199ae2375509d64"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , typename Tz , <a class="el" href="group__vector__types_ga1b4c392b9d20db66ae254ef9833f9717.html#ga1b4c392b9d20db66ae254ef9833f9717">require_all_vector_t</a>&lt; Ta, Tb &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Tz &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a07d08d078ae29b8e2199ae2375509d64"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a07d08d078ae29b8e2199ae2375509d64.html#a07d08d078ae29b8e2199ae2375509d64">hypergeometric_3F2</a> (const Ta &amp;a, const Tb &amp;b, const Tz &amp;z)</td></tr>
<tr class="memdesc:a07d08d078ae29b8e2199ae2375509d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hypergeometric function (3F2).  <br /></td></tr>
<tr class="separator:a07d08d078ae29b8e2199ae2375509d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd3624c278c1db4b1b04aa7824b8cd0"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , typename Tz , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; Ta, Tb, Tz &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1cd3624c278c1db4b1b04aa7824b8cd0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1cd3624c278c1db4b1b04aa7824b8cd0.html#a1cd3624c278c1db4b1b04aa7824b8cd0">hypergeometric_3F2</a> (const std::initializer_list&lt; Ta &gt; &amp;a, const std::initializer_list&lt; Tb &gt; &amp;b, const Tz &amp;z)</td></tr>
<tr class="memdesc:a1cd3624c278c1db4b1b04aa7824b8cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hypergeometric function (3F2).  <br /></td></tr>
<tr class="separator:a1cd3624c278c1db4b1b04aa7824b8cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cc5836dd471451427e528c588b09a9"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , typename Tz , <a class="el" href="group__eigen__types_gaacdb91c9b32a7c57333c45d2c97de495.html#gaacdb91c9b32a7c57333c45d2c97de495">require_all_eigen_st</a>&lt; std::is_arithmetic, Ta, Tb &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Tz &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a29cc5836dd471451427e528c588b09a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Ta, Tb, Tz &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a29cc5836dd471451427e528c588b09a9.html#a29cc5836dd471451427e528c588b09a9">hypergeometric_pFq</a> (const Ta &amp;a, const Tb &amp;b, const Tz &amp;z)</td></tr>
<tr class="memdesc:a29cc5836dd471451427e528c588b09a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the generalized hypergeometric function applied to the input arguments: \(_pF_q(a_1,...,a_p;b_1,...,b_q;z)\).  <br /></td></tr>
<tr class="separator:a29cc5836dd471451427e528c588b09a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cf8aebb689a21c7b30572d82c73889"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a79cf8aebb689a21c7b30572d82c73889"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a79cf8aebb689a21c7b30572d82c73889.html#a79cf8aebb689a21c7b30572d82c73889">hypot</a> (T1 x, T2 y)</td></tr>
<tr class="memdesc:a79cf8aebb689a21c7b30572d82c73889"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the length of the hypotenuse of a right triangle with opposite and adjacent side lengths given by the specified arguments (C++11).  <br /></td></tr>
<tr class="separator:a79cf8aebb689a21c7b30572d82c73889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe83cc912462e15f4d7f47ac13262852"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afe83cc912462e15f4d7f47ac13262852"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afe83cc912462e15f4d7f47ac13262852.html#afe83cc912462e15f4d7f47ac13262852">hypot</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:afe83cc912462e15f4d7f47ac13262852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the hypot function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:afe83cc912462e15f4d7f47ac13262852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b9b22392239aa929714b56f35cdf62"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a03b9b22392239aa929714b56f35cdf62"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a03b9b22392239aa929714b56f35cdf62.html#a03b9b22392239aa929714b56f35cdf62">i_times</a> (const std::complex&lt; T &gt; &amp;z)</td></tr>
<tr class="memdesc:a03b9b22392239aa929714b56f35cdf62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified complex number multiplied by <code>i</code>.  <br /></td></tr>
<tr class="separator:a03b9b22392239aa929714b56f35cdf62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d068693afced39f5720d341d1c411f4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0d068693afced39f5720d341d1c411f4"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0d068693afced39f5720d341d1c411f4.html#a0d068693afced39f5720d341d1c411f4">neg_i_times</a> (const std::complex&lt; T &gt; &amp;z)</td></tr>
<tr class="memdesc:a0d068693afced39f5720d341d1c411f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified complex number multiplied by <code>-i</code>.  <br /></td></tr>
<tr class="separator:a0d068693afced39f5720d341d1c411f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4d50fd1a852e9012b7a840a22f35d3"><td class="memTemplParams" colspan="2">template&lt;typename V &gt; </td></tr>
<tr class="memitem:a8d4d50fd1a852e9012b7a840a22f35d3"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8d4d50fd1a852e9012b7a840a22f35d3.html#a8d4d50fd1a852e9012b7a840a22f35d3">complex_negate</a> (const std::complex&lt; V &gt; &amp;z)</td></tr>
<tr class="memdesc:a8d4d50fd1a852e9012b7a840a22f35d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the complex negation of the specified complex argument.  <br /></td></tr>
<tr class="separator:a8d4d50fd1a852e9012b7a840a22f35d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f5f15c0aa9bdebcf8b5fe9aa3710db"><td class="memTemplParams" colspan="2">template&lt;typename T_true , typename T_false &gt; </td></tr>
<tr class="memitem:a43f5f15c0aa9bdebcf8b5fe9aa3710db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_true, T_false &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a43f5f15c0aa9bdebcf8b5fe9aa3710db.html#a43f5f15c0aa9bdebcf8b5fe9aa3710db">if_else</a> (const bool c, const T_true y_true, const T_false y_false)</td></tr>
<tr class="memdesc:a43f5f15c0aa9bdebcf8b5fe9aa3710db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the second argument if the first argument is true and otherwise return the second argument.  <br /></td></tr>
<tr class="separator:a43f5f15c0aa9bdebcf8b5fe9aa3710db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61eebd126447446d428c170d9ba952e6"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__autodiff__types_ga9c0ebeb539d0429f2cbceb0fdb24c2d6.html#ga9c0ebeb539d0429f2cbceb0fdb24c2d6">require_autodiff_t</a>&lt; T &gt; &gt; </td></tr>
<tr class="memitem:a61eebd126447446d428c170d9ba952e6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a61eebd126447446d428c170d9ba952e6.html#a61eebd126447446d428c170d9ba952e6">imag</a> (const std::complex&lt; T &gt; &amp;z)</td></tr>
<tr class="memdesc:a61eebd126447446d428c170d9ba952e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the imaginary component of the complex argument.  <br /></td></tr>
<tr class="separator:a61eebd126447446d428c170d9ba952e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fada3940c12a45aed49750fe845ae57"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5fada3940c12a45aed49750fe845ae57.html#a5fada3940c12a45aed49750fe845ae57">inc_beta</a> (double a, double b, double x)</td></tr>
<tr class="memdesc:a5fada3940c12a45aed49750fe845ae57"><td class="mdescLeft">&#160;</td><td class="mdescRight">The normalized incomplete beta function of a, b, with outcome x.  <br /></td></tr>
<tr class="separator:a5fada3940c12a45aed49750fe845ae57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448e440df648bc4f1a30381f73d0429f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2, T3 &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_gae0f57b6105cb69165aeee0f2de2e50db.html#gae0f57b6105cb69165aeee0f2de2e50db">require_all_not_var_matrix_t</a>&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a448e440df648bc4f1a30381f73d0429f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a448e440df648bc4f1a30381f73d0429f.html#a448e440df648bc4f1a30381f73d0429f">inc_beta</a> (const T1 &amp;a, const T2 &amp;b, const T3 &amp;c)</td></tr>
<tr class="memdesc:a448e440df648bc4f1a30381f73d0429f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the inc_beta function, when any arguments are containers.  <br /></td></tr>
<tr class="separator:a448e440df648bc4f1a30381f73d0429f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c265eb14e915edc9bd457e93aaaf166"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c265eb14e915edc9bd457e93aaaf166"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9c265eb14e915edc9bd457e93aaaf166.html#a9c265eb14e915edc9bd457e93aaaf166">inc_beta_dda</a> (T a, T b, T z, T digamma_a, T digamma_ab)</td></tr>
<tr class="memdesc:a9c265eb14e915edc9bd457e93aaaf166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the partial derivative of the regularized incomplete beta function, I_{z}(a, b) with respect to a.  <br /></td></tr>
<tr class="separator:a9c265eb14e915edc9bd457e93aaaf166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc99a6a1e74fd1daeab96f7eeb3b05a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afc99a6a1e74fd1daeab96f7eeb3b05a8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afc99a6a1e74fd1daeab96f7eeb3b05a8.html#afc99a6a1e74fd1daeab96f7eeb3b05a8">inc_beta_ddb</a> (T a, T b, T z, T digamma_b, T digamma_ab)</td></tr>
<tr class="memdesc:afc99a6a1e74fd1daeab96f7eeb3b05a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the partial derivative of the regularized incomplete beta function, I_{z}(a, b) with respect to b.  <br /></td></tr>
<tr class="separator:afc99a6a1e74fd1daeab96f7eeb3b05a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2412f96d2114b4c15efb1ddbddaef35b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2412f96d2114b4c15efb1ddbddaef35b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2412f96d2114b4c15efb1ddbddaef35b.html#a2412f96d2114b4c15efb1ddbddaef35b">inc_beta_ddz</a> (T a, T b, T z)</td></tr>
<tr class="memdesc:a2412f96d2114b4c15efb1ddbddaef35b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the partial derivative of the regularized incomplete beta function, I_{z}(a, b) with respect to z.  <br /></td></tr>
<tr class="separator:a2412f96d2114b4c15efb1ddbddaef35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5957e2cb19140e6c7bacf5c68320b7"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3e5957e2cb19140e6c7bacf5c68320b7"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3e5957e2cb19140e6c7bacf5c68320b7.html#a3e5957e2cb19140e6c7bacf5c68320b7">inc_beta_ddz</a> (double a, double b, double z)</td></tr>
<tr class="separator:a3e5957e2cb19140e6c7bacf5c68320b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34507a08b7a507e638b304b614ef1311"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T, V &gt; *  = nullptr, <a class="el" href="group__convertible__types_ga75ccdf76808b5de55da12ea4d5e09625.html#ga75ccdf76808b5de55da12ea4d5e09625">require_convertible_t</a>&lt; V, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a34507a08b7a507e638b304b614ef1311"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a34507a08b7a507e638b304b614ef1311.html#a34507a08b7a507e638b304b614ef1311">initialize</a> (T &amp;x, V v)</td></tr>
<tr class="separator:a34507a08b7a507e638b304b614ef1311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb47e7569cabd57a1c0c6816ca48293"><td class="memTemplParams" colspan="2">template&lt;typename T , int R, int C, typename V &gt; </td></tr>
<tr class="memitem:a1cb47e7569cabd57a1c0c6816ca48293"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1cb47e7569cabd57a1c0c6816ca48293.html#a1cb47e7569cabd57a1c0c6816ca48293">initialize</a> (Eigen::Matrix&lt; T, R, C &gt; &amp;x, const V &amp;v)</td></tr>
<tr class="separator:a1cb47e7569cabd57a1c0c6816ca48293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27706378f77dc22746ad74721d495d4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ad27706378f77dc22746ad74721d495d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad27706378f77dc22746ad74721d495d4.html#ad27706378f77dc22746ad74721d495d4">initialize</a> (std::vector&lt; T &gt; &amp;x, const V &amp;v)</td></tr>
<tr class="separator:ad27706378f77dc22746ad74721d495d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee985a4eda856634569eeb4dd299d3d"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename S , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8ee985a4eda856634569eeb4dd299d3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8ee985a4eda856634569eeb4dd299d3d.html#a8ee985a4eda856634569eeb4dd299d3d">initialize_fill</a> (EigMat &amp;x, const S &amp;y)</td></tr>
<tr class="memdesc:a8ee985a4eda856634569eeb4dd299d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <br /></td></tr>
<tr class="separator:a8ee985a4eda856634569eeb4dd299d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0079527e3b721f4740873ff283136911"><td class="memTemplParams" colspan="2">template&lt;typename T , typename S , <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_assignable&lt; std::decay_t&lt; T &gt; &amp;, std::decay_t&lt; S &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0079527e3b721f4740873ff283136911"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0079527e3b721f4740873ff283136911.html#a0079527e3b721f4740873ff283136911">initialize_fill</a> (T &amp;x, S &amp;&amp;y)</td></tr>
<tr class="memdesc:a0079527e3b721f4740873ff283136911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <br /></td></tr>
<tr class="separator:a0079527e3b721f4740873ff283136911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093b6b3a42514835ad8e4b5e741ac8c6"><td class="memTemplParams" colspan="2">template&lt;typename Vec , typename S , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a093b6b3a42514835ad8e4b5e741ac8c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a093b6b3a42514835ad8e4b5e741ac8c6.html#a093b6b3a42514835ad8e4b5e741ac8c6">initialize_fill</a> (Vec &amp;x, S &amp;&amp;y)</td></tr>
<tr class="memdesc:a093b6b3a42514835ad8e4b5e741ac8c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <br /></td></tr>
<tr class="separator:a093b6b3a42514835ad8e4b5e741ac8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f65194aba95541f409d496c7ec90187"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1f65194aba95541f409d496c7ec90187"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1f65194aba95541f409d496c7ec90187.html#a1f65194aba95541f409d496c7ec90187">int_step</a> (const T &amp;y)</td></tr>
<tr class="memdesc:a1f65194aba95541f409d496c7ec90187"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integer step, or Heaviside, function.  <br /></td></tr>
<tr class="separator:a1f65194aba95541f409d496c7ec90187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab575aafb07e346dd7cfc4f9eb934d666"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__container__types_ga1b135bb62a0729e31b4233e370170a53.html#ga1b135bb62a0729e31b4233e370170a53">require_not_container_st</a>&lt; std::is_arithmetic, T &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab575aafb07e346dd7cfc4f9eb934d666"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab575aafb07e346dd7cfc4f9eb934d666.html#ab575aafb07e346dd7cfc4f9eb934d666">inv</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ab575aafb07e346dd7cfc4f9eb934d666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise 1.0 / x of the specified argument, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:ab575aafb07e346dd7cfc4f9eb934d666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeaef46e5b7e686cd1f01e730ffe7d41"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga7bc6670ad3273187c8b6fff5c86288ae.html#ga7bc6670ad3273187c8b6fff5c86288ae">require_container_st</a>&lt; std::is_arithmetic, Container &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeeaef46e5b7e686cd1f01e730ffe7d41"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeeaef46e5b7e686cd1f01e730ffe7d41.html#aeeaef46e5b7e686cd1f01e730ffe7d41">inv</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:aeeaef46e5b7e686cd1f01e730ffe7d41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_aefd273d6fda1b0a302c1032c3cf91ef7.html#aefd273d6fda1b0a302c1032c3cf91ef7">inv()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <br /></td></tr>
<tr class="separator:aeeaef46e5b7e686cd1f01e730ffe7d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d81f9089152c2b0e5a78942e5f010dd"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8d81f9089152c2b0e5a78942e5f010dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8d81f9089152c2b0e5a78942e5f010dd.html#a8d81f9089152c2b0e5a78942e5f010dd">inv_cloglog</a> (const T x)</td></tr>
<tr class="memdesc:a8d81f9089152c2b0e5a78942e5f010dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse complementary log-log function.  <br /></td></tr>
<tr class="separator:a8d81f9089152c2b0e5a78942e5f010dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6a908f1844ef221c03b63285ea789a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__complex__types_ga9e1429c7448a296d62bf6b4b037d1a6f.html#ga9e1429c7448a296d62bf6b4b037d1a6f">require_complex_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3a6a908f1844ef221c03b63285ea789a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3a6a908f1844ef221c03b63285ea789a.html#a3a6a908f1844ef221c03b63285ea789a">inv_cloglog</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a3a6a908f1844ef221c03b63285ea789a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse complementary log-log function.  <br /></td></tr>
<tr class="separator:a3a6a908f1844ef221c03b63285ea789a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa1533d79beac91c9fc9b6d9d612547"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3fa1533d79beac91c9fc9b6d9d612547"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3fa1533d79beac91c9fc9b6d9d612547.html#a3fa1533d79beac91c9fc9b6d9d612547">inv_cloglog</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a3fa1533d79beac91c9fc9b6d9d612547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a5bb7dcaa37a8cadd5e4ad89ff323a7d5.html#a5bb7dcaa37a8cadd5e4ad89ff323a7d5">inv_cloglog()</a>.  <br /></td></tr>
<tr class="separator:a3fa1533d79beac91c9fc9b6d9d612547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e23342723ebe97f5bc565be353cbce8"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2e23342723ebe97f5bc565be353cbce8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2e23342723ebe97f5bc565be353cbce8.html#a2e23342723ebe97f5bc565be353cbce8">inv_erfc</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a2e23342723ebe97f5bc565be353cbce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse complementary error function for variables.  <br /></td></tr>
<tr class="separator:a2e23342723ebe97f5bc565be353cbce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9087337af2d434c33dd8ae01b04049c"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga40125f31ec8c3027b2e85215f20b5702.html#ga40125f31ec8c3027b2e85215f20b5702">require_not_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae9087337af2d434c33dd8ae01b04049c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae9087337af2d434c33dd8ae01b04049c.html#ae9087337af2d434c33dd8ae01b04049c">inv_erfc</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae9087337af2d434c33dd8ae01b04049c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_aab99816a26d0021e1bb5df954414f060.html#aab99816a26d0021e1bb5df954414f060">inv_erfc()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:ae9087337af2d434c33dd8ae01b04049c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cca4efbd4462c9f1c4815e1e92672a2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3cca4efbd4462c9f1c4815e1e92672a2.html#a3cca4efbd4462c9f1c4815e1e92672a2">inv_inc_beta</a> (double a, double b, double p)</td></tr>
<tr class="memdesc:a3cca4efbd4462c9f1c4815e1e92672a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of the normalized incomplete beta function of a, b, with probability p.  <br /></td></tr>
<tr class="separator:a3cca4efbd4462c9f1c4815e1e92672a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3340f6b99b9c87fcb1630a85b23610"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0b3340f6b99b9c87fcb1630a85b23610"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0b3340f6b99b9c87fcb1630a85b23610.html#a0b3340f6b99b9c87fcb1630a85b23610">inv_inc_beta</a> (const T1 &amp;a, const T2 &amp;b, const T3 &amp;c)</td></tr>
<tr class="memdesc:a0b3340f6b99b9c87fcb1630a85b23610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the inv_inc_beta function, when any arguments are containers.  <br /></td></tr>
<tr class="separator:a0b3340f6b99b9c87fcb1630a85b23610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d68af3b629d4048e4044c7db23a1dc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a91d68af3b629d4048e4044c7db23a1dc.html#a91d68af3b629d4048e4044c7db23a1dc">inv_logit</a> (double a)</td></tr>
<tr class="memdesc:a91d68af3b629d4048e4044c7db23a1dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse logit function applied to the argument.  <br /></td></tr>
<tr class="separator:a91d68af3b629d4048e4044c7db23a1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80bc90009bf507958baf4a4e349ec75"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae80bc90009bf507958baf4a4e349ec75"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae80bc90009bf507958baf4a4e349ec75.html#ae80bc90009bf507958baf4a4e349ec75">inv_logit</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae80bc90009bf507958baf4a4e349ec75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_ae0010641b9d5d7ab95187e4a05993344.html#ae0010641b9d5d7ab95187e4a05993344" title="Returns the inverse logit function applied to the argument.">inv_logit()</a>.  <br /></td></tr>
<tr class="separator:ae80bc90009bf507958baf4a4e349ec75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ce9274d4f9c0ebe500fbe3a0ac4560"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a24ce9274d4f9c0ebe500fbe3a0ac4560.html#a24ce9274d4f9c0ebe500fbe3a0ac4560">inv_Phi</a> (double p)</td></tr>
<tr class="memdesc:a24ce9274d4f9c0ebe500fbe3a0ac4560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the inverse standard normal cumulative distribution function at the specified argument.  <br /></td></tr>
<tr class="separator:a24ce9274d4f9c0ebe500fbe3a0ac4560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78758abb894bd7858957d5fe9ed8ccb7"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a78758abb894bd7858957d5fe9ed8ccb7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a78758abb894bd7858957d5fe9ed8ccb7.html#a78758abb894bd7858957d5fe9ed8ccb7">inv_Phi</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a78758abb894bd7858957d5fe9ed8ccb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a9f9475283849b02264ae7eb4472dabcb.html#a9f9475283849b02264ae7eb4472dabcb">inv_Phi()</a>.  <br /></td></tr>
<tr class="separator:a78758abb894bd7858957d5fe9ed8ccb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed3a926cede2306d0fc622bee0f0ff4"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeed3a926cede2306d0fc622bee0f0ff4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeed3a926cede2306d0fc622bee0f0ff4.html#aeed3a926cede2306d0fc622bee0f0ff4">inv_sqrt</a> (const T x)</td></tr>
<tr class="separator:aeed3a926cede2306d0fc622bee0f0ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ef45f6d5c70c3bb1f7fd82cf1dd579"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a45ef45f6d5c70c3bb1f7fd82cf1dd579"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a45ef45f6d5c70c3bb1f7fd82cf1dd579.html#a45ef45f6d5c70c3bb1f7fd82cf1dd579">inv_sqrt</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a45ef45f6d5c70c3bb1f7fd82cf1dd579"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise <code>1 / sqrt(x)}</code> of the specified argument, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:a45ef45f6d5c70c3bb1f7fd82cf1dd579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eca69ce438e1bb35fe0ac6478f2bbdf"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; Container &gt; *  = nullptr, <a class="el" href="group__container__types_ga846e5c75f0e49887b255adb8e56e1a7e.html#ga846e5c75f0e49887b255adb8e56e1a7e">require_container_bt</a>&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0eca69ce438e1bb35fe0ac6478f2bbdf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0eca69ce438e1bb35fe0ac6478f2bbdf.html#a0eca69ce438e1bb35fe0ac6478f2bbdf">inv_sqrt</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a0eca69ce438e1bb35fe0ac6478f2bbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_aedb364653df48e278a5463dcfab5345d.html#aedb364653df48e278a5463dcfab5345d">inv_sqrt()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <br /></td></tr>
<tr class="separator:a0eca69ce438e1bb35fe0ac6478f2bbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad899b08240100518db6dc0e761ef6f98"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga1b135bb62a0729e31b4233e370170a53.html#ga1b135bb62a0729e31b4233e370170a53">require_not_container_st</a>&lt; std::is_arithmetic, Container &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad899b08240100518db6dc0e761ef6f98"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad899b08240100518db6dc0e761ef6f98.html#ad899b08240100518db6dc0e761ef6f98">inv_square</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ad899b08240100518db6dc0e761ef6f98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>1 / square(x)</code>.  <br /></td></tr>
<tr class="separator:ad899b08240100518db6dc0e761ef6f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177d121abcc2600b862d0e0db04ac14d"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga7bc6670ad3273187c8b6fff5c86288ae.html#ga7bc6670ad3273187c8b6fff5c86288ae">require_container_st</a>&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a177d121abcc2600b862d0e0db04ac14d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a177d121abcc2600b862d0e0db04ac14d.html#a177d121abcc2600b862d0e0db04ac14d">inv_square</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a177d121abcc2600b862d0e0db04ac14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="namespacestan_1_1math_a2e06fba4a23adac049865e0715c4a191.html#a2e06fba4a23adac049865e0715c4a191">inv_square()</a> that accepts <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Matrix/Array objects or expressions.  <br /></td></tr>
<tr class="separator:a177d121abcc2600b862d0e0db04ac14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad080307f51eea3c092265fd6dd67549d"><td class="memTemplParams" colspan="2">template&lt;typename Vector , <a class="el" href="group__vector__types_ga49bbe2450e11ac6a02210ab0dcde62bb.html#ga49bbe2450e11ac6a02210ab0dcde62bb">require_vector_t</a>&lt; Vector &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad080307f51eea3c092265fd6dd67549d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad080307f51eea3c092265fd6dd67549d.html#ad080307f51eea3c092265fd6dd67549d">inverse_softmax</a> (const Vector &amp;simplex, Vector &amp;y)</td></tr>
<tr class="memdesc:ad080307f51eea3c092265fd6dd67549d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the inverse softmax of the simplex argument into the second argument.  <br /></td></tr>
<tr class="separator:ad080307f51eea3c092265fd6dd67549d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f121067ff82b67a23f51d647131347"><td class="memTemplParams" colspan="2">template&lt;typename EigMat &gt; </td></tr>
<tr class="memitem:ac6f121067ff82b67a23f51d647131347"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac6f121067ff82b67a23f51d647131347.html#ac6f121067ff82b67a23f51d647131347">inverse_spd</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:ac6f121067ff82b67a23f51d647131347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse of the specified symmetric, pos/neg-definite matrix.  <br /></td></tr>
<tr class="separator:ac6f121067ff82b67a23f51d647131347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e07e16a252f5b2327cf97bac22ac33"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae5e07e16a252f5b2327cf97bac22ac33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae5e07e16a252f5b2327cf97bac22ac33.html#ae5e07e16a252f5b2327cf97bac22ac33">is_any_nan</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae5e07e16a252f5b2327cf97bac22ac33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the input is NaN and false otherwise.  <br /></td></tr>
<tr class="separator:ae5e07e16a252f5b2327cf97bac22ac33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22717ad06cad8be927efbe7c74d52cd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:ab22717ad06cad8be927efbe7c74d52cd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab22717ad06cad8be927efbe7c74d52cd.html#ab22717ad06cad8be927efbe7c74d52cd">is_any_nan</a> (const T &amp;x, const Ts &amp;... xs)</td></tr>
<tr class="memdesc:ab22717ad06cad8be927efbe7c74d52cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if any input is NaN and false otherwise.  <br /></td></tr>
<tr class="separator:ab22717ad06cad8be927efbe7c74d52cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273d56418e376b9d9b49c50a4b4abc46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a273d56418e376b9d9b49c50a4b4abc46.html#a273d56418e376b9d9b49c50a4b4abc46">is_inf</a> (double x)</td></tr>
<tr class="memdesc:a273d56418e376b9d9b49c50a4b4abc46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the input is infinite and false otherwise.  <br /></td></tr>
<tr class="separator:a273d56418e376b9d9b49c50a4b4abc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1168db19a6fedad3d1389bc73be60f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaf1168db19a6fedad3d1389bc73be60f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaf1168db19a6fedad3d1389bc73be60f.html#aaf1168db19a6fedad3d1389bc73be60f">is_integer</a> (T x)</td></tr>
<tr class="memdesc:aaf1168db19a6fedad3d1389bc73be60f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the input is an integer and false otherwise.  <br /></td></tr>
<tr class="separator:aaf1168db19a6fedad3d1389bc73be60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4affa7de6f01f5cccd402781c0d9b83a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__integral__types_ga31729c13937697c747fee3e83c0b957e.html#ga31729c13937697c747fee3e83c0b957e">require_integral_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4affa7de6f01f5cccd402781c0d9b83a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4affa7de6f01f5cccd402781c0d9b83a.html#a4affa7de6f01f5cccd402781c0d9b83a">is_nan</a> (T x)</td></tr>
<tr class="memdesc:a4affa7de6f01f5cccd402781c0d9b83a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if the input is Not a Number (NaN)  <br /></td></tr>
<tr class="separator:a4affa7de6f01f5cccd402781c0d9b83a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17467f023eab6f274732132434fd44f9"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a17467f023eab6f274732132434fd44f9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a17467f023eab6f274732132434fd44f9.html#a17467f023eab6f274732132434fd44f9">is_nan</a> (const T &amp;x)</td></tr>
<tr class="separator:a17467f023eab6f274732132434fd44f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcec73152fe82aca7c9b44ab2b8536bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abcec73152fe82aca7c9b44ab2b8536bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abcec73152fe82aca7c9b44ab2b8536bd.html#abcec73152fe82aca7c9b44ab2b8536bd">is_nonpositive_integer</a> (T x)</td></tr>
<tr class="memdesc:abcec73152fe82aca7c9b44ab2b8536bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the input is a nonpositive integer and false otherwise.  <br /></td></tr>
<tr class="separator:abcec73152fe82aca7c9b44ab2b8536bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c14c26dc55a985e05695b3ff1eeef2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40c14c26dc55a985e05695b3ff1eeef2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a40c14c26dc55a985e05695b3ff1eeef2.html#a40c14c26dc55a985e05695b3ff1eeef2">is_uninitialized</a> (T x)</td></tr>
<tr class="memdesc:a40c14c26dc55a985e05695b3ff1eeef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the specified variable is uninitialized.  <br /></td></tr>
<tr class="separator:a40c14c26dc55a985e05695b3ff1eeef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511adcae58163983f2eb5623df58d5c7"><td class="memTemplParams" colspan="2">template&lt;typename ADType , <a class="el" href="group__autodiff__types_ga9c0ebeb539d0429f2cbceb0fdb24c2d6.html#ga9c0ebeb539d0429f2cbceb0fdb24c2d6">require_autodiff_t</a>&lt; ADType &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a511adcae58163983f2eb5623df58d5c7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a511adcae58163983f2eb5623df58d5c7.html#a511adcae58163983f2eb5623df58d5c7">isfinite</a> (ADType &amp;&amp;v)</td></tr>
<tr class="memdesc:a511adcae58163983f2eb5623df58d5c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if specified argument is finite (not infinite and not not-a-number).  <br /></td></tr>
<tr class="separator:a511adcae58163983f2eb5623df58d5c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c4a0fdb55af864f53543c66d48bcff"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_autodiff_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a02c4a0fdb55af864f53543c66d48bcff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a02c4a0fdb55af864f53543c66d48bcff.html#a02c4a0fdb55af864f53543c66d48bcff">isinf</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a02c4a0fdb55af864f53543c66d48bcff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if specified argument is infinite (positive or negative).  <br /></td></tr>
<tr class="separator:a02c4a0fdb55af864f53543c66d48bcff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cf6c38e2cb76c37b04ee27b1f90684"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_autodiff_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a06cf6c38e2cb76c37b04ee27b1f90684"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a06cf6c38e2cb76c37b04ee27b1f90684.html#a06cf6c38e2cb76c37b04ee27b1f90684">isnan</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a06cf6c38e2cb76c37b04ee27b1f90684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if specified argument is not-a-number.  <br /></td></tr>
<tr class="separator:a06cf6c38e2cb76c37b04ee27b1f90684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb19a220786c93c90d20f3858c25c33"><td class="memTemplParams" colspan="2">template&lt;typename ADType , <a class="el" href="group__autodiff__types_ga9c0ebeb539d0429f2cbceb0fdb24c2d6.html#ga9c0ebeb539d0429f2cbceb0fdb24c2d6">require_autodiff_t</a>&lt; ADType &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adeb19a220786c93c90d20f3858c25c33"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adeb19a220786c93c90d20f3858c25c33.html#adeb19a220786c93c90d20f3858c25c33">isnormal</a> (ADType &amp;&amp;v)</td></tr>
<tr class="memdesc:adeb19a220786c93c90d20f3858c25c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if specified argument is normal.  <br /></td></tr>
<tr class="separator:adeb19a220786c93c90d20f3858c25c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6afbd6caa2c39ace92a10a51705a0cb6"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6afbd6caa2c39ace92a10a51705a0cb6"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6afbd6caa2c39ace92a10a51705a0cb6.html#a6afbd6caa2c39ace92a10a51705a0cb6">lambert_w0</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a6afbd6caa2c39ace92a10a51705a0cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Lambert W function on W0 branch for a value x.  <br /></td></tr>
<tr class="separator:a6afbd6caa2c39ace92a10a51705a0cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0586b60205d9d94cd690529427aa81"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0a0586b60205d9d94cd690529427aa81"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0a0586b60205d9d94cd690529427aa81.html#a0a0586b60205d9d94cd690529427aa81">lambert_wm1</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a0a0586b60205d9d94cd690529427aa81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the Lambert W function on W-1 branch for a value x.  <br /></td></tr>
<tr class="separator:a0a0586b60205d9d94cd690529427aa81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa034cacb69d10ecaee16c446944c9d52"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__types_ga8e2ecf4866780c76833f71cd4d28e3cf.html#ga8e2ecf4866780c76833f71cd4d28e3cf">require_not_stan_scalar_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa034cacb69d10ecaee16c446944c9d52"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa034cacb69d10ecaee16c446944c9d52.html#aa034cacb69d10ecaee16c446944c9d52">lambert_w0</a> (const T &amp;x)</td></tr>
<tr class="memdesc:aa034cacb69d10ecaee16c446944c9d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a281df36ccb31fc7ed3c6dad5992da7a2.html#a281df36ccb31fc7ed3c6dad5992da7a2">lambert_w0()</a>.  <br /></td></tr>
<tr class="separator:aa034cacb69d10ecaee16c446944c9d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5eea61465214a2b77e80dceda997b1"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__types_ga8e2ecf4866780c76833f71cd4d28e3cf.html#ga8e2ecf4866780c76833f71cd4d28e3cf">require_not_stan_scalar_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0a5eea61465214a2b77e80dceda997b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0a5eea61465214a2b77e80dceda997b1.html#a0a5eea61465214a2b77e80dceda997b1">lambert_wm1</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a0a5eea61465214a2b77e80dceda997b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a584c7a349fe52ff297fe8e438db5fd8f.html#a584c7a349fe52ff297fe8e438db5fd8f">lambert_wm1()</a>.  <br /></td></tr>
<tr class="separator:a0a5eea61465214a2b77e80dceda997b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d7f025f8ceed87b6a7374f5bdce3ba"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a44d7f025f8ceed87b6a7374f5bdce3ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a44d7f025f8ceed87b6a7374f5bdce3ba.html#a44d7f025f8ceed87b6a7374f5bdce3ba">lbeta</a> (const T1 a, const T2 b)</td></tr>
<tr class="memdesc:a44d7f025f8ceed87b6a7374f5bdce3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of the beta function applied to the specified arguments.  <br /></td></tr>
<tr class="separator:a44d7f025f8ceed87b6a7374f5bdce3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4001e74e67c0cd8a5e38a61194975abc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4001e74e67c0cd8a5e38a61194975abc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4001e74e67c0cd8a5e38a61194975abc.html#a4001e74e67c0cd8a5e38a61194975abc">lbeta</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a4001e74e67c0cd8a5e38a61194975abc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the lbeta function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:a4001e74e67c0cd8a5e38a61194975abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0616f5f75ae889dba3dbaaf4474157fc"><td class="memTemplParams" colspan="2">template&lt;typename T1 , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T1 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0616f5f75ae889dba3dbaaf4474157fc"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0616f5f75ae889dba3dbaaf4474157fc.html#a0616f5f75ae889dba3dbaaf4474157fc">ldexp</a> (T1 a, int b)</td></tr>
<tr class="memdesc:a0616f5f75ae889dba3dbaaf4474157fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of a (the significand) and 2 to power b (the exponent).  <br /></td></tr>
<tr class="separator:a0616f5f75ae889dba3dbaaf4474157fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc5db5a46e795f5e02798b0eb259bda"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aacc5db5a46e795f5e02798b0eb259bda"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aacc5db5a46e795f5e02798b0eb259bda.html#aacc5db5a46e795f5e02798b0eb259bda">ldexp</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:aacc5db5a46e795f5e02798b0eb259bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the ldexp function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:aacc5db5a46e795f5e02798b0eb259bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c8ccca3e47d6bee7b24c4974f8e77a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a14c8ccca3e47d6bee7b24c4974f8e77a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a14c8ccca3e47d6bee7b24c4974f8e77a.html#a14c8ccca3e47d6bee7b24c4974f8e77a">make_ldlt_factor</a> (const T &amp;A)</td></tr>
<tr class="memdesc:a14c8ccca3e47d6bee7b24c4974f8e77a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> with matrix type <code>plain_type_t&lt;T&gt;</code>  <br /></td></tr>
<tr class="separator:a14c8ccca3e47d6bee7b24c4974f8e77a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836f46d7f63f5118a32cad11382c0551"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a836f46d7f63f5118a32cad11382c0551.html#a836f46d7f63f5118a32cad11382c0551">lgamma</a> (double x)</td></tr>
<tr class="memdesc:a836f46d7f63f5118a32cad11382c0551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the gamma function applied to the specified argument.  <br /></td></tr>
<tr class="separator:a836f46d7f63f5118a32cad11382c0551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022448967319f16d2ae705ef122b219c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a022448967319f16d2ae705ef122b219c.html#a022448967319f16d2ae705ef122b219c">lgamma</a> (int x)</td></tr>
<tr class="memdesc:a022448967319f16d2ae705ef122b219c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the gamma function applied to the specified argument.  <br /></td></tr>
<tr class="separator:a022448967319f16d2ae705ef122b219c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71147c5af9cdaca2866cd529ee26d624"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga55c0f71f335505ceeac88af143771e88.html#ga55c0f71f335505ceeac88af143771e88">require_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a71147c5af9cdaca2866cd529ee26d624"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a71147c5af9cdaca2866cd529ee26d624.html#a71147c5af9cdaca2866cd529ee26d624">lgamma</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a71147c5af9cdaca2866cd529ee26d624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_aa888b5d6ff71fe9ab37deaee025a33bf.html#aa888b5d6ff71fe9ab37deaee025a33bf" title="Return the natural logarithm of the gamma function applied to the specified argument.">lgamma()</a>.  <br /></td></tr>
<tr class="separator:a71147c5af9cdaca2866cd529ee26d624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db0ff3e88a0a869f79dfbcd15f5fb00"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7db0ff3e88a0a869f79dfbcd15f5fb00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7db0ff3e88a0a869f79dfbcd15f5fb00.html#a7db0ff3e88a0a869f79dfbcd15f5fb00">lgamma_stirling</a> (const T x)</td></tr>
<tr class="memdesc:a7db0ff3e88a0a869f79dfbcd15f5fb00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Stirling approximation to the lgamma function.  <br /></td></tr>
<tr class="separator:a7db0ff3e88a0a869f79dfbcd15f5fb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a995fe390c4c44c7ea8a1c308acc40"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac2a995fe390c4c44c7ea8a1c308acc40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac2a995fe390c4c44c7ea8a1c308acc40.html#ac2a995fe390c4c44c7ea8a1c308acc40">lgamma_stirling_diff</a> (const T x)</td></tr>
<tr class="memdesc:ac2a995fe390c4c44c7ea8a1c308acc40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the difference between log of the gamma function and its Stirling approximation.  <br /></td></tr>
<tr class="separator:ac2a995fe390c4c44c7ea8a1c308acc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f47fcd942a207e83f7091ba6ff72ba9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7f47fcd942a207e83f7091ba6ff72ba9.html#a7f47fcd942a207e83f7091ba6ff72ba9">linspaced_array</a> (int K, double low, double high)</td></tr>
<tr class="memdesc:a7f47fcd942a207e83f7091ba6ff72ba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array of linearly spaced elements.  <br /></td></tr>
<tr class="separator:a7f47fcd942a207e83f7091ba6ff72ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e32ab7d5d0d673059ae6576f20fff74"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6e32ab7d5d0d673059ae6576f20fff74.html#a6e32ab7d5d0d673059ae6576f20fff74">linspaced_int_array</a> (int K, int low, int high)</td></tr>
<tr class="memdesc:a6e32ab7d5d0d673059ae6576f20fff74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array of linearly spaced integers.  <br /></td></tr>
<tr class="separator:a6e32ab7d5d0d673059ae6576f20fff74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f8599be4fe5cccb131aa8cce455165"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae7f8599be4fe5cccb131aa8cce455165.html#ae7f8599be4fe5cccb131aa8cce455165">linspaced_row_vector</a> (int K, double low, double high)</td></tr>
<tr class="memdesc:ae7f8599be4fe5cccb131aa8cce455165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row vector of linearly spaced elements.  <br /></td></tr>
<tr class="separator:ae7f8599be4fe5cccb131aa8cce455165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6932b13c75f264fcdae7f78b32962a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3a6932b13c75f264fcdae7f78b32962a.html#a3a6932b13c75f264fcdae7f78b32962a">linspaced_vector</a> (int K, double low, double high)</td></tr>
<tr class="memdesc:a3a6932b13c75f264fcdae7f78b32962a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of linearly spaced elements.  <br /></td></tr>
<tr class="separator:a3a6932b13c75f264fcdae7f78b32962a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27eed21409604698e1bfa8a93e1f7da3"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a27eed21409604698e1bfa8a93e1f7da3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a27eed21409604698e1bfa8a93e1f7da3.html#a27eed21409604698e1bfa8a93e1f7da3">lmgamma</a> (int k, T x)</td></tr>
<tr class="memdesc:a27eed21409604698e1bfa8a93e1f7da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the multivariate gamma function with the specified dimensions and argument.  <br /></td></tr>
<tr class="separator:a27eed21409604698e1bfa8a93e1f7da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c9fcbdad55212c061659c4f082d761"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae5c9fcbdad55212c061659c4f082d761"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae5c9fcbdad55212c061659c4f082d761.html#ae5c9fcbdad55212c061659c4f082d761">lmgamma</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ae5c9fcbdad55212c061659c4f082d761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the natural log of the multivariate gamma function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:ae5c9fcbdad55212c061659c4f082d761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad203bac8e28cb7ea9f51abcc999eaf38"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad203bac8e28cb7ea9f51abcc999eaf38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad203bac8e28cb7ea9f51abcc999eaf38.html#ad203bac8e28cb7ea9f51abcc999eaf38">lmultiply</a> (const T1 a, const T2 b)</td></tr>
<tr class="memdesc:ad203bac8e28cb7ea9f51abcc999eaf38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument times the log of the second argument.  <br /></td></tr>
<tr class="separator:ad203bac8e28cb7ea9f51abcc999eaf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a5692c4e84d336fe8093c760d4720f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_gae0f57b6105cb69165aeee0f2de2e50db.html#gae0f57b6105cb69165aeee0f2de2e50db">require_all_not_var_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae7a5692c4e84d336fe8093c760d4720f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae7a5692c4e84d336fe8093c760d4720f.html#ae7a5692c4e84d336fe8093c760d4720f">lmultiply</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:ae7a5692c4e84d336fe8093c760d4720f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of applying <code>lmultiply</code> to the arguments elementwise, with broadcasting if one of the arguments is a scalar.  <br /></td></tr>
<tr class="separator:ae7a5692c4e84d336fe8093c760d4720f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017de64aabb40c6211a489bbb0300c2f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a017de64aabb40c6211a489bbb0300c2f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a017de64aabb40c6211a489bbb0300c2f.html#a017de64aabb40c6211a489bbb0300c2f">log</a> (const T x)</td></tr>
<tr class="memdesc:a017de64aabb40c6211a489bbb0300c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the arithmetic argument.  <br /></td></tr>
<tr class="separator:a017de64aabb40c6211a489bbb0300c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66c367272e2ff36820f1f9332a9df0f9"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a66c367272e2ff36820f1f9332a9df0f9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a66c367272e2ff36820f1f9332a9df0f9.html#a66c367272e2ff36820f1f9332a9df0f9">log</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a66c367272e2ff36820f1f9332a9df0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise natural log of the specified argument, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:a66c367272e2ff36820f1f9332a9df0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d6d466b900b2cf7ee407dd754103fd"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a25d6d466b900b2cf7ee407dd754103fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a25d6d466b900b2cf7ee407dd754103fd.html#a25d6d466b900b2cf7ee407dd754103fd">log10</a> (const T x)</td></tr>
<tr class="memdesc:a25d6d466b900b2cf7ee407dd754103fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base 10 logarithm of the arithmetic argument.  <br /></td></tr>
<tr class="separator:a25d6d466b900b2cf7ee407dd754103fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbad1abda71a738f051904147a9d686a"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abbad1abda71a738f051904147a9d686a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abbad1abda71a738f051904147a9d686a.html#abbad1abda71a738f051904147a9d686a">log10</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:abbad1abda71a738f051904147a9d686a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_aaadc90acda3e608b200fc3eb6188c486.html#aaadc90acda3e608b200fc3eb6188c486" title="Returns the natural logarithm of ten.">log10()</a>.  <br /></td></tr>
<tr class="separator:abbad1abda71a738f051904147a9d686a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6081423c9042ea5849a0b8f3c3540e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aff6081423c9042ea5849a0b8f3c3540e.html#aff6081423c9042ea5849a0b8f3c3540e">log1m</a> (double x)</td></tr>
<tr class="memdesc:aff6081423c9042ea5849a0b8f3c3540e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one minus the specified value.  <br /></td></tr>
<tr class="separator:aff6081423c9042ea5849a0b8f3c3540e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baa8880a0f695e5d100682376c399b0"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7baa8880a0f695e5d100682376c399b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7baa8880a0f695e5d100682376c399b0.html#a7baa8880a0f695e5d100682376c399b0">log1m</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a7baa8880a0f695e5d100682376c399b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_ae426e656b1c72332aeadeaed27c5ecf4.html#ae426e656b1c72332aeadeaed27c5ecf4">log1m()</a>.  <br /></td></tr>
<tr class="separator:a7baa8880a0f695e5d100682376c399b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8a7380246a034a750c5bafbfa2e2c5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3b8a7380246a034a750c5bafbfa2e2c5.html#a3b8a7380246a034a750c5bafbfa2e2c5">log1m_exp</a> (double a)</td></tr>
<tr class="memdesc:a3b8a7380246a034a750c5bafbfa2e2c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the natural logarithm of one minus the exponential of the specified value without overflow,.  <br /></td></tr>
<tr class="separator:a3b8a7380246a034a750c5bafbfa2e2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7a7cc7c2f96948cb6aca4edd537b76"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9c7a7cc7c2f96948cb6aca4edd537b76"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9c7a7cc7c2f96948cb6aca4edd537b76.html#a9c7a7cc7c2f96948cb6aca4edd537b76">log1m_exp</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a9c7a7cc7c2f96948cb6aca4edd537b76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a452e4f39f00638a425f76b27c150e8ec.html#a452e4f39f00638a425f76b27c150e8ec" title="Return the natural logarithm of one minus the exponentiation of the specified argument.">log1m_exp()</a>.  <br /></td></tr>
<tr class="separator:a9c7a7cc7c2f96948cb6aca4edd537b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbc99a62ef0f24b77c9c3c950a6003d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aabbc99a62ef0f24b77c9c3c950a6003d.html#aabbc99a62ef0f24b77c9c3c950a6003d">log1m_inv_logit</a> (double u)</td></tr>
<tr class="memdesc:aabbc99a62ef0f24b77c9c3c950a6003d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of 1 minus the inverse logit of the specified argument.  <br /></td></tr>
<tr class="separator:aabbc99a62ef0f24b77c9c3c950a6003d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ec6f02e29ec6560cdfba104e1993cf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a04ec6f02e29ec6560cdfba104e1993cf.html#a04ec6f02e29ec6560cdfba104e1993cf">log1m_inv_logit</a> (int u)</td></tr>
<tr class="memdesc:a04ec6f02e29ec6560cdfba104e1993cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one minus the inverse logit of the specified argument.  <br /></td></tr>
<tr class="separator:a04ec6f02e29ec6560cdfba104e1993cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb13eba2d2597d5f38f25d966292901c"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga55c0f71f335505ceeac88af143771e88.html#ga55c0f71f335505ceeac88af143771e88">require_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afb13eba2d2597d5f38f25d966292901c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1apply__scalar__unary.html">apply_scalar_unary</a>&lt; <a class="el" href="structstan_1_1math_1_1log1m__inv__logit__fun.html">log1m_inv_logit_fun</a>, T &gt;::return_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afb13eba2d2597d5f38f25d966292901c.html#afb13eba2d2597d5f38f25d966292901c">log1m_inv_logit</a> (const T &amp;x)</td></tr>
<tr class="memdesc:afb13eba2d2597d5f38f25d966292901c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_aebfd796b601a6cb2b9022ddedd7b6748.html#aebfd796b601a6cb2b9022ddedd7b6748" title="Return the natural logarithm of one minus the inverse logit of the specified argument.">log1m_inv_logit()</a></code> to specified argument container.  <br /></td></tr>
<tr class="separator:afb13eba2d2597d5f38f25d966292901c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c8b55bdbd94b5f6f60208336da665e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a80c8b55bdbd94b5f6f60208336da665e.html#a80c8b55bdbd94b5f6f60208336da665e">log1p</a> (double x)</td></tr>
<tr class="memdesc:a80c8b55bdbd94b5f6f60208336da665e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one plus the specified value.  <br /></td></tr>
<tr class="separator:a80c8b55bdbd94b5f6f60208336da665e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4211f75c8f20d524ec882ff02ddc626"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae4211f75c8f20d524ec882ff02ddc626.html#ae4211f75c8f20d524ec882ff02ddc626">log1p</a> (int x)</td></tr>
<tr class="memdesc:ae4211f75c8f20d524ec882ff02ddc626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one plus the specified argument.  <br /></td></tr>
<tr class="separator:ae4211f75c8f20d524ec882ff02ddc626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d55dc641b6a46255a609b827ff3871a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga55c0f71f335505ceeac88af143771e88.html#ga55c0f71f335505ceeac88af143771e88">require_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6d55dc641b6a46255a609b827ff3871a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6d55dc641b6a46255a609b827ff3871a.html#a6d55dc641b6a46255a609b827ff3871a">log1p</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a6d55dc641b6a46255a609b827ff3871a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a9cb72ed892210a6a63de6e4db6c3c056.html#a9cb72ed892210a6a63de6e4db6c3c056">log1p()</a></code> to specified argument container.  <br /></td></tr>
<tr class="separator:a6d55dc641b6a46255a609b827ff3871a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83fcffd9ef56632268d02e8d6144aee7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a83fcffd9ef56632268d02e8d6144aee7.html#a83fcffd9ef56632268d02e8d6144aee7">log1p_exp</a> (double a)</td></tr>
<tr class="memdesc:a83fcffd9ef56632268d02e8d6144aee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log of 1 plus the exponential of the specified value without overflow.  <br /></td></tr>
<tr class="separator:a83fcffd9ef56632268d02e8d6144aee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6183eda9ebe6e81e3d8e80b6f47c8f5d"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga55c0f71f335505ceeac88af143771e88.html#ga55c0f71f335505ceeac88af143771e88">require_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6183eda9ebe6e81e3d8e80b6f47c8f5d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6183eda9ebe6e81e3d8e80b6f47c8f5d.html#a6183eda9ebe6e81e3d8e80b6f47c8f5d">log1p_exp</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a6183eda9ebe6e81e3d8e80b6f47c8f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a7a46dfa4816b15da29603c2a13928996.html#a7a46dfa4816b15da29603c2a13928996">log1p_exp()</a>.  <br /></td></tr>
<tr class="separator:a6183eda9ebe6e81e3d8e80b6f47c8f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44eb38e5b317dadf97e8b359197902ea"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a44eb38e5b317dadf97e8b359197902ea.html#a44eb38e5b317dadf97e8b359197902ea">log2</a> ()</td></tr>
<tr class="memdesc:a44eb38e5b317dadf97e8b359197902ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return natural logarithm of two.  <br /></td></tr>
<tr class="separator:a44eb38e5b317dadf97e8b359197902ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7251d72d334fd8a8595c14d3231003cd"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga55c0f71f335505ceeac88af143771e88.html#ga55c0f71f335505ceeac88af143771e88">require_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7251d72d334fd8a8595c14d3231003cd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7251d72d334fd8a8595c14d3231003cd.html#a7251d72d334fd8a8595c14d3231003cd">log2</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a7251d72d334fd8a8595c14d3231003cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a44eb38e5b317dadf97e8b359197902ea.html#a44eb38e5b317dadf97e8b359197902ea" title="Return natural logarithm of two.">log2()</a></code> to specified argument container.  <br /></td></tr>
<tr class="separator:a7251d72d334fd8a8595c14d3231003cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aea673e4d0dc59e520c2c96005fb7aa"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga7bcca863ac22d5e256ec4d8146db7bf3.html#ga7bcca863ac22d5e256ec4d8146db7bf3">require_not_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0aea673e4d0dc59e520c2c96005fb7aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0aea673e4d0dc59e520c2c96005fb7aa.html#a0aea673e4d0dc59e520c2c96005fb7aa">log_determinant_ldlt</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a0aea673e4d0dc59e520c2c96005fb7aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns log(abs(det(A))) given a <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> of A.  <br /></td></tr>
<tr class="separator:a0aea673e4d0dc59e520c2c96005fb7aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c26413863ce5cdf374e70aeea044ed9"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__var__types_ga49bd546c64ba1da0a583715b7162c898.html#ga49bd546c64ba1da0a583715b7162c898">require_not_vt_var</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4c26413863ce5cdf374e70aeea044ed9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4c26413863ce5cdf374e70aeea044ed9.html#a4c26413863ce5cdf374e70aeea044ed9">log_determinant_spd</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a4c26413863ce5cdf374e70aeea044ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log absolute determinant of the specified square matrix.  <br /></td></tr>
<tr class="separator:a4c26413863ce5cdf374e70aeea044ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb13771854e0e5388cc220be7cd0b48"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0fb13771854e0e5388cc220be7cd0b48"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0fb13771854e0e5388cc220be7cd0b48.html#a0fb13771854e0e5388cc220be7cd0b48">log_diff_exp</a> (const T1 x, const T2 y)</td></tr>
<tr class="memdesc:a0fb13771854e0e5388cc220be7cd0b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of the difference of the natural exponentiation of x and the natural exponentiation of y.  <br /></td></tr>
<tr class="separator:a0fb13771854e0e5388cc220be7cd0b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdf787b2994e5987cfa1991c8d3a1fe"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adcdf787b2994e5987cfa1991c8d3a1fe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adcdf787b2994e5987cfa1991c8d3a1fe.html#adcdf787b2994e5987cfa1991c8d3a1fe">log_diff_exp</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:adcdf787b2994e5987cfa1991c8d3a1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the log_diff_exp function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:adcdf787b2994e5987cfa1991c8d3a1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fdd49b4fa64215c01525d0120bde8c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af9fdd49b4fa64215c01525d0120bde8c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af9fdd49b4fa64215c01525d0120bde8c.html#af9fdd49b4fa64215c01525d0120bde8c">log_falling_factorial</a> (const T1 x, const T2 n)</td></tr>
<tr class="memdesc:af9fdd49b4fa64215c01525d0120bde8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural log of the falling factorial of the specified arguments.  <br /></td></tr>
<tr class="separator:af9fdd49b4fa64215c01525d0120bde8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded9b4e858cdd4e6cf93d9ab450ec5d9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aded9b4e858cdd4e6cf93d9ab450ec5d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aded9b4e858cdd4e6cf93d9ab450ec5d9.html#aded9b4e858cdd4e6cf93d9ab450ec5d9">log_falling_factorial</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:aded9b4e858cdd4e6cf93d9ab450ec5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the log_falling_factorial function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:aded9b4e858cdd4e6cf93d9ab450ec5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a844ee30d107f63c17406629071fdf71d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a844ee30d107f63c17406629071fdf71d.html#a844ee30d107f63c17406629071fdf71d">log_inv_logit</a> (double u)</td></tr>
<tr class="memdesc:a844ee30d107f63c17406629071fdf71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the inverse logit of the specified argument.  <br /></td></tr>
<tr class="separator:a844ee30d107f63c17406629071fdf71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e26b21d942c19f21f440ed7b4be7fac"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8e26b21d942c19f21f440ed7b4be7fac.html#a8e26b21d942c19f21f440ed7b4be7fac">log_inv_logit</a> (int u)</td></tr>
<tr class="memdesc:a8e26b21d942c19f21f440ed7b4be7fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the inverse logit of the specified argument.  <br /></td></tr>
<tr class="separator:a8e26b21d942c19f21f440ed7b4be7fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112901c06de36b0d5da8c129eac2b279"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga55c0f71f335505ceeac88af143771e88.html#ga55c0f71f335505ceeac88af143771e88">require_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a112901c06de36b0d5da8c129eac2b279"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a112901c06de36b0d5da8c129eac2b279.html#a112901c06de36b0d5da8c129eac2b279">log_inv_logit</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a112901c06de36b0d5da8c129eac2b279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a609450c56db01ed4b4989dc7f9dd755c.html#a609450c56db01ed4b4989dc7f9dd755c">log_inv_logit()</a></code> to specified argument container.  <br /></td></tr>
<tr class="separator:a112901c06de36b0d5da8c129eac2b279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbca4111040b00a8b84e6127d8f8419"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5fbca4111040b00a8b84e6127d8f8419"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5fbca4111040b00a8b84e6127d8f8419.html#a5fbca4111040b00a8b84e6127d8f8419">log_inv_logit_diff</a> (const T1 &amp;x, const T2 &amp;y)</td></tr>
<tr class="memdesc:a5fbca4111040b00a8b84e6127d8f8419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the difference of the inverse logits of the specified arguments.  <br /></td></tr>
<tr class="separator:a5fbca4111040b00a8b84e6127d8f8419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5f2098c95854af0f2c9c8c36c54a5a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acc5f2098c95854af0f2c9c8c36c54a5a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acc5f2098c95854af0f2c9c8c36c54a5a.html#acc5f2098c95854af0f2c9c8c36c54a5a">log_inv_logit_diff</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:acc5f2098c95854af0f2c9c8c36c54a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the log_inv_logit_diff function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:acc5f2098c95854af0f2c9c8c36c54a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778f1e17b8fd2b6e566c68054a96ec20"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , typename T_lambda1 , typename T_lambda2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T_theta, T_lambda1, T_lambda2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a778f1e17b8fd2b6e566c68054a96ec20"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a778f1e17b8fd2b6e566c68054a96ec20.html#a778f1e17b8fd2b6e566c68054a96ec20">log_mix</a> (T_theta theta, T_lambda1 lambda1, T_lambda2 lambda2)</td></tr>
<tr class="memdesc:a778f1e17b8fd2b6e566c68054a96ec20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log mixture density with specified mixing proportion and log densities.  <br /></td></tr>
<tr class="separator:a778f1e17b8fd2b6e566c68054a96ec20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c4c7185a0e6969c6ff28783cc558358"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , typename T_lam , <a class="el" href="group__vector__types_gaf4b57bdd6be03bbb97e34236e194bdde.html#gaf4b57bdd6be03bbb97e34236e194bdde">require_any_vector_t</a>&lt; T_theta, T_lam &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3c4c7185a0e6969c6ff28783cc558358"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta, T_lam &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3c4c7185a0e6969c6ff28783cc558358.html#a3c4c7185a0e6969c6ff28783cc558358">log_mix</a> (const T_theta &amp;theta, const T_lam &amp;lambda)</td></tr>
<tr class="memdesc:a3c4c7185a0e6969c6ff28783cc558358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log mixture density with specified mixing proportions and log densities.  <br /></td></tr>
<tr class="separator:a3c4c7185a0e6969c6ff28783cc558358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcdba2ec75cbc57492e9857092798b3"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , typename T_lam , <a class="el" href="group__vector__types_ga49bbe2450e11ac6a02210ab0dcde62bb.html#ga49bbe2450e11ac6a02210ab0dcde62bb">require_vector_t</a>&lt; T_lam &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1dcdba2ec75cbc57492e9857092798b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta, std::vector&lt; T_lam &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1dcdba2ec75cbc57492e9857092798b3.html#a1dcdba2ec75cbc57492e9857092798b3">log_mix</a> (const T_theta &amp;theta, const std::vector&lt; T_lam &gt; &amp;lambda)</td></tr>
<tr class="memdesc:a1dcdba2ec75cbc57492e9857092798b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log mixture density given specified mixing proportions and array of log density vectors.  <br /></td></tr>
<tr class="separator:a1dcdba2ec75cbc57492e9857092798b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db8110c1e37112290798ad1c0a81fd9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5db8110c1e37112290798ad1c0a81fd9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5db8110c1e37112290798ad1c0a81fd9.html#a5db8110c1e37112290798ad1c0a81fd9">log_modified_bessel_first_kind</a> (const T1 v, const T2 z)</td></tr>
<tr class="separator:a5db8110c1e37112290798ad1c0a81fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340e3839a6d0cfb34ce12548115b2ff2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a340e3839a6d0cfb34ce12548115b2ff2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a340e3839a6d0cfb34ce12548115b2ff2.html#a340e3839a6d0cfb34ce12548115b2ff2">log_modified_bessel_first_kind</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a340e3839a6d0cfb34ce12548115b2ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the log_modified_bessel_first_kind function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:a340e3839a6d0cfb34ce12548115b2ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5a41d01e7647f1423bdac6a89e216e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6c5a41d01e7647f1423bdac6a89e216e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6c5a41d01e7647f1423bdac6a89e216e.html#a6c5a41d01e7647f1423bdac6a89e216e">log_rising_factorial</a> (const T1 &amp;x, const T2 &amp;n)</td></tr>
<tr class="memdesc:a6c5a41d01e7647f1423bdac6a89e216e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the rising factorial from the first specified argument to the second.  <br /></td></tr>
<tr class="separator:a6c5a41d01e7647f1423bdac6a89e216e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6920b039552582b319e26a0d9166c82"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af6920b039552582b319e26a0d9166c82"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af6920b039552582b319e26a0d9166c82.html#af6920b039552582b319e26a0d9166c82">log_rising_factorial</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:af6920b039552582b319e26a0d9166c82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the log_rising_factorial function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:af6920b039552582b319e26a0d9166c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d78a2d07ada896bb46eb7bfc03e3a3"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__arithmetic__types_ga948d431ec5773ff848a6bfa0d0b7aa79.html#ga948d431ec5773ff848a6bfa0d0b7aa79">require_st_arithmetic</a>&lt; Container &gt; *  = nullptr, <a class="el" href="group__container__types_gac5dfcc325ecaff91dd97f8a1a8f09431.html#gac5dfcc325ecaff91dd97f8a1a8f09431">require_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a42d78a2d07ada896bb46eb7bfc03e3a3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a42d78a2d07ada896bb46eb7bfc03e3a3.html#a42d78a2d07ada896bb46eb7bfc03e3a3">log_softmax</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a42d78a2d07ada896bb46eb7bfc03e3a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the softmax of the specified vector.  <br /></td></tr>
<tr class="separator:a42d78a2d07ada896bb46eb7bfc03e3a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03d594cef2c8767b82a2b63eb2f1458"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae03d594cef2c8767b82a2b63eb2f1458"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae03d594cef2c8767b82a2b63eb2f1458.html#ae03d594cef2c8767b82a2b63eb2f1458">log_sum_exp</a> (const T2 &amp;a, const T1 &amp;b)</td></tr>
<tr class="memdesc:ae03d594cef2c8767b82a2b63eb2f1458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log sum of exponentials without overflow.  <br /></td></tr>
<tr class="separator:ae03d594cef2c8767b82a2b63eb2f1458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f9625b3e7eb63877ac4016a05ef923"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a79f9625b3e7eb63877ac4016a05ef923"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a79f9625b3e7eb63877ac4016a05ef923.html#a79f9625b3e7eb63877ac4016a05ef923">log_sum_exp</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a79f9625b3e7eb63877ac4016a05ef923"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the log_sum_exp function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:a79f9625b3e7eb63877ac4016a05ef923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d444cc18b68938cffe3e91fc5618df"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a12d444cc18b68938cffe3e91fc5618df"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a12d444cc18b68938cffe3e91fc5618df.html#a12d444cc18b68938cffe3e91fc5618df">log_sum_exp_signed</a> (const T1 &amp;a, int a_sign, const T2 &amp;b, int b_sign)</td></tr>
<tr class="memdesc:a12d444cc18b68938cffe3e91fc5618df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log sum of exponentials without overflow, accounting for the signs of the inputs.  <br /></td></tr>
<tr class="separator:a12d444cc18b68938cffe3e91fc5618df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a868b0772a7c29d7f7ea8f28c2d205ff5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_autodiff_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a868b0772a7c29d7f7ea8f28c2d205ff5"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a868b0772a7c29d7f7ea8f28c2d205ff5.html#a868b0772a7c29d7f7ea8f28c2d205ff5">logb</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a868b0772a7c29d7f7ea8f28c2d205ff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the unbiased radix-independent exponent from the floating-point argument.  <br /></td></tr>
<tr class="separator:a868b0772a7c29d7f7ea8f28c2d205ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adc35bab2db89b3ceda66f11e1fa53ec8.html#adc35bab2db89b3ceda66f11e1fa53ec8">logical_and</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical and function which returns 1 if both arguments are unequal to zero and 0 otherwise.  <br /></td></tr>
<tr class="separator:adc35bab2db89b3ceda66f11e1fa53ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2213736b55fd6696fa0120fd3fe72e4"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab2213736b55fd6696fa0120fd3fe72e4"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab2213736b55fd6696fa0120fd3fe72e4.html#ab2213736b55fd6696fa0120fd3fe72e4">logical_eq</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:ab2213736b55fd6696fa0120fd3fe72e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is equal to the second.  <br /></td></tr>
<tr class="separator:ab2213736b55fd6696fa0120fd3fe72e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6997e6a36d3166194c640158f3cfe16"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ab6997e6a36d3166194c640158f3cfe16"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab6997e6a36d3166194c640158f3cfe16.html#ab6997e6a36d3166194c640158f3cfe16">logical_gt</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:ab6997e6a36d3166194c640158f3cfe16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is strictly greater than the second.  <br /></td></tr>
<tr class="separator:ab6997e6a36d3166194c640158f3cfe16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae411878fff3cdcc04a6acdb2ad04b57d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ae411878fff3cdcc04a6acdb2ad04b57d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae411878fff3cdcc04a6acdb2ad04b57d.html#ae411878fff3cdcc04a6acdb2ad04b57d">logical_gte</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:ae411878fff3cdcc04a6acdb2ad04b57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is greater than or equal to the second.  <br /></td></tr>
<tr class="separator:ae411878fff3cdcc04a6acdb2ad04b57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff4be4f156c548433292ea3df5bfb20"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a8ff4be4f156c548433292ea3df5bfb20"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8ff4be4f156c548433292ea3df5bfb20.html#a8ff4be4f156c548433292ea3df5bfb20">logical_lt</a> (T1 x1, T2 x2)</td></tr>
<tr class="memdesc:a8ff4be4f156c548433292ea3df5bfb20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is strictly less than the second.  <br /></td></tr>
<tr class="separator:a8ff4be4f156c548433292ea3df5bfb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37f90533a3e94f2dba3542597ff5b6d6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a37f90533a3e94f2dba3542597ff5b6d6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a37f90533a3e94f2dba3542597ff5b6d6.html#a37f90533a3e94f2dba3542597ff5b6d6">logical_lte</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:a37f90533a3e94f2dba3542597ff5b6d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is less than or equal to the second.  <br /></td></tr>
<tr class="separator:a37f90533a3e94f2dba3542597ff5b6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28610d664daa3fa5abd69646a2d97f5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a28610d664daa3fa5abd69646a2d97f5a"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a28610d664daa3fa5abd69646a2d97f5a.html#a28610d664daa3fa5abd69646a2d97f5a">logical_negation</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a28610d664daa3fa5abd69646a2d97f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical negation function which returns one if the input is equal to zero and zero otherwise.  <br /></td></tr>
<tr class="separator:a28610d664daa3fa5abd69646a2d97f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206eb210d8e7e2c718af25c40de8f9d1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a206eb210d8e7e2c718af25c40de8f9d1"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a206eb210d8e7e2c718af25c40de8f9d1.html#a206eb210d8e7e2c718af25c40de8f9d1">logical_neq</a> (const T1 x1, const T2 x2)</td></tr>
<tr class="memdesc:a206eb210d8e7e2c718af25c40de8f9d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the first argument is unequal to the second.  <br /></td></tr>
<tr class="separator:a206eb210d8e7e2c718af25c40de8f9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74007e2d5f55d5ae4a308f535869aee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac74007e2d5f55d5ae4a308f535869aee"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac74007e2d5f55d5ae4a308f535869aee.html#ac74007e2d5f55d5ae4a308f535869aee">logical_or</a> (T1 x1, T2 x2)</td></tr>
<tr class="memdesc:ac74007e2d5f55d5ae4a308f535869aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">The logical or function which returns 1 if either argument is unequal to zero and 0 otherwise.  <br /></td></tr>
<tr class="separator:ac74007e2d5f55d5ae4a308f535869aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0996479e486b6ea868fb81041c25147a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__floating__point__types_ga94fb93a2c53b62e4f71947afbf3de358.html#ga94fb93a2c53b62e4f71947afbf3de358">require_floating_point_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0996479e486b6ea868fb81041c25147a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0996479e486b6ea868fb81041c25147a.html#a0996479e486b6ea868fb81041c25147a">logit</a> (const T u)</td></tr>
<tr class="memdesc:a0996479e486b6ea868fb81041c25147a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log odds of the argument.  <br /></td></tr>
<tr class="separator:a0996479e486b6ea868fb81041c25147a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d651925b8f57e59c0aa08e2b7cfd0fe"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8d651925b8f57e59c0aa08e2b7cfd0fe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8d651925b8f57e59c0aa08e2b7cfd0fe.html#a8d651925b8f57e59c0aa08e2b7cfd0fe">logit</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a8d651925b8f57e59c0aa08e2b7cfd0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a229da97d194861a2715450b9877173c4.html#a229da97d194861a2715450b9877173c4">logit()</a></code> to specified argument container.  <br /></td></tr>
<tr class="separator:a8d651925b8f57e59c0aa08e2b7cfd0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16716c2835bc9d3559c9824249f2d7b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab16716c2835bc9d3559c9824249f2d7b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Array&lt; T, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab16716c2835bc9d3559c9824249f2d7b.html#ab16716c2835bc9d3559c9824249f2d7b">make_nu</a> (const T &amp;eta, size_t K)</td></tr>
<tr class="memdesc:ab16716c2835bc9d3559c9824249f2d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the degrees of freedom for the t distribution that corresponds to the shape parameter in the LKJ distribution.  <br /></td></tr>
<tr class="separator:ab16716c2835bc9d3559c9824249f2d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc00a36648a791d743d4adc14a36a5f5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_eigen_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:abc00a36648a791d743d4adc14a36a5f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abc00a36648a791d743d4adc14a36a5f5.html#abc00a36648a791d743d4adc14a36a5f5">matrix_exp</a> (const T &amp;A_in)</td></tr>
<tr class="memdesc:abc00a36648a791d743d4adc14a36a5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the matrix exponential of the input matrix.  <br /></td></tr>
<tr class="separator:abc00a36648a791d743d4adc14a36a5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5269a84800fcb881e3c0f9d9e73e5aa"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac5269a84800fcb881e3c0f9d9e73e5aa"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac5269a84800fcb881e3c0f9d9e73e5aa.html#ac5269a84800fcb881e3c0f9d9e73e5aa">matrix_exp_2x2</a> (const EigMat &amp;A)</td></tr>
<tr class="memdesc:ac5269a84800fcb881e3c0f9d9e73e5aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the matrix exponential of a 2x2 matrix.  <br /></td></tr>
<tr class="separator:ac5269a84800fcb881e3c0f9d9e73e5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b88cf40bfdaf233a9d6f7a62900b716"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr, <a class="el" href="group__same__types_ga043fb726038d356f89f88fa6e6cb912f.html#ga043fb726038d356f89f88fa6e6cb912f">require_all_st_same</a>&lt; double, EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b88cf40bfdaf233a9d6f7a62900b716"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, Eigen::Dynamic, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4b88cf40bfdaf233a9d6f7a62900b716.html#a4b88cf40bfdaf233a9d6f7a62900b716">matrix_exp_multiply</a> (const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:a4b88cf40bfdaf233a9d6f7a62900b716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return product of exp(A) and B, where A is a NxN double matrix, B is a NxCb double matrix, and t is a double.  <br /></td></tr>
<tr class="separator:a4b88cf40bfdaf233a9d6f7a62900b716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6c1dd07e6c2fcc0b692e192884d988"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ade6c1dd07e6c2fcc0b692e192884d988"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, EigMat::RowsAtCompileTime, EigMat::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade6c1dd07e6c2fcc0b692e192884d988.html#ade6c1dd07e6c2fcc0b692e192884d988">matrix_exp_pade</a> (const EigMat &amp;<a class="el" href="namespacestan_1_1math_a500fda68d64f44323202b69ffa804f5f.html#a500fda68d64f44323202b69ffa804f5f">arg</a>)</td></tr>
<tr class="memdesc:ade6c1dd07e6c2fcc0b692e192884d988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the matrix exponential, using a Pade approximation, coupled with scaling and squaring.  <br /></td></tr>
<tr class="separator:ade6c1dd07e6c2fcc0b692e192884d988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d4ad7c0a67c585efd12c335f4eeabca"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__var__types_ga49bd546c64ba1da0a583715b7162c898.html#ga49bd546c64ba1da0a583715b7162c898">require_not_vt_var</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6d4ad7c0a67c585efd12c335f4eeabca"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, EigMat::RowsAtCompileTime, EigMat::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6d4ad7c0a67c585efd12c335f4eeabca.html#a6d4ad7c0a67c585efd12c335f4eeabca">matrix_power</a> (const EigMat &amp;M, const int n)</td></tr>
<tr class="memdesc:a6d4ad7c0a67c585efd12c335f4eeabca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth power of the specific matrix.  <br /></td></tr>
<tr class="separator:a6d4ad7c0a67c585efd12c335f4eeabca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf24e5701be5a13b7ea7c10cb94ec32"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5cf24e5701be5a13b7ea7c10cb94ec32"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, EigMat::RowsAtCompileTime, EigMat::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5cf24e5701be5a13b7ea7c10cb94ec32.html#a5cf24e5701be5a13b7ea7c10cb94ec32">operator^</a> (const EigMat &amp;M, const int n)</td></tr>
<tr class="separator:a5cf24e5701be5a13b7ea7c10cb94ec32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b5e7fd8ad5d82b06906917a4393c67"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a79b5e7fd8ad5d82b06906917a4393c67"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a79b5e7fd8ad5d82b06906917a4393c67.html#a79b5e7fd8ad5d82b06906917a4393c67">max</a> (T1 x, T2 y)</td></tr>
<tr class="memdesc:a79b5e7fd8ad5d82b06906917a4393c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum value of the two specified scalar arguments.  <br /></td></tr>
<tr class="separator:a79b5e7fd8ad5d82b06906917a4393c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de362e24f30427c6f10f8eeca587ec0"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__container__types_gac5dfcc325ecaff91dd97f8a1a8f09431.html#gac5dfcc325ecaff91dd97f8a1a8f09431">require_container_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8de362e24f30427c6f10f8eeca587ec0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8de362e24f30427c6f10f8eeca587ec0.html#a8de362e24f30427c6f10f8eeca587ec0">max</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a8de362e24f30427c6f10f8eeca587ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum value in the specified matrix, vector, row vector or std vector.  <br /></td></tr>
<tr class="separator:a8de362e24f30427c6f10f8eeca587ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40a7e607f33a06249bbb8f623aec377"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename... Ts&gt; </td></tr>
<tr class="memitem:ae40a7e607f33a06249bbb8f623aec377"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae40a7e607f33a06249bbb8f623aec377.html#ae40a7e607f33a06249bbb8f623aec377">max_size</a> (const T1 &amp;x1, const Ts &amp;... xs)</td></tr>
<tr class="memdesc:ae40a7e607f33a06249bbb8f623aec377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size of the largest input.  <br /></td></tr>
<tr class="separator:ae40a7e607f33a06249bbb8f623aec377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733a1ea274353f926cbe8ebc63fb7ea8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename... Ts&gt; </td></tr>
<tr class="memitem:a733a1ea274353f926cbe8ebc63fb7ea8"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a733a1ea274353f926cbe8ebc63fb7ea8.html#a733a1ea274353f926cbe8ebc63fb7ea8">max_size_mvt</a> (const T1 &amp;x1, const Ts &amp;... xs)</td></tr>
<tr class="memdesc:a733a1ea274353f926cbe8ebc63fb7ea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the size of the largest multivariate input.  <br /></td></tr>
<tr class="separator:a733a1ea274353f926cbe8ebc63fb7ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79ece13741ba80f42fbb865429d33f8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__eigen__types_ga06fcddbaf041c31d2c20c8b006ebba79.html#ga06fcddbaf041c31d2c20c8b006ebba79">require_all_eigen_vt</a>&lt; std::is_arithmetic, T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab79ece13741ba80f42fbb865429d33f8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab79ece13741ba80f42fbb865429d33f8.html#ab79ece13741ba80f42fbb865429d33f8">mdivide_left</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="memdesc:ab79ece13741ba80f42fbb865429d33f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b.  <br /></td></tr>
<tr class="separator:ab79ece13741ba80f42fbb865429d33f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdde7178c5bcd223971bb7c0e018a9d8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; T, EigMat &gt; *  = nullptr, <a class="el" href="namespacestan_aab02e1df7877fb9e7ffb376469932e27.html#aab02e1df7877fb9e7ffb376469932e27">require_any_not_t</a>&lt; std::is_arithmetic&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &gt;, <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afdde7178c5bcd223971bb7c0e018a9d8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, EigMat &gt;, Eigen::Dynamic, EigMat::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afdde7178c5bcd223971bb7c0e018a9d8.html#afdde7178c5bcd223971bb7c0e018a9d8">mdivide_left_ldlt</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A, const EigMat &amp;b)</td></tr>
<tr class="memdesc:afdde7178c5bcd223971bb7c0e018a9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> of A.  <br /></td></tr>
<tr class="separator:afdde7178c5bcd223971bb7c0e018a9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a65d99c27fffde8815d46746261a36d"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr, <a class="el" href="group__var__types_ga3c77b10bca27291f016c8e19f90965b0.html#ga3c77b10bca27291f016c8e19f90965b0">require_all_not_vt_var</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4a65d99c27fffde8815d46746261a36d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, EigMat2 &gt;, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a65d99c27fffde8815d46746261a36d.html#a4a65d99c27fffde8815d46746261a36d">mdivide_left_spd</a> (const EigMat1 &amp;A, const EigMat2 &amp;b)</td></tr>
<tr class="memdesc:a4a65d99c27fffde8815d46746261a36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b where A is symmetric positive definite.  <br /></td></tr>
<tr class="separator:a4a65d99c27fffde8815d46746261a36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfd285d3510ff638c8f023f7b55e13a"><td class="memTemplParams" colspan="2">template&lt;Eigen::UpLoType TriView, typename T1 , typename T2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__eigen__types_gac30da5b4d9bf217de273208379b7b92e.html#gac30da5b4d9bf217de273208379b7b92e">require_all_not_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9dfd285d3510ff638c8f023f7b55e13a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9dfd285d3510ff638c8f023f7b55e13a.html#a9dfd285d3510ff638c8f023f7b55e13a">mdivide_left_tri</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="memdesc:a9dfd285d3510ff638c8f023f7b55e13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is triangular.  <br /></td></tr>
<tr class="separator:a9dfd285d3510ff638c8f023f7b55e13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513e8ee1bab128dc2ee3bedac950a14b"><td class="memTemplParams" colspan="2">template&lt;Eigen::UpLoType TriView, typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a513e8ee1bab128dc2ee3bedac950a14b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a513e8ee1bab128dc2ee3bedac950a14b.html#a513e8ee1bab128dc2ee3bedac950a14b">mdivide_left_tri</a> (const T &amp;A)</td></tr>
<tr class="memdesc:a513e8ee1bab128dc2ee3bedac950a14b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b when A is triangular and b=I.  <br /></td></tr>
<tr class="separator:a513e8ee1bab128dc2ee3bedac950a14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67ccd0324217e4031bb73ea4f2ac04af"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__eigen__types_gac30da5b4d9bf217de273208379b7b92e.html#gac30da5b4d9bf217de273208379b7b92e">require_all_not_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a67ccd0324217e4031bb73ea4f2ac04af"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt;, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a67ccd0324217e4031bb73ea4f2ac04af.html#a67ccd0324217e4031bb73ea4f2ac04af">mdivide_left_tri_low</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="memdesc:a67ccd0324217e4031bb73ea4f2ac04af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of left dividing the second argument by the first argument.  <br /></td></tr>
<tr class="separator:a67ccd0324217e4031bb73ea4f2ac04af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7de593290c3c4457ea451a37b162026"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga93918b2590606552cac973a4397ab38a.html#ga93918b2590606552cac973a4397ab38a">require_not_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__fvar.html">is_fvar</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad7de593290c3c4457ea451a37b162026"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad7de593290c3c4457ea451a37b162026.html#ad7de593290c3c4457ea451a37b162026">mdivide_left_tri_low</a> (const T &amp;A)</td></tr>
<tr class="separator:ad7de593290c3c4457ea451a37b162026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99869f8fe86e1db5fd579c6dbf96daec"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr, <a class="el" href="group__fvar__types_ga2af52367fd6b72c88688720fcc50d6c7.html#ga2af52367fd6b72c88688720fcc50d6c7">require_all_not_vt_fvar</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a99869f8fe86e1db5fd579c6dbf96daec"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, EigMat2 &gt;, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a99869f8fe86e1db5fd579c6dbf96daec.html#a99869f8fe86e1db5fd579c6dbf96daec">mdivide_right</a> (const EigMat1 &amp;b, const EigMat2 &amp;A)</td></tr>
<tr class="memdesc:a99869f8fe86e1db5fd579c6dbf96daec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system xA=b.  <br /></td></tr>
<tr class="separator:a99869f8fe86e1db5fd579c6dbf96daec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c6a1c2143143a9540e2ebe417509fd"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename T , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; EigMat, T &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga6edc00dc67d479efca08150a952d7588.html#ga6edc00dc67d479efca08150a952d7588">require_any_not_st_arithmetic</a>&lt; EigMat, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a15c6a1c2143143a9540e2ebe417509fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a15c6a1c2143143a9540e2ebe417509fd.html#a15c6a1c2143143a9540e2ebe417509fd">mdivide_right_ldlt</a> (const EigMat &amp;b, <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a15c6a1c2143143a9540e2ebe417509fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system xA=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> of A.  <br /></td></tr>
<tr class="separator:a15c6a1c2143143a9540e2ebe417509fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8af6b74846b26b0472c914b269485c71"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename T , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; EigMat, T &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga3ccb7bb7ca23838c90e98961789c1153.html#ga3ccb7bb7ca23838c90e98961789c1153">require_all_st_arithmetic</a>&lt; EigMat, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8af6b74846b26b0472c914b269485c71"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, EigMat::RowsAtCompileTime, T::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8af6b74846b26b0472c914b269485c71.html#a8af6b74846b26b0472c914b269485c71">mdivide_right_ldlt</a> (const EigMat &amp;b, <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:a8af6b74846b26b0472c914b269485c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system xA=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> of A.  <br /></td></tr>
<tr class="separator:a8af6b74846b26b0472c914b269485c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9d9a5bca13264c20222411deea87ea"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2b9d9a5bca13264c20222411deea87ea"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, EigMat2 &gt;, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2b9d9a5bca13264c20222411deea87ea.html#a2b9d9a5bca13264c20222411deea87ea">mdivide_right_spd</a> (const EigMat1 &amp;b, const EigMat2 &amp;A)</td></tr>
<tr class="memdesc:a2b9d9a5bca13264c20222411deea87ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system xA=b where A is symmetric positive definite.  <br /></td></tr>
<tr class="separator:a2b9d9a5bca13264c20222411deea87ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330401f3fc11a48d1e1e4fcb2153a859"><td class="memTemplParams" colspan="2">template&lt;Eigen::UpLoType TriView, typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a330401f3fc11a48d1e1e4fcb2153a859"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a330401f3fc11a48d1e1e4fcb2153a859.html#a330401f3fc11a48d1e1e4fcb2153a859">mdivide_right_tri</a> (const EigMat1 &amp;b, const EigMat2 &amp;A)</td></tr>
<tr class="memdesc:a330401f3fc11a48d1e1e4fcb2153a859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system xA=b when A is triangular.  <br /></td></tr>
<tr class="separator:a330401f3fc11a48d1e1e4fcb2153a859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507a4bcf4e2faaef07785f1870b8dcb7"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr, <a class="el" href="group__fvar__types_ga2af52367fd6b72c88688720fcc50d6c7.html#ga2af52367fd6b72c88688720fcc50d6c7">require_all_not_vt_fvar</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a507a4bcf4e2faaef07785f1870b8dcb7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, EigMat2 &gt;, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a507a4bcf4e2faaef07785f1870b8dcb7.html#a507a4bcf4e2faaef07785f1870b8dcb7">mdivide_right_tri_low</a> (const EigMat1 &amp;b, const EigMat2 &amp;A)</td></tr>
<tr class="memdesc:a507a4bcf4e2faaef07785f1870b8dcb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system x tri(A) = b when tri(A) is a lower triangular view of the matrix A.  <br /></td></tr>
<tr class="separator:a507a4bcf4e2faaef07785f1870b8dcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bcbd761b1e9fb54a78918a35c8048f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__container__types_gac5dfcc325ecaff91dd97f8a1a8f09431.html#gac5dfcc325ecaff91dd97f8a1a8f09431">require_container_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a93bcbd761b1e9fb54a78918a35c8048f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a93bcbd761b1e9fb54a78918a35c8048f.html#a93bcbd761b1e9fb54a78918a35c8048f">mean</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a93bcbd761b1e9fb54a78918a35c8048f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample mean (i.e., average) of the coefficients in the specified std vector, vector, row vector, or matrix.  <br /></td></tr>
<tr class="separator:a93bcbd761b1e9fb54a78918a35c8048f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a27b88030b63e82f2a8cbf1aaad2fd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a40a27b88030b63e82f2a8cbf1aaad2fd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a40a27b88030b63e82f2a8cbf1aaad2fd.html#a40a27b88030b63e82f2a8cbf1aaad2fd">min</a> (T1 x, T2 y)</td></tr>
<tr class="memdesc:a40a27b88030b63e82f2a8cbf1aaad2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum coefficient of the two specified scalar arguments.  <br /></td></tr>
<tr class="separator:a40a27b88030b63e82f2a8cbf1aaad2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bcfe1d38b93f5091fc925b254bfa8b"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__container__types_gac5dfcc325ecaff91dd97f8a1a8f09431.html#gac5dfcc325ecaff91dd97f8a1a8f09431">require_container_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a21bcfe1d38b93f5091fc925b254bfa8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a21bcfe1d38b93f5091fc925b254bfa8b.html#a21bcfe1d38b93f5091fc925b254bfa8b">min</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a21bcfe1d38b93f5091fc925b254bfa8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum coefficient in the specified matrix, vector, row vector or std vector.  <br /></td></tr>
<tr class="separator:a21bcfe1d38b93f5091fc925b254bfa8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5449888b8ed4b97189b0582fa04858"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5c5449888b8ed4b97189b0582fa04858"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5c5449888b8ed4b97189b0582fa04858.html#a5c5449888b8ed4b97189b0582fa04858">minus</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a5c5449888b8ed4b97189b0582fa04858"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the negation of the specified scalar or matrix.  <br /></td></tr>
<tr class="separator:a5c5449888b8ed4b97189b0582fa04858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c859ebf7340e846850c820dc776c9e1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5c859ebf7340e846850c820dc776c9e1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5c859ebf7340e846850c820dc776c9e1.html#a5c859ebf7340e846850c820dc776c9e1">minus</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a5c859ebf7340e846850c820dc776c9e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negation of the each element of a vector.  <br /></td></tr>
<tr class="separator:a5c859ebf7340e846850c820dc776c9e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79b03c1902b72500d0374e7e8e0d17c"><td class="memTemplParams" colspan="2">template&lt;typename T2 , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac79b03c1902b72500d0374e7e8e0d17c"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac79b03c1902b72500d0374e7e8e0d17c.html#ac79b03c1902b72500d0374e7e8e0d17c">modified_bessel_first_kind</a> (int v, const T2 z)</td></tr>
<tr class="separator:ac79b03c1902b72500d0374e7e8e0d17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ca66bb0d964fed5f674e337638a933"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a51ca66bb0d964fed5f674e337638a933.html#a51ca66bb0d964fed5f674e337638a933">modified_bessel_first_kind</a> (int v, int z)</td></tr>
<tr class="memdesc:a51ca66bb0d964fed5f674e337638a933"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function exists because when z is of type integer, cyl_bessel_i(v, z) returns an integer.  <br /></td></tr>
<tr class="separator:a51ca66bb0d964fed5f674e337638a933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409b61bce5fbe6663bf23fd4dcac0c68"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a409b61bce5fbe6663bf23fd4dcac0c68"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a409b61bce5fbe6663bf23fd4dcac0c68.html#a409b61bce5fbe6663bf23fd4dcac0c68">modified_bessel_first_kind</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a409b61bce5fbe6663bf23fd4dcac0c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the modified_bessel_first_kind function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:a409b61bce5fbe6663bf23fd4dcac0c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6648ce15a9deb7c469d4615e6b2019"><td class="memTemplParams" colspan="2">template&lt;typename T2 , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaf6648ce15a9deb7c469d4615e6b2019"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaf6648ce15a9deb7c469d4615e6b2019.html#aaf6648ce15a9deb7c469d4615e6b2019">modified_bessel_second_kind</a> (int v, const T2 z)</td></tr>
<tr class="separator:aaf6648ce15a9deb7c469d4615e6b2019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0f55ec26ce8dc242d4de21ea3a99b2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abb0f55ec26ce8dc242d4de21ea3a99b2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abb0f55ec26ce8dc242d4de21ea3a99b2.html#abb0f55ec26ce8dc242d4de21ea3a99b2">modified_bessel_second_kind</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:abb0f55ec26ce8dc242d4de21ea3a99b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the modified_bessel_second_kind function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:abb0f55ec26ce8dc242d4de21ea3a99b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4949bffcdbae074c6017c13756a199e3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4949bffcdbae074c6017c13756a199e3.html#a4949bffcdbae074c6017c13756a199e3">modulus</a> (int x, int y)</td></tr>
<tr class="separator:a4949bffcdbae074c6017c13756a199e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac01c236597fa71e13877a182aa5c3c"><td class="memTemplParams" colspan="2">template&lt;typename Mat , typename Scal , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; Scal, Mat &gt; *  = nullptr, <a class="el" href="group__complex__types_ga7e3024186a248e51f8539efef0985a33.html#ga7e3024186a248e51f8539efef0985a33">require_all_not_complex_t</a>&lt; Scal, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; Mat &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9ac01c236597fa71e13877a182aa5c3c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ac01c236597fa71e13877a182aa5c3c.html#a9ac01c236597fa71e13877a182aa5c3c">multiply</a> (const Mat &amp;m, Scal c)</td></tr>
<tr class="memdesc:a9ac01c236597fa71e13877a182aa5c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified matrix multiplied by specified scalar.  <br /></td></tr>
<tr class="separator:a9ac01c236597fa71e13877a182aa5c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e07ed24522fba9a8a099c6d1bbd9851"><td class="memTemplParams" colspan="2">template&lt;typename Mat , typename Scal , <a class="el" href="group__complex__types_gaaaf50be6f85054e2e28517fc2deef6f3.html#gaaaf50be6f85054e2e28517fc2deef6f3">require_any_complex_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; Mat &gt;, Scal &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__eigen__types_gabf4f9e63ae91ddc6d41c9570149edab2.html#gabf4f9e63ae91ddc6d41c9570149edab2">require_not_eigen_t</a>&lt; Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9e07ed24522fba9a8a099c6d1bbd9851"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9e07ed24522fba9a8a099c6d1bbd9851.html#a9e07ed24522fba9a8a099c6d1bbd9851">multiply</a> (const Mat &amp;m, Scal c)</td></tr>
<tr class="memdesc:a9e07ed24522fba9a8a099c6d1bbd9851"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the specified matrix and scalar, one of which must have a complex value type.  <br /></td></tr>
<tr class="separator:a9e07ed24522fba9a8a099c6d1bbd9851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f48447fbea87a44755806b5de5aeb9"><td class="memTemplParams" colspan="2">template&lt;typename Mat , typename Scal , <a class="el" href="group__complex__types_gaaaf50be6f85054e2e28517fc2deef6f3.html#gaaaf50be6f85054e2e28517fc2deef6f3">require_any_complex_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; Mat &gt;, Scal &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__eigen__types_gabf4f9e63ae91ddc6d41c9570149edab2.html#gabf4f9e63ae91ddc6d41c9570149edab2">require_not_eigen_t</a>&lt; Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a24f48447fbea87a44755806b5de5aeb9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a24f48447fbea87a44755806b5de5aeb9.html#a24f48447fbea87a44755806b5de5aeb9">multiply</a> (const Scal &amp;m, const Mat &amp;c)</td></tr>
<tr class="memdesc:a24f48447fbea87a44755806b5de5aeb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the specified matrix and scalar, one of which must have a complex value type.  <br /></td></tr>
<tr class="separator:a24f48447fbea87a44755806b5de5aeb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162d159f007e5858090dd348400d35e6"><td class="memTemplParams" colspan="2">template&lt;typename Scal , typename Mat , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; Scal, Mat &gt; *  = nullptr, <a class="el" href="group__complex__types_ga7e3024186a248e51f8539efef0985a33.html#ga7e3024186a248e51f8539efef0985a33">require_all_not_complex_t</a>&lt; Scal, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; Mat &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a162d159f007e5858090dd348400d35e6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a162d159f007e5858090dd348400d35e6.html#a162d159f007e5858090dd348400d35e6">multiply</a> (Scal c, const Mat &amp;m)</td></tr>
<tr class="memdesc:a162d159f007e5858090dd348400d35e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified scalar multiplied by specified matrix.  <br /></td></tr>
<tr class="separator:a162d159f007e5858090dd348400d35e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0093659bc153fd5dcaecb29d33ff9f"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , <a class="el" href="group__eigen__types_ga06fcddbaf041c31d2c20c8b006ebba79.html#ga06fcddbaf041c31d2c20c8b006ebba79">require_all_eigen_vt</a>&lt; std::is_arithmetic, Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="namespacestan_a1f4146fe117dbf61403c3c021c07c728.html#a1f4146fe117dbf61403c3c021c07c728">require_not_eigen_row_and_col_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaf0093659bc153fd5dcaecb29d33ff9f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaf0093659bc153fd5dcaecb29d33ff9f.html#aaf0093659bc153fd5dcaecb29d33ff9f">multiply</a> (const Mat1 &amp;m1, const Mat2 &amp;m2)</td></tr>
<tr class="memdesc:aaf0093659bc153fd5dcaecb29d33ff9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of the specified matrices.  <br /></td></tr>
<tr class="separator:aaf0093659bc153fd5dcaecb29d33ff9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b4549f797ad9b35249fddc6e3586dd"><td class="memTemplParams" colspan="2">template&lt;typename RowVec , typename ColVec , <a class="el" href="group__var__types_ga202c72c7f8418f766eeb3e013a43e25c.html#ga202c72c7f8418f766eeb3e013a43e25c">require_not_var_t</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; RowVec, ColVec &gt; &gt; *  = nullptr, <a class="el" href="namespacestan_a308053ee9550b3fca823589e3ebf0258.html#a308053ee9550b3fca823589e3ebf0258">require_eigen_row_and_col_t</a>&lt; RowVec, ColVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab5b4549f797ad9b35249fddc6e3586dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab5b4549f797ad9b35249fddc6e3586dd.html#ab5b4549f797ad9b35249fddc6e3586dd">multiply</a> (const RowVec &amp;rv, const ColVec &amp;v)</td></tr>
<tr class="memdesc:ab5b4549f797ad9b35249fddc6e3586dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the scalar product of the specified row vector and specified column vector.  <br /></td></tr>
<tr class="separator:ab5b4549f797ad9b35249fddc6e3586dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a045077d617c64167362fb76f26385ca5"><td class="memTemplParams" colspan="2">template&lt;typename Scalar1 , typename Scalar2 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; Scalar1, Scalar2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a045077d617c64167362fb76f26385ca5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Scalar1, Scalar2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a045077d617c64167362fb76f26385ca5.html#a045077d617c64167362fb76f26385ca5">multiply</a> (Scalar1 m, Scalar2 c)</td></tr>
<tr class="memdesc:a045077d617c64167362fb76f26385ca5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return product of scalars.  <br /></td></tr>
<tr class="separator:a045077d617c64167362fb76f26385ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1747d1920fff593ccc2cec0b4b1df082"><td class="memTemplParams" colspan="2">template&lt;typename T_a , typename T_b , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T_a, T_b &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1747d1920fff593ccc2cec0b4b1df082"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_a, T_b &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1747d1920fff593ccc2cec0b4b1df082.html#a1747d1920fff593ccc2cec0b4b1df082">multiply_log</a> (const T_a a, const T_b b)</td></tr>
<tr class="memdesc:a1747d1920fff593ccc2cec0b4b1df082"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value of the first argument times log of the second argument while behaving properly with 0 inputs.  <br /></td></tr>
<tr class="separator:a1747d1920fff593ccc2cec0b4b1df082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42f126b20c232247a1c95d68aaf672e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_gae0f57b6105cb69165aeee0f2de2e50db.html#gae0f57b6105cb69165aeee0f2de2e50db">require_all_not_var_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa42f126b20c232247a1c95d68aaf672e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa42f126b20c232247a1c95d68aaf672e.html#aa42f126b20c232247a1c95d68aaf672e">multiply_log</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:aa42f126b20c232247a1c95d68aaf672e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the multiply_log function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:aa42f126b20c232247a1c95d68aaf672e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89008c6dab18001aef6ddef1ac298db"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__autodiff__types_ga1239707c3883de97b6c74f9c41269da1.html#ga1239707c3883de97b6c74f9c41269da1">require_not_st_autodiff</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac89008c6dab18001aef6ddef1ac298db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_aca2e8a0b7c1cca979b7ff43cbb75ca65.html#aca2e8a0b7c1cca979b7ff43cbb75ca65">matrix_d</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac89008c6dab18001aef6ddef1ac298db.html#ac89008c6dab18001aef6ddef1ac298db">multiply_lower_tri_self_transpose</a> (const EigMat &amp;L)</td></tr>
<tr class="memdesc:ac89008c6dab18001aef6ddef1ac298db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of multiplying the lower triangular portion of the input matrix by its own transpose.  <br /></td></tr>
<tr class="separator:ac89008c6dab18001aef6ddef1ac298db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bf206ecd3ba8467bffd0880c10bcd6"><td class="memTemplParams" colspan="2">template&lt;typename V , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa0bf206ecd3ba8467bffd0880c10bcd6"><td class="memTemplItemLeft" align="right" valign="top">V&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa0bf206ecd3ba8467bffd0880c10bcd6.html#aa0bf206ecd3ba8467bffd0880c10bcd6">norm</a> (const std::complex&lt; V &gt; &amp;z)</td></tr>
<tr class="memdesc:aa0bf206ecd3ba8467bffd0880c10bcd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the squared magnitude of the complex argument.  <br /></td></tr>
<tr class="separator:aa0bf206ecd3ba8467bffd0880c10bcd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7837e5b258e3cc77500a296d8902baec"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; std::is_arithmetic, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7837e5b258e3cc77500a296d8902baec"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7837e5b258e3cc77500a296d8902baec.html#a7837e5b258e3cc77500a296d8902baec">norm1</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a7837e5b258e3cc77500a296d8902baec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns L1 norm of a vector.  <br /></td></tr>
<tr class="separator:a7837e5b258e3cc77500a296d8902baec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece7684acb74c6c155a8a573bf6423cb"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; std::is_arithmetic, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aece7684acb74c6c155a8a573bf6423cb"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aece7684acb74c6c155a8a573bf6423cb.html#aece7684acb74c6c155a8a573bf6423cb">norm2</a> (const T &amp;v)</td></tr>
<tr class="memdesc:aece7684acb74c6c155a8a573bf6423cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns L2 norm of a vector.  <br /></td></tr>
<tr class="separator:aece7684acb74c6c155a8a573bf6423cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dd503cf7f20c28b3a90480f15a6978"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa6dd503cf7f20c28b3a90480f15a6978"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa6dd503cf7f20c28b3a90480f15a6978.html#aa6dd503cf7f20c28b3a90480f15a6978">num_elements</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:aa6dd503cf7f20c28b3a90480f15a6978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of elements in the specified vector.  <br /></td></tr>
<tr class="separator:aa6dd503cf7f20c28b3a90480f15a6978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8d029eccd2d26e69b4f37155e22612"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aca8d029eccd2d26e69b4f37155e22612.html#aca8d029eccd2d26e69b4f37155e22612">one_hot_array</a> (int K, int k)</td></tr>
<tr class="memdesc:aca8d029eccd2d26e69b4f37155e22612"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array with 1 in the k-th position and zero elsewhere.  <br /></td></tr>
<tr class="separator:aca8d029eccd2d26e69b4f37155e22612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad221274674089d892afa8481550b2012"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad221274674089d892afa8481550b2012.html#ad221274674089d892afa8481550b2012">one_hot_int_array</a> (int K, int k)</td></tr>
<tr class="memdesc:ad221274674089d892afa8481550b2012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an integer array with 1 in the k-th position and zero elsewhere.  <br /></td></tr>
<tr class="separator:ad221274674089d892afa8481550b2012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd26302c05628b4ffa75fc74e8ba01e8"><td class="memItemLeft" align="right" valign="top">Eigen::RowVectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afd26302c05628b4ffa75fc74e8ba01e8.html#afd26302c05628b4ffa75fc74e8ba01e8">one_hot_row_vector</a> (int K, int k)</td></tr>
<tr class="memdesc:afd26302c05628b4ffa75fc74e8ba01e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row vector with 1 in the k-th position and zero elsewhere.  <br /></td></tr>
<tr class="separator:afd26302c05628b4ffa75fc74e8ba01e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca3688bf2cadf2f53e5c1e44db81047"><td class="memItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeca3688bf2cadf2f53e5c1e44db81047.html#aeca3688bf2cadf2f53e5c1e44db81047">one_hot_vector</a> (int K, int k)</td></tr>
<tr class="memdesc:aeca3688bf2cadf2f53e5c1e44db81047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector with 1 in the k-th position and zero elsewhere.  <br /></td></tr>
<tr class="separator:aeca3688bf2cadf2f53e5c1e44db81047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaacd839fe87d031095a0bc03277d436"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adaacd839fe87d031095a0bc03277d436.html#adaacd839fe87d031095a0bc03277d436">ones_array</a> (int K)</td></tr>
<tr class="memdesc:adaacd839fe87d031095a0bc03277d436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array of ones.  <br /></td></tr>
<tr class="separator:adaacd839fe87d031095a0bc03277d436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7b8a7a238d79d96ee4a63b3463d288"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0d7b8a7a238d79d96ee4a63b3463d288.html#a0d7b8a7a238d79d96ee4a63b3463d288">ones_int_array</a> (int K)</td></tr>
<tr class="memdesc:a0d7b8a7a238d79d96ee4a63b3463d288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an integer array of ones.  <br /></td></tr>
<tr class="separator:a0d7b8a7a238d79d96ee4a63b3463d288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046a8930e6ddfa1971e8b3702f0f0d07"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a046a8930e6ddfa1971e8b3702f0f0d07.html#a046a8930e6ddfa1971e8b3702f0f0d07">ones_row_vector</a> (int K)</td></tr>
<tr class="memdesc:a046a8930e6ddfa1971e8b3702f0f0d07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row vector of ones.  <br /></td></tr>
<tr class="separator:a046a8930e6ddfa1971e8b3702f0f0d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864bcb045ed57c89c5be99cfd90681f2"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a864bcb045ed57c89c5be99cfd90681f2.html#a864bcb045ed57c89c5be99cfd90681f2">ones_vector</a> (int K)</td></tr>
<tr class="memdesc:a864bcb045ed57c89c5be99cfd90681f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of ones.  <br /></td></tr>
<tr class="separator:a864bcb045ed57c89c5be99cfd90681f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3cb1a99f207d37c15d722085576834b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac3cb1a99f207d37c15d722085576834b.html#ac3cb1a99f207d37c15d722085576834b">owens_t</a> (double h, double a)</td></tr>
<tr class="memdesc:ac3cb1a99f207d37c15d722085576834b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of applying Owen's T function to the specified arguments.  <br /></td></tr>
<tr class="separator:ac3cb1a99f207d37c15d722085576834b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f2f601c3b4f55c0c426ba25f1b12ee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="namespacestan_a27bd66f94354326e52c8335de0d9f69b.html#a27bd66f94354326e52c8335de0d9f69b">require_all_not_var_and_matrix_types</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a49f2f601c3b4f55c0c426ba25f1b12ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a49f2f601c3b4f55c0c426ba25f1b12ee.html#a49f2f601c3b4f55c0c426ba25f1b12ee">owens_t</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a49f2f601c3b4f55c0c426ba25f1b12ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the owens_t function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:a49f2f601c3b4f55c0c426ba25f1b12ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230f87fdb29de01fb55f204f184ffd52"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a230f87fdb29de01fb55f204f184ffd52.html#a230f87fdb29de01fb55f204f184ffd52">Phi</a> (double x)</td></tr>
<tr class="memdesc:a230f87fdb29de01fb55f204f184ffd52"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unit normal cumulative distribution function.  <br /></td></tr>
<tr class="separator:a230f87fdb29de01fb55f204f184ffd52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a5b0f856d404ca9d40626033de418f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a85a5b0f856d404ca9d40626033de418f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a85a5b0f856d404ca9d40626033de418f.html#a85a5b0f856d404ca9d40626033de418f">Phi</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a85a5b0f856d404ca9d40626033de418f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a8f550856f585617566096f8f129caff8.html#a8f550856f585617566096f8f129caff8">Phi()</a>.  <br /></td></tr>
<tr class="separator:a85a5b0f856d404ca9d40626033de418f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afafe7c31f20df7e498de012e1e599d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2afafe7c31f20df7e498de012e1e599d.html#a2afafe7c31f20df7e498de012e1e599d">Phi_approx</a> (double x)</td></tr>
<tr class="memdesc:a2afafe7c31f20df7e498de012e1e599d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an approximation of the unit normal CDF.  <br /></td></tr>
<tr class="separator:a2afafe7c31f20df7e498de012e1e599d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f646df0e9eca0cbe1a325e5e4fc85e9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4f646df0e9eca0cbe1a325e5e4fc85e9.html#a4f646df0e9eca0cbe1a325e5e4fc85e9">Phi_approx</a> (int x)</td></tr>
<tr class="memdesc:a4f646df0e9eca0cbe1a325e5e4fc85e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an approximation of the unit normal CDF.  <br /></td></tr>
<tr class="separator:a4f646df0e9eca0cbe1a325e5e4fc85e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516e74bff9b716b35aac30455a85f212"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a516e74bff9b716b35aac30455a85f212"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a516e74bff9b716b35aac30455a85f212.html#a516e74bff9b716b35aac30455a85f212">Phi_approx</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a516e74bff9b716b35aac30455a85f212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a5e969ba79729a18cbab9cf9731cced63.html#a5e969ba79729a18cbab9cf9731cced63" title="Return an approximation of the unit normal cumulative distribution function (CDF).">Phi_approx()</a></code> to specified argument container.  <br /></td></tr>
<tr class="separator:a516e74bff9b716b35aac30455a85f212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86bc80305f8bb8db823d88c3e4f05eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af86bc80305f8bb8db823d88c3e4f05eb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af86bc80305f8bb8db823d88c3e4f05eb.html#af86bc80305f8bb8db823d88c3e4f05eb">plus</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:af86bc80305f8bb8db823d88c3e4f05eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unary plus of the input.  <br /></td></tr>
<tr class="separator:af86bc80305f8bb8db823d88c3e4f05eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0048bf7d42347dac498eb993a63aa7bb"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , typename T_scalar  = scalar_type_t&lt;T_theta&gt;, <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T_theta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0048bf7d42347dac498eb993a63aa7bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0048bf7d42347dac498eb993a63aa7bb.html#a0048bf7d42347dac498eb993a63aa7bb">poisson_binomial_log_probs</a> (int y, const T_theta &amp;theta)</td></tr>
<tr class="memdesc:a0048bf7d42347dac498eb993a63aa7bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last row of the log probability matrix of the Poisson-Binomial distribution given the number of successes and a vector of success probabilities.  <br /></td></tr>
<tr class="separator:a0048bf7d42347dac498eb993a63aa7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1d6c5176ec865af96a7fdcae7c98097"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_theta , <a class="el" href="group__integral__types_ga354e01c2052e5b9575fc6ddf20f76fba.html#ga354e01c2052e5b9575fc6ddf20f76fba">require_vt_integral</a>&lt; T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae1d6c5176ec865af96a7fdcae7c98097"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae1d6c5176ec865af96a7fdcae7c98097.html#ae1d6c5176ec865af96a7fdcae7c98097">poisson_binomial_log_probs</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:ae1d6c5176ec865af96a7fdcae7c98097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43df9cf3093760551e97fb39a1eae150"><td class="memTemplParams" colspan="2">template&lt;typename U , typename V , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; U, V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a43df9cf3093760551e97fb39a1eae150"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a43df9cf3093760551e97fb39a1eae150.html#a43df9cf3093760551e97fb39a1eae150">polar</a> (U r, V theta)</td></tr>
<tr class="memdesc:a43df9cf3093760551e97fb39a1eae150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complex number with specified magnitude and phase angle.  <br /></td></tr>
<tr class="separator:a43df9cf3093760551e97fb39a1eae150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3786280c17b4af7109af5b2541be4cd6"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3786280c17b4af7109af5b2541be4cd6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3786280c17b4af7109af5b2541be4cd6.html#a3786280c17b4af7109af5b2541be4cd6">pow</a> (const std::complex&lt; T1 &gt; &amp;a, const std::complex&lt; T2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a3786280c17b4af7109af5b2541be4cd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <br /></td></tr>
<tr class="separator:a3786280c17b4af7109af5b2541be4cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856a0593a1fd70afce53fd73c13f6658"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a856a0593a1fd70afce53fd73c13f6658"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a856a0593a1fd70afce53fd73c13f6658.html#a856a0593a1fd70afce53fd73c13f6658">pow</a> (const T1 &amp;a, const std::complex&lt; T2 &gt; &amp;b)</td></tr>
<tr class="memdesc:a856a0593a1fd70afce53fd73c13f6658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <br /></td></tr>
<tr class="separator:a856a0593a1fd70afce53fd73c13f6658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bd230d76881848f932ddb74237ca7d"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a54bd230d76881848f932ddb74237ca7d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a54bd230d76881848f932ddb74237ca7d.html#a54bd230d76881848f932ddb74237ca7d">pow</a> (const std::complex&lt; T1 &gt; &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a54bd230d76881848f932ddb74237ca7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <br /></td></tr>
<tr class="separator:a54bd230d76881848f932ddb74237ca7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa64b79bf3e702a6aa8a2512aa1c4db"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1fa64b79bf3e702a6aa8a2512aa1c4db"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1fa64b79bf3e702a6aa8a2512aa1c4db.html#a1fa64b79bf3e702a6aa8a2512aa1c4db">pow</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a1fa64b79bf3e702a6aa8a2512aa1c4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first argument raised to the power of the second argument.  <br /></td></tr>
<tr class="separator:a1fa64b79bf3e702a6aa8a2512aa1c4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86059dc7d8d5c1623d3928a2a7871644"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a86059dc7d8d5c1623d3928a2a7871644"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a86059dc7d8d5c1623d3928a2a7871644.html#a86059dc7d8d5c1623d3928a2a7871644">primitive_value</a> (T x)</td></tr>
<tr class="memdesc:a86059dc7d8d5c1623d3928a2a7871644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified arithmetic argument unmodified with its own declared type.  <br /></td></tr>
<tr class="separator:a86059dc7d8d5c1623d3928a2a7871644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29efebca718ef2275a261ae79bcde22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa29efebca718ef2275a261ae79bcde22"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_arithmetic&lt; T &gt;::value, double &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa29efebca718ef2275a261ae79bcde22.html#aa29efebca718ef2275a261ae79bcde22">primitive_value</a> (const T &amp;x)</td></tr>
<tr class="memdesc:aa29efebca718ef2275a261ae79bcde22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the primitive value of the specified argument.  <br /></td></tr>
<tr class="separator:aa29efebca718ef2275a261ae79bcde22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7a33b156c2c6a0f86dcb14583f51a7"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adc7a33b156c2c6a0f86dcb14583f51a7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adc7a33b156c2c6a0f86dcb14583f51a7.html#adc7a33b156c2c6a0f86dcb14583f51a7">prod</a> (const T &amp;v)</td></tr>
<tr class="memdesc:adc7a33b156c2c6a0f86dcb14583f51a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of given scalar.  <br /></td></tr>
<tr class="separator:adc7a33b156c2c6a0f86dcb14583f51a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1649a895ec6e79097d5645a3f8b8a1e6.html#a1649a895ec6e79097d5645a3f8b8a1e6">prod</a> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of the coefficients of the specified standard vector.  <br /></td></tr>
<tr class="separator:a1649a895ec6e79097d5645a3f8b8a1e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021dd58361b4a4f17e37afa93d0f15f2"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a021dd58361b4a4f17e37afa93d0f15f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a021dd58361b4a4f17e37afa93d0f15f2.html#a021dd58361b4a4f17e37afa93d0f15f2">prod</a> (const EigMat &amp;v)</td></tr>
<tr class="memdesc:a021dd58361b4a4f17e37afa93d0f15f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of the coefficients of the specified column vector.  <br /></td></tr>
<tr class="separator:a021dd58361b4a4f17e37afa93d0f15f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79e2f6a39eded0f6c9201f25b6b2233c"><td class="memTemplParams" colspan="2">template&lt;typename V , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; V &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a79e2f6a39eded0f6c9201f25b6b2233c"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a79e2f6a39eded0f6c9201f25b6b2233c.html#a79e2f6a39eded0f6c9201f25b6b2233c">proj</a> (const std::complex&lt; V &gt; &amp;z)</td></tr>
<tr class="memdesc:a79e2f6a39eded0f6c9201f25b6b2233c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the projection of the complex argument onto the Riemann sphere.  <br /></td></tr>
<tr class="separator:a79e2f6a39eded0f6c9201f25b6b2233c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ab54f1764c792a9b24f40f08639ab9"><td class="memTemplParams" colspan="2">template&lt;typename PromotionScalar , typename UnPromotedType , <a class="el" href="group__constructible__types_gace83beabc05af15d3a0c7632e9733625.html#gace83beabc05af15d3a0c7632e9733625">require_constructible_t</a>&lt; PromotionScalar, UnPromotedType &gt; *  = nullptr, <a class="el" href="group__same__types_ga151adb676402a791de98a5d743d7a10d.html#ga151adb676402a791de98a5d743d7a10d">require_not_same_t</a>&lt; PromotionScalar, UnPromotedType &gt; *  = nullptr, <a class="el" href="group__tuple__types_ga7c6cf84c6e0253fd1901f0ac56fef29e.html#ga7c6cf84c6e0253fd1901f0ac56fef29e">require_all_not_tuple_t</a>&lt; PromotionScalar, UnPromotedType &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a68ab54f1764c792a9b24f40f08639ab9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a68ab54f1764c792a9b24f40f08639ab9.html#a68ab54f1764c792a9b24f40f08639ab9">promote_scalar</a> (UnPromotedType &amp;&amp;x)</td></tr>
<tr class="memdesc:a68ab54f1764c792a9b24f40f08639ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote a scalar to another scalar type.  <br /></td></tr>
<tr class="separator:a68ab54f1764c792a9b24f40f08639ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a371c6e1648cb9198ca11f17abc9b8a31"><td class="memTemplParams" colspan="2">template&lt;typename PromotionScalar , typename UnPromotedType , <a class="el" href="group__same__types_ga29595127b6ba2b597e5723c80dee1b61.html#ga29595127b6ba2b597e5723c80dee1b61">require_same_t</a>&lt; PromotionScalar, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; UnPromotedType &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a371c6e1648cb9198ca11f17abc9b8a31"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a371c6e1648cb9198ca11f17abc9b8a31.html#a371c6e1648cb9198ca11f17abc9b8a31">promote_scalar</a> (UnPromotedType &amp;&amp;x) noexcept</td></tr>
<tr class="memdesc:a371c6e1648cb9198ca11f17abc9b8a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-op overload when promoting a type's scalar to the type it already has.  <br /></td></tr>
<tr class="separator:a371c6e1648cb9198ca11f17abc9b8a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92640a2dc97a9c9ca2f40d86c00f7f84"><td class="memTemplParams" colspan="2">template&lt;typename PromotionScalar , typename UnPromotedType , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; UnPromotedType &gt; *  = nullptr, <a class="el" href="group__same__types_ga151adb676402a791de98a5d743d7a10d.html#ga151adb676402a791de98a5d743d7a10d">require_not_same_t</a>&lt; PromotionScalar, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; UnPromotedType &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a92640a2dc97a9c9ca2f40d86c00f7f84"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a92640a2dc97a9c9ca2f40d86c00f7f84.html#a92640a2dc97a9c9ca2f40d86c00f7f84">promote_scalar</a> (UnPromotedType &amp;&amp;x)</td></tr>
<tr class="memdesc:a92640a2dc97a9c9ca2f40d86c00f7f84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the scalar type of an eigen matrix to the requested type.  <br /></td></tr>
<tr class="separator:a92640a2dc97a9c9ca2f40d86c00f7f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c40be37700afb7ed3a0480613327e7"><td class="memTemplParams" colspan="2">template&lt;typename PromotionScalars , typename UnPromotedTypes , <a class="el" href="group__tuple__types_ga902ae119ff8d5c58048bef0993a087dd.html#ga902ae119ff8d5c58048bef0993a087dd">require_all_tuple_t</a>&lt; PromotionScalars, UnPromotedTypes &gt; *  = nullptr, <a class="el" href="group__same__types_ga151adb676402a791de98a5d743d7a10d.html#ga151adb676402a791de98a5d743d7a10d">require_not_same_t</a>&lt; PromotionScalars, UnPromotedTypes &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae5c40be37700afb7ed3a0480613327e7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">promote_scalar_t</a>&lt; PromotionScalars, UnPromotedTypes &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae5c40be37700afb7ed3a0480613327e7.html#ae5c40be37700afb7ed3a0480613327e7">promote_scalar</a> (UnPromotedTypes &amp;&amp;x)</td></tr>
<tr class="memdesc:ae5c40be37700afb7ed3a0480613327e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promote the scalar type of a tuples elements to the requested types.  <br /></td></tr>
<tr class="separator:ae5c40be37700afb7ed3a0480613327e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dcdeb4a6e3851608e723c4656cb031"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac8dcdeb4a6e3851608e723c4656cb031"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac8dcdeb4a6e3851608e723c4656cb031.html#ac8dcdeb4a6e3851608e723c4656cb031">pseudo_eigenvalues</a> (const Eigen::Matrix&lt; T, -1, -1 &gt; &amp;m)</td></tr>
<tr class="separator:ac8dcdeb4a6e3851608e723c4656cb031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5e6876ef4003669f7af4069a6f3ccd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9f5e6876ef4003669f7af4069a6f3ccd"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9f5e6876ef4003669f7af4069a6f3ccd.html#a9f5e6876ef4003669f7af4069a6f3ccd">pseudo_eigenvectors</a> (const Eigen::Matrix&lt; T, -1, -1 &gt; &amp;m)</td></tr>
<tr class="separator:a9f5e6876ef4003669f7af4069a6f3ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a584b37174f137438206e62528c6226d3"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a584b37174f137438206e62528c6226d3"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;, Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a584b37174f137438206e62528c6226d3.html#a584b37174f137438206e62528c6226d3">qr</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a584b37174f137438206e62528c6226d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fat QR decomposition.  <br /></td></tr>
<tr class="separator:a584b37174f137438206e62528c6226d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07af5bc5999fce04f694fa9b58602b07"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a07af5bc5999fce04f694fa9b58602b07"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a07af5bc5999fce04f694fa9b58602b07.html#a07af5bc5999fce04f694fa9b58602b07">qr_Q</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a07af5bc5999fce04f694fa9b58602b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orthogonal factor of the fat QR decomposition.  <br /></td></tr>
<tr class="separator:a07af5bc5999fce04f694fa9b58602b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb047c8bf52e35aab3c2a7a7e5b25915"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adb047c8bf52e35aab3c2a7a7e5b25915"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adb047c8bf52e35aab3c2a7a7e5b25915.html#adb047c8bf52e35aab3c2a7a7e5b25915">qr_R</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:adb047c8bf52e35aab3c2a7a7e5b25915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the upper triangular factor of the fat QR decomposition.  <br /></td></tr>
<tr class="separator:adb047c8bf52e35aab3c2a7a7e5b25915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1b74529a7b7d7855a5d770af9c73f5"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9f1b74529a7b7d7855a5d770af9c73f5"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;, Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9f1b74529a7b7d7855a5d770af9c73f5.html#a9f1b74529a7b7d7855a5d770af9c73f5">qr_thin</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a9f1b74529a7b7d7855a5d770af9c73f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the thin QR decomposition.  <br /></td></tr>
<tr class="separator:a9f1b74529a7b7d7855a5d770af9c73f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5de382adafe7a4c26c3d9bb3c71017"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6b5de382adafe7a4c26c3d9bb3c71017"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6b5de382adafe7a4c26c3d9bb3c71017.html#a6b5de382adafe7a4c26c3d9bb3c71017">qr_thin_Q</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a6b5de382adafe7a4c26c3d9bb3c71017"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the orthogonal factor of the thin QR decomposition.  <br /></td></tr>
<tr class="separator:a6b5de382adafe7a4c26c3d9bb3c71017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a45672a2407506cf9654096c56c266d"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1a45672a2407506cf9654096c56c266d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1a45672a2407506cf9654096c56c266d.html#a1a45672a2407506cf9654096c56c266d">qr_thin_R</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a1a45672a2407506cf9654096c56c266d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the upper triangular factor of the thin QR decomposition.  <br /></td></tr>
<tr class="separator:a1a45672a2407506cf9654096c56c266d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7e08af24c1dad00cc176f6e95dad0a"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga76e63e3ea85c77800e3a4cda6aed0357.html#ga76e63e3ea85c77800e3a4cda6aed0357">require_not_eigen_col_vector_t</a>&lt; EigMat2 &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gac93fca88594a61f619dd4ba85418e16c.html#gac93fca88594a61f619dd4ba85418e16c">require_all_vt_arithmetic</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afc7e08af24c1dad00cc176f6e95dad0a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afc7e08af24c1dad00cc176f6e95dad0a.html#afc7e08af24c1dad00cc176f6e95dad0a">quad_form</a> (const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:afc7e08af24c1dad00cc176f6e95dad0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \).  <br /></td></tr>
<tr class="separator:afc7e08af24c1dad00cc176f6e95dad0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6773324c0078af21cae91578a0578655"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename ColVec , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; ColVec &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; EigMat, ColVec &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gac93fca88594a61f619dd4ba85418e16c.html#gac93fca88594a61f619dd4ba85418e16c">require_all_vt_arithmetic</a>&lt; EigMat, ColVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6773324c0078af21cae91578a0578655"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6773324c0078af21cae91578a0578655.html#a6773324c0078af21cae91578a0578655">quad_form</a> (const EigMat &amp;A, const ColVec &amp;B)</td></tr>
<tr class="memdesc:a6773324c0078af21cae91578a0578655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \).  <br /></td></tr>
<tr class="separator:a6773324c0078af21cae91578a0578655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e23444134726d0c61abeaedb1b7240"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename EigVec , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a26e23444134726d0c61abeaedb1b7240"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a26e23444134726d0c61abeaedb1b7240.html#a26e23444134726d0c61abeaedb1b7240">quad_form_diag</a> (const EigMat &amp;mat, const EigVec &amp;vec)</td></tr>
<tr class="separator:a26e23444134726d0c61abeaedb1b7240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92370053c9793a7cfe81e80c82182462"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga76e63e3ea85c77800e3a4cda6aed0357.html#ga76e63e3ea85c77800e3a4cda6aed0357">require_not_eigen_col_vector_t</a>&lt; EigMat2 &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gac93fca88594a61f619dd4ba85418e16c.html#gac93fca88594a61f619dd4ba85418e16c">require_all_vt_arithmetic</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a92370053c9793a7cfe81e80c82182462"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; EigMat2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a92370053c9793a7cfe81e80c82182462.html#a92370053c9793a7cfe81e80c82182462">quad_form_sym</a> (const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:a92370053c9793a7cfe81e80c82182462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \) of a symmetric matrix.  <br /></td></tr>
<tr class="separator:a92370053c9793a7cfe81e80c82182462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a066aa2b4451ff9c6423de23810c417"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename ColVec , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; ColVec &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; EigMat, ColVec &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_gac93fca88594a61f619dd4ba85418e16c.html#gac93fca88594a61f619dd4ba85418e16c">require_all_vt_arithmetic</a>&lt; EigMat, ColVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2a066aa2b4451ff9c6423de23810c417"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2a066aa2b4451ff9c6423de23810c417.html#a2a066aa2b4451ff9c6423de23810c417">quad_form_sym</a> (const EigMat &amp;A, const ColVec &amp;B)</td></tr>
<tr class="memdesc:a2a066aa2b4451ff9c6423de23810c417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \) of a symmetric matrix.  <br /></td></tr>
<tr class="separator:a2a066aa2b4451ff9c6423de23810c417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffe1d7f897c2cffbcdba638dd4ef062"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__vector__types_ga49bbe2450e11ac6a02210ab0dcde62bb.html#ga49bbe2450e11ac6a02210ab0dcde62bb">require_vector_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__vector__types_ga038ee4f0c3ca5d626e5159485ac74c8a.html#ga038ee4f0c3ca5d626e5159485ac74c8a">require_vector_vt</a>&lt; std::is_arithmetic, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5ffe1d7f897c2cffbcdba638dd4ef062"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5ffe1d7f897c2cffbcdba638dd4ef062.html#a5ffe1d7f897c2cffbcdba638dd4ef062">quantile</a> (const T &amp;samples_vec, const double p)</td></tr>
<tr class="memdesc:a5ffe1d7f897c2cffbcdba638dd4ef062"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sample quantiles corresponding to the given probabilities.  <br /></td></tr>
<tr class="separator:a5ffe1d7f897c2cffbcdba638dd4ef062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bea6184cf749182578040a6827c088a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tp , <a class="el" href="group__vector__types_ga1b4c392b9d20db66ae254ef9833f9717.html#ga1b4c392b9d20db66ae254ef9833f9717">require_all_vector_t</a>&lt; T, Tp &gt; *  = nullptr, <a class="el" href="group__vector__types_ga038ee4f0c3ca5d626e5159485ac74c8a.html#ga038ee4f0c3ca5d626e5159485ac74c8a">require_vector_vt</a>&lt; std::is_arithmetic, T &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga177ca10358abdf201cabb12e8bdb2e91.html#ga177ca10358abdf201cabb12e8bdb2e91">require_std_vector_vt</a>&lt; std::is_arithmetic, Tp &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0bea6184cf749182578040a6827c088a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0bea6184cf749182578040a6827c088a.html#a0bea6184cf749182578040a6827c088a">quantile</a> (const T &amp;samples_vec, const Tp &amp;ps)</td></tr>
<tr class="memdesc:a0bea6184cf749182578040a6827c088a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sample quantiles corresponding to the given probabilities.  <br /></td></tr>
<tr class="separator:a0bea6184cf749182578040a6827c088a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08cf44474c3253c7193f81afa498d15"><td class="memTemplParams" colspan="2">template&lt;typename C , <a class="el" href="group__container__types_gac5dfcc325ecaff91dd97f8a1a8f09431.html#gac5dfcc325ecaff91dd97f8a1a8f09431">require_container_t</a>&lt; C &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac08cf44474c3253c7193f81afa498d15"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac08cf44474c3253c7193f81afa498d15.html#ac08cf44474c3253c7193f81afa498d15">rank</a> (const C &amp;v, int s)</td></tr>
<tr class="memdesc:ac08cf44474c3253c7193f81afa498d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of components of v less than v[s].  <br /></td></tr>
<tr class="separator:ac08cf44474c3253c7193f81afa498d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f2728232fa142fcaa3b1c459938681"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af6f2728232fa142fcaa3b1c459938681"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af6f2728232fa142fcaa3b1c459938681.html#af6f2728232fa142fcaa3b1c459938681">read_corr_L</a> (const T &amp;CPCs, size_t K)</td></tr>
<tr class="memdesc:af6f2728232fa142fcaa3b1c459938681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations.  <br /></td></tr>
<tr class="separator:af6f2728232fa142fcaa3b1c459938681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad49f5b919c31a1ea3fce4c9bfe40e2c"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aad49f5b919c31a1ea3fce4c9bfe40e2c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aad49f5b919c31a1ea3fce4c9bfe40e2c.html#aad49f5b919c31a1ea3fce4c9bfe40e2c">read_corr_L</a> (const T &amp;CPCs, size_t K, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt; &amp;log_prob)</td></tr>
<tr class="memdesc:aad49f5b919c31a1ea3fce4c9bfe40e2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations, incrementing the specified scalar reference with the log absolute determinant of the Jacobian of the transformation.  <br /></td></tr>
<tr class="separator:aad49f5b919c31a1ea3fce4c9bfe40e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845ed1958fe5cf5ff276eac81b9815c9"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T_CPCs &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a845ed1958fe5cf5ff276eac81b9815c9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_CPCs &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a845ed1958fe5cf5ff276eac81b9815c9.html#a845ed1958fe5cf5ff276eac81b9815c9">read_corr_matrix</a> (const T_CPCs &amp;CPCs, size_t K)</td></tr>
<tr class="memdesc:a845ed1958fe5cf5ff276eac81b9815c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations.  <br /></td></tr>
<tr class="separator:a845ed1958fe5cf5ff276eac81b9815c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76d5d29cf5fe730f8f17de9e3627bf7"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T_CPCs &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa76d5d29cf5fe730f8f17de9e3627bf7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_CPCs &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa76d5d29cf5fe730f8f17de9e3627bf7.html#aa76d5d29cf5fe730f8f17de9e3627bf7">read_corr_matrix</a> (const T_CPCs &amp;CPCs, size_t K, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_CPCs &gt; &amp;log_prob)</td></tr>
<tr class="memdesc:aa76d5d29cf5fe730f8f17de9e3627bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations, incrementing the specified scalar reference with the log absolute determinant of the Jacobian of the transformation.  <br /></td></tr>
<tr class="separator:aa76d5d29cf5fe730f8f17de9e3627bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16ac66bf26b097cb63b1489a03a092e"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , typename T_sds , <a class="el" href="group__eigen__vector__types_gaf8c3e4d9b301746f5374ae7237eeab66.html#gaf8c3e4d9b301746f5374ae7237eeab66">require_all_eigen_vector_t</a>&lt; T_CPCs, T_sds &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; T_CPCs, T_sds &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab16ac66bf26b097cb63b1489a03a092e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_CPCs &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab16ac66bf26b097cb63b1489a03a092e.html#ab16ac66bf26b097cb63b1489a03a092e">read_cov_L</a> (const T_CPCs &amp;CPCs, const T_sds &amp;sds, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_CPCs &gt; &amp;log_prob)</td></tr>
<tr class="memdesc:ab16ac66bf26b097cb63b1489a03a092e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function that should be called prior to evaluating the density of any elliptical distribution.  <br /></td></tr>
<tr class="separator:ab16ac66bf26b097cb63b1489a03a092e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aa0477bfd7c32352b1e7dca0548c31"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , typename T_sds , <a class="el" href="group__eigen__vector__types_gaf8c3e4d9b301746f5374ae7237eeab66.html#gaf8c3e4d9b301746f5374ae7237eeab66">require_all_eigen_vector_t</a>&lt; T_CPCs, T_sds &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; T_CPCs, T_sds &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a21aa0477bfd7c32352b1e7dca0548c31"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_CPCs &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a21aa0477bfd7c32352b1e7dca0548c31.html#a21aa0477bfd7c32352b1e7dca0548c31">read_cov_matrix</a> (const T_CPCs &amp;CPCs, const T_sds &amp;sds, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_CPCs &gt; &amp;log_prob)</td></tr>
<tr class="memdesc:a21aa0477bfd7c32352b1e7dca0548c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generally worse alternative to call prior to evaluating the density of an elliptical distribution.  <br /></td></tr>
<tr class="separator:a21aa0477bfd7c32352b1e7dca0548c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f737c98f8c242ce4eabf6b996edcf1"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , typename T_sds , <a class="el" href="group__eigen__vector__types_gaf8c3e4d9b301746f5374ae7237eeab66.html#gaf8c3e4d9b301746f5374ae7237eeab66">require_all_eigen_vector_t</a>&lt; T_CPCs, T_sds &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; T_CPCs, T_sds &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a63f737c98f8c242ce4eabf6b996edcf1"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_CPCs &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a63f737c98f8c242ce4eabf6b996edcf1.html#a63f737c98f8c242ce4eabf6b996edcf1">read_cov_matrix</a> (const T_CPCs &amp;CPCs, const T_sds &amp;sds)</td></tr>
<tr class="memdesc:a63f737c98f8c242ce4eabf6b996edcf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a covariance matrix from CPCs and standard deviations.  <br /></td></tr>
<tr class="separator:a63f737c98f8c242ce4eabf6b996edcf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2385fde5624f0ea3c0d2c60d0568a5"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__autodiff__types_ga9c0ebeb539d0429f2cbceb0fdb24c2d6.html#ga9c0ebeb539d0429f2cbceb0fdb24c2d6">require_autodiff_t</a>&lt; T &gt; &gt; </td></tr>
<tr class="memitem:a3e2385fde5624f0ea3c0d2c60d0568a5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3e2385fde5624f0ea3c0d2c60d0568a5.html#a3e2385fde5624f0ea3c0d2c60d0568a5">real</a> (const std::complex&lt; T &gt; &amp;z)</td></tr>
<tr class="memdesc:a3e2385fde5624f0ea3c0d2c60d0568a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the real component of the complex argument.  <br /></td></tr>
<tr class="separator:a3e2385fde5624f0ea3c0d2c60d0568a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc33001c3a3edd4049eee754a7d5514a"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , typename In , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T_ret &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adc33001c3a3edd4049eee754a7d5514a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; In &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adc33001c3a3edd4049eee754a7d5514a.html#adc33001c3a3edd4049eee754a7d5514a">rep_array</a> (const In &amp;x, int n)</td></tr>
<tr class="separator:adc33001c3a3edd4049eee754a7d5514a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757b9e343d7d592ced1a97616a39f230"><td class="memTemplParams" colspan="2">template&lt;typename In &gt; </td></tr>
<tr class="memitem:a757b9e343d7d592ced1a97616a39f230"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; In &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a757b9e343d7d592ced1a97616a39f230.html#a757b9e343d7d592ced1a97616a39f230">rep_array</a> (const In &amp;x, int n)</td></tr>
<tr class="separator:a757b9e343d7d592ced1a97616a39f230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba538367288afbfc4fbd153a1c10d8d"><td class="memTemplParams" colspan="2">template&lt;typename In &gt; </td></tr>
<tr class="memitem:afba538367288afbfc4fbd153a1c10d8d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; In &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afba538367288afbfc4fbd153a1c10d8d.html#afba538367288afbfc4fbd153a1c10d8d">rep_array</a> (const In &amp;x, int m, int n)</td></tr>
<tr class="separator:afba538367288afbfc4fbd153a1c10d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae49a136c6b52673c36b4f81d434a64"><td class="memTemplParams" colspan="2">template&lt;typename In &gt; </td></tr>
<tr class="memitem:a2ae49a136c6b52673c36b4f81d434a64"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; std::vector&lt; <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; In &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2ae49a136c6b52673c36b4f81d434a64.html#a2ae49a136c6b52673c36b4f81d434a64">rep_array</a> (const In &amp;x, int k, int m, int n)</td></tr>
<tr class="separator:a2ae49a136c6b52673c36b4f81d434a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2382bdc64f50d70aff928c0cec0b69e4"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename T , <a class="el" href="group__eigen__matrix__dynamic__types_gae725537ef0b9f4ef9857fa1b28bd1076.html#gae725537ef0b9f4ef9857fa1b28bd1076">require_eigen_matrix_dynamic_vt</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>, Ret &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2382bdc64f50d70aff928c0cec0b69e4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2382bdc64f50d70aff928c0cec0b69e4.html#a2382bdc64f50d70aff928c0cec0b69e4">rep_matrix</a> (const T &amp;x, int m, int n)</td></tr>
<tr class="memdesc:a2382bdc64f50d70aff928c0cec0b69e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of rep_matrix returning an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix with scalar type equal to the input scalar type.  <br /></td></tr>
<tr class="separator:a2382bdc64f50d70aff928c0cec0b69e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9669d5b8a55a8ed0acc54265689c0f2b"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9669d5b8a55a8ed0acc54265689c0f2b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9669d5b8a55a8ed0acc54265689c0f2b.html#a9669d5b8a55a8ed0acc54265689c0f2b">rep_matrix</a> (const T &amp;x, int m, int n)</td></tr>
<tr class="memdesc:a9669d5b8a55a8ed0acc54265689c0f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Implementation of rep_matrix returning an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix with scalar type equal to the input scalar type.  <br /></td></tr>
<tr class="separator:a9669d5b8a55a8ed0acc54265689c0f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c1043a040a2342329fc08e732f7d1cf"><td class="memTemplParams" colspan="2">template&lt;typename Vec , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7c1043a040a2342329fc08e732f7d1cf"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7c1043a040a2342329fc08e732f7d1cf.html#a7c1043a040a2342329fc08e732f7d1cf">rep_matrix</a> (const Vec &amp;x, int n)</td></tr>
<tr class="memdesc:a7c1043a040a2342329fc08e732f7d1cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of rep_matrix returning an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix from an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vector.  <br /></td></tr>
<tr class="separator:a7c1043a040a2342329fc08e732f7d1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be864fed7d2707279e973d7281f6ba6"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , typename T , <a class="el" href="group__eigen__row__vector__types_ga2aff7daad297cba7bc223382ac23d8ff.html#ga2aff7daad297cba7bc223382ac23d8ff">require_eigen_row_vector_t</a>&lt; T_ret &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1be864fed7d2707279e973d7281f6ba6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1be864fed7d2707279e973d7281f6ba6.html#a1be864fed7d2707279e973d7281f6ba6">rep_row_vector</a> (const T &amp;x, int n)</td></tr>
<tr class="separator:a1be864fed7d2707279e973d7281f6ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e1df8e01072288a9a2f5140d93507a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a64e1df8e01072288a9a2f5140d93507a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a64e1df8e01072288a9a2f5140d93507a.html#a64e1df8e01072288a9a2f5140d93507a">rep_row_vector</a> (const T &amp;x, int n)</td></tr>
<tr class="separator:a64e1df8e01072288a9a2f5140d93507a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa94a2628245a969873d40d7c51d8be7"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , typename T , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_ret &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaa94a2628245a969873d40d7c51d8be7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaa94a2628245a969873d40d7c51d8be7.html#aaa94a2628245a969873d40d7c51d8be7">rep_vector</a> (const T &amp;x, int n)</td></tr>
<tr class="separator:aaa94a2628245a969873d40d7c51d8be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba4256db717f17c98de74df71edc1a7"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4ba4256db717f17c98de74df71edc1a7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4ba4256db717f17c98de74df71edc1a7.html#a4ba4256db717f17c98de74df71edc1a7">rep_vector</a> (const T &amp;x, int n)</td></tr>
<tr class="separator:a4ba4256db717f17c98de74df71edc1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04c2acf592bafdc7165ee76f134d700"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad04c2acf592bafdc7165ee76f134d700"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad04c2acf592bafdc7165ee76f134d700.html#ad04c2acf592bafdc7165ee76f134d700">resize</a> (T &amp;x, std::vector&lt; int &gt; <a class="el" href="group__opencl_gaff473895b1f11e364afd4c2d3cb5cab4.html#gaff473895b1f11e364afd4c2d3cb5cab4">dims</a>)</td></tr>
<tr class="memdesc:ad04c2acf592bafdc7165ee76f134d700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively resize the specified vector of vectors, which must bottom out at scalar values, <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vectors or <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrices.  <br /></td></tr>
<tr class="separator:ad04c2acf592bafdc7165ee76f134d700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553061f77037664462b47ebf8efda814"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a553061f77037664462b47ebf8efda814"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a553061f77037664462b47ebf8efda814.html#a553061f77037664462b47ebf8efda814">reverse</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a553061f77037664462b47ebf8efda814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the specified array in reversed order.  <br /></td></tr>
<tr class="separator:a553061f77037664462b47ebf8efda814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee3d799cb32c60381d7ad77cb17ba88"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_vector_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a7ee3d799cb32c60381d7ad77cb17ba88"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7ee3d799cb32c60381d7ad77cb17ba88.html#a7ee3d799cb32c60381d7ad77cb17ba88">reverse</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a7ee3d799cb32c60381d7ad77cb17ba88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a copy of the specified vector or row vector in reversed order.  <br /></td></tr>
<tr class="separator:a7ee3d799cb32c60381d7ad77cb17ba88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296c0fab22840e260c07519e52758c87"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a296c0fab22840e260c07519e52758c87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a296c0fab22840e260c07519e52758c87.html#a296c0fab22840e260c07519e52758c87">rising_factorial</a> (const T &amp;x, int n)</td></tr>
<tr class="memdesc:a296c0fab22840e260c07519e52758c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the rising factorial function evaluated at the inputs.  <br /></td></tr>
<tr class="separator:a296c0fab22840e260c07519e52758c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f43afe8a8acf0b1b3e984927b8fd90"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a60f43afe8a8acf0b1b3e984927b8fd90"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a60f43afe8a8acf0b1b3e984927b8fd90.html#a60f43afe8a8acf0b1b3e984927b8fd90">rising_factorial</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="memdesc:a60f43afe8a8acf0b1b3e984927b8fd90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the vectorized application of the rising_factorial function, when the first and/or second arguments are containers.  <br /></td></tr>
<tr class="separator:a60f43afe8a8acf0b1b3e984927b8fd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab681eea525b46c4b700b2ff106451c11"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga1b135bb62a0729e31b4233e370170a53.html#ga1b135bb62a0729e31b4233e370170a53">require_not_container_st</a>&lt; std::is_arithmetic, Container &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab681eea525b46c4b700b2ff106451c11"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab681eea525b46c4b700b2ff106451c11.html#ab681eea525b46c4b700b2ff106451c11">round</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ab681eea525b46c4b700b2ff106451c11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <code><a class="el" href="namespacestan_1_1math_ac23adb89034b334771cd25cf0fa6e2e4.html#ac23adb89034b334771cd25cf0fa6e2e4" title="Return the closest integer to the specified argument, with halfway cases rounded away from zero.">round()</a></code>.  <br /></td></tr>
<tr class="separator:ab681eea525b46c4b700b2ff106451c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f9347746c57abe5c2b318766ee2892"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga7bc6670ad3273187c8b6fff5c86288ae.html#ga7bc6670ad3273187c8b6fff5c86288ae">require_container_st</a>&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a28f9347746c57abe5c2b318766ee2892"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a28f9347746c57abe5c2b318766ee2892.html#a28f9347746c57abe5c2b318766ee2892">round</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a28f9347746c57abe5c2b318766ee2892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_ac23adb89034b334771cd25cf0fa6e2e4.html#ac23adb89034b334771cd25cf0fa6e2e4" title="Return the closest integer to the specified argument, with halfway cases rounded away from zero.">round()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <br /></td></tr>
<tr class="separator:a28f9347746c57abe5c2b318766ee2892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a170126040a0b7c594c32f16d2f280d62"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a170126040a0b7c594c32f16d2f280d62"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a170126040a0b7c594c32f16d2f280d62.html#a170126040a0b7c594c32f16d2f280d62">row</a> (const T &amp;m, size_t i)</td></tr>
<tr class="memdesc:a170126040a0b7c594c32f16d2f280d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified row of the specified matrix, using start-at-1 indexing.  <br /></td></tr>
<tr class="separator:a170126040a0b7c594c32f16d2f280d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927d0299eae775a4a8f3c1b843e61d31"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a927d0299eae775a4a8f3c1b843e61d31"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a927d0299eae775a4a8f3c1b843e61d31.html#a927d0299eae775a4a8f3c1b843e61d31">rows</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a927d0299eae775a4a8f3c1b843e61d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of rows in the specified matrix, vector, or row vector.  <br /></td></tr>
<tr class="separator:a927d0299eae775a4a8f3c1b843e61d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe0810d6ec56fa15bc3868114a61d583"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="group__eigen__types_gac30da5b4d9bf217de273208379b7b92e.html#gac30da5b4d9bf217de273208379b7b92e">require_all_not_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abe0810d6ec56fa15bc3868114a61d583"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Mat1, Mat2 &gt;, Mat1::RowsAtCompileTime, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abe0810d6ec56fa15bc3868114a61d583.html#abe0810d6ec56fa15bc3868114a61d583">rows_dot_product</a> (const Mat1 &amp;v1, const Mat2 &amp;v2)</td></tr>
<tr class="memdesc:abe0810d6ec56fa15bc3868114a61d583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of rows of the specified matrices.  <br /></td></tr>
<tr class="separator:abe0810d6ec56fa15bc3868114a61d583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af426c1d9485f458ec743c1ad3a8ca012"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af426c1d9485f458ec743c1ad3a8ca012"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, T::RowsAtCompileTime, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af426c1d9485f458ec743c1ad3a8ca012.html#af426c1d9485f458ec743c1ad3a8ca012">rows_dot_self</a> (const T &amp;x)</td></tr>
<tr class="memdesc:af426c1d9485f458ec743c1ad3a8ca012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each row of a matrix with itself.  <br /></td></tr>
<tr class="separator:af426c1d9485f458ec743c1ad3a8ca012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb68633654dd492a44bd8c240171d92"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_autodiff_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a5eb68633654dd492a44bd8c240171d92"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5eb68633654dd492a44bd8c240171d92.html#a5eb68633654dd492a44bd8c240171d92">scalbn</a> (const T &amp;x, int n)</td></tr>
<tr class="separator:a5eb68633654dd492a44bd8c240171d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7d9412b7419bbf6e517aa310698932"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga06fcddbaf041c31d2c20c8b006ebba79.html#ga06fcddbaf041c31d2c20c8b006ebba79">require_all_eigen_vt</a>&lt; std::is_arithmetic, EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6e7d9412b7419bbf6e517aa310698932"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, Eigen::Dynamic, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6e7d9412b7419bbf6e517aa310698932.html#a6e7d9412b7419bbf6e517aa310698932">scale_matrix_exp_multiply</a> (const double &amp;t, const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:a6e7d9412b7419bbf6e517aa310698932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return product of exp(At) and B, where A is a NxN double matrix, B is a NxCb double matrix, and t is a double.  <br /></td></tr>
<tr class="separator:a6e7d9412b7419bbf6e517aa310698932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fec9bf3417ee92453adc2bb3c19547a"><td class="memTemplParams" colspan="2">template&lt;typename Tt , typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr, <a class="el" href="group__autodiff__types_ga6b677072627547a42cf26c004ec18aa1.html#ga6b677072627547a42cf26c004ec18aa1">require_any_autodiff_t</a>&lt; Tt, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat1 &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat2 &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2fec9bf3417ee92453adc2bb3c19547a"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Tt, EigMat1, EigMat2 &gt;, Eigen::Dynamic, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2fec9bf3417ee92453adc2bb3c19547a.html#a2fec9bf3417ee92453adc2bb3c19547a">scale_matrix_exp_multiply</a> (const Tt &amp;t, const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:a2fec9bf3417ee92453adc2bb3c19547a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return product of exp(At) and B, where A is a NxN matrix, B is a NxCb matrix and t is a scalar.  <br /></td></tr>
<tr class="separator:a2fec9bf3417ee92453adc2bb3c19547a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4ac8609acf513ecd19de2fe90cd6f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acc4ac8609acf513ecd19de2fe90cd6f4.html#acc4ac8609acf513ecd19de2fe90cd6f4">scaled_add</a> (std::vector&lt; double &gt; &amp;x, const std::vector&lt; double &gt; &amp;y, double lambda)</td></tr>
<tr class="separator:acc4ac8609acf513ecd19de2fe90cd6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b69d1f30ba5c7c8f42646053e42955"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__container__types_gac5dfcc325ecaff91dd97f8a1a8f09431.html#gac5dfcc325ecaff91dd97f8a1a8f09431">require_container_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a20b69d1f30ba5c7c8f42646053e42955"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a20b69d1f30ba5c7c8f42646053e42955.html#a20b69d1f30ba5c7c8f42646053e42955">sd</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a20b69d1f30ba5c7c8f42646053e42955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unbiased sample standard deviation of the coefficients in the specified std vector, column vector, row vector, or matrix.  <br /></td></tr>
<tr class="separator:a20b69d1f30ba5c7c8f42646053e42955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3007ebc208b30c9b027ade071363d3b4"><td class="memTemplParams" colspan="2">template&lt;typename Vec , <a class="el" href="group__vector__types_ga49bbe2450e11ac6a02210ab0dcde62bb.html#ga49bbe2450e11ac6a02210ab0dcde62bb">require_vector_t</a>&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3007ebc208b30c9b027ade071363d3b4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3007ebc208b30c9b027ade071363d3b4.html#a3007ebc208b30c9b027ade071363d3b4">segment</a> (const Vec &amp;v, size_t i, size_t n)</td></tr>
<tr class="memdesc:a3007ebc208b30c9b027ade071363d3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a row/column vector starting from the specified element - 1 of the specified row/column vector.  <br /></td></tr>
<tr class="separator:a3007ebc208b30c9b027ade071363d3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fae4c722b86228b101edc9737ca4fe7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5fae4c722b86228b101edc9737ca4fe7"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5fae4c722b86228b101edc9737ca4fe7.html#a5fae4c722b86228b101edc9737ca4fe7">segment</a> (const std::vector&lt; T &gt; &amp;sv, size_t i, size_t n)</td></tr>
<tr class="separator:a5fae4c722b86228b101edc9737ca4fe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229c102735ad9bd8f13394ac9fa899f2"><td class="memTemplParams" colspan="2">template&lt;typename T_true , typename T_false , typename ReturnT  = return_type_t&lt;T_true, T_false&gt;, <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T_true, T_false &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a229c102735ad9bd8f13394ac9fa899f2"><td class="memTemplItemLeft" align="right" valign="top">ReturnT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a229c102735ad9bd8f13394ac9fa899f2.html#a229c102735ad9bd8f13394ac9fa899f2">select</a> (const bool c, const T_true y_true, const T_false y_false)</td></tr>
<tr class="memdesc:a229c102735ad9bd8f13394ac9fa899f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">If first argument is true return the second argument, else return the third argument.  <br /></td></tr>
<tr class="separator:a229c102735ad9bd8f13394ac9fa899f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c550301f9b9ea538b55a8bedbf9c48"><td class="memTemplParams" colspan="2">template&lt;typename T_true , typename T_false , typename T_return  = return_type_t&lt;T_true, T_false&gt;, typename T_true_plain  = promote_scalar_t&lt;T_return, plain_type_t&lt;T_true&gt;&gt;, typename T_false_plain  = promote_scalar_t&lt;T_return, plain_type_t&lt;T_false&gt;&gt;, <a class="el" href="group__container__types_ga0cf1d2303424cf90bfc85868e892dce9.html#ga0cf1d2303424cf90bfc85868e892dce9">require_all_container_t</a>&lt; T_true, T_false &gt; *  = nullptr, <a class="el" href="group__same__types_ga1d778e91aefa883ada22a64d478d7d10.html#ga1d778e91aefa883ada22a64d478d7d10">require_all_same_t</a>&lt; T_true_plain, T_false_plain &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a80c550301f9b9ea538b55a8bedbf9c48"><td class="memTemplItemLeft" align="right" valign="top">T_true_plain&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a80c550301f9b9ea538b55a8bedbf9c48.html#a80c550301f9b9ea538b55a8bedbf9c48">select</a> (const bool c, T_true &amp;&amp;y_true, T_false &amp;&amp;y_false)</td></tr>
<tr class="memdesc:a80c550301f9b9ea538b55a8bedbf9c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">If first argument is true return the second argument, else return the third argument.  <br /></td></tr>
<tr class="separator:a80c550301f9b9ea538b55a8bedbf9c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7b497b6a0763cd5f7938edbcb13ebb"><td class="memTemplParams" colspan="2">template&lt;typename T_true , typename T_false , typename ReturnT  = promote_scalar_t&lt;return_type_t&lt;T_true, T_false&gt;,                                              plain_type_t&lt;T_true&gt;&gt;, <a class="el" href="group__container__types_gac5dfcc325ecaff91dd97f8a1a8f09431.html#gac5dfcc325ecaff91dd97f8a1a8f09431">require_container_t</a>&lt; T_true &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_false &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4d7b497b6a0763cd5f7938edbcb13ebb"><td class="memTemplItemLeft" align="right" valign="top">ReturnT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4d7b497b6a0763cd5f7938edbcb13ebb.html#a4d7b497b6a0763cd5f7938edbcb13ebb">select</a> (const bool c, const T_true &amp;y_true, const T_false &amp;y_false)</td></tr>
<tr class="memdesc:a4d7b497b6a0763cd5f7938edbcb13ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">If first argument is true return the second argument, else return the third argument.  <br /></td></tr>
<tr class="separator:a4d7b497b6a0763cd5f7938edbcb13ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebbbf819e1296fa88b9536bdc301d9aa"><td class="memTemplParams" colspan="2">template&lt;typename T_true , typename T_false , typename ReturnT  = promote_scalar_t&lt;return_type_t&lt;T_true, T_false&gt;,                                              plain_type_t&lt;T_false&gt;&gt;, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_true &gt; *  = nullptr, <a class="el" href="group__container__types_gac5dfcc325ecaff91dd97f8a1a8f09431.html#gac5dfcc325ecaff91dd97f8a1a8f09431">require_container_t</a>&lt; T_false &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aebbbf819e1296fa88b9536bdc301d9aa"><td class="memTemplItemLeft" align="right" valign="top">ReturnT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aebbbf819e1296fa88b9536bdc301d9aa.html#aebbbf819e1296fa88b9536bdc301d9aa">select</a> (const bool c, const T_true y_true, const T_false y_false)</td></tr>
<tr class="memdesc:aebbbf819e1296fa88b9536bdc301d9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">If first argument is true return the second argument, else return the third argument.  <br /></td></tr>
<tr class="separator:aebbbf819e1296fa88b9536bdc301d9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af94ed67f58923db809990c986925a6"><td class="memTemplParams" colspan="2">template&lt;typename T_bool , typename T_true , typename T_false , <a class="el" href="group__eigen__array__types_ga6db561292e912aa93487ec77aa1daf57.html#ga6db561292e912aa93487ec77aa1daf57">require_eigen_array_vt</a>&lt; std::is_integral, T_bool &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T_true, T_false &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0af94ed67f58923db809990c986925a6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0af94ed67f58923db809990c986925a6.html#a0af94ed67f58923db809990c986925a6">select</a> (const T_bool c, const T_true y_true, const T_false y_false)</td></tr>
<tr class="memdesc:a0af94ed67f58923db809990c986925a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">If first argument is true return the second argument, else return the third argument.  <br /></td></tr>
<tr class="separator:a0af94ed67f58923db809990c986925a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4942b5539426ca5b4281e601bc43477e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4942b5539426ca5b4281e601bc43477e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1deserializer.html">deserializer</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4942b5539426ca5b4281e601bc43477e.html#a4942b5539426ca5b4281e601bc43477e">to_deserializer</a> (const std::vector&lt; T &gt; &amp;vals)</td></tr>
<tr class="memdesc:a4942b5539426ca5b4281e601bc43477e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a deserializer based on the specified values.  <br /></td></tr>
<tr class="separator:a4942b5539426ca5b4281e601bc43477e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b682c128efc66e73f1059df5b83e60"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a17b682c128efc66e73f1059df5b83e60"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1deserializer.html">deserializer</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a17b682c128efc66e73f1059df5b83e60.html#a17b682c128efc66e73f1059df5b83e60">to_deserializer</a> (const T &amp;vals)</td></tr>
<tr class="memdesc:a17b682c128efc66e73f1059df5b83e60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a deserializer based on the specified values.  <br /></td></tr>
<tr class="separator:a17b682c128efc66e73f1059df5b83e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa41c87294a923cecf4c523d3224d8e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adaa41c87294a923cecf4c523d3224d8e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1deserializer.html">deserializer</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adaa41c87294a923cecf4c523d3224d8e.html#adaa41c87294a923cecf4c523d3224d8e">to_deserializer</a> (const std::complex&lt; T &gt; &amp;vals)</td></tr>
<tr class="separator:adaa41c87294a923cecf4c523d3224d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fcb36444e76dea82db35432435d8f7"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ad0fcb36444e76dea82db35432435d8f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad0fcb36444e76dea82db35432435d8f7.html#ad0fcb36444e76dea82db35432435d8f7">serialize_helper</a> (<a class="el" href="structstan_1_1math_1_1serializer.html">serializer</a>&lt; U &gt; &amp;s)</td></tr>
<tr class="separator:ad0fcb36444e76dea82db35432435d8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e890cb93ca67121c8aa15ecfba9cc2"><td class="memTemplParams" colspan="2">template&lt;typename U , typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a82e890cb93ca67121c8aa15ecfba9cc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a82e890cb93ca67121c8aa15ecfba9cc2.html#a82e890cb93ca67121c8aa15ecfba9cc2">serialize_helper</a> (<a class="el" href="structstan_1_1math_1_1serializer.html">serializer</a>&lt; U &gt; &amp;s, const T &amp;x, const Ts... xs)</td></tr>
<tr class="separator:a82e890cb93ca67121c8aa15ecfba9cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a556ce9ef4c27c543b02009cf66b4cb4c"><td class="memTemplParams" colspan="2">template&lt;typename U , typename... Ts&gt; </td></tr>
<tr class="memitem:a556ce9ef4c27c543b02009cf66b4cb4c"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a556ce9ef4c27c543b02009cf66b4cb4c.html#a556ce9ef4c27c543b02009cf66b4cb4c">serialize</a> (const Ts... xs)</td></tr>
<tr class="memdesc:a556ce9ef4c27c543b02009cf66b4cb4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize the specified sequence of objects, which all must have scalar types assignable to the result scalar type.  <br /></td></tr>
<tr class="separator:a556ce9ef4c27c543b02009cf66b4cb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7413586c20412dc26b7d59fd44e94806"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7413586c20412dc26b7d59fd44e94806"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__type__trait_gac9d3fe14d5102916bf0b5b05712c833e.html#gac9d3fe14d5102916bf0b5b05712c833e">real_return_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7413586c20412dc26b7d59fd44e94806.html#a7413586c20412dc26b7d59fd44e94806">serialize_return</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a7413586c20412dc26b7d59fd44e94806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialized the specified single argument.  <br /></td></tr>
<tr class="separator:a7413586c20412dc26b7d59fd44e94806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a547d372c89966bda5642249f3209fab7"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a547d372c89966bda5642249f3209fab7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a547d372c89966bda5642249f3209fab7.html#a547d372c89966bda5642249f3209fab7">serialize_args</a> (const Ts... xs)</td></tr>
<tr class="memdesc:a547d372c89966bda5642249f3209fab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialize the specified sequence of structured objects with double-based scalars into an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vector of double values.  <br /></td></tr>
<tr class="separator:a547d372c89966bda5642249f3209fab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01efc26078fd7a89235e96b4d7898f9"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad01efc26078fd7a89235e96b4d7898f9"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad01efc26078fd7a89235e96b4d7898f9.html#ad01efc26078fd7a89235e96b4d7898f9">sign</a> (const T &amp;z)</td></tr>
<tr class="separator:ad01efc26078fd7a89235e96b4d7898f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec8241508f45b89c73ede80f4a69b67"><td class="memTemplParams" colspan="2">template&lt;typename ADType , <a class="el" href="group__autodiff__types_ga9c0ebeb539d0429f2cbceb0fdb24c2d6.html#ga9c0ebeb539d0429f2cbceb0fdb24c2d6">require_autodiff_t</a>&lt; ADType &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afec8241508f45b89c73ede80f4a69b67"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afec8241508f45b89c73ede80f4a69b67.html#afec8241508f45b89c73ede80f4a69b67">signbit</a> (ADType &amp;&amp;v)</td></tr>
<tr class="memdesc:afec8241508f45b89c73ede80f4a69b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the specified argument is negative and <code>false</code> otherwise.  <br /></td></tr>
<tr class="separator:afec8241508f45b89c73ede80f4a69b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd81db923a78c51a490c8aac4f55855"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0bd81db923a78c51a490c8aac4f55855"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0bd81db923a78c51a490c8aac4f55855.html#a0bd81db923a78c51a490c8aac4f55855">sin</a> (const T x)</td></tr>
<tr class="memdesc:a0bd81db923a78c51a490c8aac4f55855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sine of the complex argument.  <br /></td></tr>
<tr class="separator:a0bd81db923a78c51a490c8aac4f55855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d5913e2d2d90f5ac89737e686588dd"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a07d5913e2d2d90f5ac89737e686588dd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a07d5913e2d2d90f5ac89737e686588dd.html#a07d5913e2d2d90f5ac89737e686588dd">sin</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a07d5913e2d2d90f5ac89737e686588dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a03498ae670c61712c7fb60381e97368e.html#a03498ae670c61712c7fb60381e97368e">sin()</a>.  <br /></td></tr>
<tr class="separator:a07d5913e2d2d90f5ac89737e686588dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8814ed6981127e4a0e2010ead478824"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga846e5c75f0e49887b255adb8e56e1a7e.html#ga846e5c75f0e49887b255adb8e56e1a7e">require_container_bt</a>&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae8814ed6981127e4a0e2010ead478824"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae8814ed6981127e4a0e2010ead478824.html#ae8814ed6981127e4a0e2010ead478824">sin</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ae8814ed6981127e4a0e2010ead478824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <a class="el" href="namespacestan_1_1math_a03498ae670c61712c7fb60381e97368e.html#a03498ae670c61712c7fb60381e97368e">sin()</a> that accepts std::vectors, <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <br /></td></tr>
<tr class="separator:ae8814ed6981127e4a0e2010ead478824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad101c75225637f8e1a75018e246919c5"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad101c75225637f8e1a75018e246919c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad101c75225637f8e1a75018e246919c5.html#ad101c75225637f8e1a75018e246919c5">singular_values</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:ad101c75225637f8e1a75018e246919c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the vector of the singular values of the specified matrix in decreasing order of magnitude.  <br /></td></tr>
<tr class="separator:ad101c75225637f8e1a75018e246919c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f8625b7fc673f8a9babbcde5f22d76"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab5f8625b7fc673f8a9babbcde5f22d76"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab5f8625b7fc673f8a9babbcde5f22d76.html#ab5f8625b7fc673f8a9babbcde5f22d76">sinh</a> (const T x)</td></tr>
<tr class="memdesc:ab5f8625b7fc673f8a9babbcde5f22d76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic sine of the arithmetic argument.  <br /></td></tr>
<tr class="separator:ab5f8625b7fc673f8a9babbcde5f22d76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf656a1bfc885b654cb549599611abb5"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acf656a1bfc885b654cb549599611abb5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acf656a1bfc885b654cb549599611abb5.html#acf656a1bfc885b654cb549599611abb5">sinh</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:acf656a1bfc885b654cb549599611abb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_a78c0cb63b379f6bdb4d5f77de9f95e66.html#a78c0cb63b379f6bdb4d5f77de9f95e66">sinh()</a>.  <br /></td></tr>
<tr class="separator:acf656a1bfc885b654cb549599611abb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8aaf093d045fbc9a6bf4b9792cb874d"><td class="memTemplParams" colspan="2">template&lt;typename ScalarT , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; ScalarT &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa8aaf093d045fbc9a6bf4b9792cb874d"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gaa8aaf093d045fbc9a6bf4b9792cb874d.html#gaa8aaf093d045fbc9a6bf4b9792cb874d">size_mvt</a> (const ScalarT &amp;)</td></tr>
<tr class="memdesc:gaa8aaf093d045fbc9a6bf4b9792cb874d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides the size of a multivariate argument.  <br /></td></tr>
<tr class="separator:gaa8aaf093d045fbc9a6bf4b9792cb874d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93357fede786bae591aed6588d5a789b"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; MatrixT &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a93357fede786bae591aed6588d5a789b"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a93357fede786bae591aed6588d5a789b.html#a93357fede786bae591aed6588d5a789b">size_mvt</a> (const MatrixT &amp;)</td></tr>
<tr class="separator:a93357fede786bae591aed6588d5a789b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740b1a634fb4a9d36f49378ce49d5fe2"><td class="memTemplParams" colspan="2">template&lt;typename MatrixT , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; MatrixT &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a740b1a634fb4a9d36f49378ce49d5fe2"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a740b1a634fb4a9d36f49378ce49d5fe2.html#a740b1a634fb4a9d36f49378ce49d5fe2">size_mvt</a> (const std::vector&lt; MatrixT &gt; &amp;x)</td></tr>
<tr class="separator:a740b1a634fb4a9d36f49378ce49d5fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa7124838a3c8c241f21d063016a58a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2aa7124838a3c8c241f21d063016a58a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2aa7124838a3c8c241f21d063016a58a.html#a2aa7124838a3c8c241f21d063016a58a">size_zero</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a2aa7124838a3c8c241f21d063016a58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if input is of length 0, returns 0 otherwise.  <br /></td></tr>
<tr class="separator:a2aa7124838a3c8c241f21d063016a58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac31032b503cd0f3e68155fb715281a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ts&gt; </td></tr>
<tr class="memitem:a2ac31032b503cd0f3e68155fb715281a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2ac31032b503cd0f3e68155fb715281a.html#a2ac31032b503cd0f3e68155fb715281a">size_zero</a> (const T &amp;x, const Ts &amp;... xs)</td></tr>
<tr class="memdesc:a2ac31032b503cd0f3e68155fb715281a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if any inputs are of length 0, returns 0 otherwise.  <br /></td></tr>
<tr class="separator:a2ac31032b503cd0f3e68155fb715281a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44619d87f2a3ada67ff1e0f19de1e19e"><td class="memTemplParams" colspan="2">template&lt;typename ColVec , <a class="el" href="group__eigen__col__vector__types_ga16729dba6fafa4f518defdf9cccd3488.html#ga16729dba6fafa4f518defdf9cccd3488">require_eigen_col_vector_vt</a>&lt; std::is_arithmetic, ColVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a44619d87f2a3ada67ff1e0f19de1e19e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; ColVec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a44619d87f2a3ada67ff1e0f19de1e19e.html#a44619d87f2a3ada67ff1e0f19de1e19e">softmax</a> (const ColVec &amp;v)</td></tr>
<tr class="memdesc:a44619d87f2a3ada67ff1e0f19de1e19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the softmax of the specified vector.  <br /></td></tr>
<tr class="separator:a44619d87f2a3ada67ff1e0f19de1e19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44020c35665efb68c861186bcf4f458a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a44020c35665efb68c861186bcf4f458a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a44020c35665efb68c861186bcf4f458a.html#a44020c35665efb68c861186bcf4f458a">sort_asc</a> (std::vector&lt; T &gt; xs)</td></tr>
<tr class="memdesc:a44020c35665efb68c861186bcf4f458a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified standard vector in ascending order.  <br /></td></tr>
<tr class="separator:a44020c35665efb68c861186bcf4f458a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9feae20dfb79453212470b267a268b"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7e9feae20dfb79453212470b267a268b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; EigVec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7e9feae20dfb79453212470b267a268b.html#a7e9feae20dfb79453212470b267a268b">sort_asc</a> (EigVec &amp;&amp;xs)</td></tr>
<tr class="memdesc:a7e9feae20dfb79453212470b267a268b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified vector in ascending order.  <br /></td></tr>
<tr class="separator:a7e9feae20dfb79453212470b267a268b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf8f0c7a0a60b497400f6b73c560f26"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abdf8f0c7a0a60b497400f6b73c560f26"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abdf8f0c7a0a60b497400f6b73c560f26.html#abdf8f0c7a0a60b497400f6b73c560f26">sort_desc</a> (std::vector&lt; T &gt; xs)</td></tr>
<tr class="memdesc:abdf8f0c7a0a60b497400f6b73c560f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified standard vector in descending order.  <br /></td></tr>
<tr class="separator:abdf8f0c7a0a60b497400f6b73c560f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f482d14dcdc40a380b22e037de04a7"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a73f482d14dcdc40a380b22e037de04a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; EigVec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a73f482d14dcdc40a380b22e037de04a7.html#a73f482d14dcdc40a380b22e037de04a7">sort_desc</a> (EigVec &amp;&amp;xs)</td></tr>
<tr class="memdesc:a73f482d14dcdc40a380b22e037de04a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified vector in descending order.  <br /></td></tr>
<tr class="separator:a73f482d14dcdc40a380b22e037de04a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41837713abcf801eb370fd4efc42bc95"><td class="memTemplParams" colspan="2">template&lt;bool ascending, typename C &gt; </td></tr>
<tr class="memitem:a41837713abcf801eb370fd4efc42bc95"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a41837713abcf801eb370fd4efc42bc95.html#a41837713abcf801eb370fd4efc42bc95">sort_indices</a> (const C &amp;xs)</td></tr>
<tr class="memdesc:a41837713abcf801eb370fd4efc42bc95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an integer array of indices of the specified container sorting the values in ascending or descending order based on the value of the first template parameter.  <br /></td></tr>
<tr class="separator:a41837713abcf801eb370fd4efc42bc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d53574cc064a24fb6eba5c3c78eaac"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a56d53574cc064a24fb6eba5c3c78eaac"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a56d53574cc064a24fb6eba5c3c78eaac.html#a56d53574cc064a24fb6eba5c3c78eaac">sort_indices_asc</a> (const C &amp;xs)</td></tr>
<tr class="memdesc:a56d53574cc064a24fb6eba5c3c78eaac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sorted copy of the argument container in ascending order.  <br /></td></tr>
<tr class="separator:a56d53574cc064a24fb6eba5c3c78eaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5ee26ef6f95dccf93db133e80580e4"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a6d5ee26ef6f95dccf93db133e80580e4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6d5ee26ef6f95dccf93db133e80580e4.html#a6d5ee26ef6f95dccf93db133e80580e4">sort_indices_desc</a> (const C &amp;xs)</td></tr>
<tr class="memdesc:a6d5ee26ef6f95dccf93db133e80580e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a sorted copy of the argument container in ascending order.  <br /></td></tr>
<tr class="separator:a6d5ee26ef6f95dccf93db133e80580e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cf50f38064e971d8976c97c1f3034e"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a86cf50f38064e971d8976c97c1f3034e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a86cf50f38064e971d8976c97c1f3034e.html#a86cf50f38064e971d8976c97c1f3034e">sqrt</a> (const T x)</td></tr>
<tr class="memdesc:a86cf50f38064e971d8976c97c1f3034e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of the arithmetic argument.  <br /></td></tr>
<tr class="separator:a86cf50f38064e971d8976c97c1f3034e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79f22468f05a60ad4d531d4f79e0d7a"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae79f22468f05a60ad4d531d4f79e0d7a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae79f22468f05a60ad4d531d4f79e0d7a.html#ae79f22468f05a60ad4d531d4f79e0d7a">sqrt</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ae79f22468f05a60ad4d531d4f79e0d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <code><a class="el" href="namespacestan_1_1math_a81819d20047b4d6c264b58e35bb2c48d.html#a81819d20047b4d6c264b58e35bb2c48d">sqrt()</a></code>.  <br /></td></tr>
<tr class="separator:ae79f22468f05a60ad4d531d4f79e0d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37a6a298ce1b6b6d6328bf8a87954f1"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga846e5c75f0e49887b255adb8e56e1a7e.html#ga846e5c75f0e49887b255adb8e56e1a7e">require_container_bt</a>&lt; std::is_arithmetic, Container &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae37a6a298ce1b6b6d6328bf8a87954f1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae37a6a298ce1b6b6d6328bf8a87954f1.html#ae37a6a298ce1b6b6d6328bf8a87954f1">sqrt</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ae37a6a298ce1b6b6d6328bf8a87954f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of <code><a class="el" href="namespacestan_1_1math_a81819d20047b4d6c264b58e35bb2c48d.html#a81819d20047b4d6c264b58e35bb2c48d">sqrt()</a></code> that accepts std::vectors, <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Matrix/Array objects or expressions, and containers of these.  <br /></td></tr>
<tr class="separator:ae37a6a298ce1b6b6d6328bf8a87954f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff0e2b068fe4f05030e3f3d9a0294bf"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afff0e2b068fe4f05030e3f3d9a0294bf"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afff0e2b068fe4f05030e3f3d9a0294bf.html#afff0e2b068fe4f05030e3f3d9a0294bf">square</a> (const T x)</td></tr>
<tr class="memdesc:afff0e2b068fe4f05030e3f3d9a0294bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of the specified argument.  <br /></td></tr>
<tr class="separator:afff0e2b068fe4f05030e3f3d9a0294bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ccad831392dfa7fb6e5441bc782e1c"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a07ccad831392dfa7fb6e5441bc782e1c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a07ccad831392dfa7fb6e5441bc782e1c.html#a07ccad831392dfa7fb6e5441bc782e1c">square</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a07ccad831392dfa7fb6e5441bc782e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_af94738d2bfd07182b4aaa7e18a62fb74.html#af94738d2bfd07182b4aaa7e18a62fb74">square()</a>.  <br /></td></tr>
<tr class="separator:a07ccad831392dfa7fb6e5441bc782e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e673b97096569cfa09bf4fcd3e7c3cd"><td class="memTemplParams" colspan="2">template&lt;typename Scal1 , typename Scal2 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; Scal1, Scal2 &gt; *  = nullptr, <a class="el" href="group__var__types_gacd1267e326cb7764f47ddfba577dabdb.html#gacd1267e326cb7764f47ddfba577dabdb">require_all_not_var_t</a>&lt; Scal1, Scal2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6e673b97096569cfa09bf4fcd3e7c3cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Scal1, Scal2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6e673b97096569cfa09bf4fcd3e7c3cd.html#a6e673b97096569cfa09bf4fcd3e7c3cd">squared_distance</a> (const Scal1 &amp;x1, const Scal2 &amp;x2)</td></tr>
<tr class="memdesc:a6e673b97096569cfa09bf4fcd3e7c3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance.  <br /></td></tr>
<tr class="separator:a6e673b97096569cfa09bf4fcd3e7c3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f60fe35e0eba6744c4d85dd94d26d90"><td class="memTemplParams" colspan="2">template&lt;typename EigVec1 , typename EigVec2 , <a class="el" href="group__eigen__vector__types_gaf8c3e4d9b301746f5374ae7237eeab66.html#gaf8c3e4d9b301746f5374ae7237eeab66">require_all_eigen_vector_t</a>&lt; EigVec1, EigVec2 &gt; *  = nullptr, <a class="el" href="group__eigen__types_gac30da5b4d9bf217de273208379b7b92e.html#gac30da5b4d9bf217de273208379b7b92e">require_all_not_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, EigVec1, EigVec2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7f60fe35e0eba6744c4d85dd94d26d90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigVec1, EigVec2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7f60fe35e0eba6744c4d85dd94d26d90.html#a7f60fe35e0eba6744c4d85dd94d26d90">squared_distance</a> (const EigVec1 &amp;v1, const EigVec2 &amp;v2)</td></tr>
<tr class="memdesc:a7f60fe35e0eba6744c4d85dd94d26d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance between the specified vectors of the same dimensions.  <br /></td></tr>
<tr class="separator:a7f60fe35e0eba6744c4d85dd94d26d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cd98e205f627d483570fd0c9e9ac1d"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__container__types_ga459f89baca338578dee731a64a13cbe0.html#ga459f89baca338578dee731a64a13cbe0">require_not_container_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__tuple__types_gaf4445afe30360a232c34a8ef2efaea14.html#gaf4445afe30360a232c34a8ef2efaea14">require_not_tuple_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a67cd98e205f627d483570fd0c9e9ac1d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a67cd98e205f627d483570fd0c9e9ac1d.html#a67cd98e205f627d483570fd0c9e9ac1d">stan_print</a> (std::ostream *o, const T &amp;x)</td></tr>
<tr class="separator:a67cd98e205f627d483570fd0c9e9ac1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7594018532e7e465f028676dd1b3b2b0"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7594018532e7e465f028676dd1b3b2b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7594018532e7e465f028676dd1b3b2b0.html#a7594018532e7e465f028676dd1b3b2b0">stan_print</a> (std::ostream *o, const EigVec &amp;x)</td></tr>
<tr class="separator:a7594018532e7e465f028676dd1b3b2b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723e116c3a7e9161911a23420611f213"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__eigen__vector__types_ga96346a2dd6e69cd00862a734ed66532d.html#ga96346a2dd6e69cd00862a734ed66532d">require_not_eigen_vector_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a723e116c3a7e9161911a23420611f213"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a723e116c3a7e9161911a23420611f213.html#a723e116c3a7e9161911a23420611f213">stan_print</a> (std::ostream *o, const EigMat &amp;x)</td></tr>
<tr class="separator:a723e116c3a7e9161911a23420611f213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace42bb9974f5fbe1e30f9a4a5fc50c0b"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__tuple__types_ga47313edb9e9a3f50f4423f5b54b14da7.html#ga47313edb9e9a3f50f4423f5b54b14da7">require_tuple_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ace42bb9974f5fbe1e30f9a4a5fc50c0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ace42bb9974f5fbe1e30f9a4a5fc50c0b.html#ace42bb9974f5fbe1e30f9a4a5fc50c0b">stan_print</a> (std::ostream *o, const T &amp;x)</td></tr>
<tr class="separator:ace42bb9974f5fbe1e30f9a4a5fc50c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee16e810d0e707c24f7274af63f8635"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4ee16e810d0e707c24f7274af63f8635"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4ee16e810d0e707c24f7274af63f8635.html#a4ee16e810d0e707c24f7274af63f8635">step</a> (const T &amp;y)</td></tr>
<tr class="memdesc:a4ee16e810d0e707c24f7274af63f8635"><td class="mdescLeft">&#160;</td><td class="mdescRight">The step, or Heaviside, function.  <br /></td></tr>
<tr class="separator:a4ee16e810d0e707c24f7274af63f8635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04620f821b34ac0beffdb9727f268130"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__container__types_gac5dfcc325ecaff91dd97f8a1a8f09431.html#gac5dfcc325ecaff91dd97f8a1a8f09431">require_container_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a04620f821b34ac0beffdb9727f268130"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a04620f821b34ac0beffdb9727f268130.html#a04620f821b34ac0beffdb9727f268130">step</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a04620f821b34ac0beffdb9727f268130"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a4ee16e810d0e707c24f7274af63f8635.html#a4ee16e810d0e707c24f7274af63f8635" title="The step, or Heaviside, function.">step()</a></code> to specified argument container.  <br /></td></tr>
<tr class="separator:a04620f821b34ac0beffdb9727f268130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e49cae251175dfc267aae38af76c1f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a67e49cae251175dfc267aae38af76c1f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a67e49cae251175dfc267aae38af76c1f.html#a67e49cae251175dfc267aae38af76c1f">sub_col</a> (const T &amp;m, size_t i, size_t j, size_t nrows)</td></tr>
<tr class="memdesc:a67e49cae251175dfc267aae38af76c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a nrows x 1 subcolumn starting at (i-1, j-1).  <br /></td></tr>
<tr class="separator:a67e49cae251175dfc267aae38af76c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b39a3595da70eb89b520b979bb74c31"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1b39a3595da70eb89b520b979bb74c31"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1b39a3595da70eb89b520b979bb74c31.html#a1b39a3595da70eb89b520b979bb74c31">sub_row</a> (const T &amp;m, size_t i, size_t j, size_t ncols)</td></tr>
<tr class="memdesc:a1b39a3595da70eb89b520b979bb74c31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a 1 x ncols subrow starting at (i-1, j-1).  <br /></td></tr>
<tr class="separator:a1b39a3595da70eb89b520b979bb74c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571975a323f1e9ef0584caf582bc64bb"><td class="memTemplParams" colspan="2">template&lt;typename ScalarA , typename ScalarB , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; ScalarA, ScalarB &gt; *  = nullptr, <a class="el" href="group__var__types_gacd1267e326cb7764f47ddfba577dabdb.html#gacd1267e326cb7764f47ddfba577dabdb">require_all_not_var_t</a>&lt; ScalarA, ScalarB &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a571975a323f1e9ef0584caf582bc64bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; ScalarA, ScalarB &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a571975a323f1e9ef0584caf582bc64bb.html#a571975a323f1e9ef0584caf582bc64bb">subtract</a> (const ScalarA &amp;a, const ScalarB &amp;b)</td></tr>
<tr class="memdesc:a571975a323f1e9ef0584caf582bc64bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of subtracting the second scalar from the first scalar.  <br /></td></tr>
<tr class="separator:a571975a323f1e9ef0584caf582bc64bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5271ab237f1b64536256e11f84fef0e5"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5271ab237f1b64536256e11f84fef0e5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5271ab237f1b64536256e11f84fef0e5.html#a5271ab237f1b64536256e11f84fef0e5">subtract</a> (const Mat1 &amp;m1, const Mat2 &amp;m2)</td></tr>
<tr class="memdesc:a5271ab237f1b64536256e11f84fef0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of subtracting the second specified matrix from the first specified matrix.  <br /></td></tr>
<tr class="separator:a5271ab237f1b64536256e11f84fef0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c610fa5dd31e027d24ee1cca68d105b"><td class="memTemplParams" colspan="2">template&lt;typename Scal , typename Mat , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; Mat, Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6c610fa5dd31e027d24ee1cca68d105b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6c610fa5dd31e027d24ee1cca68d105b.html#a6c610fa5dd31e027d24ee1cca68d105b">subtract</a> (const Scal c, const Mat &amp;m)</td></tr>
<tr class="memdesc:a6c610fa5dd31e027d24ee1cca68d105b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of subtracting the specified matrix from the specified scalar.  <br /></td></tr>
<tr class="separator:a6c610fa5dd31e027d24ee1cca68d105b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d3ce82fde36dbcc8eb3158f48326dc"><td class="memTemplParams" colspan="2">template&lt;typename Mat , typename Scal , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; Scal, Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a34d3ce82fde36dbcc8eb3158f48326dc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a34d3ce82fde36dbcc8eb3158f48326dc.html#a34d3ce82fde36dbcc8eb3158f48326dc">subtract</a> (const Mat &amp;m, const Scal c)</td></tr>
<tr class="memdesc:a34d3ce82fde36dbcc8eb3158f48326dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of subtracting the specified scalar from the specified matrix.  <br /></td></tr>
<tr class="separator:a34d3ce82fde36dbcc8eb3158f48326dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac459ffd33c159edf3bb7b61f9daf0bc2"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac459ffd33c159edf3bb7b61f9daf0bc2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac459ffd33c159edf3bb7b61f9daf0bc2.html#ac459ffd33c159edf3bb7b61f9daf0bc2">sum</a> (T &amp;&amp;m)</td></tr>
<tr class="memdesc:ac459ffd33c159edf3bb7b61f9daf0bc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns specified input value.  <br /></td></tr>
<tr class="separator:ac459ffd33c159edf3bb7b61f9daf0bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e26d40598b8d6e024bc435210dbfbbe"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__autodiff__types_ga1d7ae63931f33367e3ea01a5cd728c3d.html#ga1d7ae63931f33367e3ea01a5cd728c3d">require_not_autodiff_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3e26d40598b8d6e024bc435210dbfbbe"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3e26d40598b8d6e024bc435210dbfbbe.html#a3e26d40598b8d6e024bc435210dbfbbe">sum</a> (const std::vector&lt; T &gt; &amp;m)</td></tr>
<tr class="memdesc:a3e26d40598b8d6e024bc435210dbfbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sum of the values in the specified standard vector.  <br /></td></tr>
<tr class="separator:a3e26d40598b8d6e024bc435210dbfbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d007d0f1186f0501b86437f3e10eee"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af8d007d0f1186f0501b86437f3e10eee"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, -1, -1 &gt;, Eigen::Matrix&lt; <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; EigMat &gt;, -1, 1 &gt;, Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, -1, -1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af8d007d0f1186f0501b86437f3e10eee.html#af8d007d0f1186f0501b86437f3e10eee">svd</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:af8d007d0f1186f0501b86437f3e10eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given input matrix m, return the singular value decomposition (U,D,V) such that <code>m = U*diag(D)*V^{T}</code>  <br /></td></tr>
<tr class="separator:af8d007d0f1186f0501b86437f3e10eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2779980dc710a9452924c4cc182355e2"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2779980dc710a9452924c4cc182355e2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2779980dc710a9452924c4cc182355e2.html#a2779980dc710a9452924c4cc182355e2">svd_U</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a2779980dc710a9452924c4cc182355e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given input matrix m, return matrix U where <code>m = UDV^{T}</code>  <br /></td></tr>
<tr class="separator:a2779980dc710a9452924c4cc182355e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8ba5fff252b1e6e9fe0a7ccfdc3ab7"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aff8ba5fff252b1e6e9fe0a7ccfdc3ab7"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aff8ba5fff252b1e6e9fe0a7ccfdc3ab7.html#aff8ba5fff252b1e6e9fe0a7ccfdc3ab7">svd_V</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:aff8ba5fff252b1e6e9fe0a7ccfdc3ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given input matrix m, return matrix V where <code>m = UDV^{T}</code>  <br /></td></tr>
<tr class="separator:aff8ba5fff252b1e6e9fe0a7ccfdc3ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1c16ea69b21883bf60f24f90b30b0f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1e1c16ea69b21883bf60f24f90b30b0f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1e1c16ea69b21883bf60f24f90b30b0f.html#a1e1c16ea69b21883bf60f24f90b30b0f">symmetrize_from_lower_tri</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a1e1c16ea69b21883bf60f24f90b30b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a symmetric matrix using elements from the lower triangular part of the input matrix.  <br /></td></tr>
<tr class="separator:a1e1c16ea69b21883bf60f24f90b30b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c31b8e416b5aeca63fb3d9269af504"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af0c31b8e416b5aeca63fb3d9269af504"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af0c31b8e416b5aeca63fb3d9269af504.html#af0c31b8e416b5aeca63fb3d9269af504">symmetrize_from_upper_tri</a> (const T &amp;m)</td></tr>
<tr class="memdesc:af0c31b8e416b5aeca63fb3d9269af504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a symmetric matrix using elements from the upper triangular part of the input matrix.  <br /></td></tr>
<tr class="separator:af0c31b8e416b5aeca63fb3d9269af504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68e83105d9d3c1629ae9c91121bc1b1"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__vector__types_ga49bbe2450e11ac6a02210ab0dcde62bb.html#ga49bbe2450e11ac6a02210ab0dcde62bb">require_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab68e83105d9d3c1629ae9c91121bc1b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab68e83105d9d3c1629ae9c91121bc1b1.html#ab68e83105d9d3c1629ae9c91121bc1b1">tail</a> (const T &amp;v, size_t n)</td></tr>
<tr class="memdesc:ab68e83105d9d3c1629ae9c91121bc1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a vector or row vector (same as input) from the back of the specified vector or row vector.  <br /></td></tr>
<tr class="separator:ab68e83105d9d3c1629ae9c91121bc1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba1248dcd59e4cf2c244d410fb32c5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ba1248dcd59e4cf2c244d410fb32c5a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ba1248dcd59e4cf2c244d410fb32c5a.html#a9ba1248dcd59e4cf2c244d410fb32c5a">tail</a> (const std::vector&lt; T &gt; &amp;sv, size_t n)</td></tr>
<tr class="memdesc:a9ba1248dcd59e4cf2c244d410fb32c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified number of elements as a standard vector from the back of the specified standard vector.  <br /></td></tr>
<tr class="separator:a9ba1248dcd59e4cf2c244d410fb32c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12a99e86a0bedfe4320a08cb8b4e52f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab12a99e86a0bedfe4320a08cb8b4e52f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab12a99e86a0bedfe4320a08cb8b4e52f.html#ab12a99e86a0bedfe4320a08cb8b4e52f">tan</a> (const T x)</td></tr>
<tr class="memdesc:ab12a99e86a0bedfe4320a08cb8b4e52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tangent of the arithmetic argument.  <br /></td></tr>
<tr class="separator:ab12a99e86a0bedfe4320a08cb8b4e52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbaa36f1e9691e3c92be71f9e7041c37"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afbaa36f1e9691e3c92be71f9e7041c37"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afbaa36f1e9691e3c92be71f9e7041c37.html#afbaa36f1e9691e3c92be71f9e7041c37">tan</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:afbaa36f1e9691e3c92be71f9e7041c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <code><a class="el" href="namespacestan_1_1math_a89071e8c3d80fe0b2ac0b23c345e9a9e.html#a89071e8c3d80fe0b2ac0b23c345e9a9e">tan()</a></code>.  <br /></td></tr>
<tr class="separator:afbaa36f1e9691e3c92be71f9e7041c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76fb2c5469a9f95ee975ee7dd2cd686"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af76fb2c5469a9f95ee975ee7dd2cd686"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af76fb2c5469a9f95ee975ee7dd2cd686.html#af76fb2c5469a9f95ee975ee7dd2cd686">tanh</a> (const T x)</td></tr>
<tr class="memdesc:af76fb2c5469a9f95ee975ee7dd2cd686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic tangent of the arithmetic argument.  <br /></td></tr>
<tr class="separator:af76fb2c5469a9f95ee975ee7dd2cd686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a1e69077c84dbc1619541732a385b3"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__container__types_ga097f517435706b1230d9d9f60a9b521b.html#ga097f517435706b1230d9d9f60a9b521b">require_ad_container_t</a>&lt; Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae6a1e69077c84dbc1619541732a385b3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae6a1e69077c84dbc1619541732a385b3.html#ae6a1e69077c84dbc1619541732a385b3">tanh</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:ae6a1e69077c84dbc1619541732a385b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <code><a class="el" href="namespacestan_1_1math_ab32c5cd88becea57416c65688771a7c8.html#ab32c5cd88becea57416c65688771a7c8">tanh()</a></code>.  <br /></td></tr>
<tr class="separator:ae6a1e69077c84dbc1619541732a385b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae675047ee8f394fcb9ec5f1e95dc6a7d"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; std::is_arithmetic, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae675047ee8f394fcb9ec5f1e95dc6a7d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;, T::RowsAtCompileTime, T::RowsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae675047ee8f394fcb9ec5f1e95dc6a7d.html#ae675047ee8f394fcb9ec5f1e95dc6a7d">tcrossprod</a> (const T &amp;M)</td></tr>
<tr class="memdesc:ae675047ee8f394fcb9ec5f1e95dc6a7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of post-multiplying a matrix by its own transpose.  <br /></td></tr>
<tr class="separator:ae675047ee8f394fcb9ec5f1e95dc6a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6b2a872141f3a9d7b2aff0dae078b07"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa6b2a872141f3a9d7b2aff0dae078b07.html#aa6b2a872141f3a9d7b2aff0dae078b07">tgamma</a> (double x)</td></tr>
<tr class="memdesc:aa6b2a872141f3a9d7b2aff0dae078b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the gamma function applied to the specified argument.  <br /></td></tr>
<tr class="separator:aa6b2a872141f3a9d7b2aff0dae078b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae7b06ec937180ec5f3b2839d7de014"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6ae7b06ec937180ec5f3b2839d7de014"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6ae7b06ec937180ec5f3b2839d7de014.html#a6ae7b06ec937180ec5f3b2839d7de014">tgamma</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a6ae7b06ec937180ec5f3b2839d7de014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vectorized version of <a class="el" href="namespacestan_1_1math_acad338502e3115d34682603230479d41.html#acad338502e3115d34682603230479d41" title="Return the result of applying the gamma function to the specified argument.">tgamma()</a>.  <br /></td></tr>
<tr class="separator:a6ae7b06ec937180ec5f3b2839d7de014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52938aa77de13f872e0bd0ef19c52cb4"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a52938aa77de13f872e0bd0ef19c52cb4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a52938aa77de13f872e0bd0ef19c52cb4.html#a52938aa77de13f872e0bd0ef19c52cb4">to_array_1d</a> (const EigMat &amp;matrix)</td></tr>
<tr class="separator:a52938aa77de13f872e0bd0ef19c52cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d3344f45fa5656a5b1940d52a7b426"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac7d3344f45fa5656a5b1940d52a7b426"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac7d3344f45fa5656a5b1940d52a7b426.html#ac7d3344f45fa5656a5b1940d52a7b426">to_array_1d</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:ac7d3344f45fa5656a5b1940d52a7b426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b297ee13d69133afb6e045713cb063"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac3b297ee13d69133afb6e045713cb063"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="structstan_1_1scalar__type.html">scalar_type</a>&lt; T &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac3b297ee13d69133afb6e045713cb063.html#ac3b297ee13d69133afb6e045713cb063">to_array_1d</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x)</td></tr>
<tr class="separator:ac3b297ee13d69133afb6e045713cb063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ab8f8bde6deb35bc43345973a4d110"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a92ab8f8bde6deb35bc43345973a4d110"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a92ab8f8bde6deb35bc43345973a4d110.html#a92ab8f8bde6deb35bc43345973a4d110">to_array_2d</a> (const EigMat &amp;matrix)</td></tr>
<tr class="separator:a92ab8f8bde6deb35bc43345973a4d110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a475490b7f7990aef65cd0d9ff6823148"><td class="memTemplParams" colspan="2">template&lt;typename T  = double, typename S  = double, <a class="el" href="group__container__types_gafd0bb8a697162d702a167b7a3918cf09.html#gafd0bb8a697162d702a167b7a3918cf09">require_all_not_container_t</a>&lt; T, S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a475490b7f7990aef65cd0d9ff6823148"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::complex&lt; <a class="el" href="group__type__trait_gac9d3fe14d5102916bf0b5b05712c833e.html#gac9d3fe14d5102916bf0b5b05712c833e">stan::real_return_t</a>&lt; T, S &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a475490b7f7990aef65cd0d9ff6823148.html#a475490b7f7990aef65cd0d9ff6823148">to_complex</a> (const T &amp;re=0, const S &amp;im=0)</td></tr>
<tr class="memdesc:a475490b7f7990aef65cd0d9ff6823148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a complex value from a real component and an imaginary component.  <br /></td></tr>
<tr class="separator:a475490b7f7990aef65cd0d9ff6823148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb769176f6114ac45be33f245da1acd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_gaf0326ae68f45d604f606567bf6c318e2.html#gaf0326ae68f45d604f606567bf6c318e2">require_all_st_stan_scalar</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3fb769176f6114ac45be33f245da1acd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3fb769176f6114ac45be33f245da1acd.html#a3fb769176f6114ac45be33f245da1acd">to_complex</a> (const T1 &amp;re, const T2 &amp;im)</td></tr>
<tr class="memdesc:a3fb769176f6114ac45be33f245da1acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a complex valued container from a real component and an imaginary component.  <br /></td></tr>
<tr class="separator:a3fb769176f6114ac45be33f245da1acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad10cc18c6e86357217fecedca8825c96"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__integral__types_ga31729c13937697c747fee3e83c0b957e.html#ga31729c13937697c747fee3e83c0b957e">require_integral_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad10cc18c6e86357217fecedca8825c96"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad10cc18c6e86357217fecedca8825c96.html#ad10cc18c6e86357217fecedca8825c96">to_int</a> (T x)</td></tr>
<tr class="memdesc:ad10cc18c6e86357217fecedca8825c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input scalar as an integer type.  <br /></td></tr>
<tr class="separator:ad10cc18c6e86357217fecedca8825c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a918d940e9012b956021e884814d4fa"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__floating__point__types_ga94fb93a2c53b62e4f71947afbf3de358.html#ga94fb93a2c53b62e4f71947afbf3de358">require_floating_point_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4a918d940e9012b956021e884814d4fa"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a918d940e9012b956021e884814d4fa.html#a4a918d940e9012b956021e884814d4fa">to_int</a> (T x)</td></tr>
<tr class="memdesc:a4a918d940e9012b956021e884814d4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the input scalar as an integer type.  <br /></td></tr>
<tr class="separator:a4a918d940e9012b956021e884814d4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114332a122c003b3c9ac9b62361154cc"><td class="memTemplParams" colspan="2">template&lt;typename Container , <a class="el" href="group__std__vector__types_ga513b41fcdff562ebb8bc2cd5e3ea8faa.html#ga513b41fcdff562ebb8bc2cd5e3ea8faa">require_std_vector_st</a>&lt; std::is_arithmetic, Container &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a114332a122c003b3c9ac9b62361154cc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a114332a122c003b3c9ac9b62361154cc.html#a114332a122c003b3c9ac9b62361154cc">to_int</a> (const Container &amp;x)</td></tr>
<tr class="memdesc:a114332a122c003b3c9ac9b62361154cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elementwise <code><a class="el" href="namespacestan_1_1math_ad10cc18c6e86357217fecedca8825c96.html#ad10cc18c6e86357217fecedca8825c96" title="Returns the input scalar as an integer type.">to_int()</a></code> of the input, which may be a scalar or any Stan container of numeric scalars.  <br /></td></tr>
<tr class="separator:a114332a122c003b3c9ac9b62361154cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ad676574bc770c93e801ae72182e7b"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__dense__dynamic__types_ga7b9ea2ce30eb6b679b63ac5630027d95.html#ga7b9ea2ce30eb6b679b63ac5630027d95">require_eigen_dense_dynamic_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a01ad676574bc770c93e801ae72182e7b"><td class="memTemplItemLeft" align="right" valign="top">EigMat&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a01ad676574bc770c93e801ae72182e7b.html#a01ad676574bc770c93e801ae72182e7b">to_matrix</a> (EigMat &amp;&amp;x)</td></tr>
<tr class="memdesc:a01ad676574bc770c93e801ae72182e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix with dynamic dimensions constructed from an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix.  <br /></td></tr>
<tr class="separator:a01ad676574bc770c93e801ae72182e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5766fea16f0d03147b15b47d9c57e7b"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac5766fea16f0d03147b15b47d9c57e7b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac5766fea16f0d03147b15b47d9c57e7b.html#ac5766fea16f0d03147b15b47d9c57e7b">to_matrix</a> (EigVec &amp;&amp;matrix)</td></tr>
<tr class="memdesc:ac5766fea16f0d03147b15b47d9c57e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix with dynamic dimensions constructed from an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> row or column vector.  <br /></td></tr>
<tr class="separator:ac5766fea16f0d03147b15b47d9c57e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fb9eb8bb4fdef216523c53753cd4db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac8fb9eb8bb4fdef216523c53753cd4db"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac8fb9eb8bb4fdef216523c53753cd4db.html#ac8fb9eb8bb4fdef216523c53753cd4db">to_matrix</a> (const std::vector&lt; Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt; &gt; &amp;x)</td></tr>
<tr class="memdesc:ac8fb9eb8bb4fdef216523c53753cd4db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of a standard vector of <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> row vectors with the same dimensions and indexing order.  <br /></td></tr>
<tr class="separator:ac8fb9eb8bb4fdef216523c53753cd4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be26d0fc219abaad2265379966c109c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0be26d0fc219abaad2265379966c109c"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, double &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0be26d0fc219abaad2265379966c109c.html#a0be26d0fc219abaad2265379966c109c">to_matrix</a> (const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;x)</td></tr>
<tr class="memdesc:a0be26d0fc219abaad2265379966c109c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of the standard vector of standard vectors with the same dimensions and indexing order.  <br /></td></tr>
<tr class="separator:a0be26d0fc219abaad2265379966c109c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b08a729fe51b13a5a5b5a8e918cc1fb"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7b08a729fe51b13a5a5b5a8e918cc1fb"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7b08a729fe51b13a5a5b5a8e918cc1fb.html#a7b08a729fe51b13a5a5b5a8e918cc1fb">to_matrix</a> (EigMat &amp;&amp;x, int m, int n)</td></tr>
<tr class="memdesc:a7b08a729fe51b13a5a5b5a8e918cc1fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of the vector in column-major order with the specified number of rows and columns.  <br /></td></tr>
<tr class="separator:a7b08a729fe51b13a5a5b5a8e918cc1fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d304ce4be8060879e8fdaf2096c5211"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3d304ce4be8060879e8fdaf2096c5211"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3d304ce4be8060879e8fdaf2096c5211.html#a3d304ce4be8060879e8fdaf2096c5211">to_matrix</a> (const std::vector&lt; T &gt; &amp;x, int m, int n)</td></tr>
<tr class="memdesc:a3d304ce4be8060879e8fdaf2096c5211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of the vector in column-major order with the specified number of rows and columns.  <br /></td></tr>
<tr class="separator:a3d304ce4be8060879e8fdaf2096c5211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990b3a452332c2c5ec6fcd805ef04e2f"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a990b3a452332c2c5ec6fcd805ef04e2f.html#a990b3a452332c2c5ec6fcd805ef04e2f">to_matrix</a> (const std::vector&lt; int &gt; &amp;x, int m, int n)</td></tr>
<tr class="memdesc:a990b3a452332c2c5ec6fcd805ef04e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of the vector in column-major order with the specified number of rows and columns.  <br /></td></tr>
<tr class="separator:a990b3a452332c2c5ec6fcd805ef04e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5208506006a1f89a322885da5c00f68"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad5208506006a1f89a322885da5c00f68"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad5208506006a1f89a322885da5c00f68.html#ad5208506006a1f89a322885da5c00f68">to_matrix</a> (EigMat &amp;&amp;x, int m, int n, bool col_major)</td></tr>
<tr class="memdesc:ad5208506006a1f89a322885da5c00f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of the vector in column-major order with the specified number of rows and columns.  <br /></td></tr>
<tr class="separator:ad5208506006a1f89a322885da5c00f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f59bc2f2a9b69fce6823e7ed177265"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af4f59bc2f2a9b69fce6823e7ed177265"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, double &gt;, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af4f59bc2f2a9b69fce6823e7ed177265.html#af4f59bc2f2a9b69fce6823e7ed177265">to_matrix</a> (const std::vector&lt; T &gt; &amp;x, int m, int n, bool col_major)</td></tr>
<tr class="memdesc:af4f59bc2f2a9b69fce6823e7ed177265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a matrix representation of the vector in column-major order with the specified number of rows and columns.  <br /></td></tr>
<tr class="separator:af4f59bc2f2a9b69fce6823e7ed177265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91d95e0eb1d304bd74adee41641f784e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a91d95e0eb1d304bd74adee41641f784e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a98f14126101865ddd8f5562480ad4927.html#a98f14126101865ddd8f5562480ad4927">ref_type_t</a>&lt; T &amp;&amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a91d95e0eb1d304bd74adee41641f784e.html#a91d95e0eb1d304bd74adee41641f784e">to_ref</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a91d95e0eb1d304bd74adee41641f784e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This evaluates expensive <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expressions.  <br /></td></tr>
<tr class="separator:a91d95e0eb1d304bd74adee41641f784e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6a46d167aa3367672cd930e2f4ab1e"><td class="memTemplParams" colspan="2">template&lt;bool Cond, typename T , std::enable_if_t&lt;!Cond &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b6a46d167aa3367672cd930e2f4ab1e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4b6a46d167aa3367672cd930e2f4ab1e.html#a4b6a46d167aa3367672cd930e2f4ab1e">to_ref_if</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a4b6a46d167aa3367672cd930e2f4ab1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-op that should be optimized away.  <br /></td></tr>
<tr class="separator:a4b6a46d167aa3367672cd930e2f4ab1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb08891bcee55419284c3f4201ca4d3"><td class="memTemplParams" colspan="2">template&lt;bool Cond, typename T , std::enable_if_t&lt; Cond &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:affb08891bcee55419284c3f4201ca4d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a98f14126101865ddd8f5562480ad4927.html#a98f14126101865ddd8f5562480ad4927">ref_type_t</a>&lt; T &amp;&amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_affb08891bcee55419284c3f4201ca4d3.html#affb08891bcee55419284c3f4201ca4d3">to_ref_if</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:affb08891bcee55419284c3f4201ca4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the condition is true, evaluates expensive <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> expressions.  <br /></td></tr>
<tr class="separator:affb08891bcee55419284c3f4201ca4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff61993100f6ab9e51d086f4fbe5a6ed"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aff61993100f6ab9e51d086f4fbe5a6ed"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, 1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aff61993100f6ab9e51d086f4fbe5a6ed.html#aff61993100f6ab9e51d086f4fbe5a6ed">to_row_vector</a> (const EigMat &amp;matrix)</td></tr>
<tr class="separator:aff61993100f6ab9e51d086f4fbe5a6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8221868edcf77c7b6e55faf096601669"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8221868edcf77c7b6e55faf096601669"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, 1, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8221868edcf77c7b6e55faf096601669.html#a8221868edcf77c7b6e55faf096601669">to_row_vector</a> (const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:a8221868edcf77c7b6e55faf096601669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930a98c81ab64857a03b36406dea2616"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, 1, Eigen::Dynamic &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a930a98c81ab64857a03b36406dea2616.html#a930a98c81ab64857a03b36406dea2616">to_row_vector</a> (const std::vector&lt; int &gt; &amp;vec)</td></tr>
<tr class="separator:a930a98c81ab64857a03b36406dea2616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1627bf251ce5c5d4be994cc83c40d7d6"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1627bf251ce5c5d4be994cc83c40d7d6"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1627bf251ce5c5d4be994cc83c40d7d6.html#a1627bf251ce5c5d4be994cc83c40d7d6">to_vector</a> (const EigMat &amp;matrix)</td></tr>
<tr class="separator:a1627bf251ce5c5d4be994cc83c40d7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b225220806b1fc3961a680dffb29350"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7b225220806b1fc3961a680dffb29350"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7b225220806b1fc3961a680dffb29350.html#a7b225220806b1fc3961a680dffb29350">to_vector</a> (const std::vector&lt; T &gt; &amp;vec)</td></tr>
<tr class="separator:a7b225220806b1fc3961a680dffb29350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f121fbc3ba037a68f8db9220516249"><td class="memItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af9f121fbc3ba037a68f8db9220516249.html#af9f121fbc3ba037a68f8db9220516249">to_vector</a> (const std::vector&lt; int &gt; &amp;vec)</td></tr>
<tr class="separator:af9f121fbc3ba037a68f8db9220516249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363cca7db120af229b5aab9c12d0910a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__types_ga2976a84494e5b9a15e396836a1762ec0.html#ga2976a84494e5b9a15e396836a1762ec0">require_not_st_var</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a363cca7db120af229b5aab9c12d0910a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a363cca7db120af229b5aab9c12d0910a.html#a363cca7db120af229b5aab9c12d0910a">trace</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a363cca7db120af229b5aab9c12d0910a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trace of the specified matrix.  <br /></td></tr>
<tr class="separator:a363cca7db120af229b5aab9c12d0910a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c7feac6e85185e11e48fd013e08ca4"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename T2 , typename EigMat3 , <a class="el" href="group__col__vector__types_ga91963f6a218d172b07857bf3d5a8aa86.html#ga91963f6a218d172b07857bf3d5a8aa86">require_not_col_vector_t</a>&lt; EigMat1 &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; EigMat1, T2, EigMat3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa1c7feac6e85185e11e48fd013e08ca4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, T2, EigMat3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa1c7feac6e85185e11e48fd013e08ca4.html#aa1c7feac6e85185e11e48fd013e08ca4">trace_gen_inv_quad_form_ldlt</a> (const EigMat1 &amp;D, <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T2 &gt; &amp;A, const EigMat3 &amp;B)</td></tr>
<tr class="memdesc:aa1c7feac6e85185e11e48fd013e08ca4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the trace of an inverse quadratic form.  <br /></td></tr>
<tr class="separator:aa1c7feac6e85185e11e48fd013e08ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6999615797ed23ffd31662e1814820"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , typename T , typename EigMat , <a class="el" href="group__col__vector__types_ga58096049cb8906ec6ad5f44f1e6fe082.html#ga58096049cb8906ec6ad5f44f1e6fe082">require_col_vector_t</a>&lt; EigVec &gt; *  = nullptr, <a class="el" href="group__var__types_ga1b5baf3b48a8485cd74f29449ce74755.html#ga1b5baf3b48a8485cd74f29449ce74755">require_all_not_st_var</a>&lt; EigVec, T, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6e6999615797ed23ffd31662e1814820"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigVec, T, EigMat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6e6999615797ed23ffd31662e1814820.html#a6e6999615797ed23ffd31662e1814820">trace_gen_inv_quad_form_ldlt</a> (const EigVec &amp;D, <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A, const EigMat &amp;B)</td></tr>
<tr class="memdesc:a6e6999615797ed23ffd31662e1814820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the trace of an inverse quadratic form.  <br /></td></tr>
<tr class="separator:a6e6999615797ed23ffd31662e1814820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2495108b8463b99a75074f3f612553"><td class="memTemplParams" colspan="2">template&lt;typename TD , typename TA , typename TB , typename  = require_all_eigen_t&lt;TD, TA, TB&gt;, typename  = require_all_not_vt_var&lt;TD, TA, TB&gt;, typename  = require_any_not_vt_arithmetic&lt;TD, TA, TB&gt;&gt; </td></tr>
<tr class="memitem:a8c2495108b8463b99a75074f3f612553"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8c2495108b8463b99a75074f3f612553.html#a8c2495108b8463b99a75074f3f612553">trace_gen_quad_form</a> (const TD &amp;D, const TA &amp;A, const TB &amp;B)</td></tr>
<tr class="memdesc:a8c2495108b8463b99a75074f3f612553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the trace of D times the quadratic form of B and A.  <br /></td></tr>
<tr class="separator:a8c2495108b8463b99a75074f3f612553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa880d0c51c43efe2deeae94c19f25662"><td class="memTemplParams" colspan="2">template&lt;typename EigMatD , typename EigMatA , typename EigMatB , <a class="el" href="group__eigen__types_ga06fcddbaf041c31d2c20c8b006ebba79.html#ga06fcddbaf041c31d2c20c8b006ebba79">require_all_eigen_vt</a>&lt; std::is_arithmetic, EigMatD, EigMatA, EigMatB &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa880d0c51c43efe2deeae94c19f25662"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa880d0c51c43efe2deeae94c19f25662.html#aa880d0c51c43efe2deeae94c19f25662">trace_gen_quad_form</a> (const EigMatD &amp;D, const EigMatA &amp;A, const EigMatB &amp;B)</td></tr>
<tr class="memdesc:aa880d0c51c43efe2deeae94c19f25662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the trace of D times the quadratic form of B and A.  <br /></td></tr>
<tr class="separator:aa880d0c51c43efe2deeae94c19f25662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a20467b72d8510f8e3e105ba690f2fd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename EigMat2 , typename  = require_all_not_st_var&lt;T, EigMat2&gt;&gt; </td></tr>
<tr class="memitem:a1a20467b72d8510f8e3e105ba690f2fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, EigMat2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1a20467b72d8510f8e3e105ba690f2fd.html#a1a20467b72d8510f8e3e105ba690f2fd">trace_inv_quad_form_ldlt</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:a1a20467b72d8510f8e3e105ba690f2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the trace of an inverse quadratic form.  <br /></td></tr>
<tr class="separator:a1a20467b72d8510f8e3e105ba690f2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890de3f955e4e668d0191d4847b8033a"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga06fcddbaf041c31d2c20c8b006ebba79.html#ga06fcddbaf041c31d2c20c8b006ebba79">require_all_eigen_vt</a>&lt; std::is_arithmetic, EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a890de3f955e4e668d0191d4847b8033a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; EigMat1, EigMat2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a890de3f955e4e668d0191d4847b8033a.html#a890de3f955e4e668d0191d4847b8033a">trace_quad_form</a> (const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:a890de3f955e4e668d0191d4847b8033a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute trace(B^T A B).  <br /></td></tr>
<tr class="separator:a890de3f955e4e668d0191d4847b8033a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b43cedefbca1e3f4c7d9b317de22e6"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad4b43cedefbca1e3f4c7d9b317de22e6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad4b43cedefbca1e3f4c7d9b317de22e6.html#ad4b43cedefbca1e3f4c7d9b317de22e6">transpose</a> (const T &amp;m)</td></tr>
<tr class="memdesc:ad4b43cedefbca1e3f4c7d9b317de22e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transposes a matrix.  <br /></td></tr>
<tr class="separator:ad4b43cedefbca1e3f4c7d9b317de22e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506d4de701530a593f41c4b426578546"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a506d4de701530a593f41c4b426578546"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a506d4de701530a593f41c4b426578546.html#a506d4de701530a593f41c4b426578546">trigamma_impl</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a506d4de701530a593f41c4b426578546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the trigamma function applied to the argument.  <br /></td></tr>
<tr class="separator:a506d4de701530a593f41c4b426578546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab9fae0321be4202e5593fdf1ee9ff3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6ab9fae0321be4202e5593fdf1ee9ff3.html#a6ab9fae0321be4202e5593fdf1ee9ff3">trigamma</a> (double u)</td></tr>
<tr class="memdesc:a6ab9fae0321be4202e5593fdf1ee9ff3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the second derivative of the log Gamma function evaluated at the specified argument.  <br /></td></tr>
<tr class="separator:a6ab9fae0321be4202e5593fdf1ee9ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97eaa7c973b3685e8f30304092df693"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af97eaa7c973b3685e8f30304092df693.html#af97eaa7c973b3685e8f30304092df693">trigamma</a> (int u)</td></tr>
<tr class="memdesc:af97eaa7c973b3685e8f30304092df693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the second derivative of the log Gamma function evaluated at the specified argument.  <br /></td></tr>
<tr class="separator:af97eaa7c973b3685e8f30304092df693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ca5b852814bbf7daa900d9111536c5"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga55c0f71f335505ceeac88af143771e88.html#ga55c0f71f335505ceeac88af143771e88">require_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad9ca5b852814bbf7daa900d9111536c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad9ca5b852814bbf7daa900d9111536c5.html#ad9ca5b852814bbf7daa900d9111536c5">trigamma</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ad9ca5b852814bbf7daa900d9111536c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_a84f337f6b108752daafab06640e2c229.html#a84f337f6b108752daafab06640e2c229" title="Return the value of the trigamma function at the specified argument (i.e., the second derivative of t...">trigamma()</a></code> to specified argument container.  <br /></td></tr>
<tr class="separator:ad9ca5b852814bbf7daa900d9111536c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db32a1233cdda92afd65fc35e643440"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9db32a1233cdda92afd65fc35e643440"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9db32a1233cdda92afd65fc35e643440.html#a9db32a1233cdda92afd65fc35e643440">trunc</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a9db32a1233cdda92afd65fc35e643440"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise application of <code><a class="el" href="namespacestan_1_1math_afac4060d610887434f513b38fb8457d6.html#afac4060d610887434f513b38fb8457d6" title="Return the nearest integral value that is not larger in magnitude than the specified argument.">trunc()</a></code> to specified argument container.  <br /></td></tr>
<tr class="separator:a9db32a1233cdda92afd65fc35e643440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f247efaab4142c9498384d4363c80ab"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4f247efaab4142c9498384d4363c80ab.html#a4f247efaab4142c9498384d4363c80ab">uniform_simplex</a> (int K)</td></tr>
<tr class="memdesc:a4f247efaab4142c9498384d4363c80ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a uniform simplex of size K.  <br /></td></tr>
<tr class="separator:a4f247efaab4142c9498384d4363c80ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c04d1ca8dbaa404d647fbf6a50b7c8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a41c04d1ca8dbaa404d647fbf6a50b7c8.html#a41c04d1ca8dbaa404d647fbf6a50b7c8">unitspaced_array</a> (int low, int high)</td></tr>
<tr class="memdesc:a41c04d1ca8dbaa404d647fbf6a50b7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array of integers in an ordered sequence.  <br /></td></tr>
<tr class="separator:a41c04d1ca8dbaa404d647fbf6a50b7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63910a0f81de7c9bcd54054e2dfd2ed7"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga948d431ec5773ff848a6bfa0d0b7aa79.html#ga948d431ec5773ff848a6bfa0d0b7aa79">require_st_arithmetic</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a63910a0f81de7c9bcd54054e2dfd2ed7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a63910a0f81de7c9bcd54054e2dfd2ed7.html#a63910a0f81de7c9bcd54054e2dfd2ed7">value_of</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:a63910a0f81de7c9bcd54054e2dfd2ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inputs that are arithmetic types or containers of airthmetric types are returned from value_of unchanged.  <br /></td></tr>
<tr class="separator:a63910a0f81de7c9bcd54054e2dfd2ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdd2a5181cf24e1cc788a5e86e27316"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__complex__types_ga9e1429c7448a296d62bf6b4b037d1a6f.html#ga9e1429c7448a296d62bf6b4b037d1a6f">require_complex_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; std::is_arithmetic&lt; typename std::decay_t&lt; T &gt;::value_type &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4fdd2a5181cf24e1cc788a5e86e27316"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4fdd2a5181cf24e1cc788a5e86e27316.html#a4fdd2a5181cf24e1cc788a5e86e27316">value_of</a> (T &amp;&amp;x)</td></tr>
<tr class="separator:a4fdd2a5181cf24e1cc788a5e86e27316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5732f20a97c47531bb0f29cbf1612367"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga405fec5a34ff4c65e052577d247f1a60.html#ga405fec5a34ff4c65e052577d247f1a60">require_not_st_arithmetic</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5732f20a97c47531bb0f29cbf1612367"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5732f20a97c47531bb0f29cbf1612367.html#a5732f20a97c47531bb0f29cbf1612367">value_of</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a5732f20a97c47531bb0f29cbf1612367"><td class="mdescLeft">&#160;</td><td class="mdescRight">For std::vectors of non-arithmetic types, return a std::vector composed of value_of applied to each element.  <br /></td></tr>
<tr class="separator:a5732f20a97c47531bb0f29cbf1612367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7919e1a4f59deff48ddc9c19e5d9c5"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__dense__base__types_ga832fc80ea0f3c9c728c1fefd681be76d.html#ga832fc80ea0f3c9c728c1fefd681be76d">require_eigen_dense_base_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga405fec5a34ff4c65e052577d247f1a60.html#ga405fec5a34ff4c65e052577d247f1a60">require_not_st_arithmetic</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adc7919e1a4f59deff48ddc9c19e5d9c5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adc7919e1a4f59deff48ddc9c19e5d9c5.html#adc7919e1a4f59deff48ddc9c19e5d9c5">value_of</a> (EigMat &amp;&amp;M)</td></tr>
<tr class="memdesc:adc7919e1a4f59deff48ddc9c19e5d9c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrices and expressions of non-arithmetic types, return an expression that represents the Eigen::Matrix resulting from applying value_of elementwise.  <br /></td></tr>
<tr class="separator:adc7919e1a4f59deff48ddc9c19e5d9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5b8cb78e6305d3e985f7c44f752785"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_stan_scalar_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:aeb5b8cb78e6305d3e985f7c44f752785"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeb5b8cb78e6305d3e985f7c44f752785.html#aeb5b8cb78e6305d3e985f7c44f752785">value_of_rec</a> (const T x)</td></tr>
<tr class="memdesc:aeb5b8cb78e6305d3e985f7c44f752785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified scalar argument converted to a double value.  <br /></td></tr>
<tr class="separator:aeb5b8cb78e6305d3e985f7c44f752785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0548ef9deaae6edf2187b885ba545b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afe0548ef9deaae6edf2187b885ba545b.html#afe0548ef9deaae6edf2187b885ba545b">value_of_rec</a> (double x)</td></tr>
<tr class="memdesc:afe0548ef9deaae6edf2187b885ba545b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified argument.  <br /></td></tr>
<tr class="separator:afe0548ef9deaae6edf2187b885ba545b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a492ad1cf164a8852d0dd793846673457"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a492ad1cf164a8852d0dd793846673457"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a492ad1cf164a8852d0dd793846673457.html#a492ad1cf164a8852d0dd793846673457">value_of_rec</a> (const std::complex&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a492ad1cf164a8852d0dd793846673457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively apply value-of to the parts of the argument.  <br /></td></tr>
<tr class="separator:a492ad1cf164a8852d0dd793846673457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6600397b5565467795b486aefce5f4"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__same__types_ga151adb676402a791de98a5d743d7a10d.html#ga151adb676402a791de98a5d743d7a10d">require_not_same_t</a>&lt; double, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9f6600397b5565467795b486aefce5f4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9f6600397b5565467795b486aefce5f4.html#a9f6600397b5565467795b486aefce5f4">value_of_rec</a> (const std::vector&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a9f6600397b5565467795b486aefce5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a std::vector of type T to a std::vector of doubles.  <br /></td></tr>
<tr class="separator:a9f6600397b5565467795b486aefce5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0881827f62ff24b1d822e0654133dc5"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; double, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac0881827f62ff24b1d822e0654133dc5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac0881827f62ff24b1d822e0654133dc5.html#ac0881827f62ff24b1d822e0654133dc5">value_of_rec</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:ac0881827f62ff24b1d822e0654133dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the specified argument.  <br /></td></tr>
<tr class="separator:ac0881827f62ff24b1d822e0654133dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45e9f7eeb8977c34f5fe541250b8ebb"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = require_not_st_same&lt;T, double&gt;, typename  = require_eigen_t&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ae45e9f7eeb8977c34f5fe541250b8ebb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae45e9f7eeb8977c34f5fe541250b8ebb.html#ae45e9f7eeb8977c34f5fe541250b8ebb">value_of_rec</a> (T &amp;&amp;M)</td></tr>
<tr class="memdesc:ae45e9f7eeb8977c34f5fe541250b8ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a matrix of type T to a matrix of doubles.  <br /></td></tr>
<tr class="separator:ae45e9f7eeb8977c34f5fe541250b8ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da261addc1df3b7d0fc62898c11d1c5"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__var__types_ga49bd546c64ba1da0a583715b7162c898.html#ga49bd546c64ba1da0a583715b7162c898">require_not_vt_var</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2da261addc1df3b7d0fc62898c11d1c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; EigMat &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2da261addc1df3b7d0fc62898c11d1c5.html#a2da261addc1df3b7d0fc62898c11d1c5">variance</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a2da261addc1df3b7d0fc62898c11d1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample variance (divide by length - 1) of the coefficients in the specified matrix.  <br /></td></tr>
<tr class="separator:a2da261addc1df3b7d0fc62898c11d1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78734021fa29f42e8870ee429166693"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , <a class="el" href="group__std__vector__types_ga61a685e43e184497f9b2b5056242ad2e.html#ga61a685e43e184497f9b2b5056242ad2e">require_std_vector_t</a>&lt; StdVec &gt; *  = nullptr, <a class="el" href="group__var__types_ga49bd546c64ba1da0a583715b7162c898.html#ga49bd546c64ba1da0a583715b7162c898">require_not_vt_var</a>&lt; StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa78734021fa29f42e8870ee429166693"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; StdVec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa78734021fa29f42e8870ee429166693.html#aa78734021fa29f42e8870ee429166693">variance</a> (const StdVec &amp;v)</td></tr>
<tr class="memdesc:aa78734021fa29f42e8870ee429166693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sample variance (divide by length - 1) of the coefficients in the specified standard vector.  <br /></td></tr>
<tr class="separator:aa78734021fa29f42e8870ee429166693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d052d8144d9d7578f3260a701c3e108"><td class="memTemplParams" colspan="2">template&lt;typename Vec , typename... Args&gt; </td></tr>
<tr class="memitem:a8d052d8144d9d7578f3260a701c3e108"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8d052d8144d9d7578f3260a701c3e108.html#a8d052d8144d9d7578f3260a701c3e108">vec_concat</a> (const Vec &amp;v1, const Args &amp;... args)</td></tr>
<tr class="memdesc:a8d052d8144d9d7578f3260a701c3e108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the event stack from a vector of events and other arguments.  <br /></td></tr>
<tr class="separator:a8d052d8144d9d7578f3260a701c3e108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fda49cf2b4e2c8c552cb8566fe2e2e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a93fda49cf2b4e2c8c552cb8566fe2e2e.html#a93fda49cf2b4e2c8c552cb8566fe2e2e">zeros_array</a> (int K)</td></tr>
<tr class="memdesc:a93fda49cf2b4e2c8c552cb8566fe2e2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an array of zeros.  <br /></td></tr>
<tr class="separator:a93fda49cf2b4e2c8c552cb8566fe2e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e828e7603fa9404d3ef392c5441e18"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a81e828e7603fa9404d3ef392c5441e18.html#a81e828e7603fa9404d3ef392c5441e18">zeros_int_array</a> (int K)</td></tr>
<tr class="memdesc:a81e828e7603fa9404d3ef392c5441e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an integer array of zeros.  <br /></td></tr>
<tr class="separator:a81e828e7603fa9404d3ef392c5441e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d994d53428a7b36ae932bd97e3274e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a44d994d53428a7b36ae932bd97e3274e.html#a44d994d53428a7b36ae932bd97e3274e">zeros_row_vector</a> (int K)</td></tr>
<tr class="memdesc:a44d994d53428a7b36ae932bd97e3274e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row vector of zeros.  <br /></td></tr>
<tr class="separator:a44d994d53428a7b36ae932bd97e3274e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abde7be965b8b219a0d48c14ecee847ea"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abde7be965b8b219a0d48c14ecee847ea.html#abde7be965b8b219a0d48c14ecee847ea">zeros_vector</a> (int K)</td></tr>
<tr class="memdesc:abde7be965b8b219a0d48c14ecee847ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector of zeros.  <br /></td></tr>
<tr class="separator:abde7be965b8b219a0d48c14ecee847ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af027055902998a8d85a4c2f000dd5c96"><td class="memTemplParams" colspan="2">template&lt;class F , class Tuple , typename... PreArgs&gt; </td></tr>
<tr class="memitem:af027055902998a8d85a4c2f000dd5c96"><td class="memTemplItemLeft" align="right" valign="top">constexpr decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af027055902998a8d85a4c2f000dd5c96.html#af027055902998a8d85a4c2f000dd5c96">apply</a> (F &amp;&amp;f, Tuple &amp;&amp;t, PreArgs &amp;&amp;... pre_args)</td></tr>
<tr class="separator:af027055902998a8d85a4c2f000dd5c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd139a5cfbed5b58bb028c6df89a712"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename F , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adcd139a5cfbed5b58bb028c6df89a712"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adcd139a5cfbed5b58bb028c6df89a712.html#adcd139a5cfbed5b58bb028c6df89a712">apply_scalar_binary</a> (const T1 &amp;x, const T2 &amp;y, const F &amp;f)</td></tr>
<tr class="memdesc:adcd139a5cfbed5b58bb028c6df89a712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template function for vectorization of binary scalar functions defined by applying a functor to a combination of scalars, containers of matching sizes, or a combination of a scalar and a container.  <br /></td></tr>
<tr class="separator:adcd139a5cfbed5b58bb028c6df89a712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f53a85af81aa364412d2c8141f423e"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename F , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a99f53a85af81aa364412d2c8141f423e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a99f53a85af81aa364412d2c8141f423e.html#a99f53a85af81aa364412d2c8141f423e">apply_scalar_binary</a> (T1 &amp;&amp;x, T2 &amp;&amp;y, F &amp;&amp;f)</td></tr>
<tr class="memdesc:a99f53a85af81aa364412d2c8141f423e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for use with two <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> inputs.  <br /></td></tr>
<tr class="separator:a99f53a85af81aa364412d2c8141f423e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0f5fd75b4a66c5862ec2d20bd897ec"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename F , <a class="el" href="group__eigen__vector__types_ga896401ad33967867f49cd60ca10d990e.html#ga896401ad33967867f49cd60ca10d990e">require_eigen_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>, T1 &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga177ca10358abdf201cabb12e8bdb2e91.html#ga177ca10358abdf201cabb12e8bdb2e91">require_std_vector_vt</a>&lt; std::is_integral, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aae0f5fd75b4a66c5862ec2d20bd897ec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aae0f5fd75b4a66c5862ec2d20bd897ec.html#aae0f5fd75b4a66c5862ec2d20bd897ec">apply_scalar_binary</a> (T1 &amp;&amp;x, T2 &amp;&amp;y, F &amp;&amp;f)</td></tr>
<tr class="memdesc:aae0f5fd75b4a66c5862ec2d20bd897ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for use with one <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vector (row or column) and a one-dimensional std::vector of integer types.  <br /></td></tr>
<tr class="separator:aae0f5fd75b4a66c5862ec2d20bd897ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9d6b14a483bfc0a6ce5f47c9e5ddac"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename F , <a class="el" href="group__eigen__matrix__dynamic__types_gae725537ef0b9f4ef9857fa1b28bd1076.html#gae725537ef0b9f4ef9857fa1b28bd1076">require_eigen_matrix_dynamic_vt</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>, T1 &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga177ca10358abdf201cabb12e8bdb2e91.html#ga177ca10358abdf201cabb12e8bdb2e91">require_std_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__std__vector.html">is_std_vector</a>, T2 &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga513b41fcdff562ebb8bc2cd5e3ea8faa.html#ga513b41fcdff562ebb8bc2cd5e3ea8faa">require_std_vector_st</a>&lt; std::is_integral, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abb9d6b14a483bfc0a6ce5f47c9e5ddac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abb9d6b14a483bfc0a6ce5f47c9e5ddac.html#abb9d6b14a483bfc0a6ce5f47c9e5ddac">apply_scalar_binary</a> (const T1 &amp;x, const T2 &amp;y, const F &amp;f)</td></tr>
<tr class="memdesc:abb9d6b14a483bfc0a6ce5f47c9e5ddac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for use with one <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix and a two-dimensional std::vector of integer types.  <br /></td></tr>
<tr class="separator:abb9d6b14a483bfc0a6ce5f47c9e5ddac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135de1c7b96ba79ba9fa8f89cfab0170"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename F , <a class="el" href="group__std__vector__types_ga177ca10358abdf201cabb12e8bdb2e91.html#ga177ca10358abdf201cabb12e8bdb2e91">require_std_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>, T1 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a135de1c7b96ba79ba9fa8f89cfab0170"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a135de1c7b96ba79ba9fa8f89cfab0170.html#a135de1c7b96ba79ba9fa8f89cfab0170">apply_scalar_binary</a> (const T1 &amp;x, const T2 &amp;y, const F &amp;f)</td></tr>
<tr class="memdesc:a135de1c7b96ba79ba9fa8f89cfab0170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for use when the first input is a (non-nested) std::vector and the second is a scalar.  <br /></td></tr>
<tr class="separator:a135de1c7b96ba79ba9fa8f89cfab0170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0e731bea1c0e6410caf980a0c77a39"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 , typename T3 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abc0e731bea1c0e6410caf980a0c77a39"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abc0e731bea1c0e6410caf980a0c77a39.html#abc0e731bea1c0e6410caf980a0c77a39">apply_scalar_ternary</a> (const F &amp;f, const T1 &amp;x, const T2 &amp;y, const T3 &amp;z)</td></tr>
<tr class="memdesc:abc0e731bea1c0e6410caf980a0c77a39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template function for vectorization of ternary scalar functions defined by applying a functor to a combination of scalars, containers of matching sizes, or a combination of a scalar and a container.  <br /></td></tr>
<tr class="separator:abc0e731bea1c0e6410caf980a0c77a39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cddf2b6c59599fb428054d27fa9c3f2"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 , typename T3 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3cddf2b6c59599fb428054d27fa9c3f2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3cddf2b6c59599fb428054d27fa9c3f2.html#a3cddf2b6c59599fb428054d27fa9c3f2">apply_scalar_ternary</a> (F &amp;&amp;f, T1 &amp;&amp;x, T2 &amp;&amp;y, T3 &amp;&amp;z)</td></tr>
<tr class="memdesc:a3cddf2b6c59599fb428054d27fa9c3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for use with three <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> inputs.  <br /></td></tr>
<tr class="separator:a3cddf2b6c59599fb428054d27fa9c3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16bf2e0110c016c88faad4f592b3f10"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 , typename T3 , <a class="el" href="group__container__types_ga67c7c607453d5d13db814b69546ea415.html#ga67c7c607453d5d13db814b69546ea415">require_any_container_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa16bf2e0110c016c88faad4f592b3f10"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa16bf2e0110c016c88faad4f592b3f10.html#aa16bf2e0110c016c88faad4f592b3f10">apply_scalar_ternary</a> (const F &amp;f, const T1 &amp;x, const T2 &amp;y, const T3 &amp;z)</td></tr>
<tr class="memdesc:aa16bf2e0110c016c88faad4f592b3f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for use where the third argument is a scalar.  <br /></td></tr>
<tr class="separator:aa16bf2e0110c016c88faad4f592b3f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd8731d906268bf1b3c160a45fca29d"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:adbd8731d906268bf1b3c160a45fca29d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adbd8731d906268bf1b3c160a45fca29d.html#adbd8731d906268bf1b3c160a45fca29d">finite_diff_gradient</a> (const F &amp;f, const Eigen::VectorXd &amp;x, double &amp;fx, Eigen::VectorXd &amp;grad_fx, double epsilon=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-03)</td></tr>
<tr class="memdesc:adbd8731d906268bf1b3c160a45fca29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value and the gradient of the specified function at the specified argument using finite difference.  <br /></td></tr>
<tr class="separator:adbd8731d906268bf1b3c160a45fca29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4473c50e1af224eea24c970de66a4187"><td class="memTemplParams" colspan="2">template&lt;typename F , typename VectorT , typename GradVectorT , typename ScalarT  = return_type_t&lt;VectorT&gt;&gt; </td></tr>
<tr class="memitem:a4473c50e1af224eea24c970de66a4187"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4473c50e1af224eea24c970de66a4187.html#a4473c50e1af224eea24c970de66a4187">finite_diff_gradient_auto</a> (const F &amp;f, VectorT &amp;&amp;x, ScalarT &amp;fx, GradVectorT &amp;grad_fx)</td></tr>
<tr class="memdesc:a4473c50e1af224eea24c970de66a4187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value and the gradient of the specified function at the specified argument using finite difference.  <br /></td></tr>
<tr class="separator:a4473c50e1af224eea24c970de66a4187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03905527dea9be46cc0eb973ad4b6120"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T &gt; </td></tr>
<tr class="memitem:a03905527dea9be46cc0eb973ad4b6120"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a03905527dea9be46cc0eb973ad4b6120.html#a03905527dea9be46cc0eb973ad4b6120">for_each</a> (F &amp;&amp;f, T &amp;&amp;t)</td></tr>
<tr class="memdesc:a03905527dea9be46cc0eb973ad4b6120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each element of a tuple.  <br /></td></tr>
<tr class="separator:a03905527dea9be46cc0eb973ad4b6120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f4ad90150c1f57a2643ab610e964d3"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af1f4ad90150c1f57a2643ab610e964d3"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af1f4ad90150c1f57a2643ab610e964d3.html#af1f4ad90150c1f57a2643ab610e964d3">for_each</a> (F &amp;&amp;f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</td></tr>
<tr class="memdesc:af1f4ad90150c1f57a2643ab610e964d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each element of two tuples.  <br /></td></tr>
<tr class="separator:af1f4ad90150c1f57a2643ab610e964d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f8789fecb763c0565624f92fc762f9"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:af2f8789fecb763c0565624f92fc762f9"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af2f8789fecb763c0565624f92fc762f9.html#af2f8789fecb763c0565624f92fc762f9">for_each</a> (F &amp;&amp;f, T1 &amp;&amp;t1, T2 &amp;&amp;t2, T3 &amp;&amp;t3)</td></tr>
<tr class="memdesc:af2f8789fecb763c0565624f92fc762f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to each element of three tuples.  <br /></td></tr>
<tr class="separator:af2f8789fecb763c0565624f92fc762f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6468031842fd9c46caaff7ff379bc5"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_a , typename T_b , typename ParsTuple , typename TAbsErr , typename TRelErr &gt; </td></tr>
<tr class="memitem:a3c6468031842fd9c46caaff7ff379bc5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3c6468031842fd9c46caaff7ff379bc5.html#a3c6468031842fd9c46caaff7ff379bc5">hcubature</a> (const F &amp;integrand, const ParsTuple &amp;pars, const int dim, const Eigen::Matrix&lt; T_a, Eigen::Dynamic, 1 &gt; &amp;a, const Eigen::Matrix&lt; T_b, Eigen::Dynamic, 1 &gt; &amp;b, const int max_eval, const TAbsErr reqAbsError, const TRelErr reqRelError)</td></tr>
<tr class="memdesc:a3c6468031842fd9c46caaff7ff379bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the [dim]-dimensional integral of the function \(f\) from \(a\) to \(b\) within specified relative and absolute tolerances or maximum number of evaluations.  <br /></td></tr>
<tr class="separator:a3c6468031842fd9c46caaff7ff379bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca44e8ac9fda3b011083dfee7a5b10eb"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:aca44e8ac9fda3b011083dfee7a5b10eb"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aca44e8ac9fda3b011083dfee7a5b10eb.html#aca44e8ac9fda3b011083dfee7a5b10eb">integrate</a> (const F &amp;f, double a, double b, double relative_tolerance)</td></tr>
<tr class="memdesc:aca44e8ac9fda3b011083dfee7a5b10eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integrate a single variable function f from a to b to within a specified relative tolerance.  <br /></td></tr>
<tr class="separator:aca44e8ac9fda3b011083dfee7a5b10eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae037a8245e74bd267b93084c11c4ca02"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Args, <a class="el" href="group__arithmetic__types_ga3ccb7bb7ca23838c90e98961789c1153.html#ga3ccb7bb7ca23838c90e98961789c1153">require_all_st_arithmetic</a>&lt; Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae037a8245e74bd267b93084c11c4ca02"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae037a8245e74bd267b93084c11c4ca02.html#ae037a8245e74bd267b93084c11c4ca02">integrate_1d_impl</a> (const F &amp;f, double a, double b, double relative_tolerance, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:ae037a8245e74bd267b93084c11c4ca02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integral of the single variable function f from a to b to within a specified relative tolerance.  <br /></td></tr>
<tr class="separator:ae037a8245e74bd267b93084c11c4ca02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c617b18457b48f46759cbdb7d9fdd06"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a5c617b18457b48f46759cbdb7d9fdd06"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5c617b18457b48f46759cbdb7d9fdd06.html#a5c617b18457b48f46759cbdb7d9fdd06">integrate_1d</a> (const F &amp;f, double a, double b, const std::vector&lt; double &gt; &amp;theta, const std::vector&lt; double &gt; &amp;x_r, const std::vector&lt; int &gt; &amp;x_i, std::ostream *msgs, const double relative_tolerance=std::sqrt(<a class="el" href="namespacestan_1_1math_a28af31756798a98947ed5351b67fd9c4.html#a28af31756798a98947ed5351b67fd9c4">EPSILON</a>))</td></tr>
<tr class="memdesc:a5c617b18457b48f46759cbdb7d9fdd06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the integral of the single variable function f from a to b to within a specified relative tolerance.  <br /></td></tr>
<tr class="separator:a5c617b18457b48f46759cbdb7d9fdd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65b85b75b4d404c0c83ee48358b569b"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_param , typename T_t0 , typename T_ts &gt; </td></tr>
<tr class="memitem:aa65b85b75b4d404c0c83ee48358b569b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa65b85b75b4d404c0c83ee48358b569b.html#aa65b85b75b4d404c0c83ee48358b569b">integrate_ode_rk45</a> (const F &amp;f, const std::vector&lt; T_y0 &gt; &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, const std::vector&lt; T_param &gt; &amp;theta, const std::vector&lt; double &gt; &amp;x, const std::vector&lt; int &gt; &amp;x_int, std::ostream *msgs=nullptr, double relative_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-6, double absolute_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-6, int max_num_steps=1e6)</td></tr>
<tr class="separator:aa65b85b75b4d404c0c83ee48358b569b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac26e47755dedc4c759b820aee8dae034"><td class="memTemplParams" colspan="2">template&lt;int call_id, typename F , typename T_shared_param , typename T_job_param , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_shared_param &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac26e47755dedc4c759b820aee8dae034"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shared_param, T_job_param &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac26e47755dedc4c759b820aee8dae034.html#ac26e47755dedc4c759b820aee8dae034">map_rect</a> (const T_shared_param &amp;shared_params, const std::vector&lt; Eigen::Matrix&lt; T_job_param, Eigen::Dynamic, 1 &gt; &gt; &amp;job_params, const std::vector&lt; std::vector&lt; double &gt; &gt; &amp;x_r, const std::vector&lt; std::vector&lt; int &gt; &gt; &amp;x_i, std::ostream *msgs=nullptr)</td></tr>
<tr class="memdesc:ac26e47755dedc4c759b820aee8dae034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map N function evaluations to parameters and data which are in rectangular format.  <br /></td></tr>
<tr class="separator:ac26e47755dedc4c759b820aee8dae034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98756ac42345d85dcf65827862725c62"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a98756ac42345d85dcf65827862725c62.html#a98756ac42345d85dcf65827862725c62">mpi_map_chunks</a> (std::size_t num_jobs, std::size_t chunk_size=1)</td></tr>
<tr class="memdesc:a98756ac42345d85dcf65827862725c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps jobs of given chunk size to workers and returning a vector of counts.  <br /></td></tr>
<tr class="separator:a98756ac42345d85dcf65827862725c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32d1b150cc0f0da1f57f213133c8291"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad32d1b150cc0f0da1f57f213133c8291"><td class="memTemplItemLeft" align="right" valign="top">std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad32d1b150cc0f0da1f57f213133c8291.html#ad32d1b150cc0f0da1f57f213133c8291">mpi_broadcast_command</a> ()</td></tr>
<tr class="memdesc:ad32d1b150cc0f0da1f57f213133c8291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts default constructible commands to the cluster.  <br /></td></tr>
<tr class="separator:ad32d1b150cc0f0da1f57f213133c8291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e755e9d286d6ca38d4bbe275899d11"><td class="memItemLeft" align="right" valign="top">std::unique_lock&lt; std::mutex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a11e755e9d286d6ca38d4bbe275899d11.html#a11e755e9d286d6ca38d4bbe275899d11">mpi_broadcast_command</a> (std::shared_ptr&lt; <a class="el" href="structstan_1_1math_1_1mpi__command.html">mpi_command</a> &gt; &amp;command)</td></tr>
<tr class="memdesc:a11e755e9d286d6ca38d4bbe275899d11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts a command instance to the listening cluster.  <br /></td></tr>
<tr class="separator:a11e755e9d286d6ca38d4bbe275899d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb6c8a4f94d115e9c146c34254f8503"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... Args, <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acdb6c8a4f94d115e9c146c34254f8503"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acdb6c8a4f94d115e9c146c34254f8503.html#acdb6c8a4f94d115e9c146c34254f8503">ode_ckrk_tol_impl</a> (const char *function_name, const F &amp;f, const T_y0 &amp;y0_arg, T_t0 t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance, double absolute_tolerance, long int max_num_steps, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:acdb6c8a4f94d115e9c146c34254f8503"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ... } using Boost's Cash-Karp54 solver.  <br /></td></tr>
<tr class="separator:acdb6c8a4f94d115e9c146c34254f8503"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f39e507700660470d82dbc8354a338"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... Args, <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a26f39e507700660470d82dbc8354a338"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a26f39e507700660470d82dbc8354a338.html#a26f39e507700660470d82dbc8354a338">ode_ckrk_tol</a> (const F &amp;f, const T_y0 &amp;y0_arg, T_t0 t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance, double absolute_tolerance, long int max_num_steps, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:a26f39e507700660470d82dbc8354a338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ... } using Boost's Cash-Karp solver.  <br /></td></tr>
<tr class="separator:a26f39e507700660470d82dbc8354a338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d87b611ab2b9a3f6c160008ea5b12c0"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... Args, <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2d87b611ab2b9a3f6c160008ea5b12c0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2d87b611ab2b9a3f6c160008ea5b12c0.html#a2d87b611ab2b9a3f6c160008ea5b12c0">ode_ckrk</a> (const F &amp;f, const T_y0 &amp;y0, T_t0 t0, const std::vector&lt; T_ts &gt; &amp;ts, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:a2d87b611ab2b9a3f6c160008ea5b12c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ... } using Boost's Cash-Karp Runge-Kutta solver with defaults for relative_tolerance, absolute_tolerance, and max_num_steps.  <br /></td></tr>
<tr class="separator:a2d87b611ab2b9a3f6c160008ea5b12c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37623d1ec1b5fbdc49e4d01558035372"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... Args, <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a37623d1ec1b5fbdc49e4d01558035372"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a37623d1ec1b5fbdc49e4d01558035372.html#a37623d1ec1b5fbdc49e4d01558035372">ode_rk45_tol_impl</a> (const char *function_name, const F &amp;f, const T_y0 &amp;y0_arg, T_t0 t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance, double absolute_tolerance, long int max_num_steps, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:a37623d1ec1b5fbdc49e4d01558035372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ... } using the non-stiff Runge-Kutta 45 solver in Boost.  <br /></td></tr>
<tr class="separator:a37623d1ec1b5fbdc49e4d01558035372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3a6ddf2f82c6a859344a39a95de143"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... Args, <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9e3a6ddf2f82c6a859344a39a95de143"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9e3a6ddf2f82c6a859344a39a95de143.html#a9e3a6ddf2f82c6a859344a39a95de143">ode_rk45_tol</a> (const F &amp;f, const T_y0 &amp;y0_arg, T_t0 t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance, double absolute_tolerance, long int max_num_steps, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:a9e3a6ddf2f82c6a859344a39a95de143"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ... } using the non-stiff Runge-Kutta 45 solver in Boost.  <br /></td></tr>
<tr class="separator:a9e3a6ddf2f82c6a859344a39a95de143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434c9721fe82d748a7d664c25e5f83ee"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... Args, <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a434c9721fe82d748a7d664c25e5f83ee"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a434c9721fe82d748a7d664c25e5f83ee.html#a434c9721fe82d748a7d664c25e5f83ee">ode_rk45</a> (const F &amp;f, const T_y0 &amp;y0, T_t0 t0, const std::vector&lt; T_ts &gt; &amp;ts, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:a434c9721fe82d748a7d664c25e5f83ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ... } using the non-stiff Runge-Kutta 45 solver in Boost with defaults for relative_tolerance, absolute_tolerance, and max_num_steps.  <br /></td></tr>
<tr class="separator:a434c9721fe82d748a7d664c25e5f83ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab414676ddd1eb0882d6b41e0c2189928"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0_t0 , typename T_t0 , typename T_t , typename... Args, typename  = require_all_arithmetic_t&lt;T_y0_t0, T_t0, T_t, scalar_type_t&lt;Args&gt;...&gt;&gt; </td></tr>
<tr class="memitem:ab414676ddd1eb0882d6b41e0c2189928"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab414676ddd1eb0882d6b41e0c2189928.html#ab414676ddd1eb0882d6b41e0c2189928">ode_store_sensitivities</a> (const F &amp;f, const std::vector&lt; double &gt; &amp;coupled_state, const Eigen::Matrix&lt; T_y0_t0, Eigen::Dynamic, 1 &gt; &amp;y0, T_t0 t0, T_t t, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:ab414676ddd1eb0882d6b41e0c2189928"><td class="mdescLeft">&#160;</td><td class="mdescRight">When all arguments are arithmetic, there are no sensitivities to store, so the function just returns the current coupled_state.  <br /></td></tr>
<tr class="separator:ab414676ddd1eb0882d6b41e0c2189928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1715b82f273f1163487bb64ddc63df40"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class... Types&gt; </td></tr>
<tr class="memitem:a1715b82f273f1163487bb64ddc63df40"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1715b82f273f1163487bb64ddc63df40.html#a1715b82f273f1163487bb64ddc63df40">edge</a> (<a class="el" href="classstan_1_1math_1_1internal_1_1partials__propagator.html">internal::partials_propagator</a>&lt; Types... &gt; &amp;x) noexcept</td></tr>
<tr class="memdesc:a1715b82f273f1163487bb64ddc63df40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the edge of an <code>partials_propagator</code>  <br /></td></tr>
<tr class="separator:a1715b82f273f1163487bb64ddc63df40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac292611991dd73470472433d4afa3b5b"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class... Types&gt; </td></tr>
<tr class="memitem:ac292611991dd73470472433d4afa3b5b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac292611991dd73470472433d4afa3b5b.html#ac292611991dd73470472433d4afa3b5b">partials</a> (<a class="el" href="classstan_1_1math_1_1internal_1_1partials__propagator.html">internal::partials_propagator</a>&lt; Types... &gt; &amp;x) noexcept</td></tr>
<tr class="memdesc:ac292611991dd73470472433d4afa3b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the partials for an edge of an <code>partials_propagator</code>  <br /></td></tr>
<tr class="separator:ac292611991dd73470472433d4afa3b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae570c734bb525825addc7d9b8b3e6c5b"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class... Types&gt; </td></tr>
<tr class="memitem:ae570c734bb525825addc7d9b8b3e6c5b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae570c734bb525825addc7d9b8b3e6c5b.html#ae570c734bb525825addc7d9b8b3e6c5b">partials_vec</a> (<a class="el" href="classstan_1_1math_1_1internal_1_1partials__propagator.html">internal::partials_propagator</a>&lt; Types... &gt; &amp;x) noexcept</td></tr>
<tr class="memdesc:ae570c734bb525825addc7d9b8b3e6c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the partials_vec for an edge of a <code>partials_propagator</code>  <br /></td></tr>
<tr class="separator:ae570c734bb525825addc7d9b8b3e6c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffcf3ad8b3bd618836b4e91bd2dd57b"><td class="memTemplParams" colspan="2">template&lt;typename... Ops&gt; </td></tr>
<tr class="memitem:aeffcf3ad8b3bd618836b4e91bd2dd57b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeffcf3ad8b3bd618836b4e91bd2dd57b.html#aeffcf3ad8b3bd618836b4e91bd2dd57b">make_partials_propagator</a> (Ops &amp;&amp;... ops)</td></tr>
<tr class="memdesc:aeffcf3ad8b3bd618836b4e91bd2dd57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an <code>partials_propagator</code>.  <br /></td></tr>
<tr class="separator:aeffcf3ad8b3bd618836b4e91bd2dd57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e156d0934e4aee29b8defd07962d9cd"><td class="memTemplParams" colspan="2">template&lt;typename ReduceFunction , typename Vec , typename  = require_vector_like_t&lt;Vec&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:a6e156d0934e4aee29b8defd07962d9cd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6e156d0934e4aee29b8defd07962d9cd.html#a6e156d0934e4aee29b8defd07962d9cd">reduce_sum</a> (Vec &amp;&amp;vmapped, int grainsize, std::ostream *msgs, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6e156d0934e4aee29b8defd07962d9cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call an instance of the function <code>ReduceFunction</code> on every element of an input sequence and sum these terms.  <br /></td></tr>
<tr class="separator:a6e156d0934e4aee29b8defd07962d9cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c5098c8dcebb6ff7c232f2ce39a553"><td class="memTemplParams" colspan="2">template&lt;typename ReduceFunction , typename Vec , typename  = require_vector_like_t&lt;Vec&gt;, typename... Args&gt; </td></tr>
<tr class="memitem:a85c5098c8dcebb6ff7c232f2ce39a553"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a85c5098c8dcebb6ff7c232f2ce39a553.html#a85c5098c8dcebb6ff7c232f2ce39a553">reduce_sum_static</a> (Vec &amp;&amp;vmapped, int grainsize, std::ostream *msgs, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a85c5098c8dcebb6ff7c232f2ce39a553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call an instance of the function <code>ReduceFunction</code> on every element of an input sequence and sum these terms.  <br /></td></tr>
<tr class="separator:a85c5098c8dcebb6ff7c232f2ce39a553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc28f5f2b014cdb24e4e2ad58a6294c4"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;std::is_same&lt;std::decay_t&lt;T_actual&gt;,                                          std::decay_t&lt;T_desired&gt;&gt;::value                             &amp;&amp; !is_eigen&lt;T_desired&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:gabc28f5f2b014cdb24e4e2ad58a6294c4"><td class="memTemplItemLeft" align="right" valign="top">T_actual &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_gabc28f5f2b014cdb24e4e2ad58a6294c4.html#gabc28f5f2b014cdb24e4e2ad58a6294c4">forward_as</a> (T_actual &amp;&amp;a)</td></tr>
<tr class="memdesc:gabc28f5f2b014cdb24e4e2ad58a6294c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume which type we get.  <br /></td></tr>
<tr class="separator:gabc28f5f2b014cdb24e4e2ad58a6294c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , typename  = std::enable_if_t&lt;              !std::is_same&lt;std::decay&lt;T_actual&gt;, std::decay&lt;T_desired&gt;&gt;::value              &amp;&amp; (!is_eigen&lt;T_desired&gt;::value || !is_eigen&lt;T_actual&gt;::value)&gt;&gt; </td></tr>
<tr class="memitem:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memTemplItemLeft" align="right" valign="top">T_desired&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga6cc77bba018fff06dd1f0f0f2d79e5b9.html#ga6cc77bba018fff06dd1f0f0f2d79e5b9">forward_as</a> (const T_actual &amp;a)</td></tr>
<tr class="memdesc:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume which type we get.  <br /></td></tr>
<tr class="separator:ga6cc77bba018fff06dd1f0f0f2d79e5b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08de2733477ccf3033ae2449d357e7bd"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T_desired &gt; *  = nullptr, std::enable_if_t&lt; std::is_same&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_actual &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_desired &gt; &gt;::value &amp;&amp;<a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>&lt; T_desired &gt;::value &amp;&amp;<a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>&lt; T_actual &gt;::value &amp;&amp;<a class="el" href="namespacestan_1_1math_1_1internal_a96d04a3ec2c9b0e26f1722efbd48776e.html#a96d04a3ec2c9b0e26f1722efbd48776e">internal::eigen_static_size_match</a>(T_desired::RowsAtCompileTime, std::decay_t&lt; T_actual &gt;::RowsAtCompileTime) &amp;&amp;<a class="el" href="namespacestan_1_1math_1_1internal_a96d04a3ec2c9b0e26f1722efbd48776e.html#a96d04a3ec2c9b0e26f1722efbd48776e">internal::eigen_static_size_match</a>(T_desired::ColsAtCompileTime, std::decay_t&lt; T_actual &gt;::ColsAtCompileTime)&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga08de2733477ccf3033ae2449d357e7bd"><td class="memTemplItemLeft" align="right" valign="top">T_actual &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__type__trait_ga08de2733477ccf3033ae2449d357e7bd.html#ga08de2733477ccf3033ae2449d357e7bd">forward_as</a> (T_actual &amp;&amp;a)</td></tr>
<tr class="memdesc:ga08de2733477ccf3033ae2449d357e7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume which type we get.  <br /></td></tr>
<tr class="separator:ga08de2733477ccf3033ae2449d357e7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9105ec386170113bb24f3808c7ba6f7"><td class="memTemplParams" colspan="2">template&lt;typename T_desired , typename T_actual , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; T_desired, T_actual &gt; *  = nullptr, std::enable_if_t&lt; !std::is_same&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_actual &gt;, <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_desired &gt; &gt;::value||!<a class="el" href="namespacestan_1_1math_1_1internal_a96d04a3ec2c9b0e26f1722efbd48776e.html#a96d04a3ec2c9b0e26f1722efbd48776e">internal::eigen_static_size_match</a>(T_desired::RowsAtCompileTime, std::decay_t&lt; T_actual &gt;::RowsAtCompileTime)||!<a class="el" href="namespacestan_1_1math_1_1internal_a96d04a3ec2c9b0e26f1722efbd48776e.html#a96d04a3ec2c9b0e26f1722efbd48776e">internal::eigen_static_size_match</a>(T_desired::ColsAtCompileTime, std::decay_t&lt; T_actual &gt;::ColsAtCompileTime)&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae9105ec386170113bb24f3808c7ba6f7"><td class="memTemplItemLeft" align="right" valign="top">T_desired&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae9105ec386170113bb24f3808c7ba6f7.html#ae9105ec386170113bb24f3808c7ba6f7">forward_as</a> (const T_actual &amp;a)</td></tr>
<tr class="memdesc:ae9105ec386170113bb24f3808c7ba6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume which type we get.  <br /></td></tr>
<tr class="separator:ae9105ec386170113bb24f3808c7ba6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa478b0c74cd87e5216789188a0a1783a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Ptrs, std::enable_if_t&lt; sizeof...(Ptrs) &gt;  = 1&gt; </td></tr>
<tr class="memitem:aa478b0c74cd87e5216789188a0a1783a"><td class="memTemplItemLeft" align="right" valign="top">Ptrs&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa478b0c74cd87e5216789188a0a1783a.html#aa478b0c74cd87e5216789188a0a1783a">holder</a> (T &amp;&amp;<a class="el" href="namespacestan_1_1math_a500fda68d64f44323202b69ffa804f5f.html#a500fda68d64f44323202b69ffa804f5f">arg</a>, Ptrs *... pointers)</td></tr>
<tr class="separator:aa478b0c74cd87e5216789188a0a1783a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34bc168bdd4da488fd9f0daef383624"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af34bc168bdd4da488fd9f0daef383624"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af34bc168bdd4da488fd9f0daef383624.html#af34bc168bdd4da488fd9f0daef383624">holder</a> (T &amp;&amp;<a class="el" href="namespacestan_1_1math_a500fda68d64f44323202b69ffa804f5f.html#a500fda68d64f44323202b69ffa804f5f">arg</a>)</td></tr>
<tr class="separator:af34bc168bdd4da488fd9f0daef383624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf8e9e8eb72e2d7b85a91f6bd2ddd77"><td class="memTemplParams" colspan="2">template&lt;typename F , typename... Args, <a class="el" href="group__plain__type__types_ga137082975fcf6b148ee009741564d4fd.html#ga137082975fcf6b148ee009741564d4fd">require_not_plain_type_t</a>&lt; decltype(std::declval&lt; F &gt;()(std::declval&lt; Args &amp; &gt;()...))&gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2bf8e9e8eb72e2d7b85a91f6bd2ddd77"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2bf8e9e8eb72e2d7b85a91f6bd2ddd77.html#a2bf8e9e8eb72e2d7b85a91f6bd2ddd77">make_holder</a> (const F &amp;func, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a2bf8e9e8eb72e2d7b85a91f6bd2ddd77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an expression from given arguments using given functor.  <br /></td></tr>
<tr class="separator:a2bf8e9e8eb72e2d7b85a91f6bd2ddd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab538359f082f3209ee2b18ed2cec99e2"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, class F &gt; </td></tr>
<tr class="memitem:ab538359f082f3209ee2b18ed2cec99e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab538359f082f3209ee2b18ed2cec99e2.html#ab538359f082f3209ee2b18ed2cec99e2">index_apply</a> (F &amp;&amp;f)</td></tr>
<tr class="memdesc:ab538359f082f3209ee2b18ed2cec99e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls given callable with an index sequence.  <br /></td></tr>
<tr class="separator:ab538359f082f3209ee2b18ed2cec99e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dfbeada90c8388f054c44532fd4e68e"><td class="memTemplParams" colspan="2">template&lt;typename CondSum , typename T , <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; CondSum &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9dfbeada90c8388f054c44532fd4e68e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9dfbeada90c8388f054c44532fd4e68e.html#a9dfbeada90c8388f054c44532fd4e68e">possibly_sum</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:a9dfbeada90c8388f054c44532fd4e68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally sum the input at compile time.  <br /></td></tr>
<tr class="separator:a9dfbeada90c8388f054c44532fd4e68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74152bd0994430700e68c83bd42f5674"><td class="memTemplParams" colspan="2">template&lt;typename CondSum , typename T1 , <a class="el" href="namespacestan_a0828f8f3d9b2ed5e8c7fd38e7600f9df.html#a0828f8f3d9b2ed5e8c7fd38e7600f9df">require_not_t</a>&lt; CondSum &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a74152bd0994430700e68c83bd42f5674"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a74152bd0994430700e68c83bd42f5674.html#a74152bd0994430700e68c83bd42f5674">possibly_sum</a> (T1 &amp;&amp;x)</td></tr>
<tr class="memdesc:a74152bd0994430700e68c83bd42f5674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditionally sum the input at compile time.  <br /></td></tr>
<tr class="separator:a74152bd0994430700e68c83bd42f5674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77598ca0189cc2eb170753992871808c"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename T1 , typename T2 , std::enable_if_t&lt; Condition &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a77598ca0189cc2eb170753992871808c"><td class="memTemplItemLeft" align="right" valign="top">T1&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a77598ca0189cc2eb170753992871808c.html#a77598ca0189cc2eb170753992871808c">static_select</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="memdesc:a77598ca0189cc2eb170753992871808c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of the arguments that can be of different type, depending on the compile time condition.  <br /></td></tr>
<tr class="separator:a77598ca0189cc2eb170753992871808c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2f64b7e48cacc08513b024a9acea27"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename T1 , typename T2 , std::enable_if_t&lt;!Condition &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b2f64b7e48cacc08513b024a9acea27"><td class="memTemplItemLeft" align="right" valign="top">T2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4b2f64b7e48cacc08513b024a9acea27.html#a4b2f64b7e48cacc08513b024a9acea27">static_select</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="separator:a4b2f64b7e48cacc08513b024a9acea27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c5001a080ec1037b9de2577eb390626"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:ga5c5001a080ec1037b9de2577eb390626"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga5c5001a080ec1037b9de2577eb390626.html#ga5c5001a080ec1037b9de2577eb390626">bernoulli_ccdf_log</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga5c5001a080ec1037b9de2577eb390626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa8122e34a1808d6b1070cba1b5b8eb3"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n, T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gafa8122e34a1808d6b1070cba1b5b8eb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gafa8122e34a1808d6b1070cba1b5b8eb3.html#gafa8122e34a1808d6b1070cba1b5b8eb3">bernoulli_cdf</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="memdesc:gafa8122e34a1808d6b1070cba1b5b8eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CDF of the Bernoulli distribution.  <br /></td></tr>
<tr class="separator:gafa8122e34a1808d6b1070cba1b5b8eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a889a4245ef622543b58879b5be6cac"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:ga6a889a4245ef622543b58879b5be6cac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga6a889a4245ef622543b58879b5be6cac.html#ga6a889a4245ef622543b58879b5be6cac">bernoulli_cdf_log</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga6a889a4245ef622543b58879b5be6cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2efda2f9ec72cb4df593feecaef47f29"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n, T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2efda2f9ec72cb4df593feecaef47f29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga2efda2f9ec72cb4df593feecaef47f29.html#ga2efda2f9ec72cb4df593feecaef47f29">bernoulli_lccdf</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="memdesc:ga2efda2f9ec72cb4df593feecaef47f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log CCDF of the Bernoulli distribution.  <br /></td></tr>
<tr class="separator:ga2efda2f9ec72cb4df593feecaef47f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff7871f802c2adbc4cc9f43d2d7a7af9"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n, T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaff7871f802c2adbc4cc9f43d2d7a7af9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaff7871f802c2adbc4cc9f43d2d7a7af9.html#gaff7871f802c2adbc4cc9f43d2d7a7af9">bernoulli_lcdf</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="memdesc:gaff7871f802c2adbc4cc9f43d2d7a7af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log CDF of the Bernoulli distribution.  <br /></td></tr>
<tr class="separator:gaff7871f802c2adbc4cc9f43d2d7a7af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf3272d33273a5bccc23eec9c9c09c14"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacf3272d33273a5bccc23eec9c9c09c14"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gacf3272d33273a5bccc23eec9c9c09c14.html#gacf3272d33273a5bccc23eec9c9c09c14">bernoulli_logit_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gacf3272d33273a5bccc23eec9c9c09c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Bernoulli distribution and logit link function.  <br /></td></tr>
<tr class="separator:gacf3272d33273a5bccc23eec9c9c09c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d51ca69cbb7cc76969de38f41ef3d69"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:a0d51ca69cbb7cc76969de38f41ef3d69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_beta, T_alpha &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0d51ca69cbb7cc76969de38f41ef3d69.html#a0d51ca69cbb7cc76969de38f41ef3d69">bernoulli_logit_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:a0d51ca69cbb7cc76969de38f41ef3d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga292dc46acae1bfa8127d5aa7f5fdd265"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_alpha , typename T_beta , class RNG &gt; </td></tr>
<tr class="memitem:ga292dc46acae1bfa8127d5aa7f5fdd265"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_alpha &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga292dc46acae1bfa8127d5aa7f5fdd265.html#ga292dc46acae1bfa8127d5aa7f5fdd265">bernoulli_logit_glm_rng</a> (const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga292dc46acae1bfa8127d5aa7f5fdd265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a draw from the Generalized Linear Model (GLM) with Bernoulli distribution and logit link function.  <br /></td></tr>
<tr class="separator:ga292dc46acae1bfa8127d5aa7f5fdd265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2444b141c6725a813f439a8dc33b01c"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_prob , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n, T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac2444b141c6725a813f439a8dc33b01c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gac2444b141c6725a813f439a8dc33b01c.html#gac2444b141c6725a813f439a8dc33b01c">bernoulli_logit_lpmf</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="memdesc:gac2444b141c6725a813f439a8dc33b01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the logit-parametrized Bernoulli distribution.  <br /></td></tr>
<tr class="separator:gac2444b141c6725a813f439a8dc33b01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a86c2811737a9c9ad9a63defddb742"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob &gt; </td></tr>
<tr class="memitem:a59a86c2811737a9c9ad9a63defddb742"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a59a86c2811737a9c9ad9a63defddb742.html#a59a86c2811737a9c9ad9a63defddb742">bernoulli_logit_lpmf</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:a59a86c2811737a9c9ad9a63defddb742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac31d7152a96b7378b111c93c47a4678d"><td class="memTemplParams" colspan="2">template&lt;typename T_t , class RNG &gt; </td></tr>
<tr class="memitem:gac31d7152a96b7378b111c93c47a4678d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_t &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gac31d7152a96b7378b111c93c47a4678d.html#gac31d7152a96b7378b111c93c47a4678d">bernoulli_logit_rng</a> (const T_t &amp;t, RNG &amp;rng)</td></tr>
<tr class="memdesc:gac31d7152a96b7378b111c93c47a4678d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Bernoulli random variate with logit-parameterized chance of success using the specified random number generator.  <br /></td></tr>
<tr class="separator:gac31d7152a96b7378b111c93c47a4678d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae515e914997508dc125ff5ac48929a5"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_prob , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n, T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaae515e914997508dc125ff5ac48929a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaae515e914997508dc125ff5ac48929a5.html#gaae515e914997508dc125ff5ac48929a5">bernoulli_lpmf</a> (const T_n &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="memdesc:gaae515e914997508dc125ff5ac48929a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Bernoulli distribution.  <br /></td></tr>
<tr class="separator:gaae515e914997508dc125ff5ac48929a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4660ec3c70569aebd561f7e4e976fe2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_prob &gt; </td></tr>
<tr class="memitem:af4660ec3c70569aebd561f7e4e976fe2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af4660ec3c70569aebd561f7e4e976fe2.html#af4660ec3c70569aebd561f7e4e976fe2">bernoulli_lpmf</a> (const T_y &amp;n, const T_prob &amp;theta)</td></tr>
<tr class="separator:af4660ec3c70569aebd561f7e4e976fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a9a54f88f69d7874fe3cd260197c2d0"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , class RNG &gt; </td></tr>
<tr class="memitem:ga0a9a54f88f69d7874fe3cd260197c2d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_theta &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga0a9a54f88f69d7874fe3cd260197c2d0.html#ga0a9a54f88f69d7874fe3cd260197c2d0">bernoulli_rng</a> (const T_theta &amp;theta, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga0a9a54f88f69d7874fe3cd260197c2d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Bernoulli random variate with specified chance of success parameter using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga0a9a54f88f69d7874fe3cd260197c2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15d14602e0d068446b96502296d345d7"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:ga15d14602e0d068446b96502296d345d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_size1, T_size2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga15d14602e0d068446b96502296d345d7.html#ga15d14602e0d068446b96502296d345d7">beta_binomial_ccdf_log</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:ga15d14602e0d068446b96502296d345d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38d6e7672e904359e246285bc34b7740"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:ga38d6e7672e904359e246285bc34b7740"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_size1, T_size2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga38d6e7672e904359e246285bc34b7740.html#ga38d6e7672e904359e246285bc34b7740">beta_binomial_cdf</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga38d6e7672e904359e246285bc34b7740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CDF of the Beta-Binomial distribution with given population size, prior success, and prior failure parameters.  <br /></td></tr>
<tr class="separator:ga38d6e7672e904359e246285bc34b7740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae764dd49aa7c019a3f0667ea420d189d"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:gae764dd49aa7c019a3f0667ea420d189d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_size1, T_size2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae764dd49aa7c019a3f0667ea420d189d.html#gae764dd49aa7c019a3f0667ea420d189d">beta_binomial_cdf_log</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:gae764dd49aa7c019a3f0667ea420d189d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e3df2a8a4d19e4d37c571b67d8384d7"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:ga8e3df2a8a4d19e4d37c571b67d8384d7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_size1, T_size2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga8e3df2a8a4d19e4d37c571b67d8384d7.html#ga8e3df2a8a4d19e4d37c571b67d8384d7">beta_binomial_lccdf</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga8e3df2a8a4d19e4d37c571b67d8384d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log CCDF of the Beta-Binomial distribution with given population size, prior success, and prior failure parameters.  <br /></td></tr>
<tr class="separator:ga8e3df2a8a4d19e4d37c571b67d8384d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga132bb213183af16d8239622e790dbecc"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:ga132bb213183af16d8239622e790dbecc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_size1, T_size2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga132bb213183af16d8239622e790dbecc.html#ga132bb213183af16d8239622e790dbecc">beta_binomial_lcdf</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga132bb213183af16d8239622e790dbecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log CDF of the Beta-Binomial distribution with given population size, prior success, and prior failure parameters.  <br /></td></tr>
<tr class="separator:ga132bb213183af16d8239622e790dbecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91d47b23e7164c7ab8613d471b491984"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_N , typename T_size1 , typename T_size2 , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n, T_N, T_size1, T_size2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga91d47b23e7164c7ab8613d471b491984"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_size1, T_size2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga91d47b23e7164c7ab8613d471b491984.html#ga91d47b23e7164c7ab8613d471b491984">beta_binomial_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga91d47b23e7164c7ab8613d471b491984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Beta-Binomial distribution with given population size, prior success, and prior failure parameters.  <br /></td></tr>
<tr class="separator:ga91d47b23e7164c7ab8613d471b491984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5089149653104229ecf9a90a56a2ef7d"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_size1 , typename T_size2 &gt; </td></tr>
<tr class="memitem:a5089149653104229ecf9a90a56a2ef7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_size1, T_size2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5089149653104229ecf9a90a56a2ef7d.html#a5089149653104229ecf9a90a56a2ef7d">beta_binomial_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_size1 &amp;alpha, const T_size2 &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:a5089149653104229ecf9a90a56a2ef7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fa83d72d18157264c5093ad76d6e01a"><td class="memTemplParams" colspan="2">template&lt;typename T_N , typename T_shape1 , typename T_shape2 , class RNG &gt; </td></tr>
<tr class="memitem:ga2fa83d72d18157264c5093ad76d6e01a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_N, T_shape1, T_shape2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga2fa83d72d18157264c5093ad76d6e01a.html#ga2fa83d72d18157264c5093ad76d6e01a">beta_binomial_rng</a> (const T_N &amp;N, const T_shape1 &amp;alpha, const T_shape2 &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga2fa83d72d18157264c5093ad76d6e01a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a beta-binomial random variate with the specified population size, success, and failure parameters using the given random number generator.  <br /></td></tr>
<tr class="separator:ga2fa83d72d18157264c5093ad76d6e01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6031d7c50a614a373eb35b89933513bf"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:ga6031d7c50a614a373eb35b89933513bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale_succ, T_scale_fail &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga6031d7c50a614a373eb35b89933513bf.html#ga6031d7c50a614a373eb35b89933513bf">beta_ccdf_log</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:ga6031d7c50a614a373eb35b89933513bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2acc03351cc1be378623646b4990611"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:gad2acc03351cc1be378623646b4990611"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale_succ, T_scale_fail &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad2acc03351cc1be378623646b4990611.html#gad2acc03351cc1be378623646b4990611">beta_cdf</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gad2acc03351cc1be378623646b4990611"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the beta cumulative distribution function for the given variate and scale variables.  <br /></td></tr>
<tr class="separator:gad2acc03351cc1be378623646b4990611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad02b21683c02722425289fbd4a070067"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:gad02b21683c02722425289fbd4a070067"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale_succ, T_scale_fail &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad02b21683c02722425289fbd4a070067.html#gad02b21683c02722425289fbd4a070067">beta_cdf_log</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:gad02b21683c02722425289fbd4a070067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3292e0c1671a2df894eb379116b9c8d5"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:ga3292e0c1671a2df894eb379116b9c8d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale_succ, T_scale_fail &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3292e0c1671a2df894eb379116b9c8d5.html#ga3292e0c1671a2df894eb379116b9c8d5">beta_lccdf</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;beta_param)</td></tr>
<tr class="memdesc:ga3292e0c1671a2df894eb379116b9c8d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the beta log complementary cumulative distribution function for the given probability, success, and failure parameters.  <br /></td></tr>
<tr class="separator:ga3292e0c1671a2df894eb379116b9c8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab130b5501c05903119ce6fdf4266163a"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:gab130b5501c05903119ce6fdf4266163a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale_succ, T_scale_fail &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab130b5501c05903119ce6fdf4266163a.html#gab130b5501c05903119ce6fdf4266163a">beta_lcdf</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;beta_param)</td></tr>
<tr class="memdesc:gab130b5501c05903119ce6fdf4266163a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the beta log cumulative distribution function for the given probability, success, and failure parameters.  <br /></td></tr>
<tr class="separator:gab130b5501c05903119ce6fdf4266163a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd2a9fb1a0a2118a50d516888986f0b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_scale_succ , typename T_scale_fail , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_scale_succ, T_scale_fail &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3dd2a9fb1a0a2118a50d516888986f0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale_succ, T_scale_fail &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3dd2a9fb1a0a2118a50d516888986f0b.html#ga3dd2a9fb1a0a2118a50d516888986f0b">beta_lpdf</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga3dd2a9fb1a0a2118a50d516888986f0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the beta density for the specified scalar(s) given the specified sample stan::math::size(s).  <br /></td></tr>
<tr class="separator:ga3dd2a9fb1a0a2118a50d516888986f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54634828a40e230cbc7e57d8256e978b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale_succ , typename T_scale_fail &gt; </td></tr>
<tr class="memitem:a54634828a40e230cbc7e57d8256e978b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale_succ, T_scale_fail &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a54634828a40e230cbc7e57d8256e978b.html#a54634828a40e230cbc7e57d8256e978b">beta_lpdf</a> (const T_y &amp;y, const T_scale_succ &amp;alpha, const T_scale_fail &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:a54634828a40e230cbc7e57d8256e978b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7312bc6a6d30fc084fa2fbd68b4d108"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_r , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:gae7312bc6a6d30fc084fa2fbd68b4d108"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_r, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae7312bc6a6d30fc084fa2fbd68b4d108.html#gae7312bc6a6d30fc084fa2fbd68b4d108">beta_neg_binomial_cdf</a> (const T_n &amp;n, const T_r &amp;r, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, const double precision=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-8, const int max_steps=1e8)</td></tr>
<tr class="memdesc:gae7312bc6a6d30fc084fa2fbd68b4d108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CDF of the Beta-Negative Binomial distribution with given number of successes, prior success, and prior failure parameters.  <br /></td></tr>
<tr class="separator:gae7312bc6a6d30fc084fa2fbd68b4d108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fa92ca85d5451981e4f1c7027d1fd5b"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_r , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:ga1fa92ca85d5451981e4f1c7027d1fd5b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_r, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga1fa92ca85d5451981e4f1c7027d1fd5b.html#ga1fa92ca85d5451981e4f1c7027d1fd5b">beta_neg_binomial_lccdf</a> (const T_n &amp;n, const T_r &amp;r, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, const double precision=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-8, const int max_steps=1e8)</td></tr>
<tr class="memdesc:ga1fa92ca85d5451981e4f1c7027d1fd5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log CCDF of the Beta-Negative Binomial distribution with given number of successes, prior success, and prior failure parameters.  <br /></td></tr>
<tr class="separator:ga1fa92ca85d5451981e4f1c7027d1fd5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92405e884f6190d0a1524c561fc92b1f"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_r , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:ga92405e884f6190d0a1524c561fc92b1f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_r, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga92405e884f6190d0a1524c561fc92b1f.html#ga92405e884f6190d0a1524c561fc92b1f">beta_neg_binomial_lcdf</a> (const T_n &amp;n, const T_r &amp;r, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, const double precision=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-8, const int max_steps=1e8)</td></tr>
<tr class="memdesc:ga92405e884f6190d0a1524c561fc92b1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log CDF of the Beta-Negative Binomial distribution with given number of successes, prior success, and prior failure parameters.  <br /></td></tr>
<tr class="separator:ga92405e884f6190d0a1524c561fc92b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga195914d6f59a441f187e452e98e45a02"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_r , typename T_alpha , typename T_beta , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n, T_r, T_alpha, T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga195914d6f59a441f187e452e98e45a02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_r, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga195914d6f59a441f187e452e98e45a02.html#ga195914d6f59a441f187e452e98e45a02">beta_neg_binomial_lpmf</a> (const T_n &amp;n, const T_r &amp;r, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga195914d6f59a441f187e452e98e45a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Beta Negative Binomial distribution with given number of successes, prior success, and prior failure parameters.  <br /></td></tr>
<tr class="separator:ga195914d6f59a441f187e452e98e45a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bea0e39daa138e7ec4c8f02eb651ce6"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_r , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:a4bea0e39daa138e7ec4c8f02eb651ce6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_r, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4bea0e39daa138e7ec4c8f02eb651ce6.html#a4bea0e39daa138e7ec4c8f02eb651ce6">beta_neg_binomial_lpmf</a> (const T_n &amp;n, const T_r &amp;r, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:a4bea0e39daa138e7ec4c8f02eb651ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba6c87439536af2c3d1bbdc3d199c0fe"><td class="memTemplParams" colspan="2">template&lt;typename T_r , typename T_alpha , typename T_beta , typename RNG &gt; </td></tr>
<tr class="memitem:gaba6c87439536af2c3d1bbdc3d199c0fe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaba6c87439536af2c3d1bbdc3d199c0fe.html#gaba6c87439536af2c3d1bbdc3d199c0fe">beta_neg_binomial_rng</a> (const T_r &amp;r, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, RNG &amp;rng)</td></tr>
<tr class="memdesc:gaba6c87439536af2c3d1bbdc3d199c0fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a beta-negative binomial random variate with the given number of successes, prior success, and prior failure parameters, using the given random number generator.  <br /></td></tr>
<tr class="separator:gaba6c87439536af2c3d1bbdc3d199c0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65d4234e09916b46282762e92f55b242"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_prec &gt; </td></tr>
<tr class="memitem:ga65d4234e09916b46282762e92f55b242"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_prec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga65d4234e09916b46282762e92f55b242.html#ga65d4234e09916b46282762e92f55b242">beta_proportion_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_prec &amp;kappa)</td></tr>
<tr class="separator:ga65d4234e09916b46282762e92f55b242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c0b84bbdff3d171a369677d233fe56"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_prec &gt; </td></tr>
<tr class="memitem:gab7c0b84bbdff3d171a369677d233fe56"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_prec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab7c0b84bbdff3d171a369677d233fe56.html#gab7c0b84bbdff3d171a369677d233fe56">beta_proportion_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_prec &amp;kappa)</td></tr>
<tr class="separator:gab7c0b84bbdff3d171a369677d233fe56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0d3b12eacd31f95bd3f9f9e1ef4b056"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_prec &gt; </td></tr>
<tr class="memitem:gab0d3b12eacd31f95bd3f9f9e1ef4b056"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_prec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab0d3b12eacd31f95bd3f9f9e1ef4b056.html#gab0d3b12eacd31f95bd3f9f9e1ef4b056">beta_proportion_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_prec &amp;kappa)</td></tr>
<tr class="memdesc:gab0d3b12eacd31f95bd3f9f9e1ef4b056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the beta log complementary cumulative distribution function for specified probability, location, and precision parameters: beta_proportion_lccdf(y | mu, kappa) = beta_lccdf(y | mu * kappa, (1 - mu) * kappa).  <br /></td></tr>
<tr class="separator:gab0d3b12eacd31f95bd3f9f9e1ef4b056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99a253259819291233c02bd4806673a1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_prec &gt; </td></tr>
<tr class="memitem:ga99a253259819291233c02bd4806673a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_prec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga99a253259819291233c02bd4806673a1.html#ga99a253259819291233c02bd4806673a1">beta_proportion_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_prec &amp;kappa)</td></tr>
<tr class="memdesc:ga99a253259819291233c02bd4806673a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the beta log cumulative distribution function for specified probability, location, and precision parameters: beta_proportion_lcdf(y | mu, kappa) = beta_lcdf(y | mu * kappa, (1 - mu) * kappa).  <br /></td></tr>
<tr class="separator:ga99a253259819291233c02bd4806673a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13da3ab0e1dfe5ab00fb14437df0c824"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_prec , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_prec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga13da3ab0e1dfe5ab00fb14437df0c824"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_prec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga13da3ab0e1dfe5ab00fb14437df0c824.html#ga13da3ab0e1dfe5ab00fb14437df0c824">beta_proportion_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_prec &amp;kappa)</td></tr>
<tr class="memdesc:ga13da3ab0e1dfe5ab00fb14437df0c824"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the beta density for specified y, location, and precision: beta_proportion_lpdf(y | mu, kappa) = beta_lpdf(y | mu * kappa, (1 - mu) * kappa).  <br /></td></tr>
<tr class="separator:ga13da3ab0e1dfe5ab00fb14437df0c824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada0e6cd720b82824bf998fe76e75dce"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_prec &gt; </td></tr>
<tr class="memitem:aada0e6cd720b82824bf998fe76e75dce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_prec &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aada0e6cd720b82824bf998fe76e75dce.html#aada0e6cd720b82824bf998fe76e75dce">beta_proportion_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_prec &amp;kappa)</td></tr>
<tr class="separator:aada0e6cd720b82824bf998fe76e75dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad45fd44e8f51e1267f708e85c6c718c4"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_prec , class RNG &gt; </td></tr>
<tr class="memitem:gad45fd44e8f51e1267f708e85c6c718c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_prec &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad45fd44e8f51e1267f708e85c6c718c4.html#gad45fd44e8f51e1267f708e85c6c718c4">beta_proportion_rng</a> (const T_loc &amp;mu, const T_prec &amp;kappa, RNG &amp;rng)</td></tr>
<tr class="memdesc:gad45fd44e8f51e1267f708e85c6c718c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Beta random variate specified probability, location, and precision parameters: beta_proportion_rng(y | mu, kappa) = beta_rng(y | mu * kappa, (1 - mu) * kappa).  <br /></td></tr>
<tr class="separator:gad45fd44e8f51e1267f708e85c6c718c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89ab9781a556340c59a1077e22f53b7d"><td class="memTemplParams" colspan="2">template&lt;typename T_shape1 , typename T_shape2 , class RNG &gt; </td></tr>
<tr class="memitem:ga89ab9781a556340c59a1077e22f53b7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_shape1, T_shape2 &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga89ab9781a556340c59a1077e22f53b7d.html#ga89ab9781a556340c59a1077e22f53b7d">beta_rng</a> (const T_shape1 &amp;alpha, const T_shape2 &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga89ab9781a556340c59a1077e22f53b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Beta random variate with the supplied success and failure parameters using the given random number generator.  <br /></td></tr>
<tr class="separator:ga89ab9781a556340c59a1077e22f53b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02c4e680cb0872cb702c33358a958e16"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:ga02c4e680cb0872cb702c33358a958e16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga02c4e680cb0872cb702c33358a958e16.html#ga02c4e680cb0872cb702c33358a958e16">binomial_ccdf_log</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga02c4e680cb0872cb702c33358a958e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c22af29d78046a1a8de90e57d576e2"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:ga49c22af29d78046a1a8de90e57d576e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga49c22af29d78046a1a8de90e57d576e2.html#ga49c22af29d78046a1a8de90e57d576e2">binomial_cdf</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="memdesc:ga49c22af29d78046a1a8de90e57d576e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CDF for the binomial distribution evaluated at the specified success, population size, and chance of success.  <br /></td></tr>
<tr class="separator:ga49c22af29d78046a1a8de90e57d576e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga605e6ae20fef90e303a1a7a83f18d80c"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:ga605e6ae20fef90e303a1a7a83f18d80c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga605e6ae20fef90e303a1a7a83f18d80c.html#ga605e6ae20fef90e303a1a7a83f18d80c">binomial_cdf_log</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="separator:ga605e6ae20fef90e303a1a7a83f18d80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac59a3643b3b9d1ef4b6de3247fc5813e"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:gac59a3643b3b9d1ef4b6de3247fc5813e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gac59a3643b3b9d1ef4b6de3247fc5813e.html#gac59a3643b3b9d1ef4b6de3247fc5813e">binomial_lccdf</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="memdesc:gac59a3643b3b9d1ef4b6de3247fc5813e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log CCDF for the binomial distribution evaluated at the specified success, population size, and chance of success.  <br /></td></tr>
<tr class="separator:gac59a3643b3b9d1ef4b6de3247fc5813e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4c9e1b71238433f325bce942e6fccf9"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:gaa4c9e1b71238433f325bce942e6fccf9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaa4c9e1b71238433f325bce942e6fccf9.html#gaa4c9e1b71238433f325bce942e6fccf9">binomial_lcdf</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="memdesc:gaa4c9e1b71238433f325bce942e6fccf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log CDF for the binomial distribution evaluated at the specified success, population size, and chance of success.  <br /></td></tr>
<tr class="separator:gaa4c9e1b71238433f325bce942e6fccf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ac73687dce00be0d80bea1ae128c662"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_N , typename T_x , typename T_alpha , typename T_beta , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5ac73687dce00be0d80bea1ae128c662"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga5ac73687dce00be0d80bea1ae128c662.html#ga5ac73687dce00be0d80bea1ae128c662">binomial_logit_glm_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga5ac73687dce00be0d80bea1ae128c662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Binomial distribution and logit link function.  <br /></td></tr>
<tr class="separator:ga5ac73687dce00be0d80bea1ae128c662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb58c3874e9a3ecb59a9558295df416e"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_x , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:acb58c3874e9a3ecb59a9558295df416e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_beta, T_alpha &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acb58c3874e9a3ecb59a9558295df416e.html#acb58c3874e9a3ecb59a9558295df416e">binomial_logit_glm_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:acb58c3874e9a3ecb59a9558295df416e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf0311a67c81d425cacd2c6dc6d0c304"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_N , typename T_prob , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n, T_N, T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacf0311a67c81d425cacd2c6dc6d0c304"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gacf0311a67c81d425cacd2c6dc6d0c304.html#gacf0311a67c81d425cacd2c6dc6d0c304">binomial_logit_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;alpha)</td></tr>
<tr class="memdesc:gacf0311a67c81d425cacd2c6dc6d0c304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binomial log PMF in logit parametrization.  <br /></td></tr>
<tr class="separator:gacf0311a67c81d425cacd2c6dc6d0c304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18810b7dcd16574d4a1d1b12bcd34d4c"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:a18810b7dcd16574d4a1d1b12bcd34d4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a18810b7dcd16574d4a1d1b12bcd34d4c.html#a18810b7dcd16574d4a1d1b12bcd34d4c">binomial_logit_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;alpha)</td></tr>
<tr class="separator:a18810b7dcd16574d4a1d1b12bcd34d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfb3359733bd0b6f87ec3736b88620ba"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_N , typename T_prob , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n, T_N, T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gadfb3359733bd0b6f87ec3736b88620ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gadfb3359733bd0b6f87ec3736b88620ba.html#gadfb3359733bd0b6f87ec3736b88620ba">binomial_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="memdesc:gadfb3359733bd0b6f87ec3736b88620ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF for the binomial distribution evaluated at the specified success, population size, and chance of success.  <br /></td></tr>
<tr class="separator:gadfb3359733bd0b6f87ec3736b88620ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e58df032276b50d8d320098e764ec9"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_prob &gt; </td></tr>
<tr class="memitem:a63e58df032276b50d8d320098e764ec9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a63e58df032276b50d8d320098e764ec9.html#a63e58df032276b50d8d320098e764ec9">binomial_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_prob &amp;theta)</td></tr>
<tr class="separator:a63e58df032276b50d8d320098e764ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86d430da2cf1d3c5e9e84459a1197458"><td class="memTemplParams" colspan="2">template&lt;typename T_N , typename T_theta , class RNG &gt; </td></tr>
<tr class="memitem:ga86d430da2cf1d3c5e9e84459a1197458"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_N, T_theta &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga86d430da2cf1d3c5e9e84459a1197458.html#ga86d430da2cf1d3c5e9e84459a1197458">binomial_rng</a> (const T_N &amp;N, const T_theta &amp;theta, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga86d430da2cf1d3c5e9e84459a1197458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pseudorandom binomial random variable for the given population size and chance of success parameters using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga86d430da2cf1d3c5e9e84459a1197458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66cf9ba7d33aa08758ce146962b3c7fe"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T_x &gt; *  = nullptr, <a class="el" href="group__col__vector__types_ga58096049cb8906ec6ad5f44f1e6fe082.html#ga58096049cb8906ec6ad5f44f1e6fe082">require_col_vector_t</a>&lt; T_alpha &gt; *  = nullptr, <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga66cf9ba7d33aa08758ce146962b3c7fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga66cf9ba7d33aa08758ce146962b3c7fe.html#ga66cf9ba7d33aa08758ce146962b3c7fe">categorical_logit_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga66cf9ba7d33aa08758ce146962b3c7fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with categorical distribution and logit (softmax) link function.  <br /></td></tr>
<tr class="separator:ga66cf9ba7d33aa08758ce146962b3c7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1996afa7edf939d2c3ff12649b8fd909"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:a1996afa7edf939d2c3ff12649b8fd909"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1996afa7edf939d2c3ff12649b8fd909.html#a1996afa7edf939d2c3ff12649b8fd909">categorical_logit_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:a1996afa7edf939d2c3ff12649b8fd909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3907bbcce319d14a13714d5d21deb5"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , <a class="el" href="group__col__vector__types_ga58096049cb8906ec6ad5f44f1e6fe082.html#ga58096049cb8906ec6ad5f44f1e6fe082">require_col_vector_t</a>&lt; T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adc3907bbcce319d14a13714d5d21deb5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adc3907bbcce319d14a13714d5d21deb5.html#adc3907bbcce319d14a13714d5d21deb5">categorical_logit_lpmf</a> (int n, const T_prob &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:adc3907bbcce319d14a13714d5d21deb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe739c7463744f463ef05f0796322a5d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , <a class="el" href="group__col__vector__types_ga58096049cb8906ec6ad5f44f1e6fe082.html#ga58096049cb8906ec6ad5f44f1e6fe082">require_col_vector_t</a>&lt; T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afe739c7463744f463ef05f0796322a5d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afe739c7463744f463ef05f0796322a5d.html#afe739c7463744f463ef05f0796322a5d">categorical_logit_lpmf</a> (const std::vector&lt; int &gt; &amp;ns, const T_prob &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:afe739c7463744f463ef05f0796322a5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba9b8c5444b9be3e1ebc450c830d4ab"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob , <a class="el" href="group__integral__types_ga8d10ea9813909bf7fc1a2394e880165a.html#ga8d10ea9813909bf7fc1a2394e880165a">require_st_integral</a>&lt; T_n &gt; *  = nullptr, <a class="el" href="group__col__vector__types_ga58096049cb8906ec6ad5f44f1e6fe082.html#ga58096049cb8906ec6ad5f44f1e6fe082">require_col_vector_t</a>&lt; T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1ba9b8c5444b9be3e1ebc450c830d4ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1ba9b8c5444b9be3e1ebc450c830d4ab.html#a1ba9b8c5444b9be3e1ebc450c830d4ab">categorical_logit_lpmf</a> (const T_n &amp;ns, const T_prob &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:a1ba9b8c5444b9be3e1ebc450c830d4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga735693bdf47c855697175ca6f5698929"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ga735693bdf47c855697175ca6f5698929"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga735693bdf47c855697175ca6f5698929.html#ga735693bdf47c855697175ca6f5698929">categorical_logit_rng</a> (const Eigen::VectorXd &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga735693bdf47c855697175ca6f5698929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a draw from a Categorical distribution given a a vector of unnormalized log probabilities and a psuedo-random number generator.  <br /></td></tr>
<tr class="separator:ga735693bdf47c855697175ca6f5698929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a82e2fb9c19f283043bb44c8a8281f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a53a82e2fb9c19f283043bb44c8a8281f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a53a82e2fb9c19f283043bb44c8a8281f.html#a53a82e2fb9c19f283043bb44c8a8281f">categorical_lpmf</a> (int n, const T_prob &amp;theta)</td></tr>
<tr class="separator:a53a82e2fb9c19f283043bb44c8a8281f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c9fb2292d355183a3adac786bcff1c"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab1c9fb2292d355183a3adac786bcff1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab1c9fb2292d355183a3adac786bcff1c.html#ab1c9fb2292d355183a3adac786bcff1c">categorical_lpmf</a> (const std::vector&lt; int &gt; &amp;ns, const T_prob &amp;theta)</td></tr>
<tr class="separator:ab1c9fb2292d355183a3adac786bcff1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4aa462dbb40d13ef8888088fed6924"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_prob , <a class="el" href="group__integral__types_ga8d10ea9813909bf7fc1a2394e880165a.html#ga8d10ea9813909bf7fc1a2394e880165a">require_st_integral</a>&lt; T_n &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abf4aa462dbb40d13ef8888088fed6924"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abf4aa462dbb40d13ef8888088fed6924.html#abf4aa462dbb40d13ef8888088fed6924">categorical_lpmf</a> (const T_n &amp;ns, const T_prob &amp;theta)</td></tr>
<tr class="separator:abf4aa462dbb40d13ef8888088fed6924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8b55cdaa59f3fe7718d5b45889cda6"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a1f8b55cdaa59f3fe7718d5b45889cda6"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1f8b55cdaa59f3fe7718d5b45889cda6.html#a1f8b55cdaa59f3fe7718d5b45889cda6">categorical_rng</a> (const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;theta, RNG &amp;rng)</td></tr>
<tr class="separator:a1f8b55cdaa59f3fe7718d5b45889cda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4506fe83953ba5694e27b232b46c3ee1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga4506fe83953ba5694e27b232b46c3ee1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga4506fe83953ba5694e27b232b46c3ee1.html#ga4506fe83953ba5694e27b232b46c3ee1">cauchy_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga4506fe83953ba5694e27b232b46c3ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga958ea818fe25772e9188cd82af26c07c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga958ea818fe25772e9188cd82af26c07c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga958ea818fe25772e9188cd82af26c07c.html#ga958ea818fe25772e9188cd82af26c07c">cauchy_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:ga958ea818fe25772e9188cd82af26c07c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cauchy cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:ga958ea818fe25772e9188cd82af26c07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40dd05c398b3b54d64acba39dbff09ca"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga40dd05c398b3b54d64acba39dbff09ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga40dd05c398b3b54d64acba39dbff09ca.html#ga40dd05c398b3b54d64acba39dbff09ca">cauchy_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga40dd05c398b3b54d64acba39dbff09ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa775f1ea0aa8786c7edf40d1f40fcd58"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa775f1ea0aa8786c7edf40d1f40fcd58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaa775f1ea0aa8786c7edf40d1f40fcd58.html#gaa775f1ea0aa8786c7edf40d1f40fcd58">cauchy_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:gaa775f1ea0aa8786c7edf40d1f40fcd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cauchy log complementary cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gaa775f1ea0aa8786c7edf40d1f40fcd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8ad823ea5e14a7bd72fa4d34cfce197"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa8ad823ea5e14a7bd72fa4d34cfce197"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaa8ad823ea5e14a7bd72fa4d34cfce197.html#gaa8ad823ea5e14a7bd72fa4d34cfce197">cauchy_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:gaa8ad823ea5e14a7bd72fa4d34cfce197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cauchy log cumulative distribution function for the given location, and scale.  <br /></td></tr>
<tr class="separator:gaa8ad823ea5e14a7bd72fa4d34cfce197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dac7d09986306ce882e80436db60505"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6dac7d09986306ce882e80436db60505"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga6dac7d09986306ce882e80436db60505.html#ga6dac7d09986306ce882e80436db60505">cauchy_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:ga6dac7d09986306ce882e80436db60505"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Cauchy density for the specified scalar(s) given the specified location parameter(s) and scale parameter(s).  <br /></td></tr>
<tr class="separator:ga6dac7d09986306ce882e80436db60505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2f8f9b4b22a7f97ac54a85cf8889c0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:add2f8f9b4b22a7f97ac54a85cf8889c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_add2f8f9b4b22a7f97ac54a85cf8889c0.html#add2f8f9b4b22a7f97ac54a85cf8889c0">cauchy_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:add2f8f9b4b22a7f97ac54a85cf8889c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33561f2f42f28a43c006a53eb7bd5729"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga33561f2f42f28a43c006a53eb7bd5729"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga33561f2f42f28a43c006a53eb7bd5729.html#ga33561f2f42f28a43c006a53eb7bd5729">cauchy_rng</a> (const T_loc &amp;mu, const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga33561f2f42f28a43c006a53eb7bd5729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Cauchy random variate for the given location and scale using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga33561f2f42f28a43c006a53eb7bd5729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5999717e92da73cb35fe3495354297f1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:ga5999717e92da73cb35fe3495354297f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga5999717e92da73cb35fe3495354297f1.html#ga5999717e92da73cb35fe3495354297f1">chi_square_ccdf_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:ga5999717e92da73cb35fe3495354297f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7861a9d400d6fdee9c7ca517c87b6770"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:ga7861a9d400d6fdee9c7ca517c87b6770"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga7861a9d400d6fdee9c7ca517c87b6770.html#ga7861a9d400d6fdee9c7ca517c87b6770">chi_square_cdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="memdesc:ga7861a9d400d6fdee9c7ca517c87b6770"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the chi square cumulative distribution function for the given variate and degrees of freedom.  <br /></td></tr>
<tr class="separator:ga7861a9d400d6fdee9c7ca517c87b6770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5e143c742b49ef8a9fce06779e15552"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:gad5e143c742b49ef8a9fce06779e15552"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad5e143c742b49ef8a9fce06779e15552.html#gad5e143c742b49ef8a9fce06779e15552">chi_square_cdf_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:gad5e143c742b49ef8a9fce06779e15552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3da5db5a9f336d83a9530af2d2ed2585"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:ga3da5db5a9f336d83a9530af2d2ed2585"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3da5db5a9f336d83a9530af2d2ed2585.html#ga3da5db5a9f336d83a9530af2d2ed2585">chi_square_lccdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="memdesc:ga3da5db5a9f336d83a9530af2d2ed2585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the chi square log complementary cumulative distribution function for the given variate and degrees of freedom.  <br /></td></tr>
<tr class="separator:ga3da5db5a9f336d83a9530af2d2ed2585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfcef6ac004d4850f005b92b2d9dca90"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:gadfcef6ac004d4850f005b92b2d9dca90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gadfcef6ac004d4850f005b92b2d9dca90.html#gadfcef6ac004d4850f005b92b2d9dca90">chi_square_lcdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="memdesc:gadfcef6ac004d4850f005b92b2d9dca90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the chi square log cumulative distribution function for the given variate and degrees of freedom.  <br /></td></tr>
<tr class="separator:gadfcef6ac004d4850f005b92b2d9dca90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fda2ed791f967ae7907d175f702e11d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_dof &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga0fda2ed791f967ae7907d175f702e11d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga0fda2ed791f967ae7907d175f702e11d.html#ga0fda2ed791f967ae7907d175f702e11d">chi_square_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="memdesc:ga0fda2ed791f967ae7907d175f702e11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a chi-squared density for y with the specified degrees of freedom parameter.  <br /></td></tr>
<tr class="separator:ga0fda2ed791f967ae7907d175f702e11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa94cd0fe27fb20f4ba90997761607c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:abfa94cd0fe27fb20f4ba90997761607c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abfa94cd0fe27fb20f4ba90997761607c.html#abfa94cd0fe27fb20f4ba90997761607c">chi_square_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:abfa94cd0fe27fb20f4ba90997761607c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bcf747c6df2b5799f4980adcc228523"><td class="memTemplParams" colspan="2">template&lt;typename T_deg , class RNG &gt; </td></tr>
<tr class="memitem:ga4bcf747c6df2b5799f4980adcc228523"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_deg &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga4bcf747c6df2b5799f4980adcc228523.html#ga4bcf747c6df2b5799f4980adcc228523">chi_square_rng</a> (const T_deg &amp;nu, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga4bcf747c6df2b5799f4980adcc228523"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a chi squared random variate with nu degrees of freedom using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga4bcf747c6df2b5799f4980adcc228523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad895e7a80ecd48d1628fbc3e46156b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , typename T_prior_size , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_prob, T_prior_size &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gacad895e7a80ecd48d1628fbc3e46156b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob, T_prior_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gacad895e7a80ecd48d1628fbc3e46156b.html#gacad895e7a80ecd48d1628fbc3e46156b">dirichlet_lpdf</a> (const T_prob &amp;theta, const T_prior_size &amp;alpha)</td></tr>
<tr class="memdesc:gacad895e7a80ecd48d1628fbc3e46156b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Dirichlet density for the given theta and a vector of prior sample sizes, alpha.  <br /></td></tr>
<tr class="separator:gacad895e7a80ecd48d1628fbc3e46156b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59588fc22720a213717c76fc5abe6a29"><td class="memTemplParams" colspan="2">template&lt;typename T_prob , typename T_prior_size &gt; </td></tr>
<tr class="memitem:a59588fc22720a213717c76fc5abe6a29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob, T_prior_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a59588fc22720a213717c76fc5abe6a29.html#a59588fc22720a213717c76fc5abe6a29">dirichlet_lpdf</a> (const T_prob &amp;theta, const T_prior_size &amp;alpha)</td></tr>
<tr class="separator:a59588fc22720a213717c76fc5abe6a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7842f54120112aaaed729063a4438ea"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prior_size , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_prior_size &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae7842f54120112aaaed729063a4438ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prior_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gae7842f54120112aaaed729063a4438ea.html#gae7842f54120112aaaed729063a4438ea">dirichlet_multinomial_lpmf</a> (const std::vector&lt; int &gt; &amp;ns, const T_prior_size &amp;alpha)</td></tr>
<tr class="memdesc:gae7842f54120112aaaed729063a4438ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Dirichlet-Multinomial probability for the given integer vector \(n\) and a vector of prior sample sizes, \(\alpha\).  <br /></td></tr>
<tr class="separator:gae7842f54120112aaaed729063a4438ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f82b348b76c1374010c649ef2892740"><td class="memTemplParams" colspan="2">template&lt;typename T_prior_size &gt; </td></tr>
<tr class="memitem:a5f82b348b76c1374010c649ef2892740"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prior_size &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5f82b348b76c1374010c649ef2892740.html#a5f82b348b76c1374010c649ef2892740">dirichlet_multinomial_lpmf</a> (const std::vector&lt; int &gt; &amp;ns, const T_prior_size &amp;alpha)</td></tr>
<tr class="separator:a5f82b348b76c1374010c649ef2892740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1acef1610ba212f530803261300d838e"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ga1acef1610ba212f530803261300d838e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga1acef1610ba212f530803261300d838e.html#ga1acef1610ba212f530803261300d838e">dirichlet_multinomial_rng</a> (const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;alpha, int N, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga1acef1610ba212f530803261300d838e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a draw from a Dirichlet-Multinomial distribution with specified parameters \(\alpha\) and \(N\) and pseudo-random number generator rng.  <br /></td></tr>
<tr class="separator:ga1acef1610ba212f530803261300d838e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb288324f889b7da57f2960570f459ea"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:gacb288324f889b7da57f2960570f459ea"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gacb288324f889b7da57f2960570f459ea.html#gacb288324f889b7da57f2960570f459ea">dirichlet_rng</a> (const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;alpha, RNG &amp;rng)</td></tr>
<tr class="memdesc:gacb288324f889b7da57f2960570f459ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a draw from a Dirichlet distribution with specified parameters and pseudo-random number generator.  <br /></td></tr>
<tr class="separator:gacb288324f889b7da57f2960570f459ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7621b6ab8cbcc4349c5c2be9c1ec42e1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_lower , typename T_upper &gt; </td></tr>
<tr class="memitem:ga7621b6ab8cbcc4349c5c2be9c1ec42e1"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga7621b6ab8cbcc4349c5c2be9c1ec42e1.html#ga7621b6ab8cbcc4349c5c2be9c1ec42e1">discrete_range_ccdf_log</a> (const T_y &amp;y, const T_lower &amp;lower, const T_upper &amp;upper)</td></tr>
<tr class="separator:ga7621b6ab8cbcc4349c5c2be9c1ec42e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7cc6ceebeb08c343f18bab11942ff28"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_lower , typename T_upper &gt; </td></tr>
<tr class="memitem:gaf7cc6ceebeb08c343f18bab11942ff28"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaf7cc6ceebeb08c343f18bab11942ff28.html#gaf7cc6ceebeb08c343f18bab11942ff28">discrete_range_cdf</a> (const T_y &amp;y, const T_lower &amp;lower, const T_upper &amp;upper)</td></tr>
<tr class="memdesc:gaf7cc6ceebeb08c343f18bab11942ff28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the CDF of a discrete range distribution for the given y, lower and upper bounds (all integers).  <br /></td></tr>
<tr class="separator:gaf7cc6ceebeb08c343f18bab11942ff28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf813f3e5c20172f6cceed446f096a326"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_lower , typename T_upper &gt; </td></tr>
<tr class="memitem:gaf813f3e5c20172f6cceed446f096a326"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaf813f3e5c20172f6cceed446f096a326.html#gaf813f3e5c20172f6cceed446f096a326">discrete_range_cdf_log</a> (const T_y &amp;y, const T_lower &amp;lower, const T_upper &amp;upper)</td></tr>
<tr class="separator:gaf813f3e5c20172f6cceed446f096a326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab63d42319276a30b3b06721fe60daa8d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_lower , typename T_upper &gt; </td></tr>
<tr class="memitem:gab63d42319276a30b3b06721fe60daa8d"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab63d42319276a30b3b06721fe60daa8d.html#gab63d42319276a30b3b06721fe60daa8d">discrete_range_lccdf</a> (const T_y &amp;y, const T_lower &amp;lower, const T_upper &amp;upper)</td></tr>
<tr class="memdesc:gab63d42319276a30b3b06721fe60daa8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log CCDF of a discrete range distribution for the given y, lower and upper bounds (all integers).  <br /></td></tr>
<tr class="separator:gab63d42319276a30b3b06721fe60daa8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga034e6456b6fe522ba26bf9df45517b90"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_lower , typename T_upper &gt; </td></tr>
<tr class="memitem:ga034e6456b6fe522ba26bf9df45517b90"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga034e6456b6fe522ba26bf9df45517b90.html#ga034e6456b6fe522ba26bf9df45517b90">discrete_range_lcdf</a> (const T_y &amp;y, const T_lower &amp;lower, const T_upper &amp;upper)</td></tr>
<tr class="memdesc:ga034e6456b6fe522ba26bf9df45517b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log CDF of a discrete range distribution for the given y, lower and upper bounds (all integers).  <br /></td></tr>
<tr class="separator:ga034e6456b6fe522ba26bf9df45517b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98e44514f76d23b96c80f75857579f86"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_lower , typename T_upper &gt; </td></tr>
<tr class="memitem:ga98e44514f76d23b96c80f75857579f86"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga98e44514f76d23b96c80f75857579f86.html#ga98e44514f76d23b96c80f75857579f86">discrete_range_lpmf</a> (const T_y &amp;y, const T_lower &amp;lower, const T_upper &amp;upper)</td></tr>
<tr class="memdesc:ga98e44514f76d23b96c80f75857579f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log PMF of a discrete range for the given y, lower and upper bound (all integers).  <br /></td></tr>
<tr class="separator:ga98e44514f76d23b96c80f75857579f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af071177a90fab33367de7a7b84904a4a"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_lower , typename T_upper &gt; </td></tr>
<tr class="memitem:af071177a90fab33367de7a7b84904a4a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af071177a90fab33367de7a7b84904a4a.html#af071177a90fab33367de7a7b84904a4a">discrete_range_lpmf</a> (const T_y &amp;y, const T_lower &amp;lower, const T_upper &amp;upper)</td></tr>
<tr class="separator:af071177a90fab33367de7a7b84904a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e2a9abf50a319d6263a5d3ff8a6e3a6"><td class="memTemplParams" colspan="2">template&lt;typename T_lower , typename T_upper , class RNG &gt; </td></tr>
<tr class="memitem:ga0e2a9abf50a319d6263a5d3ff8a6e3a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_lower, T_upper &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga0e2a9abf50a319d6263a5d3ff8a6e3a6.html#ga0e2a9abf50a319d6263a5d3ff8a6e3a6">discrete_range_rng</a> (const T_lower &amp;lower, const T_upper &amp;upper, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga0e2a9abf50a319d6263a5d3ff8a6e3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an integer random variate between the given lower and upper bounds (inclusive) using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga0e2a9abf50a319d6263a5d3ff8a6e3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20cd2073054e3c5945637ccafcc0e9e0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga20cd2073054e3c5945637ccafcc0e9e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga20cd2073054e3c5945637ccafcc0e9e0.html#ga20cd2073054e3c5945637ccafcc0e9e0">double_exponential_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga20cd2073054e3c5945637ccafcc0e9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39cf24218395a5b075798e58518156f9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga39cf24218395a5b075798e58518156f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga39cf24218395a5b075798e58518156f9.html#ga39cf24218395a5b075798e58518156f9">double_exponential_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:ga39cf24218395a5b075798e58518156f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double exponential cumulative density function.  <br /></td></tr>
<tr class="separator:ga39cf24218395a5b075798e58518156f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5775dd396e8591f76cfe205935018985"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga5775dd396e8591f76cfe205935018985"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga5775dd396e8591f76cfe205935018985.html#ga5775dd396e8591f76cfe205935018985">double_exponential_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga5775dd396e8591f76cfe205935018985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34f9bcdef2e234a1711683ee05559fa1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga34f9bcdef2e234a1711683ee05559fa1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga34f9bcdef2e234a1711683ee05559fa1.html#ga34f9bcdef2e234a1711683ee05559fa1">double_exponential_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:ga34f9bcdef2e234a1711683ee05559fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double exponential log complementary cumulative density function.  <br /></td></tr>
<tr class="separator:ga34f9bcdef2e234a1711683ee05559fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a0202a1a9bb5109858c41c1307f2d24"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga1a0202a1a9bb5109858c41c1307f2d24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga1a0202a1a9bb5109858c41c1307f2d24.html#ga1a0202a1a9bb5109858c41c1307f2d24">double_exponential_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:ga1a0202a1a9bb5109858c41c1307f2d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double exponential log cumulative density function.  <br /></td></tr>
<tr class="separator:ga1a0202a1a9bb5109858c41c1307f2d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6bab787e5f015a48b9a53a2cf66833b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae6bab787e5f015a48b9a53a2cf66833b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae6bab787e5f015a48b9a53a2cf66833b.html#gae6bab787e5f015a48b9a53a2cf66833b">double_exponential_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:gae6bab787e5f015a48b9a53a2cf66833b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double exponential log probability density function.  <br /></td></tr>
<tr class="separator:gae6bab787e5f015a48b9a53a2cf66833b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab08594af7c5c305a86541d01f30e12a7"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ab08594af7c5c305a86541d01f30e12a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab08594af7c5c305a86541d01f30e12a7.html#ab08594af7c5c305a86541d01f30e12a7">double_exponential_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ab08594af7c5c305a86541d01f30e12a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga762eb9bfe4088a8d5aef28147599ed77"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga762eb9bfe4088a8d5aef28147599ed77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga762eb9bfe4088a8d5aef28147599ed77.html#ga762eb9bfe4088a8d5aef28147599ed77">double_exponential_rng</a> (const T_loc &amp;mu, const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga762eb9bfe4088a8d5aef28147599ed77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a double exponential random variate with the given location and scale using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga762eb9bfe4088a8d5aef28147599ed77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a2de80318bcc979e4811deaa1ed521f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:ga2a2de80318bcc979e4811deaa1ed521f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga2a2de80318bcc979e4811deaa1ed521f.html#ga2a2de80318bcc979e4811deaa1ed521f">exp_mod_normal_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:ga2a2de80318bcc979e4811deaa1ed521f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf929bea1efa40a11bc5284fd898d88f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaf929bea1efa40a11bc5284fd898d88f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaf929bea1efa40a11bc5284fd898d88f.html#aaf929bea1efa40a11bc5284fd898d88f">exp_mod_normal_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:aaf929bea1efa40a11bc5284fd898d88f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5926eff671b9d85caf5ae94b6027f37"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:gaa5926eff671b9d85caf5ae94b6027f37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaa5926eff671b9d85caf5ae94b6027f37.html#gaa5926eff671b9d85caf5ae94b6027f37">exp_mod_normal_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:gaa5926eff671b9d85caf5ae94b6027f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9be9842bbd716e5c11f1ebc3e1ec913"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af9be9842bbd716e5c11f1ebc3e1ec913"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af9be9842bbd716e5c11f1ebc3e1ec913.html#af9be9842bbd716e5c11f1ebc3e1ec913">exp_mod_normal_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:af9be9842bbd716e5c11f1ebc3e1ec913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1d9ef5405ce7596112954002d2b7f6"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:add1d9ef5405ce7596112954002d2b7f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_add1d9ef5405ce7596112954002d2b7f6.html#add1d9ef5405ce7596112954002d2b7f6">exp_mod_normal_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:add1d9ef5405ce7596112954002d2b7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b540f13c20805a52ac4efe0f586e5ce"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_inv_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0b540f13c20805a52ac4efe0f586e5ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0b540f13c20805a52ac4efe0f586e5ce.html#a0b540f13c20805a52ac4efe0f586e5ce">exp_mod_normal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:a0b540f13c20805a52ac4efe0f586e5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affa27297bca6ee68bfa060c4c19cc526"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:affa27297bca6ee68bfa060c4c19cc526"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_affa27297bca6ee68bfa060c4c19cc526.html#affa27297bca6ee68bfa060c4c19cc526">exp_mod_normal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda)</td></tr>
<tr class="separator:affa27297bca6ee68bfa060c4c19cc526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4206c76978f02df32b09a4f39b8a634"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , typename T_inv_scale , class RNG &gt; </td></tr>
<tr class="memitem:gab4206c76978f02df32b09a4f39b8a634"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale, T_inv_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab4206c76978f02df32b09a4f39b8a634.html#gab4206c76978f02df32b09a4f39b8a634">exp_mod_normal_rng</a> (const T_loc &amp;mu, const T_scale &amp;sigma, const T_inv_scale &amp;lambda, RNG &amp;rng)</td></tr>
<tr class="memdesc:gab4206c76978f02df32b09a4f39b8a634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an exponentially modified normal random variate for the given location, scale, and inverse scale using the specified random number generator.  <br /></td></tr>
<tr class="separator:gab4206c76978f02df32b09a4f39b8a634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f0947babd9bcfcbc84a60dfcb390e11"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:ga3f0947babd9bcfcbc84a60dfcb390e11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3f0947babd9bcfcbc84a60dfcb390e11.html#ga3f0947babd9bcfcbc84a60dfcb390e11">exponential_ccdf_log</a> (const T_y &amp;y, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:ga3f0947babd9bcfcbc84a60dfcb390e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d939fbd7e76b2dec5c910fc79125e2f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_inv_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3d939fbd7e76b2dec5c910fc79125e2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3d939fbd7e76b2dec5c910fc79125e2f.html#ga3d939fbd7e76b2dec5c910fc79125e2f">exponential_cdf</a> (const T_y &amp;y, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga3d939fbd7e76b2dec5c910fc79125e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the exponential cumulative distribution function for the given y and beta.  <br /></td></tr>
<tr class="separator:ga3d939fbd7e76b2dec5c910fc79125e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98bd23361050931774e07b9c08218af0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:ga98bd23361050931774e07b9c08218af0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga98bd23361050931774e07b9c08218af0.html#ga98bd23361050931774e07b9c08218af0">exponential_cdf_log</a> (const T_y &amp;y, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:ga98bd23361050931774e07b9c08218af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8894741d8648e154ae7cb5463476560"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_inv_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac8894741d8648e154ae7cb5463476560"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac8894741d8648e154ae7cb5463476560.html#ac8894741d8648e154ae7cb5463476560">exponential_lccdf</a> (const T_y &amp;y, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:ac8894741d8648e154ae7cb5463476560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a44c0b9724fa779f0d9294b6ae4b19"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_inv_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a50a44c0b9724fa779f0d9294b6ae4b19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a50a44c0b9724fa779f0d9294b6ae4b19.html#a50a44c0b9724fa779f0d9294b6ae4b19">exponential_lcdf</a> (const T_y &amp;y, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:a50a44c0b9724fa779f0d9294b6ae4b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec8282ab28eb66d6540b0f23eb7a8b10"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_inv_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaec8282ab28eb66d6540b0f23eb7a8b10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaec8282ab28eb66d6540b0f23eb7a8b10.html#gaec8282ab28eb66d6540b0f23eb7a8b10">exponential_lpdf</a> (const T_y &amp;y, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gaec8282ab28eb66d6540b0f23eb7a8b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an exponential density for y with the specified inverse scale parameter.  <br /></td></tr>
<tr class="separator:gaec8282ab28eb66d6540b0f23eb7a8b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe55a52169316f05fff3941c5d0d16c9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:afe55a52169316f05fff3941c5d0d16c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afe55a52169316f05fff3941c5d0d16c9.html#afe55a52169316f05fff3941c5d0d16c9">exponential_lpdf</a> (const T_y &amp;y, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:afe55a52169316f05fff3941c5d0d16c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6de082d1268b1d649ed2673a8573287b"><td class="memTemplParams" colspan="2">template&lt;typename T_inv , class RNG &gt; </td></tr>
<tr class="memitem:ga6de082d1268b1d649ed2673a8573287b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_inv &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga6de082d1268b1d649ed2673a8573287b.html#ga6de082d1268b1d649ed2673a8573287b">exponential_rng</a> (const T_inv &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga6de082d1268b1d649ed2673a8573287b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a exponential random variate with inverse scale beta using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga6de082d1268b1d649ed2673a8573287b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2aa329f489db468d3d6e8c040d4aa96"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:gab2aa329f489db468d3d6e8c040d4aa96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab2aa329f489db468d3d6e8c040d4aa96.html#gab2aa329f489db468d3d6e8c040d4aa96">frechet_ccdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gab2aa329f489db468d3d6e8c040d4aa96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec763889e8f1107eaefe8d7c8d9b5de1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aec763889e8f1107eaefe8d7c8d9b5de1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aec763889e8f1107eaefe8d7c8d9b5de1.html#aec763889e8f1107eaefe8d7c8d9b5de1">frechet_cdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aec763889e8f1107eaefe8d7c8d9b5de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a9fc925e3891d1a2d623e1fa38fb7cd"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ga1a9fc925e3891d1a2d623e1fa38fb7cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga1a9fc925e3891d1a2d623e1fa38fb7cd.html#ga1a9fc925e3891d1a2d623e1fa38fb7cd">frechet_cdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga1a9fc925e3891d1a2d623e1fa38fb7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8337337823c2b82727e355a92c2d0227"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8337337823c2b82727e355a92c2d0227"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8337337823c2b82727e355a92c2d0227.html#a8337337823c2b82727e355a92c2d0227">frechet_lccdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a8337337823c2b82727e355a92c2d0227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8db639f1ce6a9f42407e6550f1a308b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac8db639f1ce6a9f42407e6550f1a308b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac8db639f1ce6a9f42407e6550f1a308b.html#ac8db639f1ce6a9f42407e6550f1a308b">frechet_lcdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ac8db639f1ce6a9f42407e6550f1a308b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762cd329d5cb1035b983c15da865a7cf"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a762cd329d5cb1035b983c15da865a7cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a762cd329d5cb1035b983c15da865a7cf.html#a762cd329d5cb1035b983c15da865a7cf">frechet_lpdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a762cd329d5cb1035b983c15da865a7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8def0ce7b979188c76a91eca163445"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:aea8def0ce7b979188c76a91eca163445"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aea8def0ce7b979188c76a91eca163445.html#aea8def0ce7b979188c76a91eca163445">frechet_lpdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aea8def0ce7b979188c76a91eca163445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e339a339a62cc373dd520ff38b91030"><td class="memTemplParams" colspan="2">template&lt;typename T_shape , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga7e339a339a62cc373dd520ff38b91030"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_shape, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga7e339a339a62cc373dd520ff38b91030.html#ga7e339a339a62cc373dd520ff38b91030">frechet_rng</a> (const T_shape &amp;alpha, const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga7e339a339a62cc373dd520ff38b91030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pseudorandom Frechet variate for the given shape and scale parameters using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga7e339a339a62cc373dd520ff38b91030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga851ffe34a8e94a7979192ecb29322a88"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:ga851ffe34a8e94a7979192ecb29322a88"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga851ffe34a8e94a7979192ecb29322a88.html#ga851ffe34a8e94a7979192ecb29322a88">gamma_ccdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:ga851ffe34a8e94a7979192ecb29322a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad82583336827661a4042a2bc4565afcd"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:gad82583336827661a4042a2bc4565afcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gad82583336827661a4042a2bc4565afcd.html#gad82583336827661a4042a2bc4565afcd">gamma_cdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gad82583336827661a4042a2bc4565afcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The cumulative density function for a gamma distribution for y with the specified shape and inverse scale parameters.  <br /></td></tr>
<tr class="separator:gad82583336827661a4042a2bc4565afcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae715efc6779b1e76b09cb50408338c95"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:gae715efc6779b1e76b09cb50408338c95"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae715efc6779b1e76b09cb50408338c95.html#gae715efc6779b1e76b09cb50408338c95">gamma_cdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:gae715efc6779b1e76b09cb50408338c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca814007b246990d4a5e11c30fb79e0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a4ca814007b246990d4a5e11c30fb79e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4ca814007b246990d4a5e11c30fb79e0.html#a4ca814007b246990d4a5e11c30fb79e0">gamma_lccdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:a4ca814007b246990d4a5e11c30fb79e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293f3298ef3de3fe0982999c38c7b623"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a293f3298ef3de3fe0982999c38c7b623"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a293f3298ef3de3fe0982999c38c7b623.html#a293f3298ef3de3fe0982999c38c7b623">gamma_lcdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:a293f3298ef3de3fe0982999c38c7b623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbe10b4945a42d08010420e57d692eba"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape , typename T_inv_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_shape, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gafbe10b4945a42d08010420e57d692eba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gafbe10b4945a42d08010420e57d692eba.html#gafbe10b4945a42d08010420e57d692eba">gamma_lpdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gafbe10b4945a42d08010420e57d692eba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a gamma density for y with the specified shape and inverse scale parameters.  <br /></td></tr>
<tr class="separator:gafbe10b4945a42d08010420e57d692eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae0d13afe64fbfaa2409bd16187b1de"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:abae0d13afe64fbfaa2409bd16187b1de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abae0d13afe64fbfaa2409bd16187b1de.html#abae0d13afe64fbfaa2409bd16187b1de">gamma_lpdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:abae0d13afe64fbfaa2409bd16187b1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacde8ce4e80e28c9d47eb7b47cea052b3"><td class="memTemplParams" colspan="2">template&lt;typename T_shape , typename T_inv , class RNG &gt; </td></tr>
<tr class="memitem:gacde8ce4e80e28c9d47eb7b47cea052b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_shape, T_inv &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gacde8ce4e80e28c9d47eb7b47cea052b3.html#gacde8ce4e80e28c9d47eb7b47cea052b3">gamma_rng</a> (const T_shape &amp;alpha, const T_inv &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, RNG &amp;rng)</td></tr>
<tr class="memdesc:gacde8ce4e80e28c9d47eb7b47cea052b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a gamma random variate for the given shape and inverse scale parameters using the specified random number generator.  <br /></td></tr>
<tr class="separator:gacde8ce4e80e28c9d47eb7b47cea052b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa04df98134e973d4d3ce2e6ba814b18a"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 , <a class="el" href="group__eigen__matrix__dynamic__types_ga8ec9030ce72bf1905d7df48b204222f6.html#ga8ec9030ce72bf1905d7df48b204222f6">require_all_eigen_matrix_dynamic_t</a>&lt; T_y, T_F, T_G, T_V, T_W, T_C0 &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_m0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa04df98134e973d4d3ce2e6ba814b18a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_F, T_G, T_V, T_W, T_m0, T_C0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gaa04df98134e973d4d3ce2e6ba814b18a.html#gaa04df98134e973d4d3ce2e6ba814b18a">gaussian_dlm_obs_lpdf</a> (const T_y &amp;y, const T_F &amp;F, const T_G &amp;G, const T_V &amp;V, const T_W &amp;W, const T_m0 &amp;m0, const T_C0 &amp;C0)</td></tr>
<tr class="memdesc:gaa04df98134e973d4d3ce2e6ba814b18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a Gaussian dynamic linear model (GDLM).  <br /></td></tr>
<tr class="separator:gaa04df98134e973d4d3ce2e6ba814b18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71cfed389d562cf3fdd18c0f2239151"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_F , typename T_G , typename T_V , typename T_W , typename T_m0 , typename T_C0 &gt; </td></tr>
<tr class="memitem:aa71cfed389d562cf3fdd18c0f2239151"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_F, T_G, T_V, T_W, T_m0, T_C0 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa71cfed389d562cf3fdd18c0f2239151.html#aa71cfed389d562cf3fdd18c0f2239151">gaussian_dlm_obs_lpdf</a> (const T_y &amp;y, const T_F &amp;F, const T_G &amp;G, const T_V &amp;V, const T_W &amp;W, const T_m0 &amp;m0, const T_C0 &amp;C0)</td></tr>
<tr class="separator:aa71cfed389d562cf3fdd18c0f2239151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38ce72e12b0f414f6c82f82f492db728"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ga38ce72e12b0f414f6c82f82f492db728"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga38ce72e12b0f414f6c82f82f492db728.html#ga38ce72e12b0f414f6c82f82f492db728">gaussian_dlm_obs_rng</a> (const Eigen::MatrixXd &amp;F, const Eigen::MatrixXd &amp;G, const Eigen::MatrixXd &amp;V, const Eigen::MatrixXd &amp;W, const Eigen::VectorXd &amp;m0, const Eigen::MatrixXd &amp;C0, const int T, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga38ce72e12b0f414f6c82f82f492db728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate random draw from Gaussian dynamic linear model (GDLM).  <br /></td></tr>
<tr class="separator:ga38ce72e12b0f414f6c82f82f492db728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73756c771f05b9a1d242c94c2811e141"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a73756c771f05b9a1d242c94c2811e141"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a73756c771f05b9a1d242c94c2811e141.html#a73756c771f05b9a1d242c94c2811e141">gaussian_dlm_obs_rng</a> (const Eigen::MatrixXd &amp;F, const Eigen::MatrixXd &amp;G, const Eigen::VectorXd &amp;V, const Eigen::MatrixXd &amp;W, const Eigen::VectorXd &amp;m0, const Eigen::MatrixXd &amp;C0, const int T, RNG &amp;rng)</td></tr>
<tr class="separator:a73756c771f05b9a1d242c94c2811e141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae21e4c667b2ddc9924c06b1bdb9958d2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gae21e4c667b2ddc9924c06b1bdb9958d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae21e4c667b2ddc9924c06b1bdb9958d2.html#gae21e4c667b2ddc9924c06b1bdb9958d2">gumbel_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:gae21e4c667b2ddc9924c06b1bdb9958d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aa8eaf832ce4cf4dba0aca185b1d024"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4aa8eaf832ce4cf4dba0aca185b1d024"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga4aa8eaf832ce4cf4dba0aca185b1d024.html#ga4aa8eaf832ce4cf4dba0aca185b1d024">gumbel_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga4aa8eaf832ce4cf4dba0aca185b1d024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gumbel distribution cumulative distribution for the given location and scale.  <br /></td></tr>
<tr class="separator:ga4aa8eaf832ce4cf4dba0aca185b1d024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafb5128874803e4d2be62fc2c3eb75fb0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gafb5128874803e4d2be62fc2c3eb75fb0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gafb5128874803e4d2be62fc2c3eb75fb0.html#gafb5128874803e4d2be62fc2c3eb75fb0">gumbel_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:gafb5128874803e4d2be62fc2c3eb75fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9cccc6acbe04c7479ceb1bd3d8b7a1d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae9cccc6acbe04c7479ceb1bd3d8b7a1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae9cccc6acbe04c7479ceb1bd3d8b7a1d.html#gae9cccc6acbe04c7479ceb1bd3d8b7a1d">gumbel_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gae9cccc6acbe04c7479ceb1bd3d8b7a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gumbel log complementary cumulative distribution for the given location and scale.  <br /></td></tr>
<tr class="separator:gae9cccc6acbe04c7479ceb1bd3d8b7a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga33eba7c5dff4ecf33b2f9101ab5fc99f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga33eba7c5dff4ecf33b2f9101ab5fc99f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga33eba7c5dff4ecf33b2f9101ab5fc99f.html#ga33eba7c5dff4ecf33b2f9101ab5fc99f">gumbel_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga33eba7c5dff4ecf33b2f9101ab5fc99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gumbel log cumulative distribution for the given location and scale.  <br /></td></tr>
<tr class="separator:ga33eba7c5dff4ecf33b2f9101ab5fc99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4630c60138b925e778d7894bc36f7730"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4630c60138b925e778d7894bc36f7730"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga4630c60138b925e778d7894bc36f7730.html#ga4630c60138b925e778d7894bc36f7730">gumbel_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga4630c60138b925e778d7894bc36f7730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Gumbel log probability density for the given location and scale.  <br /></td></tr>
<tr class="separator:ga4630c60138b925e778d7894bc36f7730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1fe721e72d9c7069c1378a9934c38c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:aad1fe721e72d9c7069c1378a9934c38c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aad1fe721e72d9c7069c1378a9934c38c.html#aad1fe721e72d9c7069c1378a9934c38c">gumbel_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:aad1fe721e72d9c7069c1378a9934c38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6a2e5a8630004d60996047727106ca3"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:gae6a2e5a8630004d60996047727106ca3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae6a2e5a8630004d60996047727106ca3.html#gae6a2e5a8630004d60996047727106ca3">gumbel_rng</a> (const T_loc &amp;mu, const T_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, RNG &amp;rng)</td></tr>
<tr class="memdesc:gae6a2e5a8630004d60996047727106ca3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Gumbel random variate with the given location and scale using the specified random number generator.  <br /></td></tr>
<tr class="separator:gae6a2e5a8630004d60996047727106ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4d90af00a90b8416fe91015083d80b"><td class="memTemplParams" colspan="2">template&lt;typename T_omega , typename T_Gamma , typename T_rho , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; T_omega, T_Gamma &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_rho &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8c4d90af00a90b8416fe91015083d80b"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8c4d90af00a90b8416fe91015083d80b.html#a8c4d90af00a90b8416fe91015083d80b">hmm_hidden_state_prob</a> (const T_omega &amp;log_omegas, const T_Gamma &amp;Gamma, const T_rho &amp;rho)</td></tr>
<tr class="memdesc:a8c4d90af00a90b8416fe91015083d80b"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a hidden Markov model with observation y, hidden state x, and parameters theta, compute the marginal probability vector for each x, given y and theta, p(x_i | y, theta).  <br /></td></tr>
<tr class="separator:a8c4d90af00a90b8416fe91015083d80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004ee24c6a3431f07e651e0d2843b8da"><td class="memTemplParams" colspan="2">template&lt;typename T_omega , typename T_Gamma , typename T_rho , class RNG , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; T_omega, T_Gamma &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_rho &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a004ee24c6a3431f07e651e0d2843b8da"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a004ee24c6a3431f07e651e0d2843b8da.html#a004ee24c6a3431f07e651e0d2843b8da">hmm_latent_rng</a> (const T_omega &amp;log_omegas, const T_Gamma &amp;Gamma, const T_rho &amp;rho, RNG &amp;rng)</td></tr>
<tr class="memdesc:a004ee24c6a3431f07e651e0d2843b8da"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a hidden Markov model with observation y, hidden state x, and parameters theta, generate samples from the posterior distribution of the hidden states, x.  <br /></td></tr>
<tr class="separator:a004ee24c6a3431f07e651e0d2843b8da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eaf3b46b9cc7ae34676432a48861885"><td class="memTemplParams" colspan="2">template&lt;typename T_omega , typename T_Gamma , typename T_rho , typename T_alpha &gt; </td></tr>
<tr class="memitem:a5eaf3b46b9cc7ae34676432a48861885"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5eaf3b46b9cc7ae34676432a48861885.html#a5eaf3b46b9cc7ae34676432a48861885">hmm_marginal_val</a> (const Eigen::Matrix&lt; T_omega, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;omegas, const T_Gamma &amp;Gamma_val, const T_rho &amp;rho_val, Eigen::Matrix&lt; T_alpha, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;alphas, Eigen::Matrix&lt; T_alpha, Eigen::Dynamic, 1 &gt; &amp;alpha_log_norms, T_alpha &amp;norm_norm)</td></tr>
<tr class="separator:a5eaf3b46b9cc7ae34676432a48861885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8399d29cac9cd55ba9ef337d635029"><td class="memTemplParams" colspan="2">template&lt;typename T_omega , typename T_Gamma , typename T_rho , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; T_omega, T_Gamma &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_rho &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3c8399d29cac9cd55ba9ef337d635029"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3c8399d29cac9cd55ba9ef337d635029.html#a3c8399d29cac9cd55ba9ef337d635029">hmm_marginal</a> (const T_omega &amp;log_omegas, const T_Gamma &amp;Gamma, const T_rho &amp;rho)</td></tr>
<tr class="memdesc:a3c8399d29cac9cd55ba9ef337d635029"><td class="mdescLeft">&#160;</td><td class="mdescRight">For a Hidden Markov Model with observation y, hidden state x, and parameters theta, return the log marginal density, log p(y | theta).  <br /></td></tr>
<tr class="separator:a3c8399d29cac9cd55ba9ef337d635029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122d20a5a9f185c9bc37291e00fc13d5"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_N , typename T_a , typename T_b &gt; </td></tr>
<tr class="memitem:a122d20a5a9f185c9bc37291e00fc13d5"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a122d20a5a9f185c9bc37291e00fc13d5.html#a122d20a5a9f185c9bc37291e00fc13d5">hypergeometric_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:a122d20a5a9f185c9bc37291e00fc13d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538aabd76ed5749ca24a6a1ce7bc2f1a"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_N , typename T_a , typename T_b &gt; </td></tr>
<tr class="memitem:a538aabd76ed5749ca24a6a1ce7bc2f1a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a538aabd76ed5749ca24a6a1ce7bc2f1a.html#a538aabd76ed5749ca24a6a1ce7bc2f1a">hypergeometric_lpmf</a> (const T_n &amp;n, const T_N &amp;N, const T_a &amp;a, const T_b &amp;b)</td></tr>
<tr class="separator:a538aabd76ed5749ca24a6a1ce7bc2f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3878889879be4781cc8d560f534ab123"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a3878889879be4781cc8d560f534ab123"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3878889879be4781cc8d560f534ab123.html#a3878889879be4781cc8d560f534ab123">hypergeometric_rng</a> (int N, int a, int b, RNG &amp;rng)</td></tr>
<tr class="separator:a3878889879be4781cc8d560f534ab123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4a114410f7b680ce7c14ace9f405874"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:gab4a114410f7b680ce7c14ace9f405874"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab4a114410f7b680ce7c14ace9f405874.html#gab4a114410f7b680ce7c14ace9f405874">inv_chi_square_ccdf_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:gab4a114410f7b680ce7c14ace9f405874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae562a1b564b8fa7f808865913b477023"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:gae562a1b564b8fa7f808865913b477023"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae562a1b564b8fa7f808865913b477023.html#gae562a1b564b8fa7f808865913b477023">inv_chi_square_cdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="memdesc:gae562a1b564b8fa7f808865913b477023"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse chi square cumulative distribution function for the given variate and degrees of freedom.  <br /></td></tr>
<tr class="separator:gae562a1b564b8fa7f808865913b477023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b89726ce4ccb6a2bc9f27458e87d90e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:ga6b89726ce4ccb6a2bc9f27458e87d90e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga6b89726ce4ccb6a2bc9f27458e87d90e.html#ga6b89726ce4ccb6a2bc9f27458e87d90e">inv_chi_square_cdf_log</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:ga6b89726ce4ccb6a2bc9f27458e87d90e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d9ca7484adbadcf2be084f31944b436"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:ga3d9ca7484adbadcf2be084f31944b436"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3d9ca7484adbadcf2be084f31944b436.html#ga3d9ca7484adbadcf2be084f31944b436">inv_chi_square_lccdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="memdesc:ga3d9ca7484adbadcf2be084f31944b436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse chi square log complementary cumulative distribution function for the given variate and degrees of freedom.  <br /></td></tr>
<tr class="separator:ga3d9ca7484adbadcf2be084f31944b436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5275f1be546b62c3d4836acc1304e6b3"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:ga5275f1be546b62c3d4836acc1304e6b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga5275f1be546b62c3d4836acc1304e6b3.html#ga5275f1be546b62c3d4836acc1304e6b3">inv_chi_square_lcdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="memdesc:ga5275f1be546b62c3d4836acc1304e6b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the inverse chi square log cumulative distribution function for the given variate and degrees of freedom.  <br /></td></tr>
<tr class="separator:ga5275f1be546b62c3d4836acc1304e6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e5ffd66b61600229e3c7fde8b62610b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_dof &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5e5ffd66b61600229e3c7fde8b62610b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga5e5ffd66b61600229e3c7fde8b62610b.html#ga5e5ffd66b61600229e3c7fde8b62610b">inv_chi_square_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="memdesc:ga5e5ffd66b61600229e3c7fde8b62610b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an inverse chi-squared density for y with the specified degrees of freedom parameter.  <br /></td></tr>
<tr class="separator:ga5e5ffd66b61600229e3c7fde8b62610b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41530edc5915c8ed1d69b31d298db2bd"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof &gt; </td></tr>
<tr class="memitem:a41530edc5915c8ed1d69b31d298db2bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a41530edc5915c8ed1d69b31d298db2bd.html#a41530edc5915c8ed1d69b31d298db2bd">inv_chi_square_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu)</td></tr>
<tr class="separator:a41530edc5915c8ed1d69b31d298db2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae546ccb2b2a3eb425a29dd315c1bd55b"><td class="memTemplParams" colspan="2">template&lt;typename T_deg , class RNG &gt; </td></tr>
<tr class="memitem:gae546ccb2b2a3eb425a29dd315c1bd55b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_deg &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae546ccb2b2a3eb425a29dd315c1bd55b.html#gae546ccb2b2a3eb425a29dd315c1bd55b">inv_chi_square_rng</a> (const T_deg &amp;nu, RNG &amp;rng)</td></tr>
<tr class="memdesc:gae546ccb2b2a3eb425a29dd315c1bd55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pseudorandom inverse chi squared variate with the nu degrees of freedom using the specified random number generator.  <br /></td></tr>
<tr class="separator:gae546ccb2b2a3eb425a29dd315c1bd55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga008adbdcc29b3f5ceb333f2b85a2eecc"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ga008adbdcc29b3f5ceb333f2b85a2eecc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga008adbdcc29b3f5ceb333f2b85a2eecc.html#ga008adbdcc29b3f5ceb333f2b85a2eecc">inv_gamma_ccdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:ga008adbdcc29b3f5ceb333f2b85a2eecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaee03af3a7b46f99a6f1976966e03c2d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:gaaee03af3a7b46f99a6f1976966e03c2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaaee03af3a7b46f99a6f1976966e03c2d.html#gaaee03af3a7b46f99a6f1976966e03c2d">inv_gamma_cdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gaaee03af3a7b46f99a6f1976966e03c2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CDF of an inverse gamma density for y with the specified shape and scale parameters.  <br /></td></tr>
<tr class="separator:gaaee03af3a7b46f99a6f1976966e03c2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecf96fc2488a9cb8e644c06a458ad0ba"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:gaecf96fc2488a9cb8e644c06a458ad0ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaecf96fc2488a9cb8e644c06a458ad0ba.html#gaecf96fc2488a9cb8e644c06a458ad0ba">inv_gamma_cdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:gaecf96fc2488a9cb8e644c06a458ad0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6509ec377a651fac0cf7e5425436ecda"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:a6509ec377a651fac0cf7e5425436ecda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6509ec377a651fac0cf7e5425436ecda.html#a6509ec377a651fac0cf7e5425436ecda">inv_gamma_lccdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:a6509ec377a651fac0cf7e5425436ecda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d93c6c6fc12573d4a607e2db4b7a19"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:a17d93c6c6fc12573d4a607e2db4b7a19"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a17d93c6c6fc12573d4a607e2db4b7a19.html#a17d93c6c6fc12573d4a607e2db4b7a19">inv_gamma_lcdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:a17d93c6c6fc12573d4a607e2db4b7a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b68e956188c8526bd89900244f8634b"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7b68e956188c8526bd89900244f8634b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga7b68e956188c8526bd89900244f8634b.html#ga7b68e956188c8526bd89900244f8634b">inv_gamma_lpdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga7b68e956188c8526bd89900244f8634b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of an inverse gamma density for y with the specified shape and scale parameters.  <br /></td></tr>
<tr class="separator:ga7b68e956188c8526bd89900244f8634b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1eb587b1cc11204cc6e8690e754802e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ae1eb587b1cc11204cc6e8690e754802e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae1eb587b1cc11204cc6e8690e754802e.html#ae1eb587b1cc11204cc6e8690e754802e">inv_gamma_lpdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:ae1eb587b1cc11204cc6e8690e754802e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47e675a3b7349c73fd751f82e0263bf1"><td class="memTemplParams" colspan="2">template&lt;typename T_shape , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga47e675a3b7349c73fd751f82e0263bf1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_shape, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga47e675a3b7349c73fd751f82e0263bf1.html#ga47e675a3b7349c73fd751f82e0263bf1">inv_gamma_rng</a> (const T_shape &amp;alpha, const T_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga47e675a3b7349c73fd751f82e0263bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pseudorandom inverse gamma variate for the given shape and scale parameters using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga47e675a3b7349c73fd751f82e0263bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d4de5fc225eff8b796b618807a14cdd"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_dof &gt; *  = nullptr, <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; T_y, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3d4de5fc225eff8b796b618807a14cdd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga3d4de5fc225eff8b796b618807a14cdd.html#ga3d4de5fc225eff8b796b618807a14cdd">inv_wishart_cholesky_lpdf</a> (const T_y &amp;L_Y, const T_dof &amp;nu, const T_scale &amp;L_S)</td></tr>
<tr class="memdesc:ga3d4de5fc225eff8b796b618807a14cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the unnormalized inverse wishart density of the specified lower-triangular Cholesky factor variate, positive degrees of freedom, and lower-triangular Cholesky factor of the scale matrix.  <br /></td></tr>
<tr class="separator:ga3d4de5fc225eff8b796b618807a14cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857dd2c334f23f597f9a6bde4d6ee4c8"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:a857dd2c334f23f597f9a6bde4d6ee4c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a857dd2c334f23f597f9a6bde4d6ee4c8.html#a857dd2c334f23f597f9a6bde4d6ee4c8">inv_wishart_cholesky_lpdf</a> (const T_y &amp;L_Y, const T_dof &amp;nu, const T_scale &amp;L_S)</td></tr>
<tr class="separator:a857dd2c334f23f597f9a6bde4d6ee4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9efca9c1665e598b602eb1885a69680"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:gad9efca9c1665e598b602eb1885a69680"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gad9efca9c1665e598b602eb1885a69680.html#gad9efca9c1665e598b602eb1885a69680">inv_wishart_cholesky_rng</a> (double nu, const Eigen::MatrixXd &amp;L_S, RNG &amp;rng)</td></tr>
<tr class="memdesc:gad9efca9c1665e598b602eb1885a69680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random Cholesky factor of a covariance matrix of the specified dimensionality drawn from the inverse Wishart distribution with the specified degrees of freedom using the specified random number generator.  <br /></td></tr>
<tr class="separator:gad9efca9c1665e598b602eb1885a69680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bc578e794b0bf59ae972862269fcdda"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:ga9bc578e794b0bf59ae972862269fcdda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga9bc578e794b0bf59ae972862269fcdda.html#ga9bc578e794b0bf59ae972862269fcdda">inv_wishart_lpdf</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="memdesc:ga9bc578e794b0bf59ae972862269fcdda"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Inverse-Wishart density for the given W, degrees of freedom, and scale matrix.  <br /></td></tr>
<tr class="separator:ga9bc578e794b0bf59ae972862269fcdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6f84c688e97a32c720ec378a9e0c4b"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:a9b6f84c688e97a32c720ec378a9e0c4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9b6f84c688e97a32c720ec378a9e0c4b.html#a9b6f84c688e97a32c720ec378a9e0c4b">inv_wishart_lpdf</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="separator:a9b6f84c688e97a32c720ec378a9e0c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717784073dda2d26fdd3cc127c29b5df"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a717784073dda2d26fdd3cc127c29b5df"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a717784073dda2d26fdd3cc127c29b5df.html#a717784073dda2d26fdd3cc127c29b5df">inv_wishart_rng</a> (double nu, const Eigen::MatrixXd &amp;S, RNG &amp;rng)</td></tr>
<tr class="separator:a717784073dda2d26fdd3cc127c29b5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6f56d56eea5ae16e7bd45341dbc237"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_covar , typename T_shape &gt; </td></tr>
<tr class="memitem:a7c6f56d56eea5ae16e7bd45341dbc237"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_covar, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7c6f56d56eea5ae16e7bd45341dbc237.html#a7c6f56d56eea5ae16e7bd45341dbc237">lkj_corr_cholesky_lpdf</a> (const T_covar &amp;L, const T_shape &amp;eta)</td></tr>
<tr class="separator:a7c6f56d56eea5ae16e7bd45341dbc237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70274b5c7f0b38d7dae9a380f2e0831c"><td class="memTemplParams" colspan="2">template&lt;typename T_covar , typename T_shape &gt; </td></tr>
<tr class="memitem:a70274b5c7f0b38d7dae9a380f2e0831c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_covar, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a70274b5c7f0b38d7dae9a380f2e0831c.html#a70274b5c7f0b38d7dae9a380f2e0831c">lkj_corr_cholesky_lpdf</a> (const T_covar &amp;L, const T_shape &amp;eta)</td></tr>
<tr class="separator:a70274b5c7f0b38d7dae9a380f2e0831c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a924c168990c6fa25b9443788655cc73d"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a924c168990c6fa25b9443788655cc73d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a924c168990c6fa25b9443788655cc73d.html#a924c168990c6fa25b9443788655cc73d">lkj_corr_cholesky_rng</a> (size_t K, double eta, RNG &amp;rng)</td></tr>
<tr class="separator:a924c168990c6fa25b9443788655cc73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aaf5ac0dd51b85880285d4c3ac0175e"><td class="memTemplParams" colspan="2">template&lt;typename T_shape &gt; </td></tr>
<tr class="memitem:a8aaf5ac0dd51b85880285d4c3ac0175e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; double, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8aaf5ac0dd51b85880285d4c3ac0175e.html#a8aaf5ac0dd51b85880285d4c3ac0175e">do_lkj_constant</a> (const T_shape &amp;eta, const unsigned int &amp;K)</td></tr>
<tr class="separator:a8aaf5ac0dd51b85880285d4c3ac0175e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0ab315d573b5c5c237a3b64b6fe8f3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape &gt; </td></tr>
<tr class="memitem:afd0ab315d573b5c5c237a3b64b6fe8f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afd0ab315d573b5c5c237a3b64b6fe8f3.html#afd0ab315d573b5c5c237a3b64b6fe8f3">lkj_corr_lpdf</a> (const T_y &amp;y, const T_shape &amp;eta)</td></tr>
<tr class="separator:afd0ab315d573b5c5c237a3b64b6fe8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a702554729ee2768cc17a5ad609f2b513"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape &gt; </td></tr>
<tr class="memitem:a702554729ee2768cc17a5ad609f2b513"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a702554729ee2768cc17a5ad609f2b513.html#a702554729ee2768cc17a5ad609f2b513">lkj_corr_lpdf</a> (const T_y &amp;y, const T_shape &amp;eta)</td></tr>
<tr class="separator:a702554729ee2768cc17a5ad609f2b513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5570fda8e3d07213840dc2a9f4155e18"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ga5570fda8e3d07213840dc2a9f4155e18"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga5570fda8e3d07213840dc2a9f4155e18.html#ga5570fda8e3d07213840dc2a9f4155e18">lkj_corr_rng</a> (size_t K, double eta, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga5570fda8e3d07213840dc2a9f4155e18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random correlation matrix (symmetric, positive definite, unit diagonal) of the specified dimensionality drawn from the LKJ distribution with the specified degrees of freedom using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga5570fda8e3d07213840dc2a9f4155e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ca6e33a747117a587f44348ed94409"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape , <a class="el" href="group__eigen__matrix__dynamic__types_gabcfd29c39378e841a8abdc54a8277c01.html#gabcfd29c39378e841a8abdc54a8277c01">require_eigen_matrix_dynamic_t</a>&lt; T_y &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_gadba3a075f0d641022a8da364d3159bfa.html#gadba3a075f0d641022a8da364d3159bfa">require_all_eigen_col_vector_t</a>&lt; T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a42ca6e33a747117a587f44348ed94409"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a42ca6e33a747117a587f44348ed94409.html#a42ca6e33a747117a587f44348ed94409">lkj_cov_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;eta)</td></tr>
<tr class="separator:a42ca6e33a747117a587f44348ed94409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6af62adba3fef4a5c64129876253ef"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:abd6af62adba3fef4a5c64129876253ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abd6af62adba3fef4a5c64129876253ef.html#abd6af62adba3fef4a5c64129876253ef">lkj_cov_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;eta)</td></tr>
<tr class="separator:abd6af62adba3fef4a5c64129876253ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19893caffc1c1362bfb2312821ba64c5"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga19893caffc1c1362bfb2312821ba64c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga19893caffc1c1362bfb2312821ba64c5.html#ga19893caffc1c1362bfb2312821ba64c5">logistic_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga19893caffc1c1362bfb2312821ba64c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf7ccc8354d6e60d4508e604729291c9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abf7ccc8354d6e60d4508e604729291c9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abf7ccc8354d6e60d4508e604729291c9.html#abf7ccc8354d6e60d4508e604729291c9">logistic_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:abf7ccc8354d6e60d4508e604729291c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8696168187398c189dd9c02d4ad350a9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga8696168187398c189dd9c02d4ad350a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga8696168187398c189dd9c02d4ad350a9.html#ga8696168187398c189dd9c02d4ad350a9">logistic_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga8696168187398c189dd9c02d4ad350a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15583b6abb396a15da42502f861b924e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a15583b6abb396a15da42502f861b924e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a15583b6abb396a15da42502f861b924e.html#a15583b6abb396a15da42502f861b924e">logistic_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a15583b6abb396a15da42502f861b924e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad094566da901106bc0a38bcf41639570"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad094566da901106bc0a38bcf41639570"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad094566da901106bc0a38bcf41639570.html#ad094566da901106bc0a38bcf41639570">logistic_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ad094566da901106bc0a38bcf41639570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc793d371e0f429eca352e3134b19699"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adc793d371e0f429eca352e3134b19699"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adc793d371e0f429eca352e3134b19699.html#adc793d371e0f429eca352e3134b19699">logistic_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:adc793d371e0f429eca352e3134b19699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e380af59ef7951e7beb088a9088659"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ad1e380af59ef7951e7beb088a9088659"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad1e380af59ef7951e7beb088a9088659.html#ad1e380af59ef7951e7beb088a9088659">logistic_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ad1e380af59ef7951e7beb088a9088659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b0835008eac0f3e3401b6c325432db6"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga2b0835008eac0f3e3401b6c325432db6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga2b0835008eac0f3e3401b6c325432db6.html#ga2b0835008eac0f3e3401b6c325432db6">logistic_rng</a> (const T_loc &amp;mu, const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga2b0835008eac0f3e3401b6c325432db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Logistic random variate for the given location and scale using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga2b0835008eac0f3e3401b6c325432db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga113065b8c4a342d22e300dfda5d02ccd"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga113065b8c4a342d22e300dfda5d02ccd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga113065b8c4a342d22e300dfda5d02ccd.html#ga113065b8c4a342d22e300dfda5d02ccd">loglogistic_cdf</a> (const T_y &amp;y, const T_scale &amp;alpha, const T_shape &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga113065b8c4a342d22e300dfda5d02ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The loglogistic cumulative distribution function for the specified scalar(s) given the specified scales(s) and shape(s).  <br /></td></tr>
<tr class="separator:ga113065b8c4a342d22e300dfda5d02ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2046d6c982d153be7c21ff319a1a1c05"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_scale , typename T_shape , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga2046d6c982d153be7c21ff319a1a1c05"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga2046d6c982d153be7c21ff319a1a1c05.html#ga2046d6c982d153be7c21ff319a1a1c05">loglogistic_lpdf</a> (const T_y &amp;y, const T_scale &amp;alpha, const T_shape &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga2046d6c982d153be7c21ff319a1a1c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the loglogistic density for the specified scalar(s) given the specified scales(s) and shape(s).  <br /></td></tr>
<tr class="separator:ga2046d6c982d153be7c21ff319a1a1c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad414e161c74dce0125e18027127d82"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a1ad414e161c74dce0125e18027127d82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1ad414e161c74dce0125e18027127d82.html#a1ad414e161c74dce0125e18027127d82">loglogistic_lpdf</a> (const T_y &amp;y, const T_scale &amp;alpha, const T_shape &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:a1ad414e161c74dce0125e18027127d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga672acbcbf83fbd360bb0e70e8a0af5ca"><td class="memTemplParams" colspan="2">template&lt;typename T_scale , typename T_shape , class RNG &gt; </td></tr>
<tr class="memitem:ga672acbcbf83fbd360bb0e70e8a0af5ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_scale, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga672acbcbf83fbd360bb0e70e8a0af5ca.html#ga672acbcbf83fbd360bb0e70e8a0af5ca">loglogistic_rng</a> (const T_scale &amp;alpha, const T_shape &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga672acbcbf83fbd360bb0e70e8a0af5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a loglogistic random variate for the given scale and shape parameters using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga672acbcbf83fbd360bb0e70e8a0af5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0a7e494eae4faf6c9d0e0b29d7c5743"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gab0a7e494eae4faf6c9d0e0b29d7c5743"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab0a7e494eae4faf6c9d0e0b29d7c5743.html#gab0a7e494eae4faf6c9d0e0b29d7c5743">lognormal_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gab0a7e494eae4faf6c9d0e0b29d7c5743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b47208a950b14d3c295457caa194377"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3b47208a950b14d3c295457caa194377"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3b47208a950b14d3c295457caa194377.html#a3b47208a950b14d3c295457caa194377">lognormal_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a3b47208a950b14d3c295457caa194377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3362689104acd532b4a0bdb3af8483cc"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga3362689104acd532b4a0bdb3af8483cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3362689104acd532b4a0bdb3af8483cc.html#ga3362689104acd532b4a0bdb3af8483cc">lognormal_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga3362689104acd532b4a0bdb3af8483cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41fa0064ee9b66cd36ccb9c4142364d3"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a41fa0064ee9b66cd36ccb9c4142364d3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a41fa0064ee9b66cd36ccb9c4142364d3.html#a41fa0064ee9b66cd36ccb9c4142364d3">lognormal_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a41fa0064ee9b66cd36ccb9c4142364d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c64994545284705f6caffda96db8020"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6c64994545284705f6caffda96db8020"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6c64994545284705f6caffda96db8020.html#a6c64994545284705f6caffda96db8020">lognormal_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a6c64994545284705f6caffda96db8020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6c59cc1b615426f377f8dd550d8343"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ade6c59cc1b615426f377f8dd550d8343"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade6c59cc1b615426f377f8dd550d8343.html#ade6c59cc1b615426f377f8dd550d8343">lognormal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ade6c59cc1b615426f377f8dd550d8343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaef74a42e42d4c5fc5b1afc46dc2c58c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:aaef74a42e42d4c5fc5b1afc46dc2c58c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaef74a42e42d4c5fc5b1afc46dc2c58c.html#aaef74a42e42d4c5fc5b1afc46dc2c58c">lognormal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aaef74a42e42d4c5fc5b1afc46dc2c58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga612a6b2e22b0609f61f45f051935834f"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga612a6b2e22b0609f61f45f051935834f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga612a6b2e22b0609f61f45f051935834f.html#ga612a6b2e22b0609f61f45f051935834f">lognormal_rng</a> (const T_loc &amp;mu, const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga612a6b2e22b0609f61f45f051935834f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a lognormal random variate for the given location and scale using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga612a6b2e22b0609f61f45f051935834f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga746b30eddb34f40afaf5ca7cc16f67fc"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_Mu , typename T_Sigma , typename T_D , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; T_y, T_Mu, T_Sigma, T_D &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga746b30eddb34f40afaf5ca7cc16f67fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_Mu, T_Sigma, T_D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga746b30eddb34f40afaf5ca7cc16f67fc.html#ga746b30eddb34f40afaf5ca7cc16f67fc">matrix_normal_prec_lpdf</a> (const T_y &amp;y, const T_Mu &amp;Mu, const T_Sigma &amp;Sigma, const T_D &amp;D)</td></tr>
<tr class="memdesc:ga746b30eddb34f40afaf5ca7cc16f67fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the matrix normal density for the given y, mu, Sigma and D where Sigma and D are given as precision matrices, not covariance matrices.  <br /></td></tr>
<tr class="separator:ga746b30eddb34f40afaf5ca7cc16f67fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea52f3b2645412b227652b3cd2742176"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_Mu , typename T_Sigma , typename T_D , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; T_y, T_Mu, T_Sigma, T_D &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aea52f3b2645412b227652b3cd2742176"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_Mu, T_Sigma, T_D &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aea52f3b2645412b227652b3cd2742176.html#aea52f3b2645412b227652b3cd2742176">matrix_normal_prec_lpdf</a> (const T_y &amp;y, const T_Mu &amp;Mu, const T_Sigma &amp;Sigma, const T_D &amp;D)</td></tr>
<tr class="separator:aea52f3b2645412b227652b3cd2742176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e4ff308feab4aaf90dd7036f85667d2"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ga3e4ff308feab4aaf90dd7036f85667d2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga3e4ff308feab4aaf90dd7036f85667d2.html#ga3e4ff308feab4aaf90dd7036f85667d2">matrix_normal_prec_rng</a> (const Eigen::MatrixXd &amp;Mu, const Eigen::MatrixXd &amp;Sigma, const Eigen::MatrixXd &amp;D, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga3e4ff308feab4aaf90dd7036f85667d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sample from the the matrix normal distribution for the given Mu, Sigma and D where Sigma and D are given as precision matrices, not covariance matrices.  <br /></td></tr>
<tr class="separator:ga3e4ff308feab4aaf90dd7036f85667d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade7cabb44b45e9cb5983ef552d1adb1c"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_covar , typename T_w , <a class="el" href="group__eigen__matrix__dynamic__types_ga8ec9030ce72bf1905d7df48b204222f6.html#ga8ec9030ce72bf1905d7df48b204222f6">require_all_eigen_matrix_dynamic_t</a>&lt; T_y, T_covar &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_w &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gade7cabb44b45e9cb5983ef552d1adb1c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gade7cabb44b45e9cb5983ef552d1adb1c.html#gade7cabb44b45e9cb5983ef552d1adb1c">multi_gp_cholesky_lpdf</a> (const T_y &amp;y, const T_covar &amp;L, const T_w &amp;w)</td></tr>
<tr class="memdesc:gade7cabb44b45e9cb5983ef552d1adb1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a multivariate Gaussian Process for the given y, w, and a Cholesky factor L of the kernel matrix Sigma.  <br /></td></tr>
<tr class="separator:gade7cabb44b45e9cb5983ef552d1adb1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edbb0a2f9d387a36ad86e01127c3bcf"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_covar , typename T_w &gt; </td></tr>
<tr class="memitem:a8edbb0a2f9d387a36ad86e01127c3bcf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8edbb0a2f9d387a36ad86e01127c3bcf.html#a8edbb0a2f9d387a36ad86e01127c3bcf">multi_gp_cholesky_lpdf</a> (const T_y &amp;y, const T_covar &amp;L, const T_w &amp;w)</td></tr>
<tr class="separator:a8edbb0a2f9d387a36ad86e01127c3bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fa96c9aee5eac6dd75d3ae07c84d761"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_covar , typename T_w , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; T_y, T_covar &gt; *  = nullptr, <a class="el" href="group__col__vector__types_ga58096049cb8906ec6ad5f44f1e6fe082.html#ga58096049cb8906ec6ad5f44f1e6fe082">require_col_vector_t</a>&lt; T_w &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6fa96c9aee5eac6dd75d3ae07c84d761"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga6fa96c9aee5eac6dd75d3ae07c84d761.html#ga6fa96c9aee5eac6dd75d3ae07c84d761">multi_gp_lpdf</a> (const T_y &amp;y, const T_covar &amp;Sigma, const T_w &amp;w)</td></tr>
<tr class="memdesc:ga6fa96c9aee5eac6dd75d3ae07c84d761"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a multivariate Gaussian Process for the given y, Sigma, and w.  <br /></td></tr>
<tr class="separator:ga6fa96c9aee5eac6dd75d3ae07c84d761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb34724b122868bf47dc2c91d6ba253"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_covar , typename T_w &gt; </td></tr>
<tr class="memitem:a9eb34724b122868bf47dc2c91d6ba253"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_covar, T_w &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9eb34724b122868bf47dc2c91d6ba253.html#a9eb34724b122868bf47dc2c91d6ba253">multi_gp_lpdf</a> (const T_y &amp;y, const T_covar &amp;Sigma, const T_w &amp;w)</td></tr>
<tr class="separator:a9eb34724b122868bf47dc2c91d6ba253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eb6d17039a2b39b4a571176da01480d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_covar , <a class="el" href="group__vector__types_ga6b63c02c5a28640209efbe825e29422a.html#ga6b63c02c5a28640209efbe825e29422a">require_any_not_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>, T_y, T_loc &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_covar &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6eb6d17039a2b39b4a571176da01480d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga6eb6d17039a2b39b4a571176da01480d.html#ga6eb6d17039a2b39b4a571176da01480d">multi_normal_cholesky_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;L)</td></tr>
<tr class="memdesc:ga6eb6d17039a2b39b4a571176da01480d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the multivariate normal density for the given y, mu, and a Cholesky factor L of the variance matrix.  <br /></td></tr>
<tr class="separator:ga6eb6d17039a2b39b4a571176da01480d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26136297a0b2f97a59b8452cbb4dae3"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:ab26136297a0b2f97a59b8452cbb4dae3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab26136297a0b2f97a59b8452cbb4dae3.html#ab26136297a0b2f97a59b8452cbb4dae3">multi_normal_cholesky_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;L)</td></tr>
<tr class="separator:ab26136297a0b2f97a59b8452cbb4dae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10293562ac3e8be52ab95b2f79c7af92"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , class RNG &gt; </td></tr>
<tr class="memitem:ga10293562ac3e8be52ab95b2f79c7af92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_std_vector_builder.html">StdVectorBuilder</a>&lt; true, Eigen::VectorXd, T_loc &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga10293562ac3e8be52ab95b2f79c7af92.html#ga10293562ac3e8be52ab95b2f79c7af92">multi_normal_cholesky_rng</a> (const T_loc &amp;mu, const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;L, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga10293562ac3e8be52ab95b2f79c7af92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a multivariate normal random variate with the given location and Cholesky factorization of the covariance using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga10293562ac3e8be52ab95b2f79c7af92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a02ed975745d61dbfb2226c9ecd1587"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_covar , <a class="el" href="group__vector__types_ga6b63c02c5a28640209efbe825e29422a.html#ga6b63c02c5a28640209efbe825e29422a">require_any_not_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>, T_y, T_loc &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_covar &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3a02ed975745d61dbfb2226c9ecd1587"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3a02ed975745d61dbfb2226c9ecd1587.html#a3a02ed975745d61dbfb2226c9ecd1587">multi_normal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:a3a02ed975745d61dbfb2226c9ecd1587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6025fb0e7807831d6c470c2195917af"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:ad6025fb0e7807831d6c470c2195917af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad6025fb0e7807831d6c470c2195917af.html#ad6025fb0e7807831d6c470c2195917af">multi_normal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:ad6025fb0e7807831d6c470c2195917af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f25b3a46e60cbac707c475a187ffa2"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:a54f25b3a46e60cbac707c475a187ffa2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a54f25b3a46e60cbac707c475a187ffa2.html#a54f25b3a46e60cbac707c475a187ffa2">multi_normal_prec_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:a54f25b3a46e60cbac707c475a187ffa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9be62696bfa88f872fa37cb450b5ad0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:ab9be62696bfa88f872fa37cb450b5ad0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab9be62696bfa88f872fa37cb450b5ad0.html#ab9be62696bfa88f872fa37cb450b5ad0">multi_normal_prec_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_covar &amp;Sigma)</td></tr>
<tr class="separator:ab9be62696bfa88f872fa37cb450b5ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac27bc6168e1572ccb8ff9c1456ac3edf"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , class RNG &gt; </td></tr>
<tr class="memitem:gac27bc6168e1572ccb8ff9c1456ac3edf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_std_vector_builder.html">StdVectorBuilder</a>&lt; true, Eigen::VectorXd, T_loc &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gac27bc6168e1572ccb8ff9c1456ac3edf.html#gac27bc6168e1572ccb8ff9c1456ac3edf">multi_normal_prec_rng</a> (const T_loc &amp;mu, const Eigen::MatrixXd &amp;S, RNG &amp;rng)</td></tr>
<tr class="memdesc:gac27bc6168e1572ccb8ff9c1456ac3edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a multivariate normal random variate with the given location and precision using the specified random number generator.  <br /></td></tr>
<tr class="separator:gac27bc6168e1572ccb8ff9c1456ac3edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1366f1f579080e664cb46cb1de681c37"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , class RNG &gt; </td></tr>
<tr class="memitem:ga1366f1f579080e664cb46cb1de681c37"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_std_vector_builder.html">StdVectorBuilder</a>&lt; true, Eigen::VectorXd, T_loc &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga1366f1f579080e664cb46cb1de681c37.html#ga1366f1f579080e664cb46cb1de681c37">multi_normal_rng</a> (const T_loc &amp;mu, const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;S, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga1366f1f579080e664cb46cb1de681c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a multivariate normal random variate with the given location and covariance using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga1366f1f579080e664cb46cb1de681c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab59c6a4cd8105b995f36650450f13edb"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_loc , typename T_covar , <a class="el" href="group__vector__types_ga6b63c02c5a28640209efbe825e29422a.html#ga6b63c02c5a28640209efbe825e29422a">require_any_not_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__stan__scalar.html">is_stan_scalar</a>, T_y, T_dof, T_loc &gt; *  = nullptr, <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_covar &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab59c6a4cd8105b995f36650450f13edb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gab59c6a4cd8105b995f36650450f13edb.html#gab59c6a4cd8105b995f36650450f13edb">multi_student_t_cholesky_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_covar &amp;L)</td></tr>
<tr class="memdesc:gab59c6a4cd8105b995f36650450f13edb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the multivariate student t density for the given y, mu, nu, and a Cholesky factor L of the scale matrix.  <br /></td></tr>
<tr class="separator:gab59c6a4cd8105b995f36650450f13edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad618730948877628e92e004fec7d1458"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_covar &gt; </td></tr>
<tr class="memitem:ad618730948877628e92e004fec7d1458"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_covar &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad618730948877628e92e004fec7d1458.html#ad618730948877628e92e004fec7d1458">multi_student_t_cholesky_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_covar &amp;L)</td></tr>
<tr class="separator:ad618730948877628e92e004fec7d1458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25cd5840ab26df0dc2fe4268787f2117"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , class RNG &gt; </td></tr>
<tr class="memitem:ga25cd5840ab26df0dc2fe4268787f2117"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_std_vector_builder.html">StdVectorBuilder</a>&lt; true, Eigen::VectorXd, T_loc &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga25cd5840ab26df0dc2fe4268787f2117.html#ga25cd5840ab26df0dc2fe4268787f2117">multi_student_t_cholesky_rng</a> (double nu, const T_loc &amp;mu, const Eigen::MatrixXd &amp;L, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga25cd5840ab26df0dc2fe4268787f2117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a multivariate student-t random variate with the given degrees of freedom location and Cholesky factor the scale matrix using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga25cd5840ab26df0dc2fe4268787f2117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3353484e25bccde867614c8801b27ce"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gae3353484e25bccde867614c8801b27ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gae3353484e25bccde867614c8801b27ce.html#gae3353484e25bccde867614c8801b27ce">multi_student_t_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;Sigma)</td></tr>
<tr class="memdesc:gae3353484e25bccde867614c8801b27ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the multivariate student t density for the given y, mu, nu, and scale matrix.  <br /></td></tr>
<tr class="separator:gae3353484e25bccde867614c8801b27ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1fb1be5bd9b3ed0f86f942866096e8"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ace1fb1be5bd9b3ed0f86f942866096e8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ace1fb1be5bd9b3ed0f86f942866096e8.html#ace1fb1be5bd9b3ed0f86f942866096e8">multi_student_t_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;Sigma)</td></tr>
<tr class="separator:ace1fb1be5bd9b3ed0f86f942866096e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadaf0b440002e691813ef5b08b8340faa"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , class RNG &gt; </td></tr>
<tr class="memitem:gadaf0b440002e691813ef5b08b8340faa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_std_vector_builder.html">StdVectorBuilder</a>&lt; true, Eigen::VectorXd, T_loc &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gadaf0b440002e691813ef5b08b8340faa.html#gadaf0b440002e691813ef5b08b8340faa">multi_student_t_rng</a> (double nu, const T_loc &amp;mu, const Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;S, RNG &amp;rng)</td></tr>
<tr class="memdesc:gadaf0b440002e691813ef5b08b8340faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a multivariate student-t random variate with the given degrees of freedom location and Cholesky factor the scale matrix using the specified random number generator.  <br /></td></tr>
<tr class="separator:gadaf0b440002e691813ef5b08b8340faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7918ec39db841e37e729964c3eaceab"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_beta , typename T_prob  = scalar_type_t&lt;T_beta&gt;, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac7918ec39db841e37e729964c3eaceab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gac7918ec39db841e37e729964c3eaceab.html#gac7918ec39db841e37e729964c3eaceab">multinomial_logit_lpmf</a> (const std::vector&lt; int &gt; &amp;ns, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:gac7918ec39db841e37e729964c3eaceab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multinomial log PMF in log parametrization.  <br /></td></tr>
<tr class="separator:gac7918ec39db841e37e729964c3eaceab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6b5a0eb89c26ccbc0a979b65db2d7f"><td class="memTemplParams" colspan="2">template&lt;typename T_beta , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afe6b5a0eb89c26ccbc0a979b65db2d7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afe6b5a0eb89c26ccbc0a979b65db2d7f.html#afe6b5a0eb89c26ccbc0a979b65db2d7f">multinomial_logit_lpmf</a> (const std::vector&lt; int &gt; &amp;ns, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:afe6b5a0eb89c26ccbc0a979b65db2d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a9e8ac45e1d512b623aa9b4652821fa"><td class="memTemplParams" colspan="2">template&lt;class RNG , typename T_beta , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_beta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7a9e8ac45e1d512b623aa9b4652821fa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga7a9e8ac45e1d512b623aa9b4652821fa.html#ga7a9e8ac45e1d512b623aa9b4652821fa">multinomial_logit_rng</a> (const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, int N, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga7a9e8ac45e1d512b623aa9b4652821fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a draw from a Multinomial distribution given a vector of unnormalized log probabilities, a total count, and a pseudo-random number generator.  <br /></td></tr>
<tr class="separator:ga7a9e8ac45e1d512b623aa9b4652821fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a521104fda7ff3712317be568f45a6863"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_prob , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_prob &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a521104fda7ff3712317be568f45a6863"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a521104fda7ff3712317be568f45a6863.html#a521104fda7ff3712317be568f45a6863">multinomial_lpmf</a> (const std::vector&lt; int &gt; &amp;ns, const T_prob &amp;theta)</td></tr>
<tr class="separator:a521104fda7ff3712317be568f45a6863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e98588673d0695458022c1039f2db3"><td class="memTemplParams" colspan="2">template&lt;typename T_prob &gt; </td></tr>
<tr class="memitem:a47e98588673d0695458022c1039f2db3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_prob &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a47e98588673d0695458022c1039f2db3.html#a47e98588673d0695458022c1039f2db3">multinomial_lpmf</a> (const std::vector&lt; int &gt; &amp;ns, const T_prob &amp;theta)</td></tr>
<tr class="separator:a47e98588673d0695458022c1039f2db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7597e3c4df61510e6ca90480dda4e635"><td class="memTemplParams" colspan="2">template&lt;class T_theta , class RNG , <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_theta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga7597e3c4df61510e6ca90480dda4e635"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga7597e3c4df61510e6ca90480dda4e635.html#ga7597e3c4df61510e6ca90480dda4e635">multinomial_rng</a> (const T_theta &amp;theta, int N, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga7597e3c4df61510e6ca90480dda4e635"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a draw from a Multinomial distribution given a probability simplex, a total count, and a pseudo-random number generator.  <br /></td></tr>
<tr class="separator:ga7597e3c4df61510e6ca90480dda4e635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga934e9cfa3366f51299dffeb018691138"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:ga934e9cfa3366f51299dffeb018691138"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga934e9cfa3366f51299dffeb018691138.html#ga934e9cfa3366f51299dffeb018691138">neg_binomial_2_ccdf_log</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:ga934e9cfa3366f51299dffeb018691138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d474666006ad4f7b2571fbad76cf77"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:ab5d474666006ad4f7b2571fbad76cf77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab5d474666006ad4f7b2571fbad76cf77.html#ab5d474666006ad4f7b2571fbad76cf77">neg_binomial_2_cdf</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:ab5d474666006ad4f7b2571fbad76cf77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61a0900ba5f4fb9cbf435c9ec53caa9d"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:ga61a0900ba5f4fb9cbf435c9ec53caa9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga61a0900ba5f4fb9cbf435c9ec53caa9d.html#ga61a0900ba5f4fb9cbf435c9ec53caa9d">neg_binomial_2_cdf_log</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:ga61a0900ba5f4fb9cbf435c9ec53caa9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cae94b2166bdd4893cadc1565fc713"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:ae5cae94b2166bdd4893cadc1565fc713"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae5cae94b2166bdd4893cadc1565fc713.html#ae5cae94b2166bdd4893cadc1565fc713">neg_binomial_2_lccdf</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:ae5cae94b2166bdd4893cadc1565fc713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacec9c1319be9845253686c18c94862b"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:aacec9c1319be9845253686c18c94862b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aacec9c1319be9845253686c18c94862b.html#aacec9c1319be9845253686c18c94862b">neg_binomial_2_lcdf</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:aacec9c1319be9845253686c18c94862b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf84b546cde249c1c3e5a7d53f7f5d55e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_precision , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaf84b546cde249c1c3e5a7d53f7f5d55e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gaf84b546cde249c1c3e5a7d53f7f5d55e.html#gaf84b546cde249c1c3e5a7d53f7f5d55e">neg_binomial_2_log_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, const T_precision &amp;phi)</td></tr>
<tr class="memdesc:gaf84b546cde249c1c3e5a7d53f7f5d55e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Negative-Binomial-2 distribution and log link function.  <br /></td></tr>
<tr class="separator:gaf84b546cde249c1c3e5a7d53f7f5d55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af90adc7aad8c4bd763bd0772ee7d00fc"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_precision &gt; </td></tr>
<tr class="memitem:af90adc7aad8c4bd763bd0772ee7d00fc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af90adc7aad8c4bd763bd0772ee7d00fc.html#af90adc7aad8c4bd763bd0772ee7d00fc">neg_binomial_2_log_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, const T_precision &amp;phi)</td></tr>
<tr class="separator:af90adc7aad8c4bd763bd0772ee7d00fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771ad40d546e568e9fa281cd2f7526de"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_log_location , typename T_precision , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n, T_log_location, T_precision &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a771ad40d546e568e9fa281cd2f7526de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_log_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a771ad40d546e568e9fa281cd2f7526de.html#a771ad40d546e568e9fa281cd2f7526de">neg_binomial_2_log_lpmf</a> (const T_n &amp;n, const T_log_location &amp;eta, const T_precision &amp;phi)</td></tr>
<tr class="separator:a771ad40d546e568e9fa281cd2f7526de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46b8ca912f2a64518c1a2b8b2c19600"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_log_location , typename T_precision &gt; </td></tr>
<tr class="memitem:ab46b8ca912f2a64518c1a2b8b2c19600"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_log_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab46b8ca912f2a64518c1a2b8b2c19600.html#ab46b8ca912f2a64518c1a2b8b2c19600">neg_binomial_2_log_lpmf</a> (const T_n &amp;n, const T_log_location &amp;eta, const T_precision &amp;phi)</td></tr>
<tr class="separator:ab46b8ca912f2a64518c1a2b8b2c19600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18cf8c66eaad84ab2271c7789af24dc0"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_inv , class RNG &gt; </td></tr>
<tr class="memitem:ga18cf8c66eaad84ab2271c7789af24dc0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_loc, T_inv &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga18cf8c66eaad84ab2271c7789af24dc0.html#ga18cf8c66eaad84ab2271c7789af24dc0">neg_binomial_2_log_rng</a> (const T_loc &amp;eta, const T_inv &amp;phi, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga18cf8c66eaad84ab2271c7789af24dc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a negative binomial random variate with the specified log-location and inverse dispersion parameters using the given random number generator.  <br /></td></tr>
<tr class="separator:ga18cf8c66eaad84ab2271c7789af24dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64297c3f8c79579a92e47dc067f083b3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_location , typename T_precision , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n, T_location, T_precision &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a64297c3f8c79579a92e47dc067f083b3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a64297c3f8c79579a92e47dc067f083b3.html#a64297c3f8c79579a92e47dc067f083b3">neg_binomial_2_lpmf</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:a64297c3f8c79579a92e47dc067f083b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37d8cadd4fea39c352229404aecbc50"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_location , typename T_precision &gt; </td></tr>
<tr class="memitem:ac37d8cadd4fea39c352229404aecbc50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_location, T_precision &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac37d8cadd4fea39c352229404aecbc50.html#ac37d8cadd4fea39c352229404aecbc50">neg_binomial_2_lpmf</a> (const T_n &amp;n, const T_location &amp;mu, const T_precision &amp;phi)</td></tr>
<tr class="separator:ac37d8cadd4fea39c352229404aecbc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee5940ea9d96b3baa264cdff4005bc2d"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_prec , class RNG &gt; </td></tr>
<tr class="memitem:gaee5940ea9d96b3baa264cdff4005bc2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_loc, T_prec &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaee5940ea9d96b3baa264cdff4005bc2d.html#gaee5940ea9d96b3baa264cdff4005bc2d">neg_binomial_2_rng</a> (const T_loc &amp;mu, const T_prec &amp;phi, RNG &amp;rng)</td></tr>
<tr class="memdesc:gaee5940ea9d96b3baa264cdff4005bc2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a negative binomial random variate with the specified location and precision parameters using the given random number generator.  <br /></td></tr>
<tr class="separator:gaee5940ea9d96b3baa264cdff4005bc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga132eea7e8707ad9408e7f2a5c084af66"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:ga132eea7e8707ad9408e7f2a5c084af66"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga132eea7e8707ad9408e7f2a5c084af66.html#ga132eea7e8707ad9408e7f2a5c084af66">neg_binomial_ccdf_log</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:ga132eea7e8707ad9408e7f2a5c084af66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32aa04bf3fe3da076ff85c162c4da039"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a32aa04bf3fe3da076ff85c162c4da039"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a32aa04bf3fe3da076ff85c162c4da039.html#a32aa04bf3fe3da076ff85c162c4da039">neg_binomial_cdf</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:a32aa04bf3fe3da076ff85c162c4da039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6839a50652d7e5178fd7d5e4b4c60dae"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:ga6839a50652d7e5178fd7d5e4b4c60dae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga6839a50652d7e5178fd7d5e4b4c60dae.html#ga6839a50652d7e5178fd7d5e4b4c60dae">neg_binomial_cdf_log</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:ga6839a50652d7e5178fd7d5e4b4c60dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b399b9734d9a919ce47a6da3bd94e69"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:a8b399b9734d9a919ce47a6da3bd94e69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8b399b9734d9a919ce47a6da3bd94e69.html#a8b399b9734d9a919ce47a6da3bd94e69">neg_binomial_lccdf</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;beta_param)</td></tr>
<tr class="separator:a8b399b9734d9a919ce47a6da3bd94e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfee0257be3263eebc844f880d2c5b88"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:adfee0257be3263eebc844f880d2c5b88"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adfee0257be3263eebc844f880d2c5b88.html#adfee0257be3263eebc844f880d2c5b88">neg_binomial_lcdf</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;beta_param)</td></tr>
<tr class="separator:adfee0257be3263eebc844f880d2c5b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7653ebcc507df4cdf2eb3c45f5e658"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_shape , typename T_inv_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n, T_shape, T_inv_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0a7653ebcc507df4cdf2eb3c45f5e658"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0a7653ebcc507df4cdf2eb3c45f5e658.html#a0a7653ebcc507df4cdf2eb3c45f5e658">neg_binomial_lpmf</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:a0a7653ebcc507df4cdf2eb3c45f5e658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd9aada764d04780861114951eac0f9"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_shape , typename T_inv_scale &gt; </td></tr>
<tr class="memitem:abfd9aada764d04780861114951eac0f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_shape, T_inv_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abfd9aada764d04780861114951eac0f9.html#abfd9aada764d04780861114951eac0f9">neg_binomial_lpmf</a> (const T_n &amp;n, const T_shape &amp;alpha, const T_inv_scale &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:abfd9aada764d04780861114951eac0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24e76f2991a8de158ffdf9b8874acad5"><td class="memTemplParams" colspan="2">template&lt;typename T_shape , typename T_inv , class RNG &gt; </td></tr>
<tr class="memitem:ga24e76f2991a8de158ffdf9b8874acad5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_shape, T_inv &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga24e76f2991a8de158ffdf9b8874acad5.html#ga24e76f2991a8de158ffdf9b8874acad5">neg_binomial_rng</a> (const T_shape &amp;alpha, const T_inv &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga24e76f2991a8de158ffdf9b8874acad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a negative binomial random variate with the specified shape and inverse scale parameters using the given random number generator.  <br /></td></tr>
<tr class="separator:ga24e76f2991a8de158ffdf9b8874acad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99040aa7f6474cffa6deef482772d8ff"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga99040aa7f6474cffa6deef482772d8ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga99040aa7f6474cffa6deef482772d8ff.html#ga99040aa7f6474cffa6deef482772d8ff">normal_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga99040aa7f6474cffa6deef482772d8ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9faf4d3c0621113c4083aab2942e031"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab9faf4d3c0621113c4083aab2942e031"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab9faf4d3c0621113c4083aab2942e031.html#gab9faf4d3c0621113c4083aab2942e031">normal_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:gab9faf4d3c0621113c4083aab2942e031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the normal cumulative distribution function for the given variate, location, and scale.  <br /></td></tr>
<tr class="separator:gab9faf4d3c0621113c4083aab2942e031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b3df3b5bbea50bf96e46970e26206d0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga7b3df3b5bbea50bf96e46970e26206d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga7b3df3b5bbea50bf96e46970e26206d0.html#ga7b3df3b5bbea50bf96e46970e26206d0">normal_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga7b3df3b5bbea50bf96e46970e26206d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3c18e6f4c41473bc86efa014bc682f6"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_scale , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae3c18e6f4c41473bc86efa014bc682f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_x, T_alpha, T_beta, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gae3c18e6f4c41473bc86efa014bc682f6.html#gae3c18e6f4c41473bc86efa014bc682f6">normal_id_glm_lpdf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:gae3c18e6f4c41473bc86efa014bc682f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PDF of the Generalized Linear Model (GLM) with Normal distribution and id link function.  <br /></td></tr>
<tr class="separator:gae3c18e6f4c41473bc86efa014bc682f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8738a204e7095c7e84bb36a7af59f8d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta , typename T_scale &gt; </td></tr>
<tr class="memitem:af8738a204e7095c7e84bb36a7af59f8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_x, T_alpha, T_beta, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af8738a204e7095c7e84bb36a7af59f8d.html#af8738a204e7095c7e84bb36a7af59f8d">normal_id_glm_lpdf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, const T_scale &amp;sigma)</td></tr>
<tr class="separator:af8738a204e7095c7e84bb36a7af59f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba999c920974d729d53965e4183e54a8"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aba999c920974d729d53965e4183e54a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aba999c920974d729d53965e4183e54a8.html#aba999c920974d729d53965e4183e54a8">normal_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aba999c920974d729d53965e4183e54a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755d4a99ee1e502eaf8e28b30e179f42"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a755d4a99ee1e502eaf8e28b30e179f42"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a755d4a99ee1e502eaf8e28b30e179f42.html#a755d4a99ee1e502eaf8e28b30e179f42">normal_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a755d4a99ee1e502eaf8e28b30e179f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac11aa3a6abffb4fb21a2c94d1f9c73eb"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gac11aa3a6abffb4fb21a2c94d1f9c73eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gac11aa3a6abffb4fb21a2c94d1f9c73eb.html#gac11aa3a6abffb4fb21a2c94d1f9c73eb">normal_lpdf</a> (T_y &amp;&amp;y, T_loc &amp;&amp;mu, T_scale &amp;&amp;sigma)</td></tr>
<tr class="memdesc:gac11aa3a6abffb4fb21a2c94d1f9c73eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the normal density for the specified scalar(s) given the specified mean(s) and deviation(s).  <br /></td></tr>
<tr class="separator:gac11aa3a6abffb4fb21a2c94d1f9c73eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4663ea65685205491f3394c8230d1c50"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a4663ea65685205491f3394c8230d1c50"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4663ea65685205491f3394c8230d1c50.html#a4663ea65685205491f3394c8230d1c50">normal_lpdf</a> (T_y &amp;&amp;y, T_loc &amp;&amp;mu, T_scale &amp;&amp;sigma)</td></tr>
<tr class="separator:a4663ea65685205491f3394c8230d1c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06cdf47e59184f4402246dd711a0e5f5"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga06cdf47e59184f4402246dd711a0e5f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga06cdf47e59184f4402246dd711a0e5f5.html#ga06cdf47e59184f4402246dd711a0e5f5">normal_rng</a> (const T_loc &amp;mu, const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga06cdf47e59184f4402246dd711a0e5f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Normal random variate for the given location and scale using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga06cdf47e59184f4402246dd711a0e5f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cfd06709c439612927ef2e7c3477bb7"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_s , typename T_n , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga3cfd06709c439612927ef2e7c3477bb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_s, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3cfd06709c439612927ef2e7c3477bb7.html#ga3cfd06709c439612927ef2e7c3477bb7">normal_sufficient_lpdf</a> (const T_y &amp;y_bar, const T_s &amp;s_squared, const T_n &amp;n_obs, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:ga3cfd06709c439612927ef2e7c3477bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the normal density for the specified scalar(s) given the specified mean(s) and deviation(s).  <br /></td></tr>
<tr class="separator:ga3cfd06709c439612927ef2e7c3477bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa51477142556e049159f063103e60c7"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_s , typename T_n , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:afa51477142556e049159f063103e60c7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_s, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afa51477142556e049159f063103e60c7.html#afa51477142556e049159f063103e60c7">normal_sufficient_lpdf</a> (const T_y &amp;y_bar, const T_s &amp;s_squared, const T_n &amp;n_obs, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:afa51477142556e049159f063103e60c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9c61223d3192e3727b6718d530c20a0"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_beta , typename T_cuts , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T_x &gt; *  = nullptr, <a class="el" href="group__col__vector__types_gafdf3846bf05a9740b053aa952f0bc0dd.html#gafdf3846bf05a9740b053aa952f0bc0dd">require_all_col_vector_t</a>&lt; T_beta, T_cuts &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaa9c61223d3192e3727b6718d530c20a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_beta, T_cuts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gaa9c61223d3192e3727b6718d530c20a0.html#gaa9c61223d3192e3727b6718d530c20a0">ordered_logistic_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, const T_cuts &amp;cuts)</td></tr>
<tr class="memdesc:gaa9c61223d3192e3727b6718d530c20a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the ordinal regression Generalized Linear Model (GLM).  <br /></td></tr>
<tr class="separator:gaa9c61223d3192e3727b6718d530c20a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde17ea69d0f949521b05311476fde90"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_beta , typename T_cuts &gt; </td></tr>
<tr class="memitem:afde17ea69d0f949521b05311476fde90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_beta, T_cuts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afde17ea69d0f949521b05311476fde90.html#afde17ea69d0f949521b05311476fde90">ordered_logistic_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, const T_cuts &amp;cuts)</td></tr>
<tr class="separator:afde17ea69d0f949521b05311476fde90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52d859ac6ef3fa60b7bd7c0154a56f39"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_cut , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_cut &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga52d859ac6ef3fa60b7bd7c0154a56f39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga52d859ac6ef3fa60b7bd7c0154a56f39.html#ga52d859ac6ef3fa60b7bd7c0154a56f39">ordered_logistic_lpmf</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="memdesc:ga52d859ac6ef3fa60b7bd7c0154a56f39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (natural) log probability of the specified array of integers given the vector of continuous locations and specified cutpoints in an ordered logistic model.  <br /></td></tr>
<tr class="separator:ga52d859ac6ef3fa60b7bd7c0154a56f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30c9a5bacbe9c4ed663f414e8835c00"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_cut &gt; </td></tr>
<tr class="memitem:af30c9a5bacbe9c4ed663f414e8835c00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af30c9a5bacbe9c4ed663f414e8835c00.html#af30c9a5bacbe9c4ed663f414e8835c00">ordered_logistic_lpmf</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="separator:af30c9a5bacbe9c4ed663f414e8835c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c484614e5c64ca762f733e031afd880"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a1c484614e5c64ca762f733e031afd880"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c484614e5c64ca762f733e031afd880.html#a1c484614e5c64ca762f733e031afd880">ordered_logistic_rng</a> (double eta, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;c, RNG &amp;rng)</td></tr>
<tr class="separator:a1c484614e5c64ca762f733e031afd880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb84ef49f7a59b141bb9a5f05cc0854f"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_cut &gt; </td></tr>
<tr class="memitem:gadb84ef49f7a59b141bb9a5f05cc0854f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gadb84ef49f7a59b141bb9a5f05cc0854f.html#gadb84ef49f7a59b141bb9a5f05cc0854f">ordered_probit_lpmf</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="memdesc:gadb84ef49f7a59b141bb9a5f05cc0854f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the (natural) log probability of the specified array of integers given the vector of continuous locations and array of specified cutpoints in an ordered probit model.  <br /></td></tr>
<tr class="separator:gadb84ef49f7a59b141bb9a5f05cc0854f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3694f1f0921bc40eea86da495facf196"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_cut &gt; </td></tr>
<tr class="memitem:a3694f1f0921bc40eea86da495facf196"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_loc, T_cut &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3694f1f0921bc40eea86da495facf196.html#a3694f1f0921bc40eea86da495facf196">ordered_probit_lpmf</a> (const T_y &amp;y, const T_loc &amp;lambda, const T_cut &amp;c)</td></tr>
<tr class="separator:a3694f1f0921bc40eea86da495facf196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9006c39e8500322d89c16a79d64c6f7e"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:a9006c39e8500322d89c16a79d64c6f7e"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9006c39e8500322d89c16a79d64c6f7e.html#a9006c39e8500322d89c16a79d64c6f7e">ordered_probit_rng</a> (double eta, const Eigen::VectorXd &amp;c, RNG &amp;rng)</td></tr>
<tr class="separator:a9006c39e8500322d89c16a79d64c6f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd06aee079207d8a3d57ec9259d47faa"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:gacd06aee079207d8a3d57ec9259d47faa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gacd06aee079207d8a3d57ec9259d47faa.html#gacd06aee079207d8a3d57ec9259d47faa">pareto_ccdf_log</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:gacd06aee079207d8a3d57ec9259d47faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41183a333a3ee7031f5ea61003d35bd"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae41183a333a3ee7031f5ea61003d35bd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae41183a333a3ee7031f5ea61003d35bd.html#ae41183a333a3ee7031f5ea61003d35bd">pareto_cdf</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ae41183a333a3ee7031f5ea61003d35bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga918ad859a5d8e6b5c24de98ec327f1bc"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ga918ad859a5d8e6b5c24de98ec327f1bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga918ad859a5d8e6b5c24de98ec327f1bc.html#ga918ad859a5d8e6b5c24de98ec327f1bc">pareto_cdf_log</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ga918ad859a5d8e6b5c24de98ec327f1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e624e541ee360e28219c847a730a542"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9e624e541ee360e28219c847a730a542"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9e624e541ee360e28219c847a730a542.html#a9e624e541ee360e28219c847a730a542">pareto_lccdf</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a9e624e541ee360e28219c847a730a542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb09dee6eaf676ea1de9b7699771b0e7"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abb09dee6eaf676ea1de9b7699771b0e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abb09dee6eaf676ea1de9b7699771b0e7.html#abb09dee6eaf676ea1de9b7699771b0e7">pareto_lcdf</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:abb09dee6eaf676ea1de9b7699771b0e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12694075ff0748d78498a696d97bfb89"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_scale , typename T_shape , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a12694075ff0748d78498a696d97bfb89"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a12694075ff0748d78498a696d97bfb89.html#a12694075ff0748d78498a696d97bfb89">pareto_lpdf</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a12694075ff0748d78498a696d97bfb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7186253983b33645d0517f1f1cc30131"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a7186253983b33645d0517f1f1cc30131"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7186253983b33645d0517f1f1cc30131.html#a7186253983b33645d0517f1f1cc30131">pareto_lpdf</a> (const T_y &amp;y, const T_scale &amp;y_min, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a7186253983b33645d0517f1f1cc30131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40ec6f69306768cb5423edda7dd348ee"><td class="memTemplParams" colspan="2">template&lt;typename T_shape , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga40ec6f69306768cb5423edda7dd348ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_shape, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga40ec6f69306768cb5423edda7dd348ee.html#ga40ec6f69306768cb5423edda7dd348ee">pareto_rng</a> (const T_scale &amp;y_min, const T_shape &amp;alpha, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga40ec6f69306768cb5423edda7dd348ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Pareto random variate for the given shape and scale parameters using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga40ec6f69306768cb5423edda7dd348ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44686f07a63ecb46edd01375f6608ae0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ga44686f07a63ecb46edd01375f6608ae0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga44686f07a63ecb46edd01375f6608ae0.html#ga44686f07a63ecb46edd01375f6608ae0">pareto_type_2_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ga44686f07a63ecb46edd01375f6608ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bc46c0e9dacd6bb2b9469aa06e5b319"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0bc46c0e9dacd6bb2b9469aa06e5b319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0bc46c0e9dacd6bb2b9469aa06e5b319.html#a0bc46c0e9dacd6bb2b9469aa06e5b319">pareto_type_2_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a0bc46c0e9dacd6bb2b9469aa06e5b319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30fef860644bf4bcf36e75401cab66da"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ga30fef860644bf4bcf36e75401cab66da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga30fef860644bf4bcf36e75401cab66da.html#ga30fef860644bf4bcf36e75401cab66da">pareto_type_2_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ga30fef860644bf4bcf36e75401cab66da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e965fb6d9a9fb16265c82c31d1bbc8"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a06e965fb6d9a9fb16265c82c31d1bbc8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a06e965fb6d9a9fb16265c82c31d1bbc8.html#a06e965fb6d9a9fb16265c82c31d1bbc8">pareto_type_2_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a06e965fb6d9a9fb16265c82c31d1bbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0fd05edd2ea9271b5c9af5238df3756"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad0fd05edd2ea9271b5c9af5238df3756"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad0fd05edd2ea9271b5c9af5238df3756.html#ad0fd05edd2ea9271b5c9af5238df3756">pareto_type_2_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ad0fd05edd2ea9271b5c9af5238df3756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5653d20432e8d91fe9857099233d477c"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5653d20432e8d91fe9857099233d477c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5653d20432e8d91fe9857099233d477c.html#a5653d20432e8d91fe9857099233d477c">pareto_type_2_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a5653d20432e8d91fe9857099233d477c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd70705c4925c1cf9582e527b65ca809"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:acd70705c4925c1cf9582e527b65ca809"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acd70705c4925c1cf9582e527b65ca809.html#acd70705c4925c1cf9582e527b65ca809">pareto_type_2_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha)</td></tr>
<tr class="separator:acd70705c4925c1cf9582e527b65ca809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab8227a2fa053be226a4a6f398b199bc"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , typename T_shape , class RNG &gt; </td></tr>
<tr class="memitem:gaab8227a2fa053be226a4a6f398b199bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaab8227a2fa053be226a4a6f398b199bc.html#gaab8227a2fa053be226a4a6f398b199bc">pareto_type_2_rng</a> (const T_loc &amp;mu, const T_scale &amp;lambda, const T_shape &amp;alpha, RNG &amp;rng)</td></tr>
<tr class="memdesc:gaab8227a2fa053be226a4a6f398b199bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Pareto type 2 random variate for the given location, scale, and shape using the specified random number generator.  <br /></td></tr>
<tr class="separator:gaab8227a2fa053be226a4a6f398b199bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga895b927188061328afd33cdebca5926e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:ga895b927188061328afd33cdebca5926e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga895b927188061328afd33cdebca5926e.html#ga895b927188061328afd33cdebca5926e">poisson_binomial_ccdf_log</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:ga895b927188061328afd33cdebca5926e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9376a5b182cd2b00a4bbf23b74aaa82e"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:ga9376a5b182cd2b00a4bbf23b74aaa82e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga9376a5b182cd2b00a4bbf23b74aaa82e.html#ga9376a5b182cd2b00a4bbf23b74aaa82e">poisson_binomial_cdf</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="memdesc:ga9376a5b182cd2b00a4bbf23b74aaa82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the CDF for the Poisson-binomial distribution evaluated at the specified number of successes and probabilities of successes.  <br /></td></tr>
<tr class="separator:ga9376a5b182cd2b00a4bbf23b74aaa82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9f72811f89c5399fbef9e21586abb58"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:af9f72811f89c5399fbef9e21586abb58"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af9f72811f89c5399fbef9e21586abb58.html#af9f72811f89c5399fbef9e21586abb58">poisson_binomial_cdf</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:af9f72811f89c5399fbef9e21586abb58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab848d22dd16954bb9fdf10d6361b5b9e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:gab848d22dd16954bb9fdf10d6361b5b9e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab848d22dd16954bb9fdf10d6361b5b9e.html#gab848d22dd16954bb9fdf10d6361b5b9e">poisson_binomial_cdf_log</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:gab848d22dd16954bb9fdf10d6361b5b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76993b0ea48cfad294f3c7914579bd75"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:ga76993b0ea48cfad294f3c7914579bd75"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga76993b0ea48cfad294f3c7914579bd75.html#ga76993b0ea48cfad294f3c7914579bd75">poisson_binomial_lccdf</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="memdesc:ga76993b0ea48cfad294f3c7914579bd75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log CCDF for the Poisson-binomial distribution evaluated at the specified number of successes and probabilities of successes.  <br /></td></tr>
<tr class="separator:ga76993b0ea48cfad294f3c7914579bd75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a007db94de8a73b58e68f0aeeb2fc76ff"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:a007db94de8a73b58e68f0aeeb2fc76ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a007db94de8a73b58e68f0aeeb2fc76ff.html#a007db94de8a73b58e68f0aeeb2fc76ff">poisson_binomial_lccdf</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:a007db94de8a73b58e68f0aeeb2fc76ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab84ae50b1f2497b7719e03c95dec2a5c"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:gab84ae50b1f2497b7719e03c95dec2a5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab84ae50b1f2497b7719e03c95dec2a5c.html#gab84ae50b1f2497b7719e03c95dec2a5c">poisson_binomial_lcdf</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="memdesc:gab84ae50b1f2497b7719e03c95dec2a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log CDF for the Poisson-binomial distribution evaluated at the specified number of successes and probabilities of successes.  <br /></td></tr>
<tr class="separator:gab84ae50b1f2497b7719e03c95dec2a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a44f81eb935c72d284a32151377f8fd"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:a3a44f81eb935c72d284a32151377f8fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3a44f81eb935c72d284a32151377f8fd.html#a3a44f81eb935c72d284a32151377f8fd">poisson_binomial_lcdf</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:a3a44f81eb935c72d284a32151377f8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga427e41486d2c5d3c7717402644993ba1"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:ga427e41486d2c5d3c7717402644993ba1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga427e41486d2c5d3c7717402644993ba1.html#ga427e41486d2c5d3c7717402644993ba1">poisson_binomial_lpmf</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="memdesc:ga427e41486d2c5d3c7717402644993ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF for the Poisson-binomial distribution evaluated at an specified array of numbers of successes and probabilities of successes.  <br /></td></tr>
<tr class="separator:ga427e41486d2c5d3c7717402644993ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13379ddd182d4183c98f88156ada3261"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_theta &gt; </td></tr>
<tr class="memitem:a13379ddd182d4183c98f88156ada3261"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a13379ddd182d4183c98f88156ada3261.html#a13379ddd182d4183c98f88156ada3261">poisson_binomial_lpmf</a> (const T_y &amp;y, const T_theta &amp;theta)</td></tr>
<tr class="separator:a13379ddd182d4183c98f88156ada3261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b0850b7e78c613d0800bace9cbf7e85"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , typename RNG , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; std::is_arithmetic, T_theta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga3b0850b7e78c613d0800bace9cbf7e85"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3b0850b7e78c613d0800bace9cbf7e85.html#ga3b0850b7e78c613d0800bace9cbf7e85">poisson_binomial_rng</a> (const T_theta &amp;theta, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga3b0850b7e78c613d0800bace9cbf7e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pseudorandom Poisson binomial random variable for the given vector of success parameters using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga3b0850b7e78c613d0800bace9cbf7e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16803e948b84cadefd61bf830f05b7f1"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:ga16803e948b84cadefd61bf830f05b7f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga16803e948b84cadefd61bf830f05b7f1.html#ga16803e948b84cadefd61bf830f05b7f1">poisson_ccdf_log</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:ga16803e948b84cadefd61bf830f05b7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830b37ff0e7797231fa810f255a8870c"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:a830b37ff0e7797231fa810f255a8870c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a830b37ff0e7797231fa810f255a8870c.html#a830b37ff0e7797231fa810f255a8870c">poisson_cdf</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:a830b37ff0e7797231fa810f255a8870c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae35e0643ace341a9e5b9a08005e612ee"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:gae35e0643ace341a9e5b9a08005e612ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae35e0643ace341a9e5b9a08005e612ee.html#gae35e0643ace341a9e5b9a08005e612ee">poisson_cdf_log</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:gae35e0643ace341a9e5b9a08005e612ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c8e5ab8eb7c457c5d2cc583381581d"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:ac9c8e5ab8eb7c457c5d2cc583381581d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac9c8e5ab8eb7c457c5d2cc583381581d.html#ac9c8e5ab8eb7c457c5d2cc583381581d">poisson_lccdf</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:ac9c8e5ab8eb7c457c5d2cc583381581d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23336702b3ad13f429d79134ef5ca94c"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:a23336702b3ad13f429d79134ef5ca94c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a23336702b3ad13f429d79134ef5ca94c.html#a23336702b3ad13f429d79134ef5ca94c">poisson_lcdf</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:a23336702b3ad13f429d79134ef5ca94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19efe29f334fcaecf4d092f8a5098999"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_x , typename T_alpha , typename T_beta , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T_x &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga19efe29f334fcaecf4d092f8a5098999"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga19efe29f334fcaecf4d092f8a5098999.html#ga19efe29f334fcaecf4d092f8a5098999">poisson_log_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga19efe29f334fcaecf4d092f8a5098999"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log PMF of the Generalized Linear Model (GLM) with Poisson distribution and log link function.  <br /></td></tr>
<tr class="separator:ga19efe29f334fcaecf4d092f8a5098999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80235907e89208c865ba8ab15f3d3a6"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_x , typename T_alpha , typename T_beta &gt; </td></tr>
<tr class="memitem:ae80235907e89208c865ba8ab15f3d3a6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_alpha, T_beta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae80235907e89208c865ba8ab15f3d3a6.html#ae80235907e89208c865ba8ab15f3d3a6">poisson_log_glm_lpmf</a> (const T_y &amp;y, const T_x &amp;x, const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:ae80235907e89208c865ba8ab15f3d3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7492ba624567b38d30648247944d9804"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_log_rate , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n, T_log_rate &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7492ba624567b38d30648247944d9804"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_log_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7492ba624567b38d30648247944d9804.html#a7492ba624567b38d30648247944d9804">poisson_log_lpmf</a> (const T_n &amp;n, const T_log_rate &amp;alpha)</td></tr>
<tr class="separator:a7492ba624567b38d30648247944d9804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4be65385be2a21dd1338f0b7ffbe86"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_log_rate &gt; </td></tr>
<tr class="memitem:a8e4be65385be2a21dd1338f0b7ffbe86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_log_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8e4be65385be2a21dd1338f0b7ffbe86.html#a8e4be65385be2a21dd1338f0b7ffbe86">poisson_log_lpmf</a> (const T_n &amp;n, const T_log_rate &amp;alpha)</td></tr>
<tr class="separator:a8e4be65385be2a21dd1338f0b7ffbe86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf46e0c77bd89e3a880ac6655e4dd85bc"><td class="memTemplParams" colspan="2">template&lt;typename T_rate , class RNG &gt; </td></tr>
<tr class="memitem:gaf46e0c77bd89e3a880ac6655e4dd85bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_rate &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaf46e0c77bd89e3a880ac6655e4dd85bc.html#gaf46e0c77bd89e3a880ac6655e4dd85bc">poisson_log_rng</a> (const T_rate &amp;alpha, RNG &amp;rng)</td></tr>
<tr class="memdesc:gaf46e0c77bd89e3a880ac6655e4dd85bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Poisson random variate with specified log rate parameter using the given random number generator.  <br /></td></tr>
<tr class="separator:gaf46e0c77bd89e3a880ac6655e4dd85bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a1d7851fd63cf6b8b931d0d53b7da3"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_n , typename T_rate , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_n, T_rate &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab5a1d7851fd63cf6b8b931d0d53b7da3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab5a1d7851fd63cf6b8b931d0d53b7da3.html#ab5a1d7851fd63cf6b8b931d0d53b7da3">poisson_lpmf</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:ab5a1d7851fd63cf6b8b931d0d53b7da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2fd88a599727c8b08ec66e66db625cc"><td class="memTemplParams" colspan="2">template&lt;typename T_n , typename T_rate &gt; </td></tr>
<tr class="memitem:ab2fd88a599727c8b08ec66e66db625cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_rate &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab2fd88a599727c8b08ec66e66db625cc.html#ab2fd88a599727c8b08ec66e66db625cc">poisson_lpmf</a> (const T_n &amp;n, const T_rate &amp;lambda)</td></tr>
<tr class="separator:ab2fd88a599727c8b08ec66e66db625cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab038c64682749fa9d95766b0aaf8a13c"><td class="memTemplParams" colspan="2">template&lt;typename T_rate , class RNG &gt; </td></tr>
<tr class="memitem:gab038c64682749fa9d95766b0aaf8a13c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, int, T_rate &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab038c64682749fa9d95766b0aaf8a13c.html#gab038c64682749fa9d95766b0aaf8a13c">poisson_rng</a> (const T_rate &amp;lambda, RNG &amp;rng)</td></tr>
<tr class="memdesc:gab038c64682749fa9d95766b0aaf8a13c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Poisson random variate with specified rate parameter using the given random number generator.  <br /></td></tr>
<tr class="separator:gab038c64682749fa9d95766b0aaf8a13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf58fd61a4beb99124d0d9ba4d1a1e1da"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale &gt; </td></tr>
<tr class="memitem:gaf58fd61a4beb99124d0d9ba4d1a1e1da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaf58fd61a4beb99124d0d9ba4d1a1e1da.html#gaf58fd61a4beb99124d0d9ba4d1a1e1da">rayleigh_ccdf_log</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gaf58fd61a4beb99124d0d9ba4d1a1e1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19667e0ffeda407c827205b637735408"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a19667e0ffeda407c827205b637735408"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a19667e0ffeda407c827205b637735408.html#a19667e0ffeda407c827205b637735408">rayleigh_cdf</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a19667e0ffeda407c827205b637735408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6add8e0e142a3556403ef483fad1feae"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale &gt; </td></tr>
<tr class="memitem:ga6add8e0e142a3556403ef483fad1feae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga6add8e0e142a3556403ef483fad1feae.html#ga6add8e0e142a3556403ef483fad1feae">rayleigh_cdf_log</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga6add8e0e142a3556403ef483fad1feae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58a03b063a6914d3218bf5d21cffe6c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa58a03b063a6914d3218bf5d21cffe6c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa58a03b063a6914d3218bf5d21cffe6c.html#aa58a03b063a6914d3218bf5d21cffe6c">rayleigh_lccdf</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aa58a03b063a6914d3218bf5d21cffe6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1abd68c17e23e560f8d301b5283028c"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad1abd68c17e23e560f8d301b5283028c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad1abd68c17e23e560f8d301b5283028c.html#ad1abd68c17e23e560f8d301b5283028c">rayleigh_lcdf</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ad1abd68c17e23e560f8d301b5283028c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee41bf0f6be6fad39c85d149e4896303"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aee41bf0f6be6fad39c85d149e4896303"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aee41bf0f6be6fad39c85d149e4896303.html#aee41bf0f6be6fad39c85d149e4896303">rayleigh_lpdf</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:aee41bf0f6be6fad39c85d149e4896303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb8db0f096286937e44048a8375ac8f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_scale &gt; </td></tr>
<tr class="memitem:a1cb8db0f096286937e44048a8375ac8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1cb8db0f096286937e44048a8375ac8f.html#a1cb8db0f096286937e44048a8375ac8f">rayleigh_lpdf</a> (const T_y &amp;y, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a1cb8db0f096286937e44048a8375ac8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e9eaf33b47bf83385afc4156d33a70e"><td class="memTemplParams" colspan="2">template&lt;typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga3e9eaf33b47bf83385afc4156d33a70e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga3e9eaf33b47bf83385afc4156d33a70e.html#ga3e9eaf33b47bf83385afc4156d33a70e">rayleigh_rng</a> (const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga3e9eaf33b47bf83385afc4156d33a70e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Rayleigh random variate with scale parameter sigma using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga3e9eaf33b47bf83385afc4156d33a70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabbd737e480b6f075848e8cd40f519348"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:gabbd737e480b6f075848e8cd40f519348"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gabbd737e480b6f075848e8cd40f519348.html#gabbd737e480b6f075848e8cd40f519348">scaled_inv_chi_square_ccdf_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="separator:gabbd737e480b6f075848e8cd40f519348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca12be1ba8e2baecca47d8676020d199"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:gaca12be1ba8e2baecca47d8676020d199"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaca12be1ba8e2baecca47d8676020d199.html#gaca12be1ba8e2baecca47d8676020d199">scaled_inv_chi_square_cdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="memdesc:gaca12be1ba8e2baecca47d8676020d199"><td class="mdescLeft">&#160;</td><td class="mdescRight">The CDF of a scaled inverse chi-squared density for y with the specified degrees of freedom parameter and scale parameter.  <br /></td></tr>
<tr class="separator:gaca12be1ba8e2baecca47d8676020d199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89e64e61a496911b0fbf971f1dee650a"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:ga89e64e61a496911b0fbf971f1dee650a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga89e64e61a496911b0fbf971f1dee650a.html#ga89e64e61a496911b0fbf971f1dee650a">scaled_inv_chi_square_cdf_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="separator:ga89e64e61a496911b0fbf971f1dee650a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f319f3df5236cae876ea33fdfdd2d02"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:a2f319f3df5236cae876ea33fdfdd2d02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f319f3df5236cae876ea33fdfdd2d02.html#a2f319f3df5236cae876ea33fdfdd2d02">scaled_inv_chi_square_lccdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="separator:a2f319f3df5236cae876ea33fdfdd2d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5333ed58a9dc12a7f5df80308a113d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:a2a5333ed58a9dc12a7f5df80308a113d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2a5333ed58a9dc12a7f5df80308a113d.html#a2a5333ed58a9dc12a7f5df80308a113d">scaled_inv_chi_square_lcdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="separator:a2a5333ed58a9dc12a7f5df80308a113d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93131ea8d432bc75e832e7e26fd61ab6"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_dof, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga93131ea8d432bc75e832e7e26fd61ab6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga93131ea8d432bc75e832e7e26fd61ab6.html#ga93131ea8d432bc75e832e7e26fd61ab6">scaled_inv_chi_square_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="memdesc:ga93131ea8d432bc75e832e7e26fd61ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a scaled inverse chi-squared density for y with the specified degrees of freedom parameter and scale parameter.  <br /></td></tr>
<tr class="separator:ga93131ea8d432bc75e832e7e26fd61ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1374a8924965505c5a52db1bf58157"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:a1c1374a8924965505c5a52db1bf58157"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c1374a8924965505c5a52db1bf58157.html#a1c1374a8924965505c5a52db1bf58157">scaled_inv_chi_square_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_scale &amp;s)</td></tr>
<tr class="separator:a1c1374a8924965505c5a52db1bf58157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c07d58d377107dd2dd44e57ceb8a14a"><td class="memTemplParams" colspan="2">template&lt;typename T_deg , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga2c07d58d377107dd2dd44e57ceb8a14a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_deg, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga2c07d58d377107dd2dd44e57ceb8a14a.html#ga2c07d58d377107dd2dd44e57ceb8a14a">scaled_inv_chi_square_rng</a> (const T_deg &amp;nu, const T_scale &amp;s, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga2c07d58d377107dd2dd44e57ceb8a14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a scaled chi square random variate for the given number of degrees of freedom and scale using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga2c07d58d377107dd2dd44e57ceb8a14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34721cdb67cbd7867cba510a69dd5de9"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_skewness &gt; </td></tr>
<tr class="memitem:ga34721cdb67cbd7867cba510a69dd5de9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga34721cdb67cbd7867cba510a69dd5de9.html#ga34721cdb67cbd7867cba510a69dd5de9">skew_double_exponential_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau)</td></tr>
<tr class="separator:ga34721cdb67cbd7867cba510a69dd5de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83f538b99d8659b23110bc3fe20090d0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_skewness , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga83f538b99d8659b23110bc3fe20090d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga83f538b99d8659b23110bc3fe20090d0.html#ga83f538b99d8659b23110bc3fe20090d0">skew_double_exponential_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau)</td></tr>
<tr class="memdesc:ga83f538b99d8659b23110bc3fe20090d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the skew double exponential cumulative density function.  <br /></td></tr>
<tr class="separator:ga83f538b99d8659b23110bc3fe20090d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7aca9f43ad335edf54cd0a3af5e6731"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_skewness &gt; </td></tr>
<tr class="memitem:gaf7aca9f43ad335edf54cd0a3af5e6731"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaf7aca9f43ad335edf54cd0a3af5e6731.html#gaf7aca9f43ad335edf54cd0a3af5e6731">skew_double_exponential_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau)</td></tr>
<tr class="separator:gaf7aca9f43ad335edf54cd0a3af5e6731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ad63020a789e71eefa66f5fcdc86559"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_skewness , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga6ad63020a789e71eefa66f5fcdc86559"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga6ad63020a789e71eefa66f5fcdc86559.html#ga6ad63020a789e71eefa66f5fcdc86559">skew_double_exponential_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau)</td></tr>
<tr class="memdesc:ga6ad63020a789e71eefa66f5fcdc86559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the skew double exponential log complementary cumulative density function.  <br /></td></tr>
<tr class="separator:ga6ad63020a789e71eefa66f5fcdc86559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75aa5a383309e5a05de7d9e1fa125c29"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_skewness , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga75aa5a383309e5a05de7d9e1fa125c29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga75aa5a383309e5a05de7d9e1fa125c29.html#ga75aa5a383309e5a05de7d9e1fa125c29">skew_double_exponential_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau)</td></tr>
<tr class="memdesc:ga75aa5a383309e5a05de7d9e1fa125c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the skew double exponential log cumulative density function.  <br /></td></tr>
<tr class="separator:ga75aa5a383309e5a05de7d9e1fa125c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39236d5956d85756a9e0e407d0fbd658"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_skewness , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga39236d5956d85756a9e0e407d0fbd658"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga39236d5956d85756a9e0e407d0fbd658.html#ga39236d5956d85756a9e0e407d0fbd658">skew_double_exponential_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau)</td></tr>
<tr class="memdesc:ga39236d5956d85756a9e0e407d0fbd658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the skew double exponential log probability density function.  <br /></td></tr>
<tr class="separator:ga39236d5956d85756a9e0e407d0fbd658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555c44fad039cad2aa05ed06a992dc10"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_skewness &gt; </td></tr>
<tr class="memitem:a555c44fad039cad2aa05ed06a992dc10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_skewness &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a555c44fad039cad2aa05ed06a992dc10.html#a555c44fad039cad2aa05ed06a992dc10">skew_double_exponential_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau)</td></tr>
<tr class="separator:a555c44fad039cad2aa05ed06a992dc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2189803ff706e417147c2249809fda5a"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , typename T_skewness , class RNG &gt; </td></tr>
<tr class="memitem:ga2189803ff706e417147c2249809fda5a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale, T_skewness &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga2189803ff706e417147c2249809fda5a.html#ga2189803ff706e417147c2249809fda5a">skew_double_exponential_rng</a> (const T_loc &amp;mu, const T_scale &amp;sigma, const T_skewness &amp;tau, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga2189803ff706e417147c2249809fda5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a skew double exponential random variate with the given location scale and skewness using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga2189803ff706e417147c2249809fda5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5284d4d79af3b462c5ca0b78168dec69"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:ga5284d4d79af3b462c5ca0b78168dec69"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga5284d4d79af3b462c5ca0b78168dec69.html#ga5284d4d79af3b462c5ca0b78168dec69">skew_normal_ccdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:ga5284d4d79af3b462c5ca0b78168dec69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072978cad0eb40d1e44391fad981445a"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:a072978cad0eb40d1e44391fad981445a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a072978cad0eb40d1e44391fad981445a.html#a072978cad0eb40d1e44391fad981445a">skew_normal_cdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:a072978cad0eb40d1e44391fad981445a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb043f4c0cee61909e48a479ad24f286"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:gadb043f4c0cee61909e48a479ad24f286"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gadb043f4c0cee61909e48a479ad24f286.html#gadb043f4c0cee61909e48a479ad24f286">skew_normal_cdf_log</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:gadb043f4c0cee61909e48a479ad24f286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f3a05a2a6776ab043b18762e24dc36"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:af5f3a05a2a6776ab043b18762e24dc36"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af5f3a05a2a6776ab043b18762e24dc36.html#af5f3a05a2a6776ab043b18762e24dc36">skew_normal_lccdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:af5f3a05a2a6776ab043b18762e24dc36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28be8b7e2c5a4219a4ee0247b054f47"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:af28be8b7e2c5a4219a4ee0247b054f47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af28be8b7e2c5a4219a4ee0247b054f47.html#af28be8b7e2c5a4219a4ee0247b054f47">skew_normal_lcdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:af28be8b7e2c5a4219a4ee0247b054f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefcedbd2e8ea41ded18a789ff2ac2ea"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale , typename T_shape , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afefcedbd2e8ea41ded18a789ff2ac2ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afefcedbd2e8ea41ded18a789ff2ac2ea.html#afefcedbd2e8ea41ded18a789ff2ac2ea">skew_normal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:afefcedbd2e8ea41ded18a789ff2ac2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0889d6414c9c0cf27fb178ddea04c0"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale , typename T_shape &gt; </td></tr>
<tr class="memitem:aec0889d6414c9c0cf27fb178ddea04c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale, T_shape &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aec0889d6414c9c0cf27fb178ddea04c0.html#aec0889d6414c9c0cf27fb178ddea04c0">skew_normal_lpdf</a> (const T_y &amp;y, const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha)</td></tr>
<tr class="separator:aec0889d6414c9c0cf27fb178ddea04c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35440e7b236ae82b1aa62466564e0af2"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_scale , typename T_shape , class RNG &gt; </td></tr>
<tr class="memitem:ga35440e7b236ae82b1aa62466564e0af2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_scale, T_shape &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga35440e7b236ae82b1aa62466564e0af2.html#ga35440e7b236ae82b1aa62466564e0af2">skew_normal_rng</a> (const T_loc &amp;mu, const T_scale &amp;sigma, const T_shape &amp;alpha, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga35440e7b236ae82b1aa62466564e0af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Skew-normal random variate for the given location, scale, and shape using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga35440e7b236ae82b1aa62466564e0af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c08790ce2967666dd372a814ce05d7b"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:ga6c08790ce2967666dd372a814ce05d7b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga6c08790ce2967666dd372a814ce05d7b.html#ga6c08790ce2967666dd372a814ce05d7b">std_normal_ccdf_log</a> (const T_y &amp;y)</td></tr>
<tr class="separator:ga6c08790ce2967666dd372a814ce05d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00f1dad59f20a88d13b2091cc7cdad13"><td class="memTemplParams" colspan="2">template&lt;typename T_y , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga00f1dad59f20a88d13b2091cc7cdad13"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga00f1dad59f20a88d13b2091cc7cdad13.html#ga00f1dad59f20a88d13b2091cc7cdad13">std_normal_cdf</a> (const T_y &amp;y)</td></tr>
<tr class="memdesc:ga00f1dad59f20a88d13b2091cc7cdad13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the standard normal cumulative distribution function for the given variate.  <br /></td></tr>
<tr class="separator:ga00f1dad59f20a88d13b2091cc7cdad13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga465fd3745bf5148ec0e9961ec2cd1c8a"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:ga465fd3745bf5148ec0e9961ec2cd1c8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga465fd3745bf5148ec0e9961ec2cd1c8a.html#ga465fd3745bf5148ec0e9961ec2cd1c8a">std_normal_cdf_log</a> (const T_y &amp;y)</td></tr>
<tr class="separator:ga465fd3745bf5148ec0e9961ec2cd1c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814a6ec5b44a015669e48b5a24e6a0b5"><td class="memTemplParams" colspan="2">template&lt;typename T_y , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a814a6ec5b44a015669e48b5a24e6a0b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a814a6ec5b44a015669e48b5a24e6a0b5.html#a814a6ec5b44a015669e48b5a24e6a0b5">std_normal_lccdf</a> (const T_y &amp;y)</td></tr>
<tr class="separator:a814a6ec5b44a015669e48b5a24e6a0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bda061adaf77a6c51503b2789d9e6fa"><td class="memTemplParams" colspan="2">template&lt;typename T_y , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2bda061adaf77a6c51503b2789d9e6fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2bda061adaf77a6c51503b2789d9e6fa.html#a2bda061adaf77a6c51503b2789d9e6fa">std_normal_lcdf</a> (const T_y &amp;y)</td></tr>
<tr class="separator:a2bda061adaf77a6c51503b2789d9e6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a992d8a59f95bb03c02cabaa39ca31e6a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a992d8a59f95bb03c02cabaa39ca31e6a.html#a992d8a59f95bb03c02cabaa39ca31e6a">std_normal_log_qf</a> (double log_p)</td></tr>
<tr class="memdesc:a992d8a59f95bb03c02cabaa39ca31e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of the unit normal cumulative distribution function evaluated at the log probability.  <br /></td></tr>
<tr class="separator:a992d8a59f95bb03c02cabaa39ca31e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcab7604d818420f4222f28f7c593d87"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abcab7604d818420f4222f28f7c593d87"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abcab7604d818420f4222f28f7c593d87.html#abcab7604d818420f4222f28f7c593d87">std_normal_log_qf</a> (const T &amp;x)</td></tr>
<tr class="memdesc:abcab7604d818420f4222f28f7c593d87"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vectorized version of <a class="el" href="namespacestan_1_1math_ac9d92215be48252702d0aa90083a371d.html#ac9d92215be48252702d0aa90083a371d">std_normal_log_qf()</a> that accepts std::vectors, <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Matrix/Array objects, or expressions, and containers of these.  <br /></td></tr>
<tr class="separator:abcab7604d818420f4222f28f7c593d87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5392cfb7d204c53d224fb6ae13f7efe0"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga5392cfb7d204c53d224fb6ae13f7efe0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga5392cfb7d204c53d224fb6ae13f7efe0.html#ga5392cfb7d204c53d224fb6ae13f7efe0">std_normal_lpdf</a> (const T_y &amp;y)</td></tr>
<tr class="memdesc:ga5392cfb7d204c53d224fb6ae13f7efe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the normal density for the specified scalar(s) given a location of 0 and a scale of 1.  <br /></td></tr>
<tr class="separator:ga5392cfb7d204c53d224fb6ae13f7efe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513e588892ca7b4300fe14c46e9b9501"><td class="memTemplParams" colspan="2">template&lt;typename T_y &gt; </td></tr>
<tr class="memitem:a513e588892ca7b4300fe14c46e9b9501"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a513e588892ca7b4300fe14c46e9b9501.html#a513e588892ca7b4300fe14c46e9b9501">std_normal_lpdf</a> (const T_y &amp;y)</td></tr>
<tr class="separator:a513e588892ca7b4300fe14c46e9b9501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga817cc9eafbbbea3ff44586ab9c54222e"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ga817cc9eafbbbea3ff44586ab9c54222e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga817cc9eafbbbea3ff44586ab9c54222e.html#ga817cc9eafbbbea3ff44586ab9c54222e">std_normal_rng</a> (RNG &amp;rng)</td></tr>
<tr class="memdesc:ga817cc9eafbbbea3ff44586ab9c54222e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a standard Normal random variate using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga817cc9eafbbbea3ff44586ab9c54222e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0f12da85d4456d54c51a3597159e7f2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:gae0f12da85d4456d54c51a3597159e7f2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae0f12da85d4456d54c51a3597159e7f2.html#gae0f12da85d4456d54c51a3597159e7f2">student_t_ccdf_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gae0f12da85d4456d54c51a3597159e7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5855d7cb42276295bb983488cc73bc4"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ae5855d7cb42276295bb983488cc73bc4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae5855d7cb42276295bb983488cc73bc4.html#ae5855d7cb42276295bb983488cc73bc4">student_t_cdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ae5855d7cb42276295bb983488cc73bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c58dc6c576b7842917bdf56e64618a8"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ga7c58dc6c576b7842917bdf56e64618a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga7c58dc6c576b7842917bdf56e64618a8.html#ga7c58dc6c576b7842917bdf56e64618a8">student_t_cdf_log</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga7c58dc6c576b7842917bdf56e64618a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace04e6b881e2ddeab04a0172e3f327ec"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ace04e6b881e2ddeab04a0172e3f327ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ace04e6b881e2ddeab04a0172e3f327ec.html#ace04e6b881e2ddeab04a0172e3f327ec">student_t_lccdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ace04e6b881e2ddeab04a0172e3f327ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5c880361a1e27e1806035b914bd53f"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a7f5c880361a1e27e1806035b914bd53f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7f5c880361a1e27e1806035b914bd53f.html#a7f5c880361a1e27e1806035b914bd53f">student_t_lcdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a7f5c880361a1e27e1806035b914bd53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab46df7774c22d7835c484a24f149d006"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_loc , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gab46df7774c22d7835c484a24f149d006"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab46df7774c22d7835c484a24f149d006.html#gab46df7774c22d7835c484a24f149d006">student_t_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:gab46df7774c22d7835c484a24f149d006"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Student-t density for the given y, nu, mean, and scale parameter.  <br /></td></tr>
<tr class="separator:gab46df7774c22d7835c484a24f149d006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b83e78181c69d4db58627e6fd5a41f1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a3b83e78181c69d4db58627e6fd5a41f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3b83e78181c69d4db58627e6fd5a41f1.html#a3b83e78181c69d4db58627e6fd5a41f1">student_t_lpdf</a> (const T_y &amp;y, const T_dof &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a3b83e78181c69d4db58627e6fd5a41f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2d8a49bac97728cdb3c6c6440758fb7"><td class="memTemplParams" colspan="2">template&lt;typename T_deg , typename T_loc , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:gaa2d8a49bac97728cdb3c6c6440758fb7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_deg, T_loc, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaa2d8a49bac97728cdb3c6c6440758fb7.html#gaa2d8a49bac97728cdb3c6c6440758fb7">student_t_rng</a> (const T_deg &amp;nu, const T_loc &amp;mu, const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="memdesc:gaa2d8a49bac97728cdb3c6c6440758fb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a student-t random variate for the given degrees of freedom, location, and scale using the specified random number generator.  <br /></td></tr>
<tr class="separator:gaa2d8a49bac97728cdb3c6c6440758fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7661b99b8934dc82ef732c48e7139d1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:gab7661b99b8934dc82ef732c48e7139d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_low, T_high &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gab7661b99b8934dc82ef732c48e7139d1.html#gab7661b99b8934dc82ef732c48e7139d1">uniform_ccdf_log</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:gab7661b99b8934dc82ef732c48e7139d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a34bcbdb661f207ae600d3bfd02091"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_low, T_high &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a96a34bcbdb661f207ae600d3bfd02091"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_low, T_high &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a96a34bcbdb661f207ae600d3bfd02091.html#a96a34bcbdb661f207ae600d3bfd02091">uniform_cdf</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:a96a34bcbdb661f207ae600d3bfd02091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf32fd8a3cf402a61451632e4fc429277"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:gaf32fd8a3cf402a61451632e4fc429277"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_low, T_high &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaf32fd8a3cf402a61451632e4fc429277.html#gaf32fd8a3cf402a61451632e4fc429277">uniform_cdf_log</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:gaf32fd8a3cf402a61451632e4fc429277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b3a5b9b6d23c60ce2aee35686a24ba"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_low, T_high &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad2b3a5b9b6d23c60ce2aee35686a24ba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_low, T_high &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad2b3a5b9b6d23c60ce2aee35686a24ba.html#ad2b3a5b9b6d23c60ce2aee35686a24ba">uniform_lccdf</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:ad2b3a5b9b6d23c60ce2aee35686a24ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab302d408ca5bb1289766f4b0f78c6f21"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_low, T_high &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab302d408ca5bb1289766f4b0f78c6f21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_low, T_high &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab302d408ca5bb1289766f4b0f78c6f21.html#ab302d408ca5bb1289766f4b0f78c6f21">uniform_lcdf</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:ab302d408ca5bb1289766f4b0f78c6f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58ec6c66471319611d9a7ebce69ad555"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_low , typename T_high , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_low, T_high &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga58ec6c66471319611d9a7ebce69ad555"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_low, T_high &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga58ec6c66471319611d9a7ebce69ad555.html#ga58ec6c66471319611d9a7ebce69ad555">uniform_lpdf</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="memdesc:ga58ec6c66471319611d9a7ebce69ad555"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of a uniform density for the given y, lower, and upper bound.  <br /></td></tr>
<tr class="separator:ga58ec6c66471319611d9a7ebce69ad555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72664597f3f410c57759eb3ba11b286"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_low , typename T_high &gt; </td></tr>
<tr class="memitem:af72664597f3f410c57759eb3ba11b286"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_low, T_high &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af72664597f3f410c57759eb3ba11b286.html#af72664597f3f410c57759eb3ba11b286">uniform_lpdf</a> (const T_y &amp;y, const T_low &amp;alpha, const T_high &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>)</td></tr>
<tr class="separator:af72664597f3f410c57759eb3ba11b286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7132b004e49ed98ddcfef0ec3df72b7d"><td class="memTemplParams" colspan="2">template&lt;typename T_alpha , typename T_beta , class RNG &gt; </td></tr>
<tr class="memitem:ga7132b004e49ed98ddcfef0ec3df72b7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_alpha, T_beta &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga7132b004e49ed98ddcfef0ec3df72b7d.html#ga7132b004e49ed98ddcfef0ec3df72b7d">uniform_rng</a> (const T_alpha &amp;alpha, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga7132b004e49ed98ddcfef0ec3df72b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a uniform random variate for the given upper and lower bounds using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga7132b004e49ed98ddcfef0ec3df72b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e6141be5c535cab5e9fc711a4c33ef5"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_mu , typename T_k &gt; </td></tr>
<tr class="memitem:ga2e6141be5c535cab5e9fc711a4c33ef5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_mu, T_k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga2e6141be5c535cab5e9fc711a4c33ef5.html#ga2e6141be5c535cab5e9fc711a4c33ef5">von_mises_ccdf_log</a> (const T_x &amp;x, const T_mu &amp;mu, const T_k &amp;k)</td></tr>
<tr class="separator:ga2e6141be5c535cab5e9fc711a4c33ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fcafdff9d739d6a5000fffe89c1c8ef"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_mu , typename T_k &gt; </td></tr>
<tr class="memitem:ga0fcafdff9d739d6a5000fffe89c1c8ef"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_mu, T_k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga0fcafdff9d739d6a5000fffe89c1c8ef.html#ga0fcafdff9d739d6a5000fffe89c1c8ef">von_mises_cdf</a> (const T_x &amp;x, const T_mu &amp;mu, const T_k &amp;k)</td></tr>
<tr class="memdesc:ga0fcafdff9d739d6a5000fffe89c1c8ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cumulative distribution function of the von Mises distribution:  <br /></td></tr>
<tr class="separator:ga0fcafdff9d739d6a5000fffe89c1c8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacedf7c60679fb092925d534f983e0966"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_mu , typename T_k &gt; </td></tr>
<tr class="memitem:gacedf7c60679fb092925d534f983e0966"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_mu, T_k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gacedf7c60679fb092925d534f983e0966.html#gacedf7c60679fb092925d534f983e0966">von_mises_cdf_log</a> (const T_x &amp;x, const T_mu &amp;mu, const T_k &amp;k)</td></tr>
<tr class="separator:gacedf7c60679fb092925d534f983e0966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a8196fe36d9dc88982336fd1921abe8"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_mu , typename T_k &gt; </td></tr>
<tr class="memitem:ga9a8196fe36d9dc88982336fd1921abe8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_mu, T_k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga9a8196fe36d9dc88982336fd1921abe8.html#ga9a8196fe36d9dc88982336fd1921abe8">von_mises_lccdf</a> (const T_x &amp;x, const T_mu &amp;mu, const T_k &amp;k)</td></tr>
<tr class="memdesc:ga9a8196fe36d9dc88982336fd1921abe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log of the complement of the cumulative distribution function of the von Mises distribution:  <br /></td></tr>
<tr class="separator:ga9a8196fe36d9dc88982336fd1921abe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c264d651e5fe22e27a0153ba4c99565"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_mu , typename T_k &gt; </td></tr>
<tr class="memitem:ga5c264d651e5fe22e27a0153ba4c99565"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_x, T_mu, T_k &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga5c264d651e5fe22e27a0153ba4c99565.html#ga5c264d651e5fe22e27a0153ba4c99565">von_mises_lcdf</a> (const T_x &amp;x, const T_mu &amp;mu, const T_k &amp;k)</td></tr>
<tr class="memdesc:ga5c264d651e5fe22e27a0153ba4c99565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the log of the cumulative distribution function of the von Mises distribution:  <br /></td></tr>
<tr class="separator:ga5c264d651e5fe22e27a0153ba4c99565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac061d65d46136035a0de9d1a9399b0ec"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:ac061d65d46136035a0de9d1a9399b0ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac061d65d46136035a0de9d1a9399b0ec.html#ac061d65d46136035a0de9d1a9399b0ec">von_mises_lpdf</a> (T_y const &amp;y, T_loc const &amp;mu, T_scale const &amp;kappa)</td></tr>
<tr class="separator:ac061d65d46136035a0de9d1a9399b0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2743bbae219a8c0402911e20cac368"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_loc , typename T_scale &gt; </td></tr>
<tr class="memitem:a6e2743bbae219a8c0402911e20cac368"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_loc, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6e2743bbae219a8c0402911e20cac368.html#a6e2743bbae219a8c0402911e20cac368">von_mises_lpdf</a> (T_y const &amp;y, T_loc const &amp;mu, T_scale const &amp;kappa)</td></tr>
<tr class="separator:a6e2743bbae219a8c0402911e20cac368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbf8d81bf27d692e656e828e4068fb4d"><td class="memTemplParams" colspan="2">template&lt;typename T_loc , typename T_conc , class RNG &gt; </td></tr>
<tr class="memitem:gacbf8d81bf27d692e656e828e4068fb4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_loc, T_conc &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gacbf8d81bf27d692e656e828e4068fb4d.html#gacbf8d81bf27d692e656e828e4068fb4d">von_mises_rng</a> (const T_loc &amp;mu, const T_conc &amp;kappa, RNG &amp;rng)</td></tr>
<tr class="memdesc:gacbf8d81bf27d692e656e828e4068fb4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a von Mises random variate for the given location and concentration using the specified random number generator.  <br /></td></tr>
<tr class="separator:gacbf8d81bf27d692e656e828e4068fb4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55162f60d430e2d90f393f1463c4bd01"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:ga55162f60d430e2d90f393f1463c4bd01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga55162f60d430e2d90f393f1463c4bd01.html#ga55162f60d430e2d90f393f1463c4bd01">weibull_ccdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:ga55162f60d430e2d90f393f1463c4bd01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed050789efbf4435945b020c20170d4e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaed050789efbf4435945b020c20170d4e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaed050789efbf4435945b020c20170d4e.html#gaed050789efbf4435945b020c20170d4e">weibull_cdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:gaed050789efbf4435945b020c20170d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Weibull cumulative distribution function for the given location and scale.  <br /></td></tr>
<tr class="separator:gaed050789efbf4435945b020c20170d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa41d57acefab996eaeff3a3cd1df084"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:gaaa41d57acefab996eaeff3a3cd1df084"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaaa41d57acefab996eaeff3a3cd1df084.html#gaaa41d57acefab996eaeff3a3cd1df084">weibull_cdf_log</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:gaaa41d57acefab996eaeff3a3cd1df084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3d43e9f1ffa4e3736d16dec00804baf"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gae3d43e9f1ffa4e3736d16dec00804baf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gae3d43e9f1ffa4e3736d16dec00804baf.html#gae3d43e9f1ffa4e3736d16dec00804baf">weibull_lccdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:gae3d43e9f1ffa4e3736d16dec00804baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Weibull log complementary cumulative distribution function for the given location and scale.  <br /></td></tr>
<tr class="separator:gae3d43e9f1ffa4e3736d16dec00804baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga650247b0c79cad66f8e919e766c8fcf2"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga650247b0c79cad66f8e919e766c8fcf2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga650247b0c79cad66f8e919e766c8fcf2.html#ga650247b0c79cad66f8e919e766c8fcf2">weibull_lcdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:ga650247b0c79cad66f8e919e766c8fcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Weibull log cumulative distribution function for the given location and scale.  <br /></td></tr>
<tr class="separator:ga650247b0c79cad66f8e919e766c8fcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadb3631e628426f67cbf4370a5ac3ad8"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_shape , typename T_scale , <a class="el" href="group__nonscalar__prim__or__rev__kernel__expression__types_ga7958557ed570a1f54df851d41b610eff.html#ga7958557ed570a1f54df851d41b610eff">require_all_not_nonscalar_prim_or_rev_kernel_expression_t</a>&lt; T_y, T_shape, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaadb3631e628426f67cbf4370a5ac3ad8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaadb3631e628426f67cbf4370a5ac3ad8.html#gaadb3631e628426f67cbf4370a5ac3ad8">weibull_lpdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="memdesc:gaadb3631e628426f67cbf4370a5ac3ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Weibull log probability density for the given location and scale.  <br /></td></tr>
<tr class="separator:gaadb3631e628426f67cbf4370a5ac3ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b7c502440447abd821c3515d35308e"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_shape , typename T_scale &gt; </td></tr>
<tr class="memitem:a72b7c502440447abd821c3515d35308e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_shape, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a72b7c502440447abd821c3515d35308e.html#a72b7c502440447abd821c3515d35308e">weibull_lpdf</a> (const T_y &amp;y, const T_shape &amp;alpha, const T_scale &amp;sigma)</td></tr>
<tr class="separator:a72b7c502440447abd821c3515d35308e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00fc239c350b247e144e080be25b3196"><td class="memTemplParams" colspan="2">template&lt;typename T_shape , typename T_scale , class RNG &gt; </td></tr>
<tr class="memitem:ga00fc239c350b247e144e080be25b3196"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1_vector_builder.html">VectorBuilder</a>&lt; true, double, T_shape, T_scale &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga00fc239c350b247e144e080be25b3196.html#ga00fc239c350b247e144e080be25b3196">weibull_rng</a> (const T_shape &amp;alpha, const T_scale &amp;sigma, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga00fc239c350b247e144e080be25b3196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a Weibull random variate for the given shape and scale parameters using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga00fc239c350b247e144e080be25b3196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5d9300cedf2820aa11928fc6c3bef6"><td class="memTemplParams" colspan="2">template&lt;bool propto = false, typename T_y , typename T_a , typename T_t0 , typename T_w , typename T_v , typename T_sv &gt; </td></tr>
<tr class="memitem:aca5d9300cedf2820aa11928fc6c3bef6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aca5d9300cedf2820aa11928fc6c3bef6.html#aca5d9300cedf2820aa11928fc6c3bef6">wiener_lpdf</a> (const T_y &amp;y, const T_a &amp;a, const T_t0 &amp;t0, const T_w &amp;w, const T_v &amp;v, const T_sv &amp;sv, const double &amp;precision_derivatives=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-4)</td></tr>
<tr class="memdesc:aca5d9300cedf2820aa11928fc6c3bef6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log-density function for the 5-parameter Wiener density.  <br /></td></tr>
<tr class="separator:aca5d9300cedf2820aa11928fc6c3bef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccf7f4ee90a8bcf19574f2668fe1c546"><td class="memTemplParams" colspan="2">template&lt;bool propto = false, typename T_y , typename T_a , typename T_t0 , typename T_w , typename T_v , typename T_sv , typename T_sw , typename T_st0 &gt; </td></tr>
<tr class="memitem:gaccf7f4ee90a8bcf19574f2668fe1c546"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_gaccf7f4ee90a8bcf19574f2668fe1c546.html#gaccf7f4ee90a8bcf19574f2668fe1c546">wiener_lpdf</a> (const T_y &amp;y, const T_a &amp;a, const T_t0 &amp;t0, const T_w &amp;w, const T_v &amp;v, const T_sv &amp;sv, const T_sw &amp;sw, const T_st0 &amp;st0, const double &amp;precision_derivatives=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-4)</td></tr>
<tr class="memdesc:gaccf7f4ee90a8bcf19574f2668fe1c546"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the first passage time density function for a (Wiener) drift diffusion model with up to 7 parameters, where \(y\in \mathbb{R}_{+}\) is the reacion time, \(a \in \mathbb{R}_{+}\) the boundary separation, \(t_0 \in \mathbb{R}_{\geq 0}\) the non-decision time, \(w \in (0, 1)\) the relative starting point (aka a-priori bias), \(v \in \mathbb{R}\) the drifte rate, \(s_v \in
  \mathbb{R}_{\geq 0}\) the inter-trial variability of the drift rate, \(s_w \in [0, 1)\) the inter-trial variability of the relative starting point, and \(s_{t_0} \in \mathbb{R}_{\geq 0}\) the inter-trial variability of the non-decision time.  <br /></td></tr>
<tr class="separator:gaccf7f4ee90a8bcf19574f2668fe1c546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ac3935e9e0561ab14e29b5fb3600271"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_alpha , typename T_tau , typename T_beta , typename T_delta &gt; </td></tr>
<tr class="memitem:ga5ac3935e9e0561ab14e29b5fb3600271"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_alpha, T_tau, T_beta, T_delta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__prob__dists_ga5ac3935e9e0561ab14e29b5fb3600271.html#ga5ac3935e9e0561ab14e29b5fb3600271">wiener_lpdf</a> (const T_y &amp;y, const T_alpha &amp;alpha, const T_tau &amp;tau, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, const T_delta &amp;delta)</td></tr>
<tr class="memdesc:ga5ac3935e9e0561ab14e29b5fb3600271"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the first passage time density function for a (Wiener) drift diffusion model for the given \(y\), boundary separation \(\alpha\), nondecision time \(\tau\), relative bias \(\beta\), and drift rate \(\delta\).  <br /></td></tr>
<tr class="separator:ga5ac3935e9e0561ab14e29b5fb3600271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954affdee571f28128b8522a70d153c1"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_alpha , typename T_tau , typename T_beta , typename T_delta &gt; </td></tr>
<tr class="memitem:a954affdee571f28128b8522a70d153c1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_alpha, T_tau, T_beta, T_delta &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a954affdee571f28128b8522a70d153c1.html#a954affdee571f28128b8522a70d153c1">wiener_lpdf</a> (const T_y &amp;y, const T_alpha &amp;alpha, const T_tau &amp;tau, const T_beta &amp;<a class="el" href="namespacestan_1_1math_ae99ae904f47e5d734efc6854f1ccf4ed.html#ae99ae904f47e5d734efc6854f1ccf4ed">beta</a>, const T_delta &amp;delta)</td></tr>
<tr class="separator:a954affdee571f28128b8522a70d153c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca2215ab05108fd1462425f668ac50d"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_dof &gt; *  = nullptr, <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; T_y, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ga4ca2215ab05108fd1462425f668ac50d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga4ca2215ab05108fd1462425f668ac50d.html#ga4ca2215ab05108fd1462425f668ac50d">wishart_cholesky_lpdf</a> (const T_y &amp;L_Y, const T_dof &amp;nu, const T_scale &amp;L_S)</td></tr>
<tr class="memdesc:ga4ca2215ab05108fd1462425f668ac50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the unnormalized Wishart density of the specified lower-triangular Cholesky factor variate, positive degrees of freedom, and lower-triangular Cholesky factor of the scale matrix.  <br /></td></tr>
<tr class="separator:ga4ca2215ab05108fd1462425f668ac50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1fa4b5ba6c6acc0656e9a74638a6eb"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:a9c1fa4b5ba6c6acc0656e9a74638a6eb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9c1fa4b5ba6c6acc0656e9a74638a6eb.html#a9c1fa4b5ba6c6acc0656e9a74638a6eb">wishart_cholesky_lpdf</a> (const T_y &amp;LW, const T_dof &amp;nu, const T_scale &amp;L_S)</td></tr>
<tr class="separator:a9c1fa4b5ba6c6acc0656e9a74638a6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6268c64d1f5d09c928bdefffa49b9371"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:ga6268c64d1f5d09c928bdefffa49b9371"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_ga6268c64d1f5d09c928bdefffa49b9371.html#ga6268c64d1f5d09c928bdefffa49b9371">wishart_cholesky_rng</a> (double nu, const Eigen::MatrixXd &amp;L_S, RNG &amp;rng)</td></tr>
<tr class="memdesc:ga6268c64d1f5d09c928bdefffa49b9371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a random Cholesky factor of the inverse covariance matrix of the specified dimensionality drawn from the Wishart distribution with the specified degrees of freedom using the specified random number generator.  <br /></td></tr>
<tr class="separator:ga6268c64d1f5d09c928bdefffa49b9371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaedb46d3a2b09150ec52b4a9e585d6a07"><td class="memTemplParams" colspan="2">template&lt;bool propto, typename T_y , typename T_dof , typename T_scale , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_dof &gt; *  = nullptr, <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; T_y, T_scale &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:gaedb46d3a2b09150ec52b4a9e585d6a07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__multivar__dists_gaedb46d3a2b09150ec52b4a9e585d6a07.html#gaedb46d3a2b09150ec52b4a9e585d6a07">wishart_lpdf</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="memdesc:gaedb46d3a2b09150ec52b4a9e585d6a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log of the Wishart density for the given W, degrees of freedom, and scale matrix.  <br /></td></tr>
<tr class="separator:gaedb46d3a2b09150ec52b4a9e585d6a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d6789a61ea921a7aed32a9c9c04f9d"><td class="memTemplParams" colspan="2">template&lt;typename T_y , typename T_dof , typename T_scale &gt; </td></tr>
<tr class="memitem:a53d6789a61ea921a7aed32a9c9c04f9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y, T_dof, T_scale &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a53d6789a61ea921a7aed32a9c9c04f9d.html#a53d6789a61ea921a7aed32a9c9c04f9d">wishart_lpdf</a> (const T_y &amp;W, const T_dof &amp;nu, const T_scale &amp;S)</td></tr>
<tr class="separator:a53d6789a61ea921a7aed32a9c9c04f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb86f966da896e53db32813047d5bcf"><td class="memTemplParams" colspan="2">template&lt;class RNG &gt; </td></tr>
<tr class="memitem:aebb86f966da896e53db32813047d5bcf"><td class="memTemplItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aebb86f966da896e53db32813047d5bcf.html#aebb86f966da896e53db32813047d5bcf">wishart_rng</a> (double nu, const Eigen::MatrixXd &amp;S, RNG &amp;rng)</td></tr>
<tr class="separator:aebb86f966da896e53db32813047d5bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6646199f1107fdd4d01ed4084d590cc"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__vector__types_ga7b9869e92fcfb027eedfe8de77507769.html#ga7b9869e92fcfb027eedfe8de77507769">require_var_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac6646199f1107fdd4d01ed4084d590cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac6646199f1107fdd4d01ed4084d590cc.html#ac6646199f1107fdd4d01ed4084d590cc">cholesky_corr_constrain</a> (const T &amp;y, int K)</td></tr>
<tr class="memdesc:ac6646199f1107fdd4d01ed4084d590cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the correlation matrix of the sepcified size read from the unconstrained vector <code>y</code>.  <br /></td></tr>
<tr class="separator:ac6646199f1107fdd4d01ed4084d590cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebc4c77232e57fb1d8a63b8a774b3a5"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__vector__types_ga7b9869e92fcfb027eedfe8de77507769.html#ga7b9869e92fcfb027eedfe8de77507769">require_var_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2ebc4c77232e57fb1d8a63b8a774b3a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2ebc4c77232e57fb1d8a63b8a774b3a5.html#a2ebc4c77232e57fb1d8a63b8a774b3a5">cholesky_corr_constrain</a> (const T &amp;y, int K, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a2ebc4c77232e57fb1d8a63b8a774b3a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the correlation matrix of the sepcified size read from the unconstrained vector <code>y</code>.  <br /></td></tr>
<tr class="separator:a2ebc4c77232e57fb1d8a63b8a774b3a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af076523e39cf6956dc095ac2f0f4f296"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__vector__types_ga7b9869e92fcfb027eedfe8de77507769.html#ga7b9869e92fcfb027eedfe8de77507769">require_var_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af076523e39cf6956dc095ac2f0f4f296"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af076523e39cf6956dc095ac2f0f4f296.html#af076523e39cf6956dc095ac2f0f4f296">cholesky_factor_constrain</a> (const T &amp;x, int M, int N)</td></tr>
<tr class="memdesc:af076523e39cf6956dc095ac2f0f4f296"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the specified size read from the specified vector.  <br /></td></tr>
<tr class="separator:af076523e39cf6956dc095ac2f0f4f296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a602345fbfbf31d90da615e9b798aa38a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__vector__types_ga7b9869e92fcfb027eedfe8de77507769.html#ga7b9869e92fcfb027eedfe8de77507769">require_var_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a602345fbfbf31d90da615e9b798aa38a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a602345fbfbf31d90da615e9b798aa38a.html#a602345fbfbf31d90da615e9b798aa38a">cholesky_factor_constrain</a> (const T &amp;x, int M, int N, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a602345fbfbf31d90da615e9b798aa38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the specified size read from the specified vector and increment the specified log probability reference with the log Jacobian adjustment of the transform.  <br /></td></tr>
<tr class="separator:a602345fbfbf31d90da615e9b798aa38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade38c9c3237ab75eb214a06d0854b711"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__vector__types_ga7b9869e92fcfb027eedfe8de77507769.html#ga7b9869e92fcfb027eedfe8de77507769">require_var_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ade38c9c3237ab75eb214a06d0854b711"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade38c9c3237ab75eb214a06d0854b711.html#ade38c9c3237ab75eb214a06d0854b711">corr_matrix_constrain</a> (const T &amp;x, Eigen::Index k)</td></tr>
<tr class="memdesc:ade38c9c3237ab75eb214a06d0854b711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality derived from the specified vector of unconstrained values.  <br /></td></tr>
<tr class="separator:ade38c9c3237ab75eb214a06d0854b711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21c68cfa72dc27cff5273436a75b18b"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__vector__types_ga7b9869e92fcfb027eedfe8de77507769.html#ga7b9869e92fcfb027eedfe8de77507769">require_var_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac21c68cfa72dc27cff5273436a75b18b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac21c68cfa72dc27cff5273436a75b18b.html#ac21c68cfa72dc27cff5273436a75b18b">corr_matrix_constrain</a> (const T &amp;x, Eigen::Index k, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:ac21c68cfa72dc27cff5273436a75b18b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality derived from the specified vector of unconstrained values.  <br /></td></tr>
<tr class="separator:ac21c68cfa72dc27cff5273436a75b18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9e389df7dbc39459ce682b082d6706"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__vector__types_ga7b9869e92fcfb027eedfe8de77507769.html#ga7b9869e92fcfb027eedfe8de77507769">require_var_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aeb9e389df7dbc39459ce682b082d6706"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeb9e389df7dbc39459ce682b082d6706.html#aeb9e389df7dbc39459ce682b082d6706">cov_matrix_constrain</a> (const T &amp;x, Eigen::Index K)</td></tr>
<tr class="memdesc:aeb9e389df7dbc39459ce682b082d6706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the symmetric, positive-definite matrix of dimensions K by K resulting from transforming the specified finite vector of size K plus (K choose 2).  <br /></td></tr>
<tr class="separator:aeb9e389df7dbc39459ce682b082d6706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f47122e1a5a16af8b84f73391048db"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__vector__types_ga7b9869e92fcfb027eedfe8de77507769.html#ga7b9869e92fcfb027eedfe8de77507769">require_var_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a38f47122e1a5a16af8b84f73391048db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a38f47122e1a5a16af8b84f73391048db.html#a38f47122e1a5a16af8b84f73391048db">cov_matrix_constrain</a> (const T &amp;x, Eigen::Index K, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a38f47122e1a5a16af8b84f73391048db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the symmetric, positive-definite matrix of dimensions K by K resulting from transforming the specified finite vector of size K plus (K choose 2).  <br /></td></tr>
<tr class="separator:a38f47122e1a5a16af8b84f73391048db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80d8ecd0993361d9dc5026bc8b6f97c"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__vector__types_ga7b9869e92fcfb027eedfe8de77507769.html#ga7b9869e92fcfb027eedfe8de77507769">require_var_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af80d8ecd0993361d9dc5026bc8b6f97c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af80d8ecd0993361d9dc5026bc8b6f97c.html#af80d8ecd0993361d9dc5026bc8b6f97c">cov_matrix_constrain_lkj</a> (const T &amp;x, size_t k)</td></tr>
<tr class="memdesc:af80d8ecd0993361d9dc5026bc8b6f97c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the covariance matrix of the specified dimensionality derived from constraining the specified vector of unconstrained values.  <br /></td></tr>
<tr class="separator:af80d8ecd0993361d9dc5026bc8b6f97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfd26001889aa20b07f2faa3e85654a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__vector__types_ga7b9869e92fcfb027eedfe8de77507769.html#ga7b9869e92fcfb027eedfe8de77507769">require_var_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afcfd26001889aa20b07f2faa3e85654a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afcfd26001889aa20b07f2faa3e85654a.html#afcfd26001889aa20b07f2faa3e85654a">cov_matrix_constrain_lkj</a> (const T &amp;x, size_t k, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:afcfd26001889aa20b07f2faa3e85654a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the covariance matrix of the specified dimensionality derived from constraining the specified vector of unconstrained values and increment the specified log probability reference with the log absolute Jacobian determinant.  <br /></td></tr>
<tr class="separator:afcfd26001889aa20b07f2faa3e85654a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a011a7e8de04e8dce184dfc29afcbd232"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T, L &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T, L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a011a7e8de04e8dce184dfc29afcbd232"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a011a7e8de04e8dce184dfc29afcbd232.html#a011a7e8de04e8dce184dfc29afcbd232">lb_constrain</a> (const T &amp;x, const L &amp;lb, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;lp)</td></tr>
<tr class="memdesc:a011a7e8de04e8dce184dfc29afcbd232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the lower-bounded value for the specified unconstrained input and specified lower bound.  <br /></td></tr>
<tr class="separator:a011a7e8de04e8dce184dfc29afcbd232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0bc788c89dc6032f4db9a2f6cf16689"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; L &gt; *  = nullptr, <a class="el" href="group__var__types_gad4fb966d630ab09756dbc3a1bfd495d4.html#gad4fb966d630ab09756dbc3a1bfd495d4">require_any_st_var</a>&lt; T, L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa0bc788c89dc6032f4db9a2f6cf16689"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa0bc788c89dc6032f4db9a2f6cf16689.html#aa0bc788c89dc6032f4db9a2f6cf16689">lb_constrain</a> (const T &amp;x, const L &amp;lb)</td></tr>
<tr class="memdesc:aa0bc788c89dc6032f4db9a2f6cf16689"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>lb_constrain</code> to apply a scalar lower bound elementwise to each input.  <br /></td></tr>
<tr class="separator:aa0bc788c89dc6032f4db9a2f6cf16689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe48fdf96981db30ca05c2fa5a4a70b9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; T, L &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; U &gt; *  = nullptr, <a class="el" href="group__var__types_gab0d7285b1a3ce33eb11e113827345d30.html#gab0d7285b1a3ce33eb11e113827345d30">require_var_t</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abe48fdf96981db30ca05c2fa5a4a70b9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abe48fdf96981db30ca05c2fa5a4a70b9.html#abe48fdf96981db30ca05c2fa5a4a70b9">lub_constrain</a> (const T &amp;x, const L &amp;lb, const U &amp;ub, std::decay_t&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, L, U &gt; &gt; &amp;lp)</td></tr>
<tr class="memdesc:abe48fdf96981db30ca05c2fa5a4a70b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix with matrix lower bound and scalar upper bound plus lp.  <br /></td></tr>
<tr class="separator:abe48fdf96981db30ca05c2fa5a4a70b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051fc17b0e31fdde842ee2c056f8149a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__col__vector__types_gaaa81c7fb1967639684eea7892b90c65c.html#gaaa81c7fb1967639684eea7892b90c65c">require_rev_col_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a051fc17b0e31fdde842ee2c056f8149a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a051fc17b0e31fdde842ee2c056f8149a.html#a051fc17b0e31fdde842ee2c056f8149a">ordered_constrain</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a051fc17b0e31fdde842ee2c056f8149a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an increasing ordered vector derived from the specified free vector.  <br /></td></tr>
<tr class="separator:a051fc17b0e31fdde842ee2c056f8149a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b35cca48ebf9684d3e126fa84602a6"><td class="memTemplParams" colspan="2">template&lt;typename VarVec , <a class="el" href="group__var__col__vector__types_ga4ab1faff10d276e9d0584855350f3365.html#ga4ab1faff10d276e9d0584855350f3365">require_var_col_vector_t</a>&lt; VarVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a11b35cca48ebf9684d3e126fa84602a6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a11b35cca48ebf9684d3e126fa84602a6.html#a11b35cca48ebf9684d3e126fa84602a6">ordered_constrain</a> (const VarVec &amp;x, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; VarVec &gt; &amp;lp)</td></tr>
<tr class="memdesc:a11b35cca48ebf9684d3e126fa84602a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a positive valued, increasing ordered vector derived from the specified free vector and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <br /></td></tr>
<tr class="separator:a11b35cca48ebf9684d3e126fa84602a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c97664c9ab35e0eef1744986efacde8"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__col__vector__types_gaaa81c7fb1967639684eea7892b90c65c.html#gaaa81c7fb1967639684eea7892b90c65c">require_rev_col_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8c97664c9ab35e0eef1744986efacde8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8c97664c9ab35e0eef1744986efacde8.html#a8c97664c9ab35e0eef1744986efacde8">positive_ordered_constrain</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a8c97664c9ab35e0eef1744986efacde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an increasing positive ordered vector derived from the specified free vector.  <br /></td></tr>
<tr class="separator:a8c97664c9ab35e0eef1744986efacde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60d44bfc1facf7b7c63a802bab2ee53"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__col__vector__types_gaaa81c7fb1967639684eea7892b90c65c.html#gaaa81c7fb1967639684eea7892b90c65c">require_rev_col_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad60d44bfc1facf7b7c63a802bab2ee53"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad60d44bfc1facf7b7c63a802bab2ee53.html#ad60d44bfc1facf7b7c63a802bab2ee53">simplex_constrain</a> (const T &amp;y)</td></tr>
<tr class="memdesc:ad60d44bfc1facf7b7c63a802bab2ee53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the simplex corresponding to the specified free vector.  <br /></td></tr>
<tr class="separator:ad60d44bfc1facf7b7c63a802bab2ee53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae564ce05fcd2814e6c7e6feee98fa3ee"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__col__vector__types_gaaa81c7fb1967639684eea7892b90c65c.html#gaaa81c7fb1967639684eea7892b90c65c">require_rev_col_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae564ce05fcd2814e6c7e6feee98fa3ee"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae564ce05fcd2814e6c7e6feee98fa3ee.html#ae564ce05fcd2814e6c7e6feee98fa3ee">simplex_constrain</a> (const T &amp;y, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:ae564ce05fcd2814e6c7e6feee98fa3ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the simplex corresponding to the specified free vector and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <br /></td></tr>
<tr class="separator:ae564ce05fcd2814e6c7e6feee98fa3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82261a2d81d8aeb3ba12742b5f95b9ca"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a82261a2d81d8aeb3ba12742b5f95b9ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a82261a2d81d8aeb3ba12742b5f95b9ca.html#a82261a2d81d8aeb3ba12742b5f95b9ca">stochastic_column_constrain</a> (const T &amp;y)</td></tr>
<tr class="memdesc:a82261a2d81d8aeb3ba12742b5f95b9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column stochastic matrix.  <br /></td></tr>
<tr class="separator:a82261a2d81d8aeb3ba12742b5f95b9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad415456c02ed1791bb6a13beae7c1ea7"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad415456c02ed1791bb6a13beae7c1ea7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad415456c02ed1791bb6a13beae7c1ea7.html#ad415456c02ed1791bb6a13beae7c1ea7">stochastic_column_constrain</a> (const T &amp;y, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:ad415456c02ed1791bb6a13beae7c1ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a column stochastic matrix and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <br /></td></tr>
<tr class="separator:ad415456c02ed1791bb6a13beae7c1ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c79521ff12bb620744664bc869e7b6d"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4c79521ff12bb620744664bc869e7b6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4c79521ff12bb620744664bc869e7b6d.html#a4c79521ff12bb620744664bc869e7b6d">stochastic_row_constrain</a> (const T &amp;y)</td></tr>
<tr class="memdesc:a4c79521ff12bb620744664bc869e7b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row stochastic matrix.  <br /></td></tr>
<tr class="separator:a4c79521ff12bb620744664bc869e7b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8723b77e6eb95b80b513c85093b18e"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aba8723b77e6eb95b80b513c85093b18e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aba8723b77e6eb95b80b513c85093b18e.html#aba8723b77e6eb95b80b513c85093b18e">stochastic_row_constrain</a> (const T &amp;y, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:aba8723b77e6eb95b80b513c85093b18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a row stochastic matrix and increment the specified log probability reference with the log absolute Jacobian determinant of the transform.  <br /></td></tr>
<tr class="separator:aba8723b77e6eb95b80b513c85093b18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be458f56de0653a25c3ee92f3da0e5f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__col__vector__types_gaaa81c7fb1967639684eea7892b90c65c.html#gaaa81c7fb1967639684eea7892b90c65c">require_rev_col_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5be458f56de0653a25c3ee92f3da0e5f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5be458f56de0653a25c3ee92f3da0e5f.html#a5be458f56de0653a25c3ee92f3da0e5f">sum_to_zero_constrain</a> (T &amp;&amp;y)</td></tr>
<tr class="memdesc:a5be458f56de0653a25c3ee92f3da0e5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector with sum zero corresponding to the specified free vector.  <br /></td></tr>
<tr class="separator:a5be458f56de0653a25c3ee92f3da0e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f55c42b8bbd1a2bce12ffdd06080d4e"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__col__vector__types_gaaa81c7fb1967639684eea7892b90c65c.html#gaaa81c7fb1967639684eea7892b90c65c">require_rev_col_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5f55c42b8bbd1a2bce12ffdd06080d4e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5f55c42b8bbd1a2bce12ffdd06080d4e.html#a5f55c42b8bbd1a2bce12ffdd06080d4e">sum_to_zero_constrain</a> (T &amp;&amp;y, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &amp;lp)</td></tr>
<tr class="memdesc:a5f55c42b8bbd1a2bce12ffdd06080d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a vector with sum zero corresponding to the specified free vector.  <br /></td></tr>
<tr class="separator:a5f55c42b8bbd1a2bce12ffdd06080d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422e6a6d0bc04f80195b36330d706d4f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; U &gt; *  = nullptr, <a class="el" href="group__var__types_gad4fb966d630ab09756dbc3a1bfd495d4.html#gad4fb966d630ab09756dbc3a1bfd495d4">require_any_st_var</a>&lt; T, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a422e6a6d0bc04f80195b36330d706d4f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a422e6a6d0bc04f80195b36330d706d4f.html#a422e6a6d0bc04f80195b36330d706d4f">ub_constrain</a> (const T &amp;x, const U &amp;ub, <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T, U &gt; &amp;lp)</td></tr>
<tr class="memdesc:a422e6a6d0bc04f80195b36330d706d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <code>ub_constrain</code> to apply a scalar upper bound elementwise to each input.  <br /></td></tr>
<tr class="separator:a422e6a6d0bc04f80195b36330d706d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc52f12b79ab010d889926f6bf09fd3a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__col__vector__types_gaaa81c7fb1967639684eea7892b90c65c.html#gaaa81c7fb1967639684eea7892b90c65c">require_rev_col_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acc52f12b79ab010d889926f6bf09fd3a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acc52f12b79ab010d889926f6bf09fd3a.html#acc52f12b79ab010d889926f6bf09fd3a">unit_vector_constrain</a> (const T &amp;y)</td></tr>
<tr class="memdesc:acc52f12b79ab010d889926f6bf09fd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the free vector y.  <br /></td></tr>
<tr class="separator:acc52f12b79ab010d889926f6bf09fd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b58913d4b412f569178256482d2679"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__col__vector__types_ga16729dba6fafa4f518defdf9cccd3488.html#ga16729dba6fafa4f518defdf9cccd3488">require_eigen_col_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a56b58913d4b412f569178256482d2679"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a56b58913d4b412f569178256482d2679.html#a56b58913d4b412f569178256482d2679">unit_vector_constrain</a> (const T &amp;y, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;lp)</td></tr>
<tr class="memdesc:a56b58913d4b412f569178256482d2679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the unit length vector corresponding to the free vector y.  <br /></td></tr>
<tr class="separator:a56b58913d4b412f569178256482d2679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad694c462755d951d8aae2e76a6d91c99"><td class="memTemplParams" colspan="2">template&lt;typename... Pargs&gt; </td></tr>
<tr class="memitem:ad694c462755d951d8aae2e76a6d91c99"><td class="memTemplItemLeft" align="right" valign="top">double *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad694c462755d951d8aae2e76a6d91c99.html#ad694c462755d951d8aae2e76a6d91c99">accumulate_adjoints</a> (double *dest, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:ad694c462755d951d8aae2e76a6d91c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate adjoints from x into storage pointed to by dest, increment the adjoint storage pointer, recursively accumulate the adjoints of the rest of the arguments, and return final position of storage pointer.  <br /></td></tr>
<tr class="separator:ad694c462755d951d8aae2e76a6d91c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ed4abe0efd57f9fa5e5ca28c4511bf"><td class="memTemplParams" colspan="2">template&lt;typename VarVec , <a class="el" href="group__std__vector__types_ga177ca10358abdf201cabb12e8bdb2e91.html#ga177ca10358abdf201cabb12e8bdb2e91">require_std_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, VarVec &gt; *  = nullptr, typename... Pargs&gt; </td></tr>
<tr class="memitem:a64ed4abe0efd57f9fa5e5ca28c4511bf"><td class="memTemplItemLeft" align="right" valign="top">double *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a64ed4abe0efd57f9fa5e5ca28c4511bf.html#a64ed4abe0efd57f9fa5e5ca28c4511bf">accumulate_adjoints</a> (double *dest, VarVec &amp;&amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a64ed4abe0efd57f9fa5e5ca28c4511bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate adjoints from std::vector x into storage pointed to by dest, increment the adjoint storage pointer, recursively accumulate the adjoints of the rest of the arguments, and return final position of storage pointer.  <br /></td></tr>
<tr class="separator:a64ed4abe0efd57f9fa5e5ca28c4511bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72556ebf9e5e07f90c16f5a0cf5086f3"><td class="memTemplParams" colspan="2">template&lt;typename VecContainer , <a class="el" href="group__std__vector__types_ga513b41fcdff562ebb8bc2cd5e3ea8faa.html#ga513b41fcdff562ebb8bc2cd5e3ea8faa">require_std_vector_st</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, VecContainer &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga177ca10358abdf201cabb12e8bdb2e91.html#ga177ca10358abdf201cabb12e8bdb2e91">require_std_vector_vt</a>&lt; <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>, VecContainer &gt; *  = nullptr, typename... Pargs&gt; </td></tr>
<tr class="memitem:a72556ebf9e5e07f90c16f5a0cf5086f3"><td class="memTemplItemLeft" align="right" valign="top">double *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a72556ebf9e5e07f90c16f5a0cf5086f3.html#a72556ebf9e5e07f90c16f5a0cf5086f3">accumulate_adjoints</a> (double *dest, VecContainer &amp;&amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a72556ebf9e5e07f90c16f5a0cf5086f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate adjoints from x (a std::vector of containers containing vars) into storage pointed to by dest, increment the adjoint storage pointer, recursively accumulate the adjoints of the rest of the arguments, and return final position of storage pointer.  <br /></td></tr>
<tr class="separator:a72556ebf9e5e07f90c16f5a0cf5086f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e37bf3dbcabc2d866f0e1885b2c34b"><td class="memTemplParams" colspan="2">template&lt;typename EigT , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, EigT &gt; *  = nullptr, typename... Pargs&gt; </td></tr>
<tr class="memitem:ab2e37bf3dbcabc2d866f0e1885b2c34b"><td class="memTemplItemLeft" align="right" valign="top">double *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab2e37bf3dbcabc2d866f0e1885b2c34b.html#ab2e37bf3dbcabc2d866f0e1885b2c34b">accumulate_adjoints</a> (double *dest, EigT &amp;&amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:ab2e37bf3dbcabc2d866f0e1885b2c34b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accumulate adjoints from x (an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> type containing vars) into storage pointed to by dest, increment the adjoint storage pointer, recursively accumulate the adjoints of the rest of the arguments, and return final position of storage pointer.  <br /></td></tr>
<tr class="separator:ab2e37bf3dbcabc2d866f0e1885b2c34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9040b37752a6e6c50ace71a4979ad071"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga948d431ec5773ff848a6bfa0d0b7aa79.html#ga948d431ec5773ff848a6bfa0d0b7aa79">require_st_arithmetic</a>&lt; Arith &gt; *  = nullptr, typename... Pargs&gt; </td></tr>
<tr class="memitem:a9040b37752a6e6c50ace71a4979ad071"><td class="memTemplItemLeft" align="right" valign="top">double *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9040b37752a6e6c50ace71a4979ad071.html#a9040b37752a6e6c50ace71a4979ad071">accumulate_adjoints</a> (double *dest, Arith &amp;&amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a9040b37752a6e6c50ace71a4979ad071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore arithmetic types.  <br /></td></tr>
<tr class="separator:a9040b37752a6e6c50ace71a4979ad071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fab0c7f17b4e5dbda5d7ec4ab822a38"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1fab0c7f17b4e5dbda5d7ec4ab822a38.html#a1fab0c7f17b4e5dbda5d7ec4ab822a38">accumulate_adjoints</a> (double *dest)</td></tr>
<tr class="memdesc:a1fab0c7f17b4e5dbda5d7ec4ab822a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">End accumulate_adjoints recursion and return pointer.  <br /></td></tr>
<tr class="separator:a1fab0c7f17b4e5dbda5d7ec4ab822a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf39b5e92d5dab76bd310d887fa2a4f"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:a9cf39b5e92d5dab76bd310d887fa2a4f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9cf39b5e92d5dab76bd310d887fa2a4f.html#a9cf39b5e92d5dab76bd310d887fa2a4f">build_vari_array</a> (const Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, R, C &gt; &amp;x)</td></tr>
<tr class="memdesc:a9cf39b5e92d5dab76bd310d887fa2a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and populates a flat array of vari pointers in the autodiff arena with the varis pointed to by the vars in the input <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix.  <br /></td></tr>
<tr class="separator:a9cf39b5e92d5dab76bd310d887fa2a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8d26999af2b842e173982c79b70404"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:afa8d26999af2b842e173982c79b70404"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1internal_1_1callback__vari.html">internal::callback_vari</a>&lt; <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;, F &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afa8d26999af2b842e173982c79b70404.html#afa8d26999af2b842e173982c79b70404">make_callback_vari</a> (T &amp;&amp;value, F &amp;&amp;functor)</td></tr>
<tr class="memdesc:afa8d26999af2b842e173982c79b70404"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new vari with given value and a callback that implements the reverse pass (chain).  <br /></td></tr>
<tr class="separator:afa8d26999af2b842e173982c79b70404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b42e5c1619046f156f42a8ce9308599"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a4b42e5c1619046f156f42a8ce9308599"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; <a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4b42e5c1619046f156f42a8ce9308599.html#a4b42e5c1619046f156f42a8ce9308599">make_callback_var</a> (T &amp;&amp;value, F &amp;&amp;functor)</td></tr>
<tr class="memdesc:a4b42e5c1619046f156f42a8ce9308599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new var initialized with a callback_vari with a given value and reverse-pass callback functor.  <br /></td></tr>
<tr class="separator:a4b42e5c1619046f156f42a8ce9308599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a746b7da3f8dc730469bcde9c6dd47459"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a746b7da3f8dc730469bcde9c6dd47459"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a746b7da3f8dc730469bcde9c6dd47459.html#a746b7da3f8dc730469bcde9c6dd47459">make_chainable_ptr</a> (T &amp;&amp;obj)</td></tr>
<tr class="memdesc:a746b7da3f8dc730469bcde9c6dd47459"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the given object in a <code><a class="el" href="classstan_1_1math_1_1chainable__object.html" title="chainable_object hold another object is useful for connecting the lifetime of a specific object to th...">chainable_object</a></code> so it is destructed only when the chainable stack memory is recovered and return a pointer to the underlying object.  <br /></td></tr>
<tr class="separator:a746b7da3f8dc730469bcde9c6dd47459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de4be1cc4ea694a0bda0dd238f7914f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3de4be1cc4ea694a0bda0dd238f7914f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3de4be1cc4ea694a0bda0dd238f7914f.html#a3de4be1cc4ea694a0bda0dd238f7914f">make_unsafe_chainable_ptr</a> (T &amp;&amp;obj)</td></tr>
<tr class="memdesc:a3de4be1cc4ea694a0bda0dd238f7914f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Store the given object in a <code><a class="el" href="classstan_1_1math_1_1chainable__object.html" title="chainable_object hold another object is useful for connecting the lifetime of a specific object to th...">chainable_object</a></code> so it is destructed only when the chainable stack memory is recovered and return a pointer to the underlying object This function differs from <code>make_chainable_object</code> in that this class does not evaluate expressions.  <br /></td></tr>
<tr class="separator:a3de4be1cc4ea694a0bda0dd238f7914f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc22cd48b0aa1ae063adbb600c8a198"><td class="memTemplParams" colspan="2">template&lt;typename... Pargs&gt; </td></tr>
<tr class="memitem:a7cc22cd48b0aa1ae063adbb600c8a198"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7cc22cd48b0aa1ae063adbb600c8a198.html#a7cc22cd48b0aa1ae063adbb600c8a198">count_vars</a> (Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7cc22cd48b0aa1ae063adbb600c8a198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of vars in the input argument list.  <br /></td></tr>
<tr class="separator:a7cc22cd48b0aa1ae063adbb600c8a198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ff0e8a272893ba0a5e27511036f741"><td class="memTemplParams" colspan="2">template&lt;typename Arith , typename  = require_arithmetic_t&lt;scalar_type_t&lt;Arith&gt;&gt;&gt; </td></tr>
<tr class="memitem:a70ff0e8a272893ba0a5e27511036f741"><td class="memTemplItemLeft" align="right" valign="top">Arith&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a70ff0e8a272893ba0a5e27511036f741.html#a70ff0e8a272893ba0a5e27511036f741">deep_copy_vars</a> (Arith &amp;&amp;<a class="el" href="namespacestan_1_1math_a500fda68d64f44323202b69ffa804f5f.html#a500fda68d64f44323202b69ffa804f5f">arg</a>)</td></tr>
<tr class="memdesc:a70ff0e8a272893ba0a5e27511036f741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward arguments that do not contain vars.  <br /></td></tr>
<tr class="separator:a70ff0e8a272893ba0a5e27511036f741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b29686f4388da084bd14c6fe1989e3"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a22b29686f4388da084bd14c6fe1989e3.html#a22b29686f4388da084bd14c6fe1989e3">deep_copy_vars</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;<a class="el" href="namespacestan_1_1math_a500fda68d64f44323202b69ffa804f5f.html#a500fda68d64f44323202b69ffa804f5f">arg</a>)</td></tr>
<tr class="memdesc:a22b29686f4388da084bd14c6fe1989e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the value of a var but reallocate a new vari.  <br /></td></tr>
<tr class="separator:a22b29686f4388da084bd14c6fe1989e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fec3c27eaf386d6aaa91f630a216cf3"><td class="memTemplParams" colspan="2">template&lt;typename VarVec , <a class="el" href="group__std__vector__types_ga177ca10358abdf201cabb12e8bdb2e91.html#ga177ca10358abdf201cabb12e8bdb2e91">require_std_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, VarVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5fec3c27eaf386d6aaa91f630a216cf3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5fec3c27eaf386d6aaa91f630a216cf3.html#a5fec3c27eaf386d6aaa91f630a216cf3">deep_copy_vars</a> (VarVec &amp;&amp;<a class="el" href="namespacestan_1_1math_a500fda68d64f44323202b69ffa804f5f.html#a500fda68d64f44323202b69ffa804f5f">arg</a>)</td></tr>
<tr class="memdesc:a5fec3c27eaf386d6aaa91f630a216cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the vars in arg but reallocate new varis for them.  <br /></td></tr>
<tr class="separator:a5fec3c27eaf386d6aaa91f630a216cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc7f8b0db0b97d8a6409d1091207d24"><td class="memTemplParams" colspan="2">template&lt;typename VecContainer , <a class="el" href="group__std__vector__types_ga513b41fcdff562ebb8bc2cd5e3ea8faa.html#ga513b41fcdff562ebb8bc2cd5e3ea8faa">require_std_vector_st</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, VecContainer &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga177ca10358abdf201cabb12e8bdb2e91.html#ga177ca10358abdf201cabb12e8bdb2e91">require_std_vector_vt</a>&lt; <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>, VecContainer &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1dc7f8b0db0b97d8a6409d1091207d24"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1dc7f8b0db0b97d8a6409d1091207d24.html#a1dc7f8b0db0b97d8a6409d1091207d24">deep_copy_vars</a> (VecContainer &amp;&amp;<a class="el" href="namespacestan_1_1math_a500fda68d64f44323202b69ffa804f5f.html#a500fda68d64f44323202b69ffa804f5f">arg</a>)</td></tr>
<tr class="memdesc:a1dc7f8b0db0b97d8a6409d1091207d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the vars in arg but reallocate new varis for them.  <br /></td></tr>
<tr class="separator:a1dc7f8b0db0b97d8a6409d1091207d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1ecbbf258a467d2023f151e1bee6df"><td class="memTemplParams" colspan="2">template&lt;typename EigT , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, EigT &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b1ecbbf258a467d2023f151e1bee6df"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4b1ecbbf258a467d2023f151e1bee6df.html#a4b1ecbbf258a467d2023f151e1bee6df">deep_copy_vars</a> (EigT &amp;&amp;<a class="el" href="namespacestan_1_1math_a500fda68d64f44323202b69ffa804f5f.html#a500fda68d64f44323202b69ffa804f5f">arg</a>)</td></tr>
<tr class="memdesc:a4b1ecbbf258a467d2023f151e1bee6df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the vars in arg but reallocate new varis for them.  <br /></td></tr>
<tr class="separator:a4b1ecbbf258a467d2023f151e1bee6df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430f171295b91277dc60dfa2177c7c0b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a430f171295b91277dc60dfa2177c7c0b.html#a430f171295b91277dc60dfa2177c7c0b">empty_nested</a> ()</td></tr>
<tr class="memdesc:a430f171295b91277dc60dfa2177c7c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there is no nested autodiff being executed.  <br /></td></tr>
<tr class="separator:a430f171295b91277dc60dfa2177c7c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae47da1792e5d3b1564c57ecb3a0de900"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae47da1792e5d3b1564c57ecb3a0de900.html#ae47da1792e5d3b1564c57ecb3a0de900">grad</a> ()</td></tr>
<tr class="memdesc:ae47da1792e5d3b1564c57ecb3a0de900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient for all variables starting from the end of the AD tape.  <br /></td></tr>
<tr class="separator:ae47da1792e5d3b1564c57ecb3a0de900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4214c4dd4dc198260d7f4f7fbb8b9fdd"><td class="memTemplParams" colspan="2">template&lt;typename Vari &gt; </td></tr>
<tr class="memitem:a4214c4dd4dc198260d7f4f7fbb8b9fdd"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4214c4dd4dc198260d7f4f7fbb8b9fdd.html#a4214c4dd4dc198260d7f4f7fbb8b9fdd">grad</a> (Vari *vi)</td></tr>
<tr class="memdesc:a4214c4dd4dc198260d7f4f7fbb8b9fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the gradient for all variables starting from the specified root variable implementation.  <br /></td></tr>
<tr class="separator:a4214c4dd4dc198260d7f4f7fbb8b9fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f68ac575a2b8dff3a7a2359962c607"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac0f68ac575a2b8dff3a7a2359962c607.html#ac0f68ac575a2b8dff3a7a2359962c607">nested_size</a> ()</td></tr>
<tr class="separator:ac0f68ac575a2b8dff3a7a2359962c607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb4c7bced043de79d94676dac3cfc4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afcb4c7bced043de79d94676dac3cfc4b.html#afcb4c7bced043de79d94676dac3cfc4b">operator+</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:afcb4c7bced043de79d94676dac3cfc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for variables (C++).  <br /></td></tr>
<tr class="separator:afcb4c7bced043de79d94676dac3cfc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802c5b7e20e2f8fad99c97dbdb55b01c"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a802c5b7e20e2f8fad99c97dbdb55b01c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a802c5b7e20e2f8fad99c97dbdb55b01c.html#a802c5b7e20e2f8fad99c97dbdb55b01c">operator+</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:a802c5b7e20e2f8fad99c97dbdb55b01c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for variable and scalar (C++).  <br /></td></tr>
<tr class="separator:a802c5b7e20e2f8fad99c97dbdb55b01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835916f3b004d05e6e6d93fb13c631bb"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a835916f3b004d05e6e6d93fb13c631bb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a835916f3b004d05e6e6d93fb13c631bb.html#a835916f3b004d05e6e6d93fb13c631bb">operator+</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a835916f3b004d05e6e6d93fb13c631bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for scalar and variable (C++).  <br /></td></tr>
<tr class="separator:a835916f3b004d05e6e6d93fb13c631bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318c0cf94b13e76b8725e2738dd9ec53"><td class="memTemplParams" colspan="2">template&lt;typename VarMat1 , typename VarMat2 , <a class="el" href="group__rev__matrix__types_gad207a403d4b54a4d3c2f24912fda464c.html#gad207a403d4b54a4d3c2f24912fda464c">require_all_rev_matrix_t</a>&lt; VarMat1, VarMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a318c0cf94b13e76b8725e2738dd9ec53"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a318c0cf94b13e76b8725e2738dd9ec53.html#a318c0cf94b13e76b8725e2738dd9ec53">add</a> (VarMat1 &amp;&amp;a, VarMat2 &amp;&amp;b)</td></tr>
<tr class="memdesc:a318c0cf94b13e76b8725e2738dd9ec53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for matrix variables (C++).  <br /></td></tr>
<tr class="separator:a318c0cf94b13e76b8725e2738dd9ec53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3ba5b97ec243c3ef21105d3fe5a55b"><td class="memTemplParams" colspan="2">template&lt;typename Arith , typename VarMat , <a class="el" href="group__arithmetic__types_ga948d431ec5773ff848a6bfa0d0b7aa79.html#ga948d431ec5773ff848a6bfa0d0b7aa79">require_st_arithmetic</a>&lt; Arith &gt; *  = nullptr, <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3e3ba5b97ec243c3ef21105d3fe5a55b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3e3ba5b97ec243c3ef21105d3fe5a55b.html#a3e3ba5b97ec243c3ef21105d3fe5a55b">add</a> (VarMat &amp;&amp;a, const Arith &amp;b)</td></tr>
<tr class="memdesc:a3e3ba5b97ec243c3ef21105d3fe5a55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for a matrix variable and arithmetic (C++).  <br /></td></tr>
<tr class="separator:a3e3ba5b97ec243c3ef21105d3fe5a55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990c32c62526f057f32c5a9447e4c739"><td class="memTemplParams" colspan="2">template&lt;typename Arith , typename VarMat , <a class="el" href="group__arithmetic__types_ga948d431ec5773ff848a6bfa0d0b7aa79.html#ga948d431ec5773ff848a6bfa0d0b7aa79">require_st_arithmetic</a>&lt; Arith &gt; *  = nullptr, <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a990c32c62526f057f32c5a9447e4c739"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a990c32c62526f057f32c5a9447e4c739.html#a990c32c62526f057f32c5a9447e4c739">add</a> (const Arith &amp;a, VarMat &amp;&amp;b)</td></tr>
<tr class="memdesc:a990c32c62526f057f32c5a9447e4c739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for an arithmetic type and matrix variable (C++).  <br /></td></tr>
<tr class="separator:a990c32c62526f057f32c5a9447e4c739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1736b421c1d5a0303405cb9353ecc46f"><td class="memTemplParams" colspan="2">template&lt;typename Var , typename EigMat , <a class="el" href="group__var__types_ga29fde8e89258f50345408f2d23070d60.html#ga29fde8e89258f50345408f2d23070d60">require_var_vt</a>&lt; std::is_arithmetic, Var &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; std::is_arithmetic, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1736b421c1d5a0303405cb9353ecc46f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1736b421c1d5a0303405cb9353ecc46f.html#a1736b421c1d5a0303405cb9353ecc46f">add</a> (const Var &amp;a, const EigMat &amp;b)</td></tr>
<tr class="memdesc:a1736b421c1d5a0303405cb9353ecc46f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for an arithmetic matrix and variable (C++).  <br /></td></tr>
<tr class="separator:a1736b421c1d5a0303405cb9353ecc46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9216d97f0985aa12f09da88b855b3e"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename Var , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; std::is_arithmetic, EigMat &gt; *  = nullptr, <a class="el" href="group__var__types_ga29fde8e89258f50345408f2d23070d60.html#ga29fde8e89258f50345408f2d23070d60">require_var_vt</a>&lt; std::is_arithmetic, Var &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1c9216d97f0985aa12f09da88b855b3e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c9216d97f0985aa12f09da88b855b3e.html#a1c9216d97f0985aa12f09da88b855b3e">add</a> (const EigMat &amp;a, const Var &amp;b)</td></tr>
<tr class="memdesc:a1c9216d97f0985aa12f09da88b855b3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for a variable and arithmetic matrix (C++).  <br /></td></tr>
<tr class="separator:a1c9216d97f0985aa12f09da88b855b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab252f36b778cc7ec9c7692c367b94abb"><td class="memTemplParams" colspan="2">template&lt;typename Var , typename VarMat , <a class="el" href="group__var__types_ga29fde8e89258f50345408f2d23070d60.html#ga29fde8e89258f50345408f2d23070d60">require_var_vt</a>&lt; std::is_arithmetic, Var &gt; *  = nullptr, <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab252f36b778cc7ec9c7692c367b94abb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab252f36b778cc7ec9c7692c367b94abb.html#ab252f36b778cc7ec9c7692c367b94abb">add</a> (const Var &amp;a, VarMat &amp;&amp;b)</td></tr>
<tr class="memdesc:ab252f36b778cc7ec9c7692c367b94abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for a variable and variable matrix (C++).  <br /></td></tr>
<tr class="separator:ab252f36b778cc7ec9c7692c367b94abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7684add01369baa3a312d5a09fc69f"><td class="memTemplParams" colspan="2">template&lt;typename Var , typename VarMat , <a class="el" href="group__var__types_ga29fde8e89258f50345408f2d23070d60.html#ga29fde8e89258f50345408f2d23070d60">require_var_vt</a>&lt; std::is_arithmetic, Var &gt; *  = nullptr, <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afb7684add01369baa3a312d5a09fc69f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afb7684add01369baa3a312d5a09fc69f.html#afb7684add01369baa3a312d5a09fc69f">add</a> (VarMat &amp;&amp;a, const Var &amp;b)</td></tr>
<tr class="memdesc:afb7684add01369baa3a312d5a09fc69f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for a variable matrix and variable (C++).  <br /></td></tr>
<tr class="separator:afb7684add01369baa3a312d5a09fc69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7c254794c6691b98f8f0ddeb75e170"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__var__types_ga71c705510643b752453ec4dbed687e86.html#ga71c705510643b752453ec4dbed687e86">require_any_var_vt</a>&lt; std::is_arithmetic, T1, T2 &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga75a77edba3f6fb2bd60267c7a9bdc08e.html#ga75a77edba3f6fb2bd60267c7a9bdc08e">require_any_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4a7c254794c6691b98f8f0ddeb75e170"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a7c254794c6691b98f8f0ddeb75e170.html#a4a7c254794c6691b98f8f0ddeb75e170">add</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:a4a7c254794c6691b98f8f0ddeb75e170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fc80944536f1612f56f155d421e42a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__var__types_gacf43b7e7d8793f9f9df153d953680032.html#gacf43b7e7d8793f9f9df153d953680032">require_all_var_vt</a>&lt; std::is_arithmetic, T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a78fc80944536f1612f56f155d421e42a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a78fc80944536f1612f56f155d421e42a.html#a78fc80944536f1612f56f155d421e42a">add</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:a78fc80944536f1612f56f155d421e42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a6a79da6d92b655a6195b978acd699"><td class="memTemplParams" colspan="2">template&lt;typename VarMat1 , typename VarMat2 , <a class="el" href="group__var__matrix__types_gaf9240f628acb5b6ce46e70cd20f93e0f.html#gaf9240f628acb5b6ce46e70cd20f93e0f">require_any_var_matrix_t</a>&lt; VarMat1, VarMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a56a6a79da6d92b655a6195b978acd699"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a56a6a79da6d92b655a6195b978acd699.html#a56a6a79da6d92b655a6195b978acd699">operator+</a> (VarMat1 &amp;&amp;a, VarMat2 &amp;&amp;b)</td></tr>
<tr class="memdesc:a56a6a79da6d92b655a6195b978acd699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for matrix variables.  <br /></td></tr>
<tr class="separator:a56a6a79da6d92b655a6195b978acd699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b3de6d6b6852949d5cf4220989e544"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa3b3de6d6b6852949d5cf4220989e544.html#aa3b3de6d6b6852949d5cf4220989e544">operator/</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;dividend, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;divisor)</td></tr>
<tr class="memdesc:aa3b3de6d6b6852949d5cf4220989e544"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for two variables (C++).  <br /></td></tr>
<tr class="separator:aa3b3de6d6b6852949d5cf4220989e544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f51599a0b355459c04ecc5c8896323"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae3f51599a0b355459c04ecc5c8896323"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae3f51599a0b355459c04ecc5c8896323.html#ae3f51599a0b355459c04ecc5c8896323">operator/</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;dividend, Arith divisor)</td></tr>
<tr class="memdesc:ae3f51599a0b355459c04ecc5c8896323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for dividing a variable by a scalar (C++).  <br /></td></tr>
<tr class="separator:ae3f51599a0b355459c04ecc5c8896323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c6daa52c8ac63dd9dbe446d84dfe3e7"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1c6daa52c8ac63dd9dbe446d84dfe3e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c6daa52c8ac63dd9dbe446d84dfe3e7.html#a1c6daa52c8ac63dd9dbe446d84dfe3e7">operator/</a> (Arith dividend, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;divisor)</td></tr>
<tr class="memdesc:a1c6daa52c8ac63dd9dbe446d84dfe3e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Division operator for dividing a scalar by a variable (C++).  <br /></td></tr>
<tr class="separator:a1c6daa52c8ac63dd9dbe446d84dfe3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8dc0569ffa3197b5e44729d435adfea"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Mat , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scalar &gt; *  = nullptr, <a class="el" href="group__var__or__arithmetic__types_ga5061e6f2e948a07b90bd6b0cde025e9e.html#ga5061e6f2e948a07b90bd6b0cde025e9e">require_all_st_var_or_arithmetic</a>&lt; Scalar, Mat &gt; *  = nullptr, <a class="el" href="group__var__types_gad4fb966d630ab09756dbc3a1bfd495d4.html#gad4fb966d630ab09756dbc3a1bfd495d4">require_any_st_var</a>&lt; Scalar, Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae8dc0569ffa3197b5e44729d435adfea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae8dc0569ffa3197b5e44729d435adfea.html#ae8dc0569ffa3197b5e44729d435adfea">divide</a> (const Mat &amp;m, Scalar c)</td></tr>
<tr class="memdesc:ae8dc0569ffa3197b5e44729d435adfea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return matrix divided by scalar.  <br /></td></tr>
<tr class="separator:ae8dc0569ffa3197b5e44729d435adfea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80daa979a1dae4d8564e53a45db9897"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Mat , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scalar &gt; *  = nullptr, <a class="el" href="group__var__or__arithmetic__types_ga5061e6f2e948a07b90bd6b0cde025e9e.html#ga5061e6f2e948a07b90bd6b0cde025e9e">require_all_st_var_or_arithmetic</a>&lt; Scalar, Mat &gt; *  = nullptr, <a class="el" href="group__var__types_gad4fb966d630ab09756dbc3a1bfd495d4.html#gad4fb966d630ab09756dbc3a1bfd495d4">require_any_st_var</a>&lt; Scalar, Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae80daa979a1dae4d8564e53a45db9897"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae80daa979a1dae4d8564e53a45db9897.html#ae80daa979a1dae4d8564e53a45db9897">divide</a> (Scalar c, const Mat &amp;m)</td></tr>
<tr class="memdesc:ae80daa979a1dae4d8564e53a45db9897"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return scalar divided by matrix.  <br /></td></tr>
<tr class="separator:ae80daa979a1dae4d8564e53a45db9897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180300a44d352de562e5d21ae3339610"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , <a class="el" href="group__matrix__types_gabb3c2790817a1e89e13bdbf460bce37b.html#gabb3c2790817a1e89e13bdbf460bce37b">require_all_matrix_st</a>&lt; <a class="el" href="group__type__trait_ga9d36a4d6158f96c2321b4fbf55243ca8.html#ga9d36a4d6158f96c2321b4fbf55243ca8">is_var_or_arithmetic</a>, Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="group__matrix__types_ga70c16a1cddf15a4e247b27efdf8fe3d3.html#ga70c16a1cddf15a4e247b27efdf8fe3d3">require_any_matrix_st</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a180300a44d352de562e5d21ae3339610"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a180300a44d352de562e5d21ae3339610.html#a180300a44d352de562e5d21ae3339610">divide</a> (const Mat1 &amp;m1, const Mat2 &amp;m2)</td></tr>
<tr class="memdesc:a180300a44d352de562e5d21ae3339610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a matrix divided by a matrix elementwise.  <br /></td></tr>
<tr class="separator:a180300a44d352de562e5d21ae3339610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c19bc019d40676cb2285305c3e20980"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__var__matrix__types_gaf9240f628acb5b6ce46e70cd20f93e0f.html#gaf9240f628acb5b6ce46e70cd20f93e0f">require_any_var_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1c19bc019d40676cb2285305c3e20980"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c19bc019d40676cb2285305c3e20980.html#a1c19bc019d40676cb2285305c3e20980">operator/</a> (const T1 &amp;dividend, const T2 &amp;divisor)</td></tr>
<tr class="separator:a1c19bc019d40676cb2285305c3e20980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63c7a8b68967a4624538d4eb5cc8429"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab63c7a8b68967a4624538d4eb5cc8429.html#ab63c7a8b68967a4624538d4eb5cc8429">operator/</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;x1, const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;x2)</td></tr>
<tr class="separator:ab63c7a8b68967a4624538d4eb5cc8429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e8c00dc01b2df161d0d242c124b046"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a62e8c00dc01b2df161d0d242c124b046.html#a62e8c00dc01b2df161d0d242c124b046">operator==</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a62e8c00dc01b2df161d0d242c124b046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator comparing two variables' values (C++).  <br /></td></tr>
<tr class="separator:a62e8c00dc01b2df161d0d242c124b046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ae79b05ad30420cbbb652a20d36690"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa3ae79b05ad30420cbbb652a20d36690"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa3ae79b05ad30420cbbb652a20d36690.html#aa3ae79b05ad30420cbbb652a20d36690">operator==</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:aa3ae79b05ad30420cbbb652a20d36690"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator comparing a variable's value and a double (C++).  <br /></td></tr>
<tr class="separator:aa3ae79b05ad30420cbbb652a20d36690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8cc5073731a06162dfe7f26b05a60ec"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa8cc5073731a06162dfe7f26b05a60ec"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa8cc5073731a06162dfe7f26b05a60ec.html#aa8cc5073731a06162dfe7f26b05a60ec">operator==</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:aa8cc5073731a06162dfe7f26b05a60ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator comparing a scalar and a variable's value (C++).  <br /></td></tr>
<tr class="separator:aa8cc5073731a06162dfe7f26b05a60ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abda3df3819326bb89481d016398d4b47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abda3df3819326bb89481d016398d4b47.html#abda3df3819326bb89481d016398d4b47">operator==</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:abda3df3819326bb89481d016398d4b47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the real number is equal to the real part of the complex number, and the imaginary part of the complex number is zero.  <br /></td></tr>
<tr class="separator:abda3df3819326bb89481d016398d4b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a3edc747df56e196b71b84059c5ed3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a05a3edc747df56e196b71b84059c5ed3.html#a05a3edc747df56e196b71b84059c5ed3">operator==</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y)</td></tr>
<tr class="memdesc:a05a3edc747df56e196b71b84059c5ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the real number is equal to the real part of the complex number, and the imaginary part of the complex number is zero.  <br /></td></tr>
<tr class="separator:a05a3edc747df56e196b71b84059c5ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465afbe6fb2692b02b60d9760e5cbda9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a465afbe6fb2692b02b60d9760e5cbda9.html#a465afbe6fb2692b02b60d9760e5cbda9">operator&gt;</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a465afbe6fb2692b02b60d9760e5cbda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than operator comparing variables' values (C++).  <br /></td></tr>
<tr class="separator:a465afbe6fb2692b02b60d9760e5cbda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b902ca384f40fe7822633a5f2d6ac61"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3b902ca384f40fe7822633a5f2d6ac61"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3b902ca384f40fe7822633a5f2d6ac61.html#a3b902ca384f40fe7822633a5f2d6ac61">operator&gt;</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:a3b902ca384f40fe7822633a5f2d6ac61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than operator comparing variable's value and double (C++).  <br /></td></tr>
<tr class="separator:a3b902ca384f40fe7822633a5f2d6ac61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6571d13d322f40de8d8f498ffba1d8"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7b6571d13d322f40de8d8f498ffba1d8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7b6571d13d322f40de8d8f498ffba1d8.html#a7b6571d13d322f40de8d8f498ffba1d8">operator&gt;</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a7b6571d13d322f40de8d8f498ffba1d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than operator comparing a double and a variable's value (C++).  <br /></td></tr>
<tr class="separator:a7b6571d13d322f40de8d8f498ffba1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938fb84cef113596828ad131e513fa1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a938fb84cef113596828ad131e513fa1e.html#a938fb84cef113596828ad131e513fa1e">operator&gt;=</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a938fb84cef113596828ad131e513fa1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal operator comparing two variables' values (C++).  <br /></td></tr>
<tr class="separator:a938fb84cef113596828ad131e513fa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac769b51a2c48934c842202f0e0da1123"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac769b51a2c48934c842202f0e0da1123"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac769b51a2c48934c842202f0e0da1123.html#ac769b51a2c48934c842202f0e0da1123">operator&gt;=</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:ac769b51a2c48934c842202f0e0da1123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal operator comparing variable's value and double (C++).  <br /></td></tr>
<tr class="separator:ac769b51a2c48934c842202f0e0da1123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431f61029137d350d6b186af1ec00aa1"><td class="memTemplParams" colspan="2">template&lt;typename Arith , typename Var , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a431f61029137d350d6b186af1ec00aa1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a431f61029137d350d6b186af1ec00aa1.html#a431f61029137d350d6b186af1ec00aa1">operator&gt;=</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a431f61029137d350d6b186af1ec00aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater than or equal operator comparing double and variable's value (C++).  <br /></td></tr>
<tr class="separator:a431f61029137d350d6b186af1ec00aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe39e7c1b0831663418188ab23b98965"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afe39e7c1b0831663418188ab23b98965.html#afe39e7c1b0831663418188ab23b98965">operator&lt;</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:afe39e7c1b0831663418188ab23b98965"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than operator comparing variables' values (C++).  <br /></td></tr>
<tr class="separator:afe39e7c1b0831663418188ab23b98965"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574a38e726f3a0ea6f197e36de064048"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a574a38e726f3a0ea6f197e36de064048"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a574a38e726f3a0ea6f197e36de064048.html#a574a38e726f3a0ea6f197e36de064048">operator&lt;</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:a574a38e726f3a0ea6f197e36de064048"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than operator comparing variable's value and a double (C++).  <br /></td></tr>
<tr class="separator:a574a38e726f3a0ea6f197e36de064048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57de9842352add5a2dbda05822b6d2db"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a57de9842352add5a2dbda05822b6d2db"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a57de9842352add5a2dbda05822b6d2db.html#a57de9842352add5a2dbda05822b6d2db">operator&lt;</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a57de9842352add5a2dbda05822b6d2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than operator comparing a double and variable's value (C++).  <br /></td></tr>
<tr class="separator:a57de9842352add5a2dbda05822b6d2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee09427479a707c4e715677d5036307b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aee09427479a707c4e715677d5036307b.html#aee09427479a707c4e715677d5036307b">operator&lt;=</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:aee09427479a707c4e715677d5036307b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal operator comparing two variables' values (C++).  <br /></td></tr>
<tr class="separator:aee09427479a707c4e715677d5036307b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a9e90ff941aed983bc663e3a5a938d"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a48a9e90ff941aed983bc663e3a5a938d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a48a9e90ff941aed983bc663e3a5a938d.html#a48a9e90ff941aed983bc663e3a5a938d">operator&lt;=</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:a48a9e90ff941aed983bc663e3a5a938d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal operator comparing a variable's value and a scalar (C++).  <br /></td></tr>
<tr class="separator:a48a9e90ff941aed983bc663e3a5a938d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19267d82a42272fa76a16612b81dd5b7"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a19267d82a42272fa76a16612b81dd5b7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a19267d82a42272fa76a16612b81dd5b7.html#a19267d82a42272fa76a16612b81dd5b7">operator&lt;=</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a19267d82a42272fa76a16612b81dd5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less than or equal operator comparing a double and variable's value (C++).  <br /></td></tr>
<tr class="separator:a19267d82a42272fa76a16612b81dd5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a966da3c5b004c346624544f9c6e087a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a966da3c5b004c346624544f9c6e087a0.html#a966da3c5b004c346624544f9c6e087a0">operator&amp;&amp;</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y)</td></tr>
<tr class="memdesc:a966da3c5b004c346624544f9c6e087a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical conjunction of the values of the two arguments as defined by <code>&amp;&amp;</code>.  <br /></td></tr>
<tr class="separator:a966da3c5b004c346624544f9c6e087a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc393a1c1dc20e7e14c2ca81e5c356f"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:accc393a1c1dc20e7e14c2ca81e5c356f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_accc393a1c1dc20e7e14c2ca81e5c356f.html#accc393a1c1dc20e7e14c2ca81e5c356f">operator&amp;&amp;</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, Arith y)</td></tr>
<tr class="memdesc:accc393a1c1dc20e7e14c2ca81e5c356f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical conjunction of the values of the two arguments as defined by <code>&amp;&amp;</code>.  <br /></td></tr>
<tr class="separator:accc393a1c1dc20e7e14c2ca81e5c356f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b01ec0670181cea3bf7347d3371f05"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a59b01ec0670181cea3bf7347d3371f05"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a59b01ec0670181cea3bf7347d3371f05.html#a59b01ec0670181cea3bf7347d3371f05">operator&amp;&amp;</a> (Arith x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y)</td></tr>
<tr class="memdesc:a59b01ec0670181cea3bf7347d3371f05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical conjunction of the values of the two arguments as defined by <code>&amp;&amp;</code>.  <br /></td></tr>
<tr class="separator:a59b01ec0670181cea3bf7347d3371f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3536c09f9def5f5a4784db14dcfacd02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3536c09f9def5f5a4784db14dcfacd02.html#a3536c09f9def5f5a4784db14dcfacd02">operator||</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y)</td></tr>
<tr class="memdesc:a3536c09f9def5f5a4784db14dcfacd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical disjunction of the values of the two arguments as defined by <code>||</code>.  <br /></td></tr>
<tr class="separator:a3536c09f9def5f5a4784db14dcfacd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5027158dabf25d8cb9c500961cf2f8"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b5027158dabf25d8cb9c500961cf2f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4b5027158dabf25d8cb9c500961cf2f8.html#a4b5027158dabf25d8cb9c500961cf2f8">operator||</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, Arith y)</td></tr>
<tr class="memdesc:a4b5027158dabf25d8cb9c500961cf2f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical disjunction of the values of the two arguments as defined by <code>||</code>.  <br /></td></tr>
<tr class="separator:a4b5027158dabf25d8cb9c500961cf2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab165a8cb3e10de571cab846cb2d5cb"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1ab165a8cb3e10de571cab846cb2d5cb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1ab165a8cb3e10de571cab846cb2d5cb.html#a1ab165a8cb3e10de571cab846cb2d5cb">operator||</a> (Arith x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y)</td></tr>
<tr class="memdesc:a1ab165a8cb3e10de571cab846cb2d5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the logical disjunction of the values of the two arguments as defined by <code>||</code>.  <br /></td></tr>
<tr class="separator:a1ab165a8cb3e10de571cab846cb2d5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436203414c825bb8765ea82786313909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a436203414c825bb8765ea82786313909.html#a436203414c825bb8765ea82786313909">operator*</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a436203414c825bb8765ea82786313909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for two variables (C++).  <br /></td></tr>
<tr class="separator:a436203414c825bb8765ea82786313909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130428db257a3686d37290c07c2929a3"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a130428db257a3686d37290c07c2929a3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a130428db257a3686d37290c07c2929a3.html#a130428db257a3686d37290c07c2929a3">operator*</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:a130428db257a3686d37290c07c2929a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for a variable and a scalar (C++).  <br /></td></tr>
<tr class="separator:a130428db257a3686d37290c07c2929a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50518a6fbac05859782970593d06ad4d"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a50518a6fbac05859782970593d06ad4d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a50518a6fbac05859782970593d06ad4d.html#a50518a6fbac05859782970593d06ad4d">operator*</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a50518a6fbac05859782970593d06ad4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication operator for a scalar and a variable (C++).  <br /></td></tr>
<tr class="separator:a50518a6fbac05859782970593d06ad4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7137f6d88210f0193034b0573358f80e"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7137f6d88210f0193034b0573358f80e.html#a7137f6d88210f0193034b0573358f80e">operator*</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> &gt; &amp;x, const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> &gt; &amp;y)</td></tr>
<tr class="memdesc:a7137f6d88210f0193034b0573358f80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of std::complex&lt;var&gt; arguments.  <br /></td></tr>
<tr class="separator:a7137f6d88210f0193034b0573358f80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355c3d2e9ac96b2a2c68d60fbdad2a6b"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a355c3d2e9ac96b2a2c68d60fbdad2a6b.html#a355c3d2e9ac96b2a2c68d60fbdad2a6b">operator*</a> (const std::complex&lt; double &gt; &amp;x, const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> &gt; &amp;y)</td></tr>
<tr class="memdesc:a355c3d2e9ac96b2a2c68d60fbdad2a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of std::complex&lt;double&gt; and std::complex&lt;var&gt; arguments.  <br /></td></tr>
<tr class="separator:a355c3d2e9ac96b2a2c68d60fbdad2a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfda4de0a5ed5f92542879ddc8f6ddd9"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adfda4de0a5ed5f92542879ddc8f6ddd9.html#adfda4de0a5ed5f92542879ddc8f6ddd9">operator*</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">stan::math::var</a> &gt; &amp;x, const std::complex&lt; double &gt; &amp;y)</td></tr>
<tr class="memdesc:adfda4de0a5ed5f92542879ddc8f6ddd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of std::complex&lt;double&gt; and std::complex&lt;var&gt; arguments.  <br /></td></tr>
<tr class="separator:adfda4de0a5ed5f92542879ddc8f6ddd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae23eb5d64637b32c92292456aa006ff0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae23eb5d64637b32c92292456aa006ff0.html#ae23eb5d64637b32c92292456aa006ff0">operator!=</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:ae23eb5d64637b32c92292456aa006ff0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator comparing two variables' values (C++).  <br /></td></tr>
<tr class="separator:ae23eb5d64637b32c92292456aa006ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3220ced29c732a3562248f3f0ececc43"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3220ced29c732a3562248f3f0ececc43"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3220ced29c732a3562248f3f0ececc43.html#a3220ced29c732a3562248f3f0ececc43">operator!=</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:a3220ced29c732a3562248f3f0ececc43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator comparing a variable's value and a double (C++).  <br /></td></tr>
<tr class="separator:a3220ced29c732a3562248f3f0ececc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f285944ba65c7fca7b50ad3b643373"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a48f285944ba65c7fca7b50ad3b643373"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a48f285944ba65c7fca7b50ad3b643373.html#a48f285944ba65c7fca7b50ad3b643373">operator!=</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a48f285944ba65c7fca7b50ad3b643373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator comparing a double and a variable's value (C++).  <br /></td></tr>
<tr class="separator:a48f285944ba65c7fca7b50ad3b643373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2b4e1b42071835672201d4a968b3515"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af2b4e1b42071835672201d4a968b3515.html#af2b4e1b42071835672201d4a968b3515">operator!=</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:af2b4e1b42071835672201d4a968b3515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>false</code> if the real number is equal to the real part of the complex number, and the imaginary part of the complex number is zero.  <br /></td></tr>
<tr class="separator:af2b4e1b42071835672201d4a968b3515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9ad9621946946982d9e2f1088a4dcc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aba9ad9621946946982d9e2f1088a4dcc.html#aba9ad9621946946982d9e2f1088a4dcc">operator!=</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y)</td></tr>
<tr class="memdesc:aba9ad9621946946982d9e2f1088a4dcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>false</code> if the real number is equal to the real part of the complex number, and the imaginary part of the complex number is zero.  <br /></td></tr>
<tr class="separator:aba9ad9621946946982d9e2f1088a4dcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971b741313ecc65a639076acc188614a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a971b741313ecc65a639076acc188614a.html#a971b741313ecc65a639076acc188614a">operator-</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a971b741313ecc65a639076acc188614a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for variables.  <br /></td></tr>
<tr class="separator:a971b741313ecc65a639076acc188614a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea55dfc43d8efb199b8ec26720e93a5"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adea55dfc43d8efb199b8ec26720e93a5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adea55dfc43d8efb199b8ec26720e93a5.html#adea55dfc43d8efb199b8ec26720e93a5">operator-</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, Arith b)</td></tr>
<tr class="memdesc:adea55dfc43d8efb199b8ec26720e93a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for variable and scalar.  <br /></td></tr>
<tr class="separator:adea55dfc43d8efb199b8ec26720e93a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75f2b829c5124ca90d4951716fe5973"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Arith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa75f2b829c5124ca90d4951716fe5973"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa75f2b829c5124ca90d4951716fe5973.html#aa75f2b829c5124ca90d4951716fe5973">operator-</a> (Arith a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:aa75f2b829c5124ca90d4951716fe5973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for scalar and variable.  <br /></td></tr>
<tr class="separator:aa75f2b829c5124ca90d4951716fe5973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85653ede9e653213494444ee89c6e07"><td class="memTemplParams" colspan="2">template&lt;typename VarMat1 , typename VarMat2 , <a class="el" href="group__rev__matrix__types_gad207a403d4b54a4d3c2f24912fda464c.html#gad207a403d4b54a4d3c2f24912fda464c">require_all_rev_matrix_t</a>&lt; VarMat1, VarMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae85653ede9e653213494444ee89c6e07"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae85653ede9e653213494444ee89c6e07.html#ae85653ede9e653213494444ee89c6e07">subtract</a> (const VarMat1 &amp;a, const VarMat2 &amp;b)</td></tr>
<tr class="memdesc:ae85653ede9e653213494444ee89c6e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for matrix variables.  <br /></td></tr>
<tr class="separator:ae85653ede9e653213494444ee89c6e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf42375b9226e0fab3ca820bfbbe864"><td class="memTemplParams" colspan="2">template&lt;typename Arith , typename VarMat , <a class="el" href="group__arithmetic__types_ga948d431ec5773ff848a6bfa0d0b7aa79.html#ga948d431ec5773ff848a6bfa0d0b7aa79">require_st_arithmetic</a>&lt; Arith &gt; *  = nullptr, <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5cf42375b9226e0fab3ca820bfbbe864"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5cf42375b9226e0fab3ca820bfbbe864.html#a5cf42375b9226e0fab3ca820bfbbe864">subtract</a> (const VarMat &amp;a, const Arith &amp;b)</td></tr>
<tr class="memdesc:a5cf42375b9226e0fab3ca820bfbbe864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for a matrix variable and arithmetic.  <br /></td></tr>
<tr class="separator:a5cf42375b9226e0fab3ca820bfbbe864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebd98058c82169301f9ef08644083da"><td class="memTemplParams" colspan="2">template&lt;typename Arith , typename VarMat , <a class="el" href="group__arithmetic__types_ga948d431ec5773ff848a6bfa0d0b7aa79.html#ga948d431ec5773ff848a6bfa0d0b7aa79">require_st_arithmetic</a>&lt; Arith &gt; *  = nullptr, <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acebd98058c82169301f9ef08644083da"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acebd98058c82169301f9ef08644083da.html#acebd98058c82169301f9ef08644083da">subtract</a> (const Arith &amp;a, const VarMat &amp;b)</td></tr>
<tr class="memdesc:acebd98058c82169301f9ef08644083da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for an arithmetic type and matrix variable.  <br /></td></tr>
<tr class="separator:acebd98058c82169301f9ef08644083da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80189bc29a1d289b6c9d8f065a4fca9c"><td class="memTemplParams" colspan="2">template&lt;typename Var , typename EigMat , <a class="el" href="group__var__types_ga29fde8e89258f50345408f2d23070d60.html#ga29fde8e89258f50345408f2d23070d60">require_var_vt</a>&lt; std::is_arithmetic, Var &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; std::is_arithmetic, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a80189bc29a1d289b6c9d8f065a4fca9c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a80189bc29a1d289b6c9d8f065a4fca9c.html#a80189bc29a1d289b6c9d8f065a4fca9c">subtract</a> (const Var &amp;a, const EigMat &amp;b)</td></tr>
<tr class="memdesc:a80189bc29a1d289b6c9d8f065a4fca9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for an arithmetic matrix and variable.  <br /></td></tr>
<tr class="separator:a80189bc29a1d289b6c9d8f065a4fca9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a66f932616754d972ccf166a85b247"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename Var , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; std::is_arithmetic, EigMat &gt; *  = nullptr, <a class="el" href="group__var__types_ga29fde8e89258f50345408f2d23070d60.html#ga29fde8e89258f50345408f2d23070d60">require_var_vt</a>&lt; std::is_arithmetic, Var &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a88a66f932616754d972ccf166a85b247"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a88a66f932616754d972ccf166a85b247.html#a88a66f932616754d972ccf166a85b247">subtract</a> (const EigMat &amp;a, const Var &amp;b)</td></tr>
<tr class="memdesc:a88a66f932616754d972ccf166a85b247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for a variable and arithmetic matrix.  <br /></td></tr>
<tr class="separator:a88a66f932616754d972ccf166a85b247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3acf4c4c4b5e093597f88f7b66c6b2c"><td class="memTemplParams" colspan="2">template&lt;typename Var , typename VarMat , <a class="el" href="group__var__types_ga29fde8e89258f50345408f2d23070d60.html#ga29fde8e89258f50345408f2d23070d60">require_var_vt</a>&lt; std::is_arithmetic, Var &gt; *  = nullptr, <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac3acf4c4c4b5e093597f88f7b66c6b2c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac3acf4c4c4b5e093597f88f7b66c6b2c.html#ac3acf4c4c4b5e093597f88f7b66c6b2c">subtract</a> (const Var &amp;a, const VarMat &amp;b)</td></tr>
<tr class="memdesc:ac3acf4c4c4b5e093597f88f7b66c6b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for a variable and variable matrix.  <br /></td></tr>
<tr class="separator:ac3acf4c4c4b5e093597f88f7b66c6b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8059a838288e540da5aeebcb9caee9fc"><td class="memTemplParams" colspan="2">template&lt;typename Var , typename VarMat , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; VarMat &gt; *  = nullptr, <a class="el" href="group__var__types_ga29fde8e89258f50345408f2d23070d60.html#ga29fde8e89258f50345408f2d23070d60">require_var_vt</a>&lt; std::is_arithmetic, Var &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8059a838288e540da5aeebcb9caee9fc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8059a838288e540da5aeebcb9caee9fc.html#a8059a838288e540da5aeebcb9caee9fc">subtract</a> (const VarMat &amp;a, const Var &amp;b)</td></tr>
<tr class="memdesc:a8059a838288e540da5aeebcb9caee9fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtraction operator for a variable matrix and variable.  <br /></td></tr>
<tr class="separator:a8059a838288e540da5aeebcb9caee9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a4cae25a673cdda949d83970decf81"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__var__types_ga71c705510643b752453ec4dbed687e86.html#ga71c705510643b752453ec4dbed687e86">require_any_var_vt</a>&lt; std::is_arithmetic, T1, T2 &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga75a77edba3f6fb2bd60267c7a9bdc08e.html#ga75a77edba3f6fb2bd60267c7a9bdc08e">require_any_arithmetic_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a88a4cae25a673cdda949d83970decf81"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a88a4cae25a673cdda949d83970decf81.html#a88a4cae25a673cdda949d83970decf81">subtract</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:a88a4cae25a673cdda949d83970decf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eef85281388cf99b5afc6b49fdfecc2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__var__types_gacf43b7e7d8793f9f9df153d953680032.html#gacf43b7e7d8793f9f9df153d953680032">require_all_var_vt</a>&lt; std::is_arithmetic, T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1eef85281388cf99b5afc6b49fdfecc2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1eef85281388cf99b5afc6b49fdfecc2.html#a1eef85281388cf99b5afc6b49fdfecc2">subtract</a> (const T1 &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:a1eef85281388cf99b5afc6b49fdfecc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3e70f96daccfcb40ded372a62fe24d"><td class="memTemplParams" colspan="2">template&lt;typename VarMat1 , typename VarMat2 , <a class="el" href="group__var__matrix__types_gaf9240f628acb5b6ce46e70cd20f93e0f.html#gaf9240f628acb5b6ce46e70cd20f93e0f">require_any_var_matrix_t</a>&lt; VarMat1, VarMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afc3e70f96daccfcb40ded372a62fe24d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afc3e70f96daccfcb40ded372a62fe24d.html#afc3e70f96daccfcb40ded372a62fe24d">operator-</a> (const VarMat1 &amp;a, const VarMat2 &amp;b)</td></tr>
<tr class="memdesc:afc3e70f96daccfcb40ded372a62fe24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Addition operator for matrix variables.  <br /></td></tr>
<tr class="separator:afc3e70f96daccfcb40ded372a62fe24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c470271d26e669b3570ff68ea80a9ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0c470271d26e669b3570ff68ea80a9ef.html#a0c470271d26e669b3570ff68ea80a9ef">operator--</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a0c470271d26e669b3570ff68ea80a9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix decrement operator for variables (C++).  <br /></td></tr>
<tr class="separator:a0c470271d26e669b3570ff68ea80a9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcadc96f506e9f1408647cdce4d09092"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abcadc96f506e9f1408647cdce4d09092.html#abcadc96f506e9f1408647cdce4d09092">operator--</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, int)</td></tr>
<tr class="memdesc:abcadc96f506e9f1408647cdce4d09092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix decrement operator for variables (C++).  <br /></td></tr>
<tr class="separator:abcadc96f506e9f1408647cdce4d09092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00f348bbb478aedeec0c5ffa88729091"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a00f348bbb478aedeec0c5ffa88729091.html#a00f348bbb478aedeec0c5ffa88729091">operator++</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a00f348bbb478aedeec0c5ffa88729091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prefix increment operator for variables (C++).  <br /></td></tr>
<tr class="separator:a00f348bbb478aedeec0c5ffa88729091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3597f71f364d94814268d4911f111674"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3597f71f364d94814268d4911f111674.html#a3597f71f364d94814268d4911f111674">operator++</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, int)</td></tr>
<tr class="memdesc:a3597f71f364d94814268d4911f111674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Postfix increment operator for variables (C++).  <br /></td></tr>
<tr class="separator:a3597f71f364d94814268d4911f111674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8564365599db5cea0b51b635ea482a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f8564365599db5cea0b51b635ea482a.html#a2f8564365599db5cea0b51b635ea482a">operator-</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a2f8564365599db5cea0b51b635ea482a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary negation operator for variables (C++).  <br /></td></tr>
<tr class="separator:a2f8564365599db5cea0b51b635ea482a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831e7a461560284293196bfb7a3d247a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a831e7a461560284293196bfb7a3d247a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a831e7a461560284293196bfb7a3d247a.html#a831e7a461560284293196bfb7a3d247a">operator-</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a831e7a461560284293196bfb7a3d247a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute additive inverse of input.  <br /></td></tr>
<tr class="separator:a831e7a461560284293196bfb7a3d247a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab717b1a12ae84baa53d6c38aefe13c49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab717b1a12ae84baa53d6c38aefe13c49.html#ab717b1a12ae84baa53d6c38aefe13c49">operator!</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:ab717b1a12ae84baa53d6c38aefe13c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the negation of the value of the argument as defined by <code>!</code>.  <br /></td></tr>
<tr class="separator:ab717b1a12ae84baa53d6c38aefe13c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f17a8253887d3b573fd59c5a4c6769"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a28f17a8253887d3b573fd59c5a4c6769.html#a28f17a8253887d3b573fd59c5a4c6769">operator+</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a28f17a8253887d3b573fd59c5a4c6769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary plus operator for variables (C++).  <br /></td></tr>
<tr class="separator:a28f17a8253887d3b573fd59c5a4c6769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93af44658d035b95d4d82e8db047b70"><td class="memTemplParams" colspan="2">template&lt;typename Arith , typename VecVar , typename VecArith , typename... ContainerOperands, typename... ContainerGradients&gt; </td></tr>
<tr class="memitem:ae93af44658d035b95d4d82e8db047b70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae93af44658d035b95d4d82e8db047b70.html#ae93af44658d035b95d4d82e8db047b70">precomputed_gradients</a> (Arith value, const VecVar &amp;operands, const VecArith &amp;gradients, const std::tuple&lt; ContainerOperands... &gt; &amp;container_operands=std::tuple&lt;&gt;(), const std::tuple&lt; ContainerGradients... &gt; &amp;container_gradients=std::tuple&lt;&gt;())</td></tr>
<tr class="memdesc:ae93af44658d035b95d4d82e8db047b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns a var for an expression that has the specified value, vector of operands, and vector of partial derivatives of value with respect to the operands.  <br /></td></tr>
<tr class="separator:ae93af44658d035b95d4d82e8db047b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0611cecb5356e187818c1901134c7665"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0611cecb5356e187818c1901134c7665.html#a0611cecb5356e187818c1901134c7665">print_stack</a> (std::ostream &amp;o)</td></tr>
<tr class="memdesc:a0611cecb5356e187818c1901134c7665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the autodiff variable stack.  <br /></td></tr>
<tr class="separator:a0611cecb5356e187818c1901134c7665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4341face977eceb2c8cdb2bac8d5ac00"><td class="memTemplParams" colspan="2">template&lt;typename EigVar , typename EigVari , typename EigDbl &gt; </td></tr>
<tr class="memitem:a4341face977eceb2c8cdb2bac8d5ac00"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4341face977eceb2c8cdb2bac8d5ac00.html#a4341face977eceb2c8cdb2bac8d5ac00">read_vi_val_adj</a> (const EigVar &amp;VarMat, EigVari &amp;VariMat, EigDbl &amp;ValMat, EigDbl &amp;AdjMat)</td></tr>
<tr class="memdesc:a4341face977eceb2c8cdb2bac8d5ac00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function applying the <a class="el" href="classstan_1_1math_1_1vi__val__adj__functor.html" title="Functor for extracting the vari*, values, and adjoints from a matrix of var.">vi_val_adj_functor</a> to extract the vari*, values, and adjoints of a given var matrix into separate matrices.  <br /></td></tr>
<tr class="separator:a4341face977eceb2c8cdb2bac8d5ac00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14fc20028e53ce0b51bc15f84bac57ea"><td class="memTemplParams" colspan="2">template&lt;typename EigRev , typename EigDbl &gt; </td></tr>
<tr class="memitem:a14fc20028e53ce0b51bc15f84bac57ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a14fc20028e53ce0b51bc15f84bac57ea.html#a14fc20028e53ce0b51bc15f84bac57ea">read_val_adj</a> (const EigRev &amp;VarMat, EigDbl &amp;ValMat, EigDbl &amp;AdjMat)</td></tr>
<tr class="memdesc:a14fc20028e53ce0b51bc15f84bac57ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function applying the <a class="el" href="classstan_1_1math_1_1val__adj__functor.html" title="Functor for extracting the values and adjoints from a matrix of var or vari.">val_adj_functor</a> to extract the values and adjoints of a given var or vari matrix into separate matrices.  <br /></td></tr>
<tr class="separator:a14fc20028e53ce0b51bc15f84bac57ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f7f51add356024c680a8bf95e79796"><td class="memTemplParams" colspan="2">template&lt;typename EigVar , typename EigVari , typename EigDbl &gt; </td></tr>
<tr class="memitem:a87f7f51add356024c680a8bf95e79796"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a87f7f51add356024c680a8bf95e79796.html#a87f7f51add356024c680a8bf95e79796">read_vi_val</a> (const EigVar &amp;VarMat, EigVari &amp;VariMat, EigDbl &amp;ValMat)</td></tr>
<tr class="memdesc:a87f7f51add356024c680a8bf95e79796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function applying the <a class="el" href="classstan_1_1math_1_1vi__val__functor.html" title="Functor for extracting the varis and values from a matrix of var.">vi_val_functor</a> to extract the varis and and values of a given var matrix into separate matrices.  <br /></td></tr>
<tr class="separator:a87f7f51add356024c680a8bf95e79796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af12d9a6dbf51074b656fcf1f0d416429"><td class="memTemplParams" colspan="2">template&lt;typename EigVar , typename EigVari , typename EigDbl &gt; </td></tr>
<tr class="memitem:af12d9a6dbf51074b656fcf1f0d416429"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af12d9a6dbf51074b656fcf1f0d416429.html#af12d9a6dbf51074b656fcf1f0d416429">read_vi_adj</a> (const EigVar &amp;VarMat, EigVari &amp;VariMat, EigDbl &amp;AdjMat)</td></tr>
<tr class="memdesc:af12d9a6dbf51074b656fcf1f0d416429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function applying the <a class="el" href="classstan_1_1math_1_1vi__adj__functor.html" title="Functor for extracting the varis and adjoints from a matrix of var.">vi_adj_functor</a> to extract the varis and and adjoints of a given var matrix into separate matrices.  <br /></td></tr>
<tr class="separator:af12d9a6dbf51074b656fcf1f0d416429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2cbb83ac9ef52296755690e61f4298"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afe2cbb83ac9ef52296755690e61f4298.html#afe2cbb83ac9ef52296755690e61f4298">recover_memory</a> ()</td></tr>
<tr class="memdesc:afe2cbb83ac9ef52296755690e61f4298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover memory used for all variables for reuse.  <br /></td></tr>
<tr class="separator:afe2cbb83ac9ef52296755690e61f4298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ebf2b2bc0f63dcb46a176b43e8b369a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8ebf2b2bc0f63dcb46a176b43e8b369a.html#a8ebf2b2bc0f63dcb46a176b43e8b369a">recover_memory_nested</a> ()</td></tr>
<tr class="memdesc:a8ebf2b2bc0f63dcb46a176b43e8b369a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recover only the memory used for the top nested call.  <br /></td></tr>
<tr class="separator:a8ebf2b2bc0f63dcb46a176b43e8b369a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc059c1f55cae403aba50db7866e80e"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a4dc059c1f55cae403aba50db7866e80e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4dc059c1f55cae403aba50db7866e80e.html#a4dc059c1f55cae403aba50db7866e80e">reverse_pass_callback</a> (F &amp;&amp;functor)</td></tr>
<tr class="memdesc:a4dc059c1f55cae403aba50db7866e80e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts a callback on the autodiff stack to be called in reverse pass.  <br /></td></tr>
<tr class="separator:a4dc059c1f55cae403aba50db7866e80e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e84a20bead947f253490be5f981b930"><td class="memTemplParams" colspan="2">template&lt;typename... Pargs&gt; </td></tr>
<tr class="memitem:a7e84a20bead947f253490be5f981b930"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7e84a20bead947f253490be5f981b930.html#a7e84a20bead947f253490be5f981b930">save_varis</a> (<a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **dest, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a7e84a20bead947f253490be5f981b930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the vari pointer in x into the memory pointed to by dest, increment the dest storage pointer, recursively call save_varis on the rest of the arguments, and return the final value of the dest storage pointer.  <br /></td></tr>
<tr class="separator:a7e84a20bead947f253490be5f981b930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072501534406f649504ac1bb4345d7ad"><td class="memTemplParams" colspan="2">template&lt;typename VarVec , <a class="el" href="group__std__vector__types_ga177ca10358abdf201cabb12e8bdb2e91.html#ga177ca10358abdf201cabb12e8bdb2e91">require_std_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, VarVec &gt; *  = nullptr, typename... Pargs&gt; </td></tr>
<tr class="memitem:a072501534406f649504ac1bb4345d7ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a072501534406f649504ac1bb4345d7ad.html#a072501534406f649504ac1bb4345d7ad">save_varis</a> (<a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **dest, VarVec &amp;&amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a072501534406f649504ac1bb4345d7ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the vari pointers in x into the memory pointed to by dest, increment the dest storage pointer, recursively call save_varis on the rest of the arguments, and return the final value of the dest storage pointer.  <br /></td></tr>
<tr class="separator:a072501534406f649504ac1bb4345d7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9d91d02eca52003754b2075250b9d4"><td class="memTemplParams" colspan="2">template&lt;typename VecContainer , <a class="el" href="group__std__vector__types_ga513b41fcdff562ebb8bc2cd5e3ea8faa.html#ga513b41fcdff562ebb8bc2cd5e3ea8faa">require_std_vector_st</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, VecContainer &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga177ca10358abdf201cabb12e8bdb2e91.html#ga177ca10358abdf201cabb12e8bdb2e91">require_std_vector_vt</a>&lt; <a class="el" href="namespacestan_a1e806f60387beb53da953bd393e8b1cb.html#a1e806f60387beb53da953bd393e8b1cb">is_container</a>, VecContainer &gt; *  = nullptr, typename... Pargs&gt; </td></tr>
<tr class="memitem:a3b9d91d02eca52003754b2075250b9d4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3b9d91d02eca52003754b2075250b9d4.html#a3b9d91d02eca52003754b2075250b9d4">save_varis</a> (<a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **dest, VecContainer &amp;&amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3b9d91d02eca52003754b2075250b9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the vari pointers in x into the memory pointed to by dest, increment the dest storage pointer, recursively call save_varis on the rest of the arguments, and return the final value of the dest storage pointer.  <br /></td></tr>
<tr class="separator:a3b9d91d02eca52003754b2075250b9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276f79c8325dff8c887a438ffdb184d1"><td class="memTemplParams" colspan="2">template&lt;typename EigT , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, EigT &gt; *  = nullptr, typename... Pargs&gt; </td></tr>
<tr class="memitem:a276f79c8325dff8c887a438ffdb184d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a276f79c8325dff8c887a438ffdb184d1.html#a276f79c8325dff8c887a438ffdb184d1">save_varis</a> (<a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **dest, EigT &amp;&amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:a276f79c8325dff8c887a438ffdb184d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save the vari pointers in x into the memory pointed to by dest, increment the dest storage pointer, recursively call save_varis on the rest of the arguments, and return the final value of the dest storage pointer.  <br /></td></tr>
<tr class="separator:a276f79c8325dff8c887a438ffdb184d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb47f7357ee2c4b35c9be30c07bf6497"><td class="memTemplParams" colspan="2">template&lt;typename Arith , <a class="el" href="group__arithmetic__types_ga948d431ec5773ff848a6bfa0d0b7aa79.html#ga948d431ec5773ff848a6bfa0d0b7aa79">require_st_arithmetic</a>&lt; Arith &gt; *  = nullptr, typename... Pargs&gt; </td></tr>
<tr class="memitem:abb47f7357ee2c4b35c9be30c07bf6497"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abb47f7357ee2c4b35c9be30c07bf6497.html#abb47f7357ee2c4b35c9be30c07bf6497">save_varis</a> (<a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **dest, Arith &amp;&amp;x, Pargs &amp;&amp;... args)</td></tr>
<tr class="memdesc:abb47f7357ee2c4b35c9be30c07bf6497"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore arithmetic types.  <br /></td></tr>
<tr class="separator:abb47f7357ee2c4b35c9be30c07bf6497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafeadb090e8d2409aebe7f25ea43b669"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aafeadb090e8d2409aebe7f25ea43b669.html#aafeadb090e8d2409aebe7f25ea43b669">save_varis</a> (<a class="el" href="namespacestan_1_1math_a61ee1c81e14d0a137cfd8bc8f1ddac46.html#a61ee1c81e14d0a137cfd8bc8f1ddac46">vari</a> **dest)</td></tr>
<tr class="memdesc:aafeadb090e8d2409aebe7f25ea43b669"><td class="mdescLeft">&#160;</td><td class="mdescRight">End save_varis recursion and return pointer.  <br /></td></tr>
<tr class="separator:aafeadb090e8d2409aebe7f25ea43b669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9614efc6fd66533b74b43ddb69f21d3b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9614efc6fd66533b74b43ddb69f21d3b.html#a9614efc6fd66533b74b43ddb69f21d3b">set_zero_all_adjoints</a> ()</td></tr>
<tr class="memdesc:a9614efc6fd66533b74b43ddb69f21d3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all adjoint values in the stack to zero.  <br /></td></tr>
<tr class="separator:a9614efc6fd66533b74b43ddb69f21d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13a9b09e0bebb14eb30f3c78a95a160"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af13a9b09e0bebb14eb30f3c78a95a160.html#af13a9b09e0bebb14eb30f3c78a95a160">set_zero_all_adjoints_nested</a> ()</td></tr>
<tr class="memdesc:af13a9b09e0bebb14eb30f3c78a95a160"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset all adjoint values in the top nested portion of the stack to zero.  <br /></td></tr>
<tr class="separator:af13a9b09e0bebb14eb30f3c78a95a160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a72c89ed9143a7760cc3611e8a0df0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad4a72c89ed9143a7760cc3611e8a0df0.html#ad4a72c89ed9143a7760cc3611e8a0df0">start_nested</a> ()</td></tr>
<tr class="memdesc:ad4a72c89ed9143a7760cc3611e8a0df0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record the current position so that <code><a class="el" href="namespacestan_1_1math_a8ebf2b2bc0f63dcb46a176b43e8b369a.html#a8ebf2b2bc0f63dcb46a176b43e8b369a" title="Recover only the memory used for the top nested call.">recover_memory_nested()</a></code> can find it.  <br /></td></tr>
<tr class="separator:ad4a72c89ed9143a7760cc3611e8a0df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4214c4dd4dc198260d7f4f7fbb8b9fdd"><td class="memTemplParams" colspan="2">template&lt;typename Vari &gt; </td></tr>
<tr class="memitem:a4214c4dd4dc198260d7f4f7fbb8b9fdd"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4214c4dd4dc198260d7f4f7fbb8b9fdd.html#a4214c4dd4dc198260d7f4f7fbb8b9fdd">grad</a> (Vari *vi)</td></tr>
<tr class="separator:a4214c4dd4dc198260d7f4f7fbb8b9fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30b0c1ce970b016f402e0a370b6a241"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab30b0c1ce970b016f402e0a370b6a241.html#ab30b0c1ce970b016f402e0a370b6a241">zero_adjoints</a> () noexcept</td></tr>
<tr class="memdesc:ab30b0c1ce970b016f402e0a370b6a241"><td class="mdescLeft">&#160;</td><td class="mdescRight">End of recursion for set_zero_adjoints.  <br /></td></tr>
<tr class="separator:ab30b0c1ce970b016f402e0a370b6a241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8e17af2ce48578b81e3201c6da82a5"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga948d431ec5773ff848a6bfa0d0b7aa79.html#ga948d431ec5773ff848a6bfa0d0b7aa79">require_st_arithmetic</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aff8e17af2ce48578b81e3201c6da82a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aff8e17af2ce48578b81e3201c6da82a5.html#aff8e17af2ce48578b81e3201c6da82a5">zero_adjoints</a> (T &amp;x) noexcept</td></tr>
<tr class="memdesc:aff8e17af2ce48578b81e3201c6da82a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do nothing for non-autodiff arguments.  <br /></td></tr>
<tr class="separator:aff8e17af2ce48578b81e3201c6da82a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cece872da916ec03174b9e8e22fe62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a56cece872da916ec03174b9e8e22fe62.html#a56cece872da916ec03174b9e8e22fe62">zero_adjoints</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:a56cece872da916ec03174b9e8e22fe62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero the adjoint of the vari in the first argument.  <br /></td></tr>
<tr class="separator:a56cece872da916ec03174b9e8e22fe62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9022171a124c032600bce2e8049f90"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:afa9022171a124c032600bce2e8049f90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afa9022171a124c032600bce2e8049f90.html#afa9022171a124c032600bce2e8049f90">zero_adjoints</a> (EigMat &amp;x)</td></tr>
<tr class="memdesc:afa9022171a124c032600bce2e8049f90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero the adjoints of the varis of every var in an Eigen::Matrix container.  <br /></td></tr>
<tr class="separator:afa9022171a124c032600bce2e8049f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac46b243e111d00fc750af22fab1f63c"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , <a class="el" href="group__std__vector__types_ga513b41fcdff562ebb8bc2cd5e3ea8faa.html#ga513b41fcdff562ebb8bc2cd5e3ea8faa">require_std_vector_st</a>&lt; <a class="el" href="structstan_1_1is__autodiff.html">is_autodiff</a>, StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aac46b243e111d00fc750af22fab1f63c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aac46b243e111d00fc750af22fab1f63c.html#aac46b243e111d00fc750af22fab1f63c">zero_adjoints</a> (StdVec &amp;x)</td></tr>
<tr class="memdesc:aac46b243e111d00fc750af22fab1f63c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zero the adjoints of every element in a vector.  <br /></td></tr>
<tr class="separator:aac46b243e111d00fc750af22fab1f63c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7015d07b6fbf056e698dc488e058312a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7015d07b6fbf056e698dc488e058312a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7015d07b6fbf056e698dc488e058312a.html#a7015d07b6fbf056e698dc488e058312a">abs</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a7015d07b6fbf056e698dc488e058312a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute value of the variable (std).  <br /></td></tr>
<tr class="separator:a7015d07b6fbf056e698dc488e058312a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fc35f4bfa8535e57f0133ce755495b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af3fc35f4bfa8535e57f0133ce755495b.html#af3fc35f4bfa8535e57f0133ce755495b">abs</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:af3fc35f4bfa8535e57f0133ce755495b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute value of the complex argument.  <br /></td></tr>
<tr class="separator:af3fc35f4bfa8535e57f0133ce755495b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452d936de09ce7e61947d1df602f8ff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a452d936de09ce7e61947d1df602f8ff9.html#a452d936de09ce7e61947d1df602f8ff9">acos</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:a452d936de09ce7e61947d1df602f8ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc cosine of a variable, in radians (cmath).  <br /></td></tr>
<tr class="separator:a452d936de09ce7e61947d1df602f8ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cb02fb2a6866205d81601d6507e22f"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a44cb02fb2a6866205d81601d6507e22f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a44cb02fb2a6866205d81601d6507e22f.html#a44cb02fb2a6866205d81601d6507e22f">acos</a> (const VarMat &amp;x)</td></tr>
<tr class="memdesc:a44cb02fb2a6866205d81601d6507e22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc cosine of a variable, in radians (cmath).  <br /></td></tr>
<tr class="separator:a44cb02fb2a6866205d81601d6507e22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3c179bcab8b60e91b059a6678bd695"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9f3c179bcab8b60e91b059a6678bd695.html#a9f3c179bcab8b60e91b059a6678bd695">acos</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a9f3c179bcab8b60e91b059a6678bd695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arc cosine of the complex argument.  <br /></td></tr>
<tr class="separator:a9f3c179bcab8b60e91b059a6678bd695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11bec2bf17b6d752058352e5631d56df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a11bec2bf17b6d752058352e5631d56df.html#a11bec2bf17b6d752058352e5631d56df">acosh</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:a11bec2bf17b6d752058352e5631d56df"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse hyperbolic cosine function for variables (C99).  <br /></td></tr>
<tr class="separator:a11bec2bf17b6d752058352e5631d56df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68492f7471c3d37e33a1d2f8a2eee400"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a68492f7471c3d37e33a1d2f8a2eee400"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a68492f7471c3d37e33a1d2f8a2eee400.html#a68492f7471c3d37e33a1d2f8a2eee400">acosh</a> (const VarMat &amp;x)</td></tr>
<tr class="memdesc:a68492f7471c3d37e33a1d2f8a2eee400"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse hyperbolic cosine function for variables (C99).  <br /></td></tr>
<tr class="separator:a68492f7471c3d37e33a1d2f8a2eee400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2991919fad67beea9c1b370dab5a55"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0c2991919fad67beea9c1b370dab5a55.html#a0c2991919fad67beea9c1b370dab5a55">acosh</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a0c2991919fad67beea9c1b370dab5a55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arc cosine of the complex argument.  <br /></td></tr>
<tr class="separator:a0c2991919fad67beea9c1b370dab5a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dede17fb191d7679baa7f14a2162f17"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__types_gab0d7285b1a3ce33eb11e113827345d30.html#gab0d7285b1a3ce33eb11e113827345d30">require_var_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4dede17fb191d7679baa7f14a2162f17"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4dede17fb191d7679baa7f14a2162f17.html#a4dede17fb191d7679baa7f14a2162f17">adjoint_of</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a4dede17fb191d7679baa7f14a2162f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to a variable's adjoint.  <br /></td></tr>
<tr class="separator:a4dede17fb191d7679baa7f14a2162f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20ad62aad9415282c6c5ed73cf1cb35"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__types_ga202c72c7f8418f766eeb3e013a43e25c.html#ga202c72c7f8418f766eeb3e013a43e25c">require_not_var_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae20ad62aad9415282c6c5ed73cf1cb35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structstan_1_1math_1_1internal_1_1nonexisting__adjoint.html">internal::nonexisting_adjoint</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae20ad62aad9415282c6c5ed73cf1cb35.html#ae20ad62aad9415282c6c5ed73cf1cb35">adjoint_of</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae20ad62aad9415282c6c5ed73cf1cb35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to a variable's adjoint.  <br /></td></tr>
<tr class="separator:ae20ad62aad9415282c6c5ed73cf1cb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbd9cac64e5f2313e80b0727925f465"><td class="memTemplParams" colspan="2">template&lt;typename Scal , typename RowVec , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal &gt; *  = nullptr, <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__row__vector.html">is_eigen_row_vector</a>&lt; RowVec &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9cbd9cac64e5f2313e80b0727925f465"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9cbd9cac64e5f2313e80b0727925f465.html#a9cbd9cac64e5f2313e80b0727925f465">append_col</a> (const Scal &amp;A, const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; RowVec &gt; &amp;B)</td></tr>
<tr class="memdesc:a9cbd9cac64e5f2313e80b0727925f465"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking an scalar on top of the a row vector, with the result being a row vector.  <br /></td></tr>
<tr class="separator:a9cbd9cac64e5f2313e80b0727925f465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7a84898549554f6cb29891fb101124"><td class="memTemplParams" colspan="2">template&lt;typename RowVec , typename Scal , <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__row__vector.html">is_eigen_row_vector</a>&lt; RowVec &gt; &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ade7a84898549554f6cb29891fb101124"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade7a84898549554f6cb29891fb101124.html#ade7a84898549554f6cb29891fb101124">append_col</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; RowVec &gt; &amp;A, const Scal &amp;B)</td></tr>
<tr class="memdesc:ade7a84898549554f6cb29891fb101124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking a row vector on top of the an scalar, with the result being a row vector.  <br /></td></tr>
<tr class="separator:ade7a84898549554f6cb29891fb101124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad660d3112fe327c0b7d95bc858d6576f"><td class="memTemplParams" colspan="2">template&lt;typename Scal , typename ColVec , <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal &gt; *  = nullptr, <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__col__vector.html">is_eigen_col_vector</a>&lt; ColVec &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad660d3112fe327c0b7d95bc858d6576f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad660d3112fe327c0b7d95bc858d6576f.html#ad660d3112fe327c0b7d95bc858d6576f">append_row</a> (const Scal &amp;A, const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; ColVec &gt; &amp;B)</td></tr>
<tr class="memdesc:ad660d3112fe327c0b7d95bc858d6576f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking an scalar on top of the a vector, with the result being a vector.  <br /></td></tr>
<tr class="separator:ad660d3112fe327c0b7d95bc858d6576f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a0a585b24edd041aa2956eeb9c035f"><td class="memTemplParams" colspan="2">template&lt;typename ColVec , typename Scal , <a class="el" href="namespacestan_ad93583561a7a3642b498cf2b059d29c0.html#ad93583561a7a3642b498cf2b059d29c0">require_t</a>&lt; <a class="el" href="structstan_1_1is__eigen__col__vector.html">is_eigen_col_vector</a>&lt; ColVec &gt; &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad6a0a585b24edd041aa2956eeb9c035f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad6a0a585b24edd041aa2956eeb9c035f.html#ad6a0a585b24edd041aa2956eeb9c035f">append_row</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; ColVec &gt; &amp;A, const Scal &amp;B)</td></tr>
<tr class="memdesc:ad6a0a585b24edd041aa2956eeb9c035f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the result of stacking a vector on top of the an scalar, with the result being a vector.  <br /></td></tr>
<tr class="separator:ad6a0a585b24edd041aa2956eeb9c035f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70e91a492cd24ca0ac5f1c703fd5b66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad70e91a492cd24ca0ac5f1c703fd5b66.html#ad70e91a492cd24ca0ac5f1c703fd5b66">arg</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:ad70e91a492cd24ca0ac5f1c703fd5b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the phase angle of the complex argument.  <br /></td></tr>
<tr class="separator:ad70e91a492cd24ca0ac5f1c703fd5b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d46a5116bd20a9b1cf228d018ae8aec"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3d46a5116bd20a9b1cf228d018ae8aec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3d46a5116bd20a9b1cf228d018ae8aec.html#a3d46a5116bd20a9b1cf228d018ae8aec">as_array_or_scalar</a> (T &amp;&amp;v)</td></tr>
<tr class="memdesc:a3d46a5116bd20a9b1cf228d018ae8aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;T&gt;</code> with inner <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix type to an <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;T&gt;</code> with an inner array.  <br /></td></tr>
<tr class="separator:a3d46a5116bd20a9b1cf228d018ae8aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ad9c5e9f0b2f99b96133ad7a158f64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab7ad9c5e9f0b2f99b96133ad7a158f64.html#ab7ad9c5e9f0b2f99b96133ad7a158f64">as_bool</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;v)</td></tr>
<tr class="memdesc:ab7ad9c5e9f0b2f99b96133ad7a158f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return 1 if the argument is unequal to zero and 0 otherwise.  <br /></td></tr>
<tr class="separator:ab7ad9c5e9f0b2f99b96133ad7a158f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f6a9290da4c24198ef67f71a73f289"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af6f6a9290da4c24198ef67f71a73f289.html#af6f6a9290da4c24198ef67f71a73f289">asin</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:af6f6a9290da4c24198ef67f71a73f289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc sine, in radians, of the specified variable (cmath).  <br /></td></tr>
<tr class="separator:af6f6a9290da4c24198ef67f71a73f289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568c5b444b0d1797a72524c733c6563d"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a568c5b444b0d1797a72524c733c6563d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a568c5b444b0d1797a72524c733c6563d.html#a568c5b444b0d1797a72524c733c6563d">asin</a> (const VarMat &amp;x)</td></tr>
<tr class="memdesc:a568c5b444b0d1797a72524c733c6563d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc sine, in radians, of the specified variable (cmath).  <br /></td></tr>
<tr class="separator:a568c5b444b0d1797a72524c733c6563d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c56c09fd05b3936141b5f8434b70e6"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a36c56c09fd05b3936141b5f8434b70e6.html#a36c56c09fd05b3936141b5f8434b70e6">asin</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a36c56c09fd05b3936141b5f8434b70e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arc sine of the complex argument.  <br /></td></tr>
<tr class="separator:a36c56c09fd05b3936141b5f8434b70e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83135599ea6bdaea64207222b04dac4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af83135599ea6bdaea64207222b04dac4.html#af83135599ea6bdaea64207222b04dac4">asinh</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:af83135599ea6bdaea64207222b04dac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse hyperbolic sine function for variables (C99).  <br /></td></tr>
<tr class="separator:af83135599ea6bdaea64207222b04dac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66a25e30a93e06a14c230e0a2eeb5eb"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa66a25e30a93e06a14c230e0a2eeb5eb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa66a25e30a93e06a14c230e0a2eeb5eb.html#aa66a25e30a93e06a14c230e0a2eeb5eb">asinh</a> (const VarMat &amp;x)</td></tr>
<tr class="memdesc:aa66a25e30a93e06a14c230e0a2eeb5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse hyperbolic sine function for variables (C99).  <br /></td></tr>
<tr class="separator:aa66a25e30a93e06a14c230e0a2eeb5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada59239e9d8daf6eef860adb4d310b53"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ada59239e9d8daf6eef860adb4d310b53.html#ada59239e9d8daf6eef860adb4d310b53">asinh</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:ada59239e9d8daf6eef860adb4d310b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arcsine of the complex argument.  <br /></td></tr>
<tr class="separator:ada59239e9d8daf6eef860adb4d310b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3fe8de80841fbcb9cfcf4c9cc4a9e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9d3fe8de80841fbcb9cfcf4c9cc4a9e5.html#a9d3fe8de80841fbcb9cfcf4c9cc4a9e5">atan</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:a9d3fe8de80841fbcb9cfcf4c9cc4a9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc tangent, in radians, of the specified variable (cmath).  <br /></td></tr>
<tr class="separator:a9d3fe8de80841fbcb9cfcf4c9cc4a9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523bc6c4084ecef288e5d0b235394fab"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a523bc6c4084ecef288e5d0b235394fab"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a523bc6c4084ecef288e5d0b235394fab.html#a523bc6c4084ecef288e5d0b235394fab">atan</a> (const VarMat &amp;x)</td></tr>
<tr class="memdesc:a523bc6c4084ecef288e5d0b235394fab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc tangent, in radians, of the specified variable (cmath).  <br /></td></tr>
<tr class="separator:a523bc6c4084ecef288e5d0b235394fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81f50894d9558dcaaa0e73cbcd424a7"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad81f50894d9558dcaaa0e73cbcd424a7.html#ad81f50894d9558dcaaa0e73cbcd424a7">atan</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:ad81f50894d9558dcaaa0e73cbcd424a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the arc tangent of the complex argument.  <br /></td></tr>
<tr class="separator:ad81f50894d9558dcaaa0e73cbcd424a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fe21eb929346e553266ceda0a97f23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a32fe21eb929346e553266ceda0a97f23.html#a32fe21eb929346e553266ceda0a97f23">atan2</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a32fe21eb929346e553266ceda0a97f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc tangent, in radians, of the first variable divided by the second (cmath).  <br /></td></tr>
<tr class="separator:a32fe21eb929346e553266ceda0a97f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260938b6b224e8d716009cc1565e8b5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a260938b6b224e8d716009cc1565e8b5e.html#a260938b6b224e8d716009cc1565e8b5e">atan2</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:a260938b6b224e8d716009cc1565e8b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc tangent, in radians, of the first variable divided by the second scalar (cmath).  <br /></td></tr>
<tr class="separator:a260938b6b224e8d716009cc1565e8b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94ca3039c321bf8a1016205d7916755"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa94ca3039c321bf8a1016205d7916755.html#aa94ca3039c321bf8a1016205d7916755">atan2</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:aa94ca3039c321bf8a1016205d7916755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the principal value of the arc tangent, in radians, of the first scalar divided by the second variable (cmath).  <br /></td></tr>
<tr class="separator:aa94ca3039c321bf8a1016205d7916755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499287dcc127c1df566eda6e967fc6c2"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , <a class="el" href="group__var__matrix__types_gaf9240f628acb5b6ce46e70cd20f93e0f.html#gaf9240f628acb5b6ce46e70cd20f93e0f">require_any_var_matrix_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a499287dcc127c1df566eda6e967fc6c2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a499287dcc127c1df566eda6e967fc6c2.html#a499287dcc127c1df566eda6e967fc6c2">atan2</a> (const Mat1 &amp;a, const Mat2 &amp;b)</td></tr>
<tr class="separator:a499287dcc127c1df566eda6e967fc6c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab1e38d95a63b7b3978eec2c9a3265b"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename VarMat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scalar &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6ab1e38d95a63b7b3978eec2c9a3265b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6ab1e38d95a63b7b3978eec2c9a3265b.html#a6ab1e38d95a63b7b3978eec2c9a3265b">atan2</a> (const Scalar &amp;a, const VarMat &amp;b)</td></tr>
<tr class="separator:a6ab1e38d95a63b7b3978eec2c9a3265b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97999e61a56ecd7ce84b934b3fbe9a25"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , typename Scalar , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scalar &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a97999e61a56ecd7ce84b934b3fbe9a25"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a97999e61a56ecd7ce84b934b3fbe9a25.html#a97999e61a56ecd7ce84b934b3fbe9a25">atan2</a> (const VarMat &amp;a, const Scalar &amp;b)</td></tr>
<tr class="separator:a97999e61a56ecd7ce84b934b3fbe9a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1c841ccce06838813d1edf07ee5640"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aac1c841ccce06838813d1edf07ee5640.html#aac1c841ccce06838813d1edf07ee5640">atanh</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:aac1c841ccce06838813d1edf07ee5640"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse hyperbolic tangent function for variables (C99).  <br /></td></tr>
<tr class="separator:aac1c841ccce06838813d1edf07ee5640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d1fbda2e50f154c081d190d221af94"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad7d1fbda2e50f154c081d190d221af94"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad7d1fbda2e50f154c081d190d221af94.html#ad7d1fbda2e50f154c081d190d221af94">atanh</a> (const VarMat &amp;x)</td></tr>
<tr class="memdesc:ad7d1fbda2e50f154c081d190d221af94"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse hyperbolic tangent function for variables (C99).  <br /></td></tr>
<tr class="separator:ad7d1fbda2e50f154c081d190d221af94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a419469ad9374e6eaa05436b85415b9bd"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a419469ad9374e6eaa05436b85415b9bd.html#a419469ad9374e6eaa05436b85415b9bd">atanh</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a419469ad9374e6eaa05436b85415b9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic arc tangent of the complex argument.  <br /></td></tr>
<tr class="separator:a419469ad9374e6eaa05436b85415b9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672ae58515af44d6b87f2a79c3214643"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a672ae58515af44d6b87f2a79c3214643.html#a672ae58515af44d6b87f2a79c3214643">bessel_first_kind</a> (int v, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="separator:a672ae58515af44d6b87f2a79c3214643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8b4801e57f41aad94ddce92bd1c311"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__integral__types_ga8d10ea9813909bf7fc1a2394e880165a.html#ga8d10ea9813909bf7fc1a2394e880165a">require_st_integral</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4c8b4801e57f41aad94ddce92bd1c311"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4c8b4801e57f41aad94ddce92bd1c311.html#a4c8b4801e57f41aad94ddce92bd1c311">bessel_first_kind</a> (const T1 &amp;v, const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T2 &gt; &amp;a)</td></tr>
<tr class="memdesc:a4c8b4801e57f41aad94ddce92bd1c311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload with <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Matrix&gt;</code> for <code>int</code>, <code>std::vector&lt;int&gt;</code>, and <code>std::vector&lt;std::vector&lt;int&gt;&gt;</code>  <br /></td></tr>
<tr class="separator:a4c8b4801e57f41aad94ddce92bd1c311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177d5e3051911f4e1026c6b149429f7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a177d5e3051911f4e1026c6b149429f7c.html#a177d5e3051911f4e1026c6b149429f7c">bessel_second_kind</a> (int v, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="separator:a177d5e3051911f4e1026c6b149429f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeab71635eacc084b6ad39f1c79eb8cd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__integral__types_ga8d10ea9813909bf7fc1a2394e880165a.html#ga8d10ea9813909bf7fc1a2394e880165a">require_st_integral</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adeab71635eacc084b6ad39f1c79eb8cd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adeab71635eacc084b6ad39f1c79eb8cd.html#adeab71635eacc084b6ad39f1c79eb8cd">bessel_second_kind</a> (const T1 &amp;v, const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T2 &gt; &amp;a)</td></tr>
<tr class="memdesc:adeab71635eacc084b6ad39f1c79eb8cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload with <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Matrix&gt;</code> for <code>int</code>, <code>std::vector&lt;int&gt;</code>, and <code>std::vector&lt;std::vector&lt;int&gt;&gt;</code>  <br /></td></tr>
<tr class="separator:adeab71635eacc084b6ad39f1c79eb8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ad6c84ed9eb7db1dbf16ea7f2d062c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af9ad6c84ed9eb7db1dbf16ea7f2d062c.html#af9ad6c84ed9eb7db1dbf16ea7f2d062c">beta</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:af9ad6c84ed9eb7db1dbf16ea7f2d062c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the beta function and gradients for two var inputs.  <br /></td></tr>
<tr class="separator:af9ad6c84ed9eb7db1dbf16ea7f2d062c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd299594f5fcb21d39e81a0bf683f32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9bd299594f5fcb21d39e81a0bf683f32.html#a9bd299594f5fcb21d39e81a0bf683f32">beta</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:a9bd299594f5fcb21d39e81a0bf683f32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the beta function and gradient for first var input.  <br /></td></tr>
<tr class="separator:a9bd299594f5fcb21d39e81a0bf683f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0fa658c9e944079a4b2fd6c05193b9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab0fa658c9e944079a4b2fd6c05193b9b.html#ab0fa658c9e944079a4b2fd6c05193b9b">beta</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:ab0fa658c9e944079a4b2fd6c05193b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the beta function and gradient for second var input.  <br /></td></tr>
<tr class="separator:ab0fa658c9e944079a4b2fd6c05193b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade4d9718c0d8aac113f17c5fb9076d1c"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , <a class="el" href="group__var__matrix__types_gaf9240f628acb5b6ce46e70cd20f93e0f.html#gaf9240f628acb5b6ce46e70cd20f93e0f">require_any_var_matrix_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ade4d9718c0d8aac113f17c5fb9076d1c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade4d9718c0d8aac113f17c5fb9076d1c.html#ade4d9718c0d8aac113f17c5fb9076d1c">beta</a> (const Mat1 &amp;a, const Mat2 &amp;b)</td></tr>
<tr class="separator:ade4d9718c0d8aac113f17c5fb9076d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47869482e60d5fc710f07772f7a13da3"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename VarMat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scalar &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a47869482e60d5fc710f07772f7a13da3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a47869482e60d5fc710f07772f7a13da3.html#a47869482e60d5fc710f07772f7a13da3">beta</a> (const Scalar &amp;a, const VarMat &amp;b)</td></tr>
<tr class="separator:a47869482e60d5fc710f07772f7a13da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddea87563c2388f31b28e658ea645a5"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , typename Scalar , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scalar &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8ddea87563c2388f31b28e658ea645a5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8ddea87563c2388f31b28e658ea645a5.html#a8ddea87563c2388f31b28e658ea645a5">beta</a> (const VarMat &amp;a, const Scalar &amp;b)</td></tr>
<tr class="separator:a8ddea87563c2388f31b28e658ea645a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74d44d3337b9f550cd4c666275f0bd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac74d44d3337b9f550cd4c666275f0bd1.html#ac74d44d3337b9f550cd4c666275f0bd1">binary_log_loss</a> (int y, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y_hat)</td></tr>
<tr class="memdesc:ac74d44d3337b9f550cd4c666275f0bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log loss function for variables (stan).  <br /></td></tr>
<tr class="separator:ac74d44d3337b9f550cd4c666275f0bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa534ce67ec8e13fd16ea1add472a7ef3"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa534ce67ec8e13fd16ea1add472a7ef3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa534ce67ec8e13fd16ea1add472a7ef3.html#aa534ce67ec8e13fd16ea1add472a7ef3">binary_log_loss</a> (int y, const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Mat &gt; &amp;y_hat)</td></tr>
<tr class="memdesc:aa534ce67ec8e13fd16ea1add472a7ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload with <code>int</code> and <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Matrix&gt;</code>  <br /></td></tr>
<tr class="separator:aa534ce67ec8e13fd16ea1add472a7ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b2981ccfb32024a759f8ca014b5ca45"><td class="memTemplParams" colspan="2">template&lt;typename StdVec , typename Mat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__integral__types_ga8d10ea9813909bf7fc1a2394e880165a.html#ga8d10ea9813909bf7fc1a2394e880165a">require_st_integral</a>&lt; StdVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4b2981ccfb32024a759f8ca014b5ca45"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4b2981ccfb32024a759f8ca014b5ca45.html#a4b2981ccfb32024a759f8ca014b5ca45">binary_log_loss</a> (const StdVec &amp;y, const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Mat &gt; &amp;y_hat)</td></tr>
<tr class="memdesc:a4b2981ccfb32024a759f8ca014b5ca45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload with <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Matrix&gt;</code> for <code>std::vector&lt;int&gt;</code> and <code>std::vector&lt;std::vector&lt;int&gt;&gt;</code>  <br /></td></tr>
<tr class="separator:a4b2981ccfb32024a759f8ca014b5ca45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a865962fcd8998de077f4a77b0a4ffa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2a865962fcd8998de077f4a77b0a4ffa.html#a2a865962fcd8998de077f4a77b0a4ffa">cbrt</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a2a865962fcd8998de077f4a77b0a4ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cube root of the specified variable (C99).  <br /></td></tr>
<tr class="separator:a2a865962fcd8998de077f4a77b0a4ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad75cfa4b59a3fb5701df679bc65c9a6d"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad75cfa4b59a3fb5701df679bc65c9a6d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad75cfa4b59a3fb5701df679bc65c9a6d.html#ad75cfa4b59a3fb5701df679bc65c9a6d">cbrt</a> (const VarMat &amp;a)</td></tr>
<tr class="memdesc:ad75cfa4b59a3fb5701df679bc65c9a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the cube root of the specified variable (C99).  <br /></td></tr>
<tr class="separator:ad75cfa4b59a3fb5701df679bc65c9a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e924d5a6c94f7593056b5cb1324b66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a06e924d5a6c94f7593056b5cb1324b66.html#a06e924d5a6c94f7593056b5cb1324b66">ceil</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a06e924d5a6c94f7593056b5cb1324b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the ceiling of the specified variable (cmath).  <br /></td></tr>
<tr class="separator:a06e924d5a6c94f7593056b5cb1324b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31addc53acacbe7505d4e0064a75e1c9"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a31addc53acacbe7505d4e0064a75e1c9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a31addc53acacbe7505d4e0064a75e1c9.html#a31addc53acacbe7505d4e0064a75e1c9">ceil</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a31addc53acacbe7505d4e0064a75e1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22a6e2c3240be231212b1b5902fe326"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac22a6e2c3240be231212b1b5902fe326"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac22a6e2c3240be231212b1b5902fe326.html#ac22a6e2c3240be231212b1b5902fe326">cholesky_decompose</a> (const EigMat &amp;A)</td></tr>
<tr class="memdesc:ac22a6e2c3240be231212b1b5902fe326"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse mode specialization of cholesky decomposition.  <br /></td></tr>
<tr class="separator:ac22a6e2c3240be231212b1b5902fe326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbc2836f96079ddd0512b75176d90ac"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abfbc2836f96079ddd0512b75176d90ac"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abfbc2836f96079ddd0512b75176d90ac.html#abfbc2836f96079ddd0512b75176d90ac">cholesky_decompose</a> (const T &amp;A)</td></tr>
<tr class="memdesc:abfbc2836f96079ddd0512b75176d90ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse mode specialization of Cholesky decomposition.  <br /></td></tr>
<tr class="separator:abfbc2836f96079ddd0512b75176d90ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bea59f00793e29f83f28644694dfa32"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_gaf9240f628acb5b6ce46e70cd20f93e0f.html#gaf9240f628acb5b6ce46e70cd20f93e0f">require_any_var_matrix_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8bea59f00793e29f83f28644694dfa32"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8bea59f00793e29f83f28644694dfa32.html#a8bea59f00793e29f83f28644694dfa32">columns_dot_product</a> (const Mat1 &amp;v1, const Mat2 &amp;v2)</td></tr>
<tr class="memdesc:a8bea59f00793e29f83f28644694dfa32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of columns of the specified matrices.  <br /></td></tr>
<tr class="separator:a8bea59f00793e29f83f28644694dfa32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ac0ed43bf6bace33025fd343162fb9"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a40ac0ed43bf6bace33025fd343162fb9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, 1, Mat::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a40ac0ed43bf6bace33025fd343162fb9.html#a40ac0ed43bf6bace33025fd343162fb9">columns_dot_self</a> (const Mat &amp;x)</td></tr>
<tr class="memdesc:a40ac0ed43bf6bace33025fd343162fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each column of a matrix with itself.  <br /></td></tr>
<tr class="separator:a40ac0ed43bf6bace33025fd343162fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0c737773c400e5315224a35d814b87"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9e0c737773c400e5315224a35d814b87"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9e0c737773c400e5315224a35d814b87.html#a9e0c737773c400e5315224a35d814b87">columns_dot_self</a> (const Mat &amp;x)</td></tr>
<tr class="memdesc:a9e0c737773c400e5315224a35d814b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each column of a matrix with itself.  <br /></td></tr>
<tr class="separator:a9e0c737773c400e5315224a35d814b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c4c759177557c050cbdaaf311c20cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af8c4c759177557c050cbdaaf311c20cc.html#af8c4c759177557c050cbdaaf311c20cc">cos</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> a)</td></tr>
<tr class="memdesc:af8c4c759177557c050cbdaaf311c20cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cosine of a radian-scaled variable (cmath).  <br /></td></tr>
<tr class="separator:af8c4c759177557c050cbdaaf311c20cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92ab559d766776945608612379fb03b"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad92ab559d766776945608612379fb03b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad92ab559d766776945608612379fb03b.html#ad92ab559d766776945608612379fb03b">cos</a> (const VarMat &amp;a)</td></tr>
<tr class="memdesc:ad92ab559d766776945608612379fb03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cosine of a radian-scaled variable (cmath).  <br /></td></tr>
<tr class="separator:ad92ab559d766776945608612379fb03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b02a8444a948078748816e910a0b4b0"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7b02a8444a948078748816e910a0b4b0.html#a7b02a8444a948078748816e910a0b4b0">cos</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a7b02a8444a948078748816e910a0b4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cosine of the complex argument.  <br /></td></tr>
<tr class="separator:a7b02a8444a948078748816e910a0b4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a43fcaf01cfef4c73074e77390a205"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab2a43fcaf01cfef4c73074e77390a205.html#ab2a43fcaf01cfef4c73074e77390a205">cosh</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:ab2a43fcaf01cfef4c73074e77390a205"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic cosine of the specified variable (cmath).  <br /></td></tr>
<tr class="separator:ab2a43fcaf01cfef4c73074e77390a205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6aceec4ffaa1a5dff857f7a6b54d305"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad6aceec4ffaa1a5dff857f7a6b54d305"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad6aceec4ffaa1a5dff857f7a6b54d305.html#ad6aceec4ffaa1a5dff857f7a6b54d305">cosh</a> (const VarMat &amp;a)</td></tr>
<tr class="memdesc:ad6aceec4ffaa1a5dff857f7a6b54d305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic cosine of the specified variable (cmath).  <br /></td></tr>
<tr class="separator:ad6aceec4ffaa1a5dff857f7a6b54d305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1dfe9032a6ee0f20d64a248f8fc539f"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae1dfe9032a6ee0f20d64a248f8fc539f.html#ae1dfe9032a6ee0f20d64a248f8fc539f">cosh</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:ae1dfe9032a6ee0f20d64a248f8fc539f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic cosine of the complex argument.  <br /></td></tr>
<tr class="separator:ae1dfe9032a6ee0f20d64a248f8fc539f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc17b5219447a9cc6d46654b797908e"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_arithmetic_t&lt;typename scalar_type&lt;T_x&gt;::type&gt;&gt; </td></tr>
<tr class="memitem:a6bc17b5219447a9cc6d46654b797908e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6bc17b5219447a9cc6d46654b797908e.html#a6bc17b5219447a9cc6d46654b797908e">cov_exp_quad</a> (const std::vector&lt; T_x &gt; &amp;x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;sigma, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;l)</td></tr>
<tr class="separator:a6bc17b5219447a9cc6d46654b797908e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d98e015c8127898ccf03e818c23779"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename  = require_arithmetic_t&lt;typename scalar_type&lt;T_x&gt;::type&gt;&gt; </td></tr>
<tr class="memitem:a38d98e015c8127898ccf03e818c23779"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a38d98e015c8127898ccf03e818c23779.html#a38d98e015c8127898ccf03e818c23779">cov_exp_quad</a> (const std::vector&lt; T_x &gt; &amp;x, double sigma, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;l)</td></tr>
<tr class="separator:a38d98e015c8127898ccf03e818c23779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96389be6dcf36281bfefd9b69dc5b74"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__rev__matrix__types_ga5b4749960545a52cc23c445f7dc781c4.html#ga5b4749960545a52cc23c445f7dc781c4">require_any_rev_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab96389be6dcf36281bfefd9b69dc5b74"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab96389be6dcf36281bfefd9b69dc5b74.html#ab96389be6dcf36281bfefd9b69dc5b74">csr_matrix_times_vector</a> (int m, int n, const T1 &amp;w, const std::vector&lt; int &gt; &amp;v, const std::vector&lt; int &gt; &amp;u, const T2 &amp;b)</td></tr>
<tr class="separator:ab96389be6dcf36281bfefd9b69dc5b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a444630878ddad2511a543aa7e5a85ade"><td class="memTemplParams" colspan="2">template&lt;typename EigVec , <a class="el" href="group__rev__vector__types_gae5f0ef9dce633c87a3496b8c51c2eb5b.html#gae5f0ef9dce633c87a3496b8c51c2eb5b">require_rev_vector_t</a>&lt; EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a444630878ddad2511a543aa7e5a85ade"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a444630878ddad2511a543aa7e5a85ade.html#a444630878ddad2511a543aa7e5a85ade">cumulative_sum</a> (const EigVec &amp;x)</td></tr>
<tr class="memdesc:a444630878ddad2511a543aa7e5a85ade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the cumulative sum of the specified vector.  <br /></td></tr>
<tr class="separator:a444630878ddad2511a543aa7e5a85ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa007bbb2b70afca96c39a9db56891e96"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa007bbb2b70afca96c39a9db56891e96"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa007bbb2b70afca96c39a9db56891e96.html#aa007bbb2b70afca96c39a9db56891e96">determinant</a> (const T &amp;m)</td></tr>
<tr class="separator:aa007bbb2b70afca96c39a9db56891e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f8a31d51a379e13dffe4db04fbbc3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a67f8a31d51a379e13dffe4db04fbbc3c.html#a67f8a31d51a379e13dffe4db04fbbc3c">digamma</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a67f8a31d51a379e13dffe4db04fbbc3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the derivative of the log gamma function at the specified value.  <br /></td></tr>
<tr class="separator:a67f8a31d51a379e13dffe4db04fbbc3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294f9826a0d22943f3f162f1a4dd6acd"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a294f9826a0d22943f3f162f1a4dd6acd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a294f9826a0d22943f3f162f1a4dd6acd.html#a294f9826a0d22943f3f162f1a4dd6acd">digamma</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a294f9826a0d22943f3f162f1a4dd6acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise derivative of the log gamma function at the given input vector.  <br /></td></tr>
<tr class="separator:a294f9826a0d22943f3f162f1a4dd6acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5204575e698cdc146deba0269c85f857"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5204575e698cdc146deba0269c85f857"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5204575e698cdc146deba0269c85f857.html#a5204575e698cdc146deba0269c85f857">dims</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="memdesc:a5204575e698cdc146deba0269c85f857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes dimensions of given argument into given result vector.  <br /></td></tr>
<tr class="separator:a5204575e698cdc146deba0269c85f857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23a41a265b0da541e9c95c47dee39a9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab23a41a265b0da541e9c95c47dee39a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab23a41a265b0da541e9c95c47dee39a9.html#ab23a41a265b0da541e9c95c47dee39a9">dims</a> (const <a class="el" href="classstan_1_1math_1_1vari__value.html">vari_value</a>&lt; T &gt; &amp;x, std::vector&lt; int &gt; &amp;result)</td></tr>
<tr class="memdesc:ab23a41a265b0da541e9c95c47dee39a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pushes dimensions of given argument into given result vector.  <br /></td></tr>
<tr class="separator:ab23a41a265b0da541e9c95c47dee39a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7720218b0c95dcbd8fc3eddf3dc18a2"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__vector__types_ga1b4c392b9d20db66ae254ef9833f9717.html#ga1b4c392b9d20db66ae254ef9833f9717">require_all_vector_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__complex__types_ga3d92736c03356df12307fb596d0fd805.html#ga3d92736c03356df12307fb596d0fd805">require_not_complex_t</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2 &gt; &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga613a895eb09b0a2c56cf757f08e3b1d0.html#ga613a895eb09b0a2c56cf757f08e3b1d0">require_all_not_std_vector_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__var__types_gad4fb966d630ab09756dbc3a1bfd495d4.html#gad4fb966d630ab09756dbc3a1bfd495d4">require_any_st_var</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad7720218b0c95dcbd8fc3eddf3dc18a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad7720218b0c95dcbd8fc3eddf3dc18a2.html#ad7720218b0c95dcbd8fc3eddf3dc18a2">dot_product</a> (const T1 &amp;v1, const T2 &amp;v2)</td></tr>
<tr class="memdesc:ad7720218b0c95dcbd8fc3eddf3dc18a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product.  <br /></td></tr>
<tr class="separator:ad7720218b0c95dcbd8fc3eddf3dc18a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c3b77e281f45807235c6585f9878c8"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__vector__types_ga896401ad33967867f49cd60ca10d990e.html#ga896401ad33967867f49cd60ca10d990e">require_eigen_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a59c3b77e281f45807235c6585f9878c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a59c3b77e281f45807235c6585f9878c8.html#a59c3b77e281f45807235c6585f9878c8">dot_self</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a59c3b77e281f45807235c6585f9878c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of a vector of var with itself.  <br /></td></tr>
<tr class="separator:a59c3b77e281f45807235c6585f9878c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52ab9925e59332f9f3b6bd1a315dc89"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad52ab9925e59332f9f3b6bd1a315dc89"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad52ab9925e59332f9f3b6bd1a315dc89.html#ad52ab9925e59332f9f3b6bd1a315dc89">eigendecompose_sym</a> (const T &amp;m)</td></tr>
<tr class="memdesc:ad52ab9925e59332f9f3b6bd1a315dc89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the decomposition of the specified symmetric matrix.  <br /></td></tr>
<tr class="separator:ad52ab9925e59332f9f3b6bd1a315dc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23e09b01928acf32720f5351c3496c3"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab23e09b01928acf32720f5351c3496c3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab23e09b01928acf32720f5351c3496c3.html#ab23e09b01928acf32720f5351c3496c3">eigenvalues_sym</a> (const T &amp;m)</td></tr>
<tr class="memdesc:ab23e09b01928acf32720f5351c3496c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eigenvalues of the specified symmetric matrix.  <br /></td></tr>
<tr class="separator:ab23e09b01928acf32720f5351c3496c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5392dd813b5cda51b8060b415ac16586"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5392dd813b5cda51b8060b415ac16586"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5392dd813b5cda51b8060b415ac16586.html#a5392dd813b5cda51b8060b415ac16586">eigenvectors_sym</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a5392dd813b5cda51b8060b415ac16586"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the eigenvectors of the specified symmetric matrix.  <br /></td></tr>
<tr class="separator:a5392dd813b5cda51b8060b415ac16586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759d52872682fdf0d6a7a6d75b4f1d9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a759d52872682fdf0d6a7a6d75b4f1d9e.html#a759d52872682fdf0d6a7a6d75b4f1d9e">erf</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a759d52872682fdf0d6a7a6d75b4f1d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The error function for variables (C99).  <br /></td></tr>
<tr class="separator:a759d52872682fdf0d6a7a6d75b4f1d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185fa79774b930771ed883f4216c7b98"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a185fa79774b930771ed883f4216c7b98"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a185fa79774b930771ed883f4216c7b98.html#a185fa79774b930771ed883f4216c7b98">erf</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a185fa79774b930771ed883f4216c7b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a8543e9c729e794bcbdff2ed223eb45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8a8543e9c729e794bcbdff2ed223eb45.html#a8a8543e9c729e794bcbdff2ed223eb45">erfc</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a8a8543e9c729e794bcbdff2ed223eb45"><td class="mdescLeft">&#160;</td><td class="mdescRight">The complementary error function for variables (C99).  <br /></td></tr>
<tr class="separator:a8a8543e9c729e794bcbdff2ed223eb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047e3ddba7034037840b01cb482b5aeb"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a047e3ddba7034037840b01cb482b5aeb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a047e3ddba7034037840b01cb482b5aeb.html#a047e3ddba7034037840b01cb482b5aeb">erfc</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a047e3ddba7034037840b01cb482b5aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43b048d4a5f53f94501773c93689a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae43b048d4a5f53f94501773c93689a65.html#ae43b048d4a5f53f94501773c93689a65">exp</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:ae43b048d4a5f53f94501773c93689a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exponentiation of the specified variable (cmath).  <br /></td></tr>
<tr class="separator:ae43b048d4a5f53f94501773c93689a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad0f736854d0a995adc9908efae43da"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adad0f736854d0a995adc9908efae43da.html#adad0f736854d0a995adc9908efae43da">exp</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:adad0f736854d0a995adc9908efae43da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exponentiation (base e) of the specified complex number.  <br /></td></tr>
<tr class="separator:adad0f736854d0a995adc9908efae43da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d6fc29468007fea5fb71f1d1fa4dcb"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae4d6fc29468007fea5fb71f1d1fa4dcb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae4d6fc29468007fea5fb71f1d1fa4dcb.html#ae4d6fc29468007fea5fb71f1d1fa4dcb">exp</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae4d6fc29468007fea5fb71f1d1fa4dcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the exponentiation of the elements of x.  <br /></td></tr>
<tr class="separator:ae4d6fc29468007fea5fb71f1d1fa4dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd4650bbf246a10ac798c71da8b99d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9fd4650bbf246a10ac798c71da8b99d5.html#a9fd4650bbf246a10ac798c71da8b99d5">exp2</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a9fd4650bbf246a10ac798c71da8b99d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exponentiation base 2 function for variables (C99).  <br /></td></tr>
<tr class="separator:a9fd4650bbf246a10ac798c71da8b99d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c6d86fc5918f1e4ce736d55f83c2e19"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4c6d86fc5918f1e4ce736d55f83c2e19"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4c6d86fc5918f1e4ce736d55f83c2e19.html#a4c6d86fc5918f1e4ce736d55f83c2e19">exp2</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a4c6d86fc5918f1e4ce736d55f83c2e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974d9d6b021e75ee0ba7146d221beed2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a974d9d6b021e75ee0ba7146d221beed2.html#a974d9d6b021e75ee0ba7146d221beed2">expm1</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a974d9d6b021e75ee0ba7146d221beed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exponentiation of the specified variable minus 1 (C99).  <br /></td></tr>
<tr class="separator:a974d9d6b021e75ee0ba7146d221beed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a442b27a359af323af62f92f95f343655"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a442b27a359af323af62f92f95f343655"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a442b27a359af323af62f92f95f343655.html#a442b27a359af323af62f92f95f343655">expm1</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a442b27a359af323af62f92f95f343655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8428395b18c89bc01669915993b8e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aea8428395b18c89bc01669915993b8e7.html#aea8428395b18c89bc01669915993b8e7">fabs</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:aea8428395b18c89bc01669915993b8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute value of the variable (cmath).  <br /></td></tr>
<tr class="separator:aea8428395b18c89bc01669915993b8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c405343c718f1c07bfad79d40d3f65"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab7c405343c718f1c07bfad79d40d3f65"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab7c405343c718f1c07bfad79d40d3f65.html#ab7c405343c718f1c07bfad79d40d3f65">fabs</a> (const VarMat &amp;a)</td></tr>
<tr class="memdesc:ab7c405343c718f1c07bfad79d40d3f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the absolute value of the variable (cmath).  <br /></td></tr>
<tr class="separator:ab7c405343c718f1c07bfad79d40d3f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9ba061a64b1c51bb0e196701882920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afe9ba061a64b1c51bb0e196701882920.html#afe9ba061a64b1c51bb0e196701882920">falling_factorial</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, int b)</td></tr>
<tr class="separator:afe9ba061a64b1c51bb0e196701882920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950981f779abb13aedba88d394c9b805"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__integral__types_ga8d10ea9813909bf7fc1a2394e880165a.html#ga8d10ea9813909bf7fc1a2394e880165a">require_st_integral</a>&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a950981f779abb13aedba88d394c9b805"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a950981f779abb13aedba88d394c9b805.html#a950981f779abb13aedba88d394c9b805">falling_factorial</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T1 &gt; &amp;a, const T2 &amp;b)</td></tr>
<tr class="separator:a950981f779abb13aedba88d394c9b805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67859aea03604f636f079ed1000c59b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a67859aea03604f636f079ed1000c59b5.html#a67859aea03604f636f079ed1000c59b5">fdim</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a67859aea03604f636f079ed1000c59b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference between the first variable's the value and the second's (C99, C++11).  <br /></td></tr>
<tr class="separator:a67859aea03604f636f079ed1000c59b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f697404813766e2548150ae6ba0f77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a04f697404813766e2548150ae6ba0f77.html#a04f697404813766e2548150ae6ba0f77">fdim</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a04f697404813766e2548150ae6ba0f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference between the first value and the value of the second variable (C99, C++11).  <br /></td></tr>
<tr class="separator:a04f697404813766e2548150ae6ba0f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdba138717a245e872b72575a2a2838"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5fdba138717a245e872b72575a2a2838.html#a5fdba138717a245e872b72575a2a2838">fdim</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:a5fdba138717a245e872b72575a2a2838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the positive difference between the first variable's value and the second value (C99, C++11).  <br /></td></tr>
<tr class="separator:a5fdba138717a245e872b72575a2a2838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c91d4180a508c7e1b2335eac7fdd7a"><td class="memTemplParams" colspan="2">template&lt;typename V , <a class="el" href="group__eigen__vector__types_ga896401ad33967867f49cd60ca10d990e.html#ga896401ad33967867f49cd60ca10d990e">require_eigen_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>, V &gt; *  = nullptr, <a class="el" href="group__var__types_gab0d7285b1a3ce33eb11e113827345d30.html#gab0d7285b1a3ce33eb11e113827345d30">require_var_t</a>&lt; <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; V &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad0c91d4180a508c7e1b2335eac7fdd7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad0c91d4180a508c7e1b2335eac7fdd7a.html#ad0c91d4180a508c7e1b2335eac7fdd7a">fft</a> (const V &amp;x)</td></tr>
<tr class="memdesc:ad0c91d4180a508c7e1b2335eac7fdd7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the discrete Fourier transform of the specified complex vector.  <br /></td></tr>
<tr class="separator:ad0c91d4180a508c7e1b2335eac7fdd7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb434410a46c42c573ac7c2811bb1ac9"><td class="memTemplParams" colspan="2">template&lt;typename V , <a class="el" href="group__eigen__vector__types_ga896401ad33967867f49cd60ca10d990e.html#ga896401ad33967867f49cd60ca10d990e">require_eigen_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>, V &gt; *  = nullptr, <a class="el" href="group__var__types_gab0d7285b1a3ce33eb11e113827345d30.html#gab0d7285b1a3ce33eb11e113827345d30">require_var_t</a>&lt; <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; V &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acb434410a46c42c573ac7c2811bb1ac9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acb434410a46c42c573ac7c2811bb1ac9.html#acb434410a46c42c573ac7c2811bb1ac9">inv_fft</a> (const V &amp;y)</td></tr>
<tr class="memdesc:acb434410a46c42c573ac7c2811bb1ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse discrete Fourier transform of the specified complex vector.  <br /></td></tr>
<tr class="separator:acb434410a46c42c573ac7c2811bb1ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2486861d58bd21ed31c2c6857e3cf7f0"><td class="memTemplParams" colspan="2">template&lt;typename M , <a class="el" href="group__eigen__dense__dynamic__types_ga36cbcf4b98f8305631d3ddc70ffc8565.html#ga36cbcf4b98f8305631d3ddc70ffc8565">require_eigen_dense_dynamic_vt</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>, M &gt; *  = nullptr, <a class="el" href="group__var__types_gab0d7285b1a3ce33eb11e113827345d30.html#gab0d7285b1a3ce33eb11e113827345d30">require_var_t</a>&lt; <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; M &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2486861d58bd21ed31c2c6857e3cf7f0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2486861d58bd21ed31c2c6857e3cf7f0.html#a2486861d58bd21ed31c2c6857e3cf7f0">fft2</a> (const M &amp;x)</td></tr>
<tr class="memdesc:a2486861d58bd21ed31c2c6857e3cf7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the two-dimensional discrete Fourier transform of the specified complex matrix.  <br /></td></tr>
<tr class="separator:a2486861d58bd21ed31c2c6857e3cf7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a2d42642ea6cfc6352b68a66e73c0e"><td class="memTemplParams" colspan="2">template&lt;typename M , <a class="el" href="group__eigen__dense__dynamic__types_ga36cbcf4b98f8305631d3ddc70ffc8565.html#ga36cbcf4b98f8305631d3ddc70ffc8565">require_eigen_dense_dynamic_vt</a>&lt; <a class="el" href="structstan_1_1is__complex.html">is_complex</a>, M &gt; *  = nullptr, <a class="el" href="group__var__types_gab0d7285b1a3ce33eb11e113827345d30.html#gab0d7285b1a3ce33eb11e113827345d30">require_var_t</a>&lt; <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; M &gt; &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a27a2d42642ea6cfc6352b68a66e73c0e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; M &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a27a2d42642ea6cfc6352b68a66e73c0e.html#a27a2d42642ea6cfc6352b68a66e73c0e">inv_fft2</a> (const M &amp;y)</td></tr>
<tr class="memdesc:a27a2d42642ea6cfc6352b68a66e73c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the two-dimensional inverse discrete Fourier transform of the specified complex matrix.  <br /></td></tr>
<tr class="separator:a27a2d42642ea6cfc6352b68a66e73c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48956e04ac71f11589e263936b6d98a9"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , typename S , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr, <a class="el" href="group__var__types_gab0d7285b1a3ce33eb11e113827345d30.html#gab0d7285b1a3ce33eb11e113827345d30">require_var_t</a>&lt; S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a48956e04ac71f11589e263936b6d98a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a48956e04ac71f11589e263936b6d98a9.html#a48956e04ac71f11589e263936b6d98a9">fill</a> (VarMat &amp;x, const S &amp;y)</td></tr>
<tr class="memdesc:a48956e04ac71f11589e263936b6d98a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <br /></td></tr>
<tr class="separator:a48956e04ac71f11589e263936b6d98a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66dea6b6d18e39c5b0f38d3204aa04d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a66dea6b6d18e39c5b0f38d3204aa04d5.html#a66dea6b6d18e39c5b0f38d3204aa04d5">floor</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a66dea6b6d18e39c5b0f38d3204aa04d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floor of the specified variable (cmath).  <br /></td></tr>
<tr class="separator:a66dea6b6d18e39c5b0f38d3204aa04d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe819627d159deb1bc0f2d2d21502f9"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aebe819627d159deb1bc0f2d2d21502f9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aebe819627d159deb1bc0f2d2d21502f9.html#aebe819627d159deb1bc0f2d2d21502f9">floor</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:aebe819627d159deb1bc0f2d2d21502f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55a6d0bcdbc9a1a83749f8ed176678fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a55a6d0bcdbc9a1a83749f8ed176678fc.html#a55a6d0bcdbc9a1a83749f8ed176678fc">fma</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;z)</td></tr>
<tr class="memdesc:a55a6d0bcdbc9a1a83749f8ed176678fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for three variables (C99).  <br /></td></tr>
<tr class="separator:a55a6d0bcdbc9a1a83749f8ed176678fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708f1f09e2c113b797491ad0fa2a0601"><td class="memTemplParams" colspan="2">template&lt;typename Tc , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Tc &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a708f1f09e2c113b797491ad0fa2a0601"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a708f1f09e2c113b797491ad0fa2a0601.html#a708f1f09e2c113b797491ad0fa2a0601">fma</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y, Tc &amp;&amp;z)</td></tr>
<tr class="memdesc:a708f1f09e2c113b797491ad0fa2a0601"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for two variables and a value (C99).  <br /></td></tr>
<tr class="separator:a708f1f09e2c113b797491ad0fa2a0601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867b06260a9c7066241a3c0736cfb415"><td class="memTemplParams" colspan="2">template&lt;typename Tb , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Tb &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a867b06260a9c7066241a3c0736cfb415"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a867b06260a9c7066241a3c0736cfb415.html#a867b06260a9c7066241a3c0736cfb415">fma</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, Tb &amp;&amp;y, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;z)</td></tr>
<tr class="memdesc:a867b06260a9c7066241a3c0736cfb415"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for a variable, value, and variable (C99).  <br /></td></tr>
<tr class="separator:a867b06260a9c7066241a3c0736cfb415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2c7db326e7be850dbc8195f1b49f10"><td class="memTemplParams" colspan="2">template&lt;typename Tb , typename Tc , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; Tb, Tc &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6d2c7db326e7be850dbc8195f1b49f10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6d2c7db326e7be850dbc8195f1b49f10.html#a6d2c7db326e7be850dbc8195f1b49f10">fma</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x, Tb &amp;&amp;y, Tc &amp;&amp;z)</td></tr>
<tr class="memdesc:a6d2c7db326e7be850dbc8195f1b49f10"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for a variable and two values (C99).  <br /></td></tr>
<tr class="separator:a6d2c7db326e7be850dbc8195f1b49f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e8eedd9f9c307555379726f37c1850"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tc , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; Ta, Tc &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a83e8eedd9f9c307555379726f37c1850"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a83e8eedd9f9c307555379726f37c1850.html#a83e8eedd9f9c307555379726f37c1850">fma</a> (Ta &amp;&amp;x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y, Tc &amp;&amp;z)</td></tr>
<tr class="memdesc:a83e8eedd9f9c307555379726f37c1850"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for a value, variable, and value (C99).  <br /></td></tr>
<tr class="separator:a83e8eedd9f9c307555379726f37c1850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3455dbaefcdeafd33393026b65c6e3b"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , <a class="el" href="group__arithmetic__types_ga09986c7ec9fdfe2f4648356230c938ff.html#ga09986c7ec9fdfe2f4648356230c938ff">require_all_arithmetic_t</a>&lt; Ta, Tb &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac3455dbaefcdeafd33393026b65c6e3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac3455dbaefcdeafd33393026b65c6e3b.html#ac3455dbaefcdeafd33393026b65c6e3b">fma</a> (Ta &amp;&amp;x, Tb &amp;&amp;y, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;z)</td></tr>
<tr class="memdesc:ac3455dbaefcdeafd33393026b65c6e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for two values and a variable, and value (C99).  <br /></td></tr>
<tr class="separator:ac3455dbaefcdeafd33393026b65c6e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2357b25e743c440163eead1df1ac38"><td class="memTemplParams" colspan="2">template&lt;typename Ta , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; Ta &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6b2357b25e743c440163eead1df1ac38"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6b2357b25e743c440163eead1df1ac38.html#a6b2357b25e743c440163eead1df1ac38">fma</a> (Ta &amp;&amp;x, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;z)</td></tr>
<tr class="memdesc:a6b2357b25e743c440163eead1df1ac38"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for a value and two variables (C99).  <br /></td></tr>
<tr class="separator:a6b2357b25e743c440163eead1df1ac38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7621a9cac916276e0f2843dbbfa61a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__matrix__types_ga1922331b5c670c8a19b234064e174cf9.html#ga1922331b5c670c8a19b234064e174cf9">require_any_matrix_t</a>&lt; T1, T2, T3 &gt; *  = nullptr, <a class="el" href="group__var__types_gab0d7285b1a3ce33eb11e113827345d30.html#gab0d7285b1a3ce33eb11e113827345d30">require_var_t</a>&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T1, T2, T3 &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5d7621a9cac916276e0f2843dbbfa61a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5d7621a9cac916276e0f2843dbbfa61a.html#a5d7621a9cac916276e0f2843dbbfa61a">fma</a> (const T1 &amp;x, const T2 &amp;y, const T3 &amp;z)</td></tr>
<tr class="memdesc:a5d7621a9cac916276e0f2843dbbfa61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fused multiply-add function for three variables (C99).  <br /></td></tr>
<tr class="separator:a5d7621a9cac916276e0f2843dbbfa61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090ff6b2b6b36510e8e5986d8c452025"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a090ff6b2b6b36510e8e5986d8c452025.html#a090ff6b2b6b36510e8e5986d8c452025">fmax</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a090ff6b2b6b36510e8e5986d8c452025"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum of the two variable arguments (C99).  <br /></td></tr>
<tr class="separator:a090ff6b2b6b36510e8e5986d8c452025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf0992be2ce2165722d060940e3305a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aacf0992be2ce2165722d060940e3305a.html#aacf0992be2ce2165722d060940e3305a">fmax</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:aacf0992be2ce2165722d060940e3305a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum of the variable and scalar, promoting the scalar to a variable if it is larger (C99).  <br /></td></tr>
<tr class="separator:aacf0992be2ce2165722d060940e3305a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb80ce6aef3b70dd0ed452619bf0ea1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acb80ce6aef3b70dd0ed452619bf0ea1a.html#acb80ce6aef3b70dd0ed452619bf0ea1a">fmax</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:acb80ce6aef3b70dd0ed452619bf0ea1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum of a scalar and variable, promoting the scalar to a variable if it is larger (C99).  <br /></td></tr>
<tr class="separator:acb80ce6aef3b70dd0ed452619bf0ea1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a002d1861d4fddb98b16ed781bf541b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5a002d1861d4fddb98b16ed781bf541b.html#a5a002d1861d4fddb98b16ed781bf541b">fmin</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a5a002d1861d4fddb98b16ed781bf541b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum of the two variable arguments (C99).  <br /></td></tr>
<tr class="separator:a5a002d1861d4fddb98b16ed781bf541b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90700a00e5d9829dbd0bd5b2692917c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a90700a00e5d9829dbd0bd5b2692917c4.html#a90700a00e5d9829dbd0bd5b2692917c4">fmin</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:a90700a00e5d9829dbd0bd5b2692917c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum of the variable and scalar, promoting the scalar to a variable if it is larger (C99).  <br /></td></tr>
<tr class="separator:a90700a00e5d9829dbd0bd5b2692917c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad59f8682c1537c9f9fa72f49577bd05a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad59f8682c1537c9f9fa72f49577bd05a.html#ad59f8682c1537c9f9fa72f49577bd05a">fmin</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:ad59f8682c1537c9f9fa72f49577bd05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum of a scalar and variable, promoting the scalar to a variable if it is larger (C99).  <br /></td></tr>
<tr class="separator:ad59f8682c1537c9f9fa72f49577bd05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935933626162d429e5a7f06ca0bde103"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a935933626162d429e5a7f06ca0bde103.html#a935933626162d429e5a7f06ca0bde103">fmod</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a935933626162d429e5a7f06ca0bde103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floating point remainder after dividing the first variable by the second (cmath).  <br /></td></tr>
<tr class="separator:a935933626162d429e5a7f06ca0bde103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8420835869a6fc4f0d0b0f6866b403"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7a8420835869a6fc4f0d0b0f6866b403.html#a7a8420835869a6fc4f0d0b0f6866b403">fmod</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:a7a8420835869a6fc4f0d0b0f6866b403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floating point remainder after dividing the the first variable by the second scalar (cmath).  <br /></td></tr>
<tr class="separator:a7a8420835869a6fc4f0d0b0f6866b403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:added805756153e21677750443283bdc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_added805756153e21677750443283bdc1.html#added805756153e21677750443283bdc1">fmod</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:added805756153e21677750443283bdc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the floating point remainder after dividing the first scalar by the second variable (cmath).  <br /></td></tr>
<tr class="separator:added805756153e21677750443283bdc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813b721424964a4ec2777a76cd8aba83"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a813b721424964a4ec2777a76cd8aba83"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, T::RowsAtCompileTime, T::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a813b721424964a4ec2777a76cd8aba83.html#a813b721424964a4ec2777a76cd8aba83">from_var_value</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a813b721424964a4ec2777a76cd8aba83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code> into an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> Matrix.  <br /></td></tr>
<tr class="separator:a813b721424964a4ec2777a76cd8aba83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a4838086f6cb2c59890cdf513e78c2"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="namespacestan_a0ded958a60b3f73671c8ed20e2ff426f.html#a0ded958a60b3f73671c8ed20e2ff426f">require_any_t</a>&lt; <a class="el" href="structstan_1_1math_1_1conjunction.html">conjunction</a>&lt; <a class="el" href="structstan_1_1is__eigen.html">is_eigen</a>&lt; T &gt;, <a class="el" href="structstan_1_1is__var.html">is_var</a>&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt; &gt; &gt;, std::is_same&lt; std::decay_t&lt; T &gt;, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;, <a class="el" href="group__type__trait_gad1046e42476333dc3c08c35bfe420302.html#gad1046e42476333dc3c08c35bfe420302">bool_constant</a>&lt;!std::is_same&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T &gt;, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;::value &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a46a4838086f6cb2c59890cdf513e78c2"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a46a4838086f6cb2c59890cdf513e78c2.html#a46a4838086f6cb2c59890cdf513e78c2">from_var_value</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a46a4838086f6cb2c59890cdf513e78c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a no-op for <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> containers of vars, scalars or prim types.  <br /></td></tr>
<tr class="separator:a46a4838086f6cb2c59890cdf513e78c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa484418490e887bdc814d50d415f8a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afa484418490e887bdc814d50d415f8a8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afa484418490e887bdc814d50d415f8a8.html#afa484418490e887bdc814d50d415f8a8">from_var_value</a> (const std::vector&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:afa484418490e887bdc814d50d415f8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the elements of the <code>std::vector</code> input to <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code> types if possible.  <br /></td></tr>
<tr class="separator:afa484418490e887bdc814d50d415f8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c66b8a83c53e18f4974988d38e41d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6c66b8a83c53e18f4974988d38e41d8f.html#a6c66b8a83c53e18f4974988d38e41d8f">gamma_p</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:a6c66b8a83c53e18f4974988d38e41d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5d71ea3ea8cbe73b3ec087a4858ed7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afd5d71ea3ea8cbe73b3ec087a4858ed7.html#afd5d71ea3ea8cbe73b3ec087a4858ed7">gamma_p</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="separator:afd5d71ea3ea8cbe73b3ec087a4858ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8ada6dde6c69c5435442c9227ade8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3b8ada6dde6c69c5435442c9227ade8b.html#a3b8ada6dde6c69c5435442c9227ade8b">gamma_p</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:a3b8ada6dde6c69c5435442c9227ade8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf59e94075aaffc23e80dfe865bf2f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeaf59e94075aaffc23e80dfe865bf2f4.html#aeaf59e94075aaffc23e80dfe865bf2f4">gamma_q</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:aeaf59e94075aaffc23e80dfe865bf2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977e96802b4cae1bd238ffd3a6887430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a977e96802b4cae1bd238ffd3a6887430.html#a977e96802b4cae1bd238ffd3a6887430">gamma_q</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="separator:a977e96802b4cae1bd238ffd3a6887430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29dcdbbac262f0103ac8bf38205453f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af29dcdbbac262f0103ac8bf38205453f.html#af29dcdbbac262f0103ac8bf38205453f">gamma_q</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:af29dcdbbac262f0103ac8bf38205453f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45baa280de387db8293ea9f150ecd9d4"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a45baa280de387db8293ea9f150ecd9d4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a45baa280de387db8293ea9f150ecd9d4.html#a45baa280de387db8293ea9f150ecd9d4">generalized_inverse</a> (const VarMat &amp;G)</td></tr>
<tr class="separator:a45baa280de387db8293ea9f150ecd9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aec2d660cbc805593afca4246d25f21"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , <a class="el" href="group__arithmetic__types_ga948d431ec5773ff848a6bfa0d0b7aa79.html#ga948d431ec5773ff848a6bfa0d0b7aa79">require_st_arithmetic</a>&lt; T_x &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_sigma &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2aec2d660cbc805593afca4246d25f21"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, -1, -1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2aec2d660cbc805593afca4246d25f21.html#a2aec2d660cbc805593afca4246d25f21">gp_exp_quad_cov</a> (const std::vector&lt; T_x &gt; &amp;x, const T_sigma sigma, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> length_scale)</td></tr>
<tr class="memdesc:a2aec2d660cbc805593afca4246d25f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a squared exponential kernel.  <br /></td></tr>
<tr class="separator:a2aec2d660cbc805593afca4246d25f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c77bc1a35fdcbaab3c18b42e8f61f8"><td class="memTemplParams" colspan="2">template&lt;typename T_x , typename T_sigma , <a class="el" href="group__arithmetic__types_ga948d431ec5773ff848a6bfa0d0b7aa79.html#ga948d431ec5773ff848a6bfa0d0b7aa79">require_st_arithmetic</a>&lt; T_x &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T_sigma &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa8c77bc1a35fdcbaab3c18b42e8f61f8"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Eigen::Dynamic, Eigen::Dynamic &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa8c77bc1a35fdcbaab3c18b42e8f61f8.html#aa8c77bc1a35fdcbaab3c18b42e8f61f8">gp_periodic_cov</a> (const std::vector&lt; T_x &gt; &amp;x, const T_sigma sigma, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> l, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> p)</td></tr>
<tr class="memdesc:aa8c77bc1a35fdcbaab3c18b42e8f61f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a periodic covariance matrix \( \mathbf{K} \) using the input \(
\mathbf{X} \).  <br /></td></tr>
<tr class="separator:aa8c77bc1a35fdcbaab3c18b42e8f61f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78c351f7c1ef5ea39c047fe102f70da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a78c351f7c1ef5ea39c047fe102f70da3.html#a78c351f7c1ef5ea39c047fe102f70da3">grad</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;v, Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Eigen::Dynamic, 1 &gt; &amp;x, Eigen::VectorXd &amp;g)</td></tr>
<tr class="memdesc:a78c351f7c1ef5ea39c047fe102f70da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Propagate chain rule to calculate gradients starting from the specified variable.  <br /></td></tr>
<tr class="separator:a78c351f7c1ef5ea39c047fe102f70da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f15a75139ebb4a3b599a1190d39fc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a25f15a75139ebb4a3b599a1190d39fc1.html#a25f15a75139ebb4a3b599a1190d39fc1">grad_inc_beta</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;g1, <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;g2, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;z)</td></tr>
<tr class="memdesc:a25f15a75139ebb4a3b599a1190d39fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gradient of the incomplete beta function beta(a, b, z) with respect to the first two arguments.  <br /></td></tr>
<tr class="separator:a25f15a75139ebb4a3b599a1190d39fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bb99232982c1e8c412d1b1abac1fa4"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tz , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; Ta, Tz &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; Ta, Tz &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae5bb99232982c1e8c412d1b1abac1fa4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae5bb99232982c1e8c412d1b1abac1fa4.html#ae5bb99232982c1e8c412d1b1abac1fa4">hypergeometric_1f0</a> (const Ta &amp;a, const Tz &amp;z)</td></tr>
<tr class="memdesc:ae5bb99232982c1e8c412d1b1abac1fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Hypergeometric 1F0 function applied to the input arguments: \( _1F_0(a;;z) = \sum_{k=1}^{\infty}\frac{\left(a\right)_kz^k}{k!}\).  <br /></td></tr>
<tr class="separator:ae5bb99232982c1e8c412d1b1abac1fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d0cf15bd351c4a45ae5321e661cdd0"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , typename Tz , bool grad_a = !is_constant&lt;Ta&gt;::value, bool grad_b = !is_constant&lt;Tb&gt;::value, bool grad_z = !is_constant&lt;Tz&gt;::value, <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; Ta, Tb &gt; *  = nullptr, <a class="el" href="namespacestan_a3671feedf945127c24a500b77adc594c.html#a3671feedf945127c24a500b77adc594c">require_return_type_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, Ta, Tb, Tz &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac1d0cf15bd351c4a45ae5321e661cdd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac1d0cf15bd351c4a45ae5321e661cdd0.html#ac1d0cf15bd351c4a45ae5321e661cdd0">hypergeometric_pFq</a> (const Ta &amp;a, const Tb &amp;b, const Tz &amp;z)</td></tr>
<tr class="memdesc:ac1d0cf15bd351c4a45ae5321e661cdd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the generalized hypergeometric function (pFq) applied to the input arguments.  <br /></td></tr>
<tr class="separator:ac1d0cf15bd351c4a45ae5321e661cdd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0827e995b465dcb291c3de1a77e2b547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0827e995b465dcb291c3de1a77e2b547.html#a0827e995b465dcb291c3de1a77e2b547">hypot</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a0827e995b465dcb291c3de1a77e2b547"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the hypotenuse of a right triangle with sides of the specified lengths (C99).  <br /></td></tr>
<tr class="separator:a0827e995b465dcb291c3de1a77e2b547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb40e789140be0e0b93a44e055a6cfc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abcb40e789140be0e0b93a44e055a6cfc.html#abcb40e789140be0e0b93a44e055a6cfc">hypot</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:abcb40e789140be0e0b93a44e055a6cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the hypotenuse of a right triangle with sides of the specified lengths (C99).  <br /></td></tr>
<tr class="separator:abcb40e789140be0e0b93a44e055a6cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9d2305ce89a46a7d182e6014fd0b3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5c9d2305ce89a46a7d182e6014fd0b3f.html#a5c9d2305ce89a46a7d182e6014fd0b3f">hypot</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a5c9d2305ce89a46a7d182e6014fd0b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the hypotenuse of a right triangle with sides of the specified lengths (C99).  <br /></td></tr>
<tr class="separator:a5c9d2305ce89a46a7d182e6014fd0b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb35d5a60bdc11a5d09eb629c50b5db5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abb35d5a60bdc11a5d09eb629c50b5db5.html#abb35d5a60bdc11a5d09eb629c50b5db5">if_else</a> (bool c, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y_true, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y_false)</td></tr>
<tr class="memdesc:abb35d5a60bdc11a5d09eb629c50b5db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specified condition is true, return the first variable, otherwise return the second variable.  <br /></td></tr>
<tr class="separator:abb35d5a60bdc11a5d09eb629c50b5db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1dc3a479994402ee1959b75fa2c70f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abc1dc3a479994402ee1959b75fa2c70f.html#abc1dc3a479994402ee1959b75fa2c70f">if_else</a> (bool c, double y_true, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y_false)</td></tr>
<tr class="memdesc:abc1dc3a479994402ee1959b75fa2c70f"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specified condition is true, return a new variable constructed from the first scalar, otherwise return the second variable.  <br /></td></tr>
<tr class="separator:abc1dc3a479994402ee1959b75fa2c70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209a6257548b6440d7468bd7cadee89b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a209a6257548b6440d7468bd7cadee89b.html#a209a6257548b6440d7468bd7cadee89b">if_else</a> (bool c, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;y_true, double y_false)</td></tr>
<tr class="memdesc:a209a6257548b6440d7468bd7cadee89b"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the specified condition is true, return the first variable, otherwise return a new variable constructed from the second scalar.  <br /></td></tr>
<tr class="separator:a209a6257548b6440d7468bd7cadee89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f5ba3e933a20c5ebd6f114cfa27dece"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7f5ba3e933a20c5ebd6f114cfa27dece.html#a7f5ba3e933a20c5ebd6f114cfa27dece">inc_beta</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;c)</td></tr>
<tr class="separator:a7f5ba3e933a20c5ebd6f114cfa27dece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fdaccda77932edc3a2583294c69d10"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , typename S , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; S &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae7fdaccda77932edc3a2583294c69d10"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae7fdaccda77932edc3a2583294c69d10.html#ae7fdaccda77932edc3a2583294c69d10">initialize_fill</a> (VarMat &amp;x, const S &amp;y)</td></tr>
<tr class="memdesc:ae7fdaccda77932edc3a2583294c69d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the specified container with the specified value.  <br /></td></tr>
<tr class="separator:ae7fdaccda77932edc3a2583294c69d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdf0a5cd40134110da3230d6fdea989"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aebdf0a5cd40134110da3230d6fdea989.html#aebdf0a5cd40134110da3230d6fdea989">initialize_variable</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;variable, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;value)</td></tr>
<tr class="memdesc:aebdf0a5cd40134110da3230d6fdea989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize variable to value.  <br /></td></tr>
<tr class="separator:aebdf0a5cd40134110da3230d6fdea989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bb474a393fa5277ff69c9498cb3809"><td class="memTemplParams" colspan="2">template&lt;int R, int C&gt; </td></tr>
<tr class="memitem:ad1bb474a393fa5277ff69c9498cb3809"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad1bb474a393fa5277ff69c9498cb3809.html#ad1bb474a393fa5277ff69c9498cb3809">initialize_variable</a> (Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, R, C &gt; &amp;matrix, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;value)</td></tr>
<tr class="memdesc:ad1bb474a393fa5277ff69c9498cb3809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize every cell in the matrix to the specified value.  <br /></td></tr>
<tr class="separator:ad1bb474a393fa5277ff69c9498cb3809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada62635d3e2320c9e36ac59a1c4bbdb0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada62635d3e2320c9e36ac59a1c4bbdb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ada62635d3e2320c9e36ac59a1c4bbdb0.html#ada62635d3e2320c9e36ac59a1c4bbdb0">initialize_variable</a> (std::vector&lt; T &gt; &amp;variables, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;value)</td></tr>
<tr class="memdesc:ada62635d3e2320c9e36ac59a1c4bbdb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the variables in the standard vector recursively.  <br /></td></tr>
<tr class="separator:ada62635d3e2320c9e36ac59a1c4bbdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ffe89f9184bfe3e09eb1376d7fbbae"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a04ffe89f9184bfe3e09eb1376d7fbbae"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a04ffe89f9184bfe3e09eb1376d7fbbae.html#a04ffe89f9184bfe3e09eb1376d7fbbae">inv</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a04ffe89f9184bfe3e09eb1376d7fbbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a98a8a08c82979b7e15e61de66a5f1b"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9a98a8a08c82979b7e15e61de66a5f1b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9a98a8a08c82979b7e15e61de66a5f1b.html#a9a98a8a08c82979b7e15e61de66a5f1b">inv_cloglog</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a9a98a8a08c82979b7e15e61de66a5f1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the inverse complementary log-log function applied specified variable (stan).  <br /></td></tr>
<tr class="separator:a9a98a8a08c82979b7e15e61de66a5f1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f68363ddbb6b9821cada9414f2fb805"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f68363ddbb6b9821cada9414f2fb805.html#a2f68363ddbb6b9821cada9414f2fb805">inv_erfc</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a2f68363ddbb6b9821cada9414f2fb805"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse complementary error function for variables.  <br /></td></tr>
<tr class="separator:a2f68363ddbb6b9821cada9414f2fb805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8873af0d3f7b3967b10c88f4e252c1c0"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8873af0d3f7b3967b10c88f4e252c1c0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8873af0d3f7b3967b10c88f4e252c1c0.html#a8873af0d3f7b3967b10c88f4e252c1c0">inv_erfc</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a8873af0d3f7b3967b10c88f4e252c1c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751f4a0ea6cf477870bfc3cf172e5ec1"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; T1, T2, T3 &gt; *  = nullptr, <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T1, T2, T3 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a751f4a0ea6cf477870bfc3cf172e5ec1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a751f4a0ea6cf477870bfc3cf172e5ec1.html#a751f4a0ea6cf477870bfc3cf172e5ec1">inv_inc_beta</a> (const T1 &amp;a, const T2 &amp;b, const T3 &amp;p)</td></tr>
<tr class="memdesc:a751f4a0ea6cf477870bfc3cf172e5ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of the normalized incomplete beta function of a, b, with probability p.  <br /></td></tr>
<tr class="separator:a751f4a0ea6cf477870bfc3cf172e5ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9a5fc59eb334179dc398d6c435e863"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adc9a5fc59eb334179dc398d6c435e863"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adc9a5fc59eb334179dc398d6c435e863.html#adc9a5fc59eb334179dc398d6c435e863">inv_logit</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:adc9a5fc59eb334179dc398d6c435e863"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse logit function for variables (stan).  <br /></td></tr>
<tr class="separator:adc9a5fc59eb334179dc398d6c435e863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb1ddd4c78517c6bc8ca08832725022"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1cb1ddd4c78517c6bc8ca08832725022.html#a1cb1ddd4c78517c6bc8ca08832725022">inv_Phi</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;p)</td></tr>
<tr class="memdesc:a1cb1ddd4c78517c6bc8ca08832725022"><td class="mdescLeft">&#160;</td><td class="mdescRight">The inverse of unit normal cumulative density function.  <br /></td></tr>
<tr class="separator:a1cb1ddd4c78517c6bc8ca08832725022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4807e86186ca996726214a632c0af9f"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab4807e86186ca996726214a632c0af9f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab4807e86186ca996726214a632c0af9f.html#ab4807e86186ca996726214a632c0af9f">inv_Phi</a> (const T &amp;p)</td></tr>
<tr class="memdesc:ab4807e86186ca996726214a632c0af9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise inverse of unit normal cumulative density function.  <br /></td></tr>
<tr class="separator:ab4807e86186ca996726214a632c0af9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6233053c65cf125929efa0982aff0485"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6233053c65cf125929efa0982aff0485"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6233053c65cf125929efa0982aff0485.html#a6233053c65cf125929efa0982aff0485">inv_sqrt</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="separator:a6233053c65cf125929efa0982aff0485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa347bbaada35746d4fbd644549416ce3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa347bbaada35746d4fbd644549416ce3.html#aa347bbaada35746d4fbd644549416ce3">inv_square</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="separator:aa347bbaada35746d4fbd644549416ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502dc19f9a468d9754817754806fa803"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a502dc19f9a468d9754817754806fa803"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a502dc19f9a468d9754817754806fa803.html#a502dc19f9a468d9754817754806fa803">inverse</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a502dc19f9a468d9754817754806fa803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse mode specialization of calculating the inverse of the matrix.  <br /></td></tr>
<tr class="separator:a502dc19f9a468d9754817754806fa803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c050932da2e90902bda668170379545"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2c050932da2e90902bda668170379545.html#a2c050932da2e90902bda668170379545">is_inf</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;v)</td></tr>
<tr class="memdesc:a2c050932da2e90902bda668170379545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the input's value is infinite and 0 otherwise.  <br /></td></tr>
<tr class="separator:a2c050932da2e90902bda668170379545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8ef1e06cddc77c4c56311f937cc183"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acf8ef1e06cddc77c4c56311f937cc183.html#acf8ef1e06cddc77c4c56311f937cc183">is_nan</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;v)</td></tr>
<tr class="memdesc:acf8ef1e06cddc77c4c56311f937cc183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns 1 if the input's value is NaN and 0 otherwise.  <br /></td></tr>
<tr class="separator:acf8ef1e06cddc77c4c56311f937cc183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8d228f0969deddaf2c485f07452fd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2f8d228f0969deddaf2c485f07452fd5.html#a2f8d228f0969deddaf2c485f07452fd5">is_uninitialized</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> x)</td></tr>
<tr class="memdesc:a2f8d228f0969deddaf2c485f07452fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the specified variable is uninitialized.  <br /></td></tr>
<tr class="separator:a2f8d228f0969deddaf2c485f07452fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ddaf50712801d40ad1ace6e4a91f5a"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac5ddaf50712801d40ad1ace6e4a91f5a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac5ddaf50712801d40ad1ace6e4a91f5a.html#ac5ddaf50712801d40ad1ace6e4a91f5a">lambert_w0</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:ac5ddaf50712801d40ad1ace6e4a91f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Lambert W function on W0 branch applied to the specified variable.  <br /></td></tr>
<tr class="separator:ac5ddaf50712801d40ad1ace6e4a91f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574e9f736da74a8d1c256a46acbc3c66"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a574e9f736da74a8d1c256a46acbc3c66"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a574e9f736da74a8d1c256a46acbc3c66.html#a574e9f736da74a8d1c256a46acbc3c66">lambert_wm1</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a574e9f736da74a8d1c256a46acbc3c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Lambert W function on W-1 branch applied to the specified variable.  <br /></td></tr>
<tr class="separator:a574e9f736da74a8d1c256a46acbc3c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1926137e835f589aae4bc1de3c38df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0c1926137e835f589aae4bc1de3c38df.html#a0c1926137e835f589aae4bc1de3c38df">lbeta</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a0c1926137e835f589aae4bc1de3c38df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the beta function and its gradients.  <br /></td></tr>
<tr class="separator:a0c1926137e835f589aae4bc1de3c38df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0d3b1bc340a39916334d6278cc3af9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aed0d3b1bc340a39916334d6278cc3af9.html#aed0d3b1bc340a39916334d6278cc3af9">lbeta</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:aed0d3b1bc340a39916334d6278cc3af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the beta function and its gradients.  <br /></td></tr>
<tr class="separator:aed0d3b1bc340a39916334d6278cc3af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e979f59835f8d76fe11c0d965f3e854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6e979f59835f8d76fe11c0d965f3e854.html#a6e979f59835f8d76fe11c0d965f3e854">lbeta</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a6e979f59835f8d76fe11c0d965f3e854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the natural logarithm of the beta function and its gradients.  <br /></td></tr>
<tr class="separator:a6e979f59835f8d76fe11c0d965f3e854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3663745044c3881171359fdba082bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae3663745044c3881171359fdba082bf0.html#ae3663745044c3881171359fdba082bf0">ldexp</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, int b)</td></tr>
<tr class="separator:ae3663745044c3881171359fdba082bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410b3274a3dc59d4886e985151f4657c"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a410b3274a3dc59d4886e985151f4657c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a410b3274a3dc59d4886e985151f4657c.html#a410b3274a3dc59d4886e985151f4657c">lgamma</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a410b3274a3dc59d4886e985151f4657c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log gamma function for variables (C99).  <br /></td></tr>
<tr class="separator:a410b3274a3dc59d4886e985151f4657c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb651f7e7681a1e21bb88ea6ba242cf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeb651f7e7681a1e21bb88ea6ba242cf6.html#aeb651f7e7681a1e21bb88ea6ba242cf6">lmgamma</a> (int a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:aeb651f7e7681a1e21bb88ea6ba242cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa794b0437e78aaf70691215e3797675d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa794b0437e78aaf70691215e3797675d.html#aa794b0437e78aaf70691215e3797675d">lmultiply</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:aa794b0437e78aaf70691215e3797675d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a*log(b).  <br /></td></tr>
<tr class="separator:aa794b0437e78aaf70691215e3797675d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa731707ebca797a73bb042c4f6ae7cc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa731707ebca797a73bb042c4f6ae7cc2.html#aa731707ebca797a73bb042c4f6ae7cc2">lmultiply</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:aa731707ebca797a73bb042c4f6ae7cc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a*log(b).  <br /></td></tr>
<tr class="separator:aa731707ebca797a73bb042c4f6ae7cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dbc3c7013e61c68da968ecd7ee68628"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3dbc3c7013e61c68da968ecd7ee68628.html#a3dbc3c7013e61c68da968ecd7ee68628">lmultiply</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a3dbc3c7013e61c68da968ecd7ee68628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a*log(b).  <br /></td></tr>
<tr class="separator:a3dbc3c7013e61c68da968ecd7ee68628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888e8c0c2053d796f168688ffb49a530"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a888e8c0c2053d796f168688ffb49a530"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a888e8c0c2053d796f168688ffb49a530.html#a888e8c0c2053d796f168688ffb49a530">log</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a888e8c0c2053d796f168688ffb49a530"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural log of the specified variable (cmath).  <br /></td></tr>
<tr class="separator:a888e8c0c2053d796f168688ffb49a530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08792296e163ca7915cb4e0c13f4c7ab"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a08792296e163ca7915cb4e0c13f4c7ab.html#a08792296e163ca7915cb4e0c13f4c7ab">log</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a08792296e163ca7915cb4e0c13f4c7ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm (base e) of the specified complex argument.  <br /></td></tr>
<tr class="separator:a08792296e163ca7915cb4e0c13f4c7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61f3f2628ea6738053a585afd2b6204"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa61f3f2628ea6738053a585afd2b6204"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa61f3f2628ea6738053a585afd2b6204.html#aa61f3f2628ea6738053a585afd2b6204">log10</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:aa61f3f2628ea6738053a585afd2b6204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base 10 log of the specified variable (cmath).  <br /></td></tr>
<tr class="separator:aa61f3f2628ea6738053a585afd2b6204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2de58256499611eac15e3e488fed8227"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2de58256499611eac15e3e488fed8227.html#a2de58256499611eac15e3e488fed8227">log10</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a2de58256499611eac15e3e488fed8227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base 10 logarithm of the specified complex number.  <br /></td></tr>
<tr class="separator:a2de58256499611eac15e3e488fed8227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5194f1e5ff8c670c7e1e844ab13d8d"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3b5194f1e5ff8c670c7e1e844ab13d8d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3b5194f1e5ff8c670c7e1e844ab13d8d.html#a3b5194f1e5ff8c670c7e1e844ab13d8d">log1m</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a3b5194f1e5ff8c670c7e1e844ab13d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log (1 - x) function for variables.  <br /></td></tr>
<tr class="separator:a3b5194f1e5ff8c670c7e1e844ab13d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cbca625898abc97dc88fd241af38cb0"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9cbca625898abc97dc88fd241af38cb0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9cbca625898abc97dc88fd241af38cb0.html#a9cbca625898abc97dc88fd241af38cb0">log1m_exp</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a9cbca625898abc97dc88fd241af38cb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of 1 minus the exponential of the specified variable.  <br /></td></tr>
<tr class="separator:a9cbca625898abc97dc88fd241af38cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295debc5e539aed7163cf533db1a8d43"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a295debc5e539aed7163cf533db1a8d43"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a295debc5e539aed7163cf533db1a8d43.html#a295debc5e539aed7163cf533db1a8d43">log1m_inv_logit</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;u)</td></tr>
<tr class="memdesc:a295debc5e539aed7163cf533db1a8d43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of one minus the inverse logit of the specified argument.  <br /></td></tr>
<tr class="separator:a295debc5e539aed7163cf533db1a8d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7c978b9930017bde80a3871ce86107"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5e7c978b9930017bde80a3871ce86107"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5e7c978b9930017bde80a3871ce86107.html#a5e7c978b9930017bde80a3871ce86107">log1p</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a5e7c978b9930017bde80a3871ce86107"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log (1 + x) function for variables (C99).  <br /></td></tr>
<tr class="separator:a5e7c978b9930017bde80a3871ce86107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef0ceb5289da23b3685612e5dedf344"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2ef0ceb5289da23b3685612e5dedf344"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2ef0ceb5289da23b3685612e5dedf344.html#a2ef0ceb5289da23b3685612e5dedf344">log1p_exp</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a2ef0ceb5289da23b3685612e5dedf344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log of 1 plus the exponential of the specified variable.  <br /></td></tr>
<tr class="separator:a2ef0ceb5289da23b3685612e5dedf344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaef1edcd42aa9bbe4f44b10a1f5af7c"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abaef1edcd42aa9bbe4f44b10a1f5af7c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abaef1edcd42aa9bbe4f44b10a1f5af7c.html#abaef1edcd42aa9bbe4f44b10a1f5af7c">log2</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:abaef1edcd42aa9bbe4f44b10a1f5af7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the base 2 logarithm of the specified variable (C99).  <br /></td></tr>
<tr class="separator:abaef1edcd42aa9bbe4f44b10a1f5af7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0859b02976d1968af674a3f78c896f55"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0859b02976d1968af674a3f78c896f55"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0859b02976d1968af674a3f78c896f55.html#a0859b02976d1968af674a3f78c896f55">log_determinant</a> (const T &amp;m)</td></tr>
<tr class="separator:a0859b02976d1968af674a3f78c896f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84bc912cc5e160919fb792981e6ab2c"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa84bc912cc5e160919fb792981e6ab2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa84bc912cc5e160919fb792981e6ab2c.html#aa84bc912cc5e160919fb792981e6ab2c">log_determinant_ldlt</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T &gt; &amp;A)</td></tr>
<tr class="memdesc:aa84bc912cc5e160919fb792981e6ab2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log det of the matrix whose LDLT factorization is given.  <br /></td></tr>
<tr class="separator:aa84bc912cc5e160919fb792981e6ab2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee476f54e790c60b71d36f2831fa3cb"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaee476f54e790c60b71d36f2831fa3cb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaee476f54e790c60b71d36f2831fa3cb.html#aaee476f54e790c60b71d36f2831fa3cb">log_determinant_spd</a> (const T &amp;M)</td></tr>
<tr class="memdesc:aaee476f54e790c60b71d36f2831fa3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log det of a symmetric, positive-definite matrix.  <br /></td></tr>
<tr class="separator:aaee476f54e790c60b71d36f2831fa3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6916bb5af6f1aa7ff76fa85f7605fa4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6916bb5af6f1aa7ff76fa85f7605fa4f.html#a6916bb5af6f1aa7ff76fa85f7605fa4f">log_diff_exp</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a6916bb5af6f1aa7ff76fa85f7605fa4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log difference of the exponentiated arguments.  <br /></td></tr>
<tr class="separator:a6916bb5af6f1aa7ff76fa85f7605fa4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c386d9b793f1fec1512c0892208a90b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c386d9b793f1fec1512c0892208a90b.html#a1c386d9b793f1fec1512c0892208a90b">log_diff_exp</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:a1c386d9b793f1fec1512c0892208a90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log difference of the exponentiated arguments.  <br /></td></tr>
<tr class="separator:a1c386d9b793f1fec1512c0892208a90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4424b6514fe72fed6b9c768df3ad8a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab4424b6514fe72fed6b9c768df3ad8a5.html#ab4424b6514fe72fed6b9c768df3ad8a5">log_diff_exp</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:ab4424b6514fe72fed6b9c768df3ad8a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log difference of the exponentiated arguments.  <br /></td></tr>
<tr class="separator:ab4424b6514fe72fed6b9c768df3ad8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b3417777ab6e39a1a3a0f092ed8f6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab6b3417777ab6e39a1a3a0f092ed8f6a.html#ab6b3417777ab6e39a1a3a0f092ed8f6a">log_falling_factorial</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="separator:ab6b3417777ab6e39a1a3a0f092ed8f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6fbe2cf74d7dc89d10999d512c3efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1a6fbe2cf74d7dc89d10999d512c3efd.html#a1a6fbe2cf74d7dc89d10999d512c3efd">log_falling_factorial</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:a1a6fbe2cf74d7dc89d10999d512c3efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31cf25da5e04a8c887c3d64cf0f3fa78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a31cf25da5e04a8c887c3d64cf0f3fa78.html#a31cf25da5e04a8c887c3d64cf0f3fa78">log_falling_factorial</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:a31cf25da5e04a8c887c3d64cf0f3fa78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66666677ee597790f803ca9059e37355"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__arithmetic__types_ga21fad8aea7b9f231cb2a85d59a9af6d8.html#ga21fad8aea7b9f231cb2a85d59a9af6d8">require_arithmetic_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a66666677ee597790f803ca9059e37355"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a66666677ee597790f803ca9059e37355.html#a66666677ee597790f803ca9059e37355">log_inv_logit</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;u)</td></tr>
<tr class="memdesc:a66666677ee597790f803ca9059e37355"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the natural logarithm of the inverse logit of the specified argument.  <br /></td></tr>
<tr class="separator:a66666677ee597790f803ca9059e37355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3145fc95d006f95b88b7075e48e0012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab3145fc95d006f95b88b7075e48e0012.html#ab3145fc95d006f95b88b7075e48e0012">log_inv_logit_diff</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="separator:ab3145fc95d006f95b88b7075e48e0012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce0d0a18ea1b0b7eccb5d8903f8238a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adce0d0a18ea1b0b7eccb5d8903f8238a.html#adce0d0a18ea1b0b7eccb5d8903f8238a">log_inv_logit_diff</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:adce0d0a18ea1b0b7eccb5d8903f8238a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefc6cdabf27fe0bf9899d1944b78efa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeefc6cdabf27fe0bf9899d1944b78efa.html#aeefc6cdabf27fe0bf9899d1944b78efa">log_inv_logit_diff</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:aeefc6cdabf27fe0bf9899d1944b78efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225cdbe3feeeaad5db32221e76308b97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a225cdbe3feeeaad5db32221e76308b97.html#a225cdbe3feeeaad5db32221e76308b97">log_mix_partial_helper</a> (double theta_val, double lambda1_val, double lambda2_val, double &amp;one_m_exp_lam2_m_lam1, double &amp;one_m_t_prod_exp_lam2_m_lam1, double &amp;one_d_t_plus_one_m_t_prod_exp_lam2_m_lam1)</td></tr>
<tr class="separator:a225cdbe3feeeaad5db32221e76308b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4ae9c6c770d54f44b03327eb22e7af"><td class="memTemplParams" colspan="2">template&lt;typename T_theta , typename T_lambda1 , typename T_lambda2 , <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; T_theta, T_lambda1, T_lambda2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8d4ae9c6c770d54f44b03327eb22e7af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_theta, T_lambda1, T_lambda2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8d4ae9c6c770d54f44b03327eb22e7af.html#a8d4ae9c6c770d54f44b03327eb22e7af">log_mix</a> (const T_theta &amp;theta, const T_lambda1 &amp;lambda1, const T_lambda2 &amp;lambda2)</td></tr>
<tr class="memdesc:a8d4ae9c6c770d54f44b03327eb22e7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log mixture density with specified mixing proportion and log densities and its derivative at each.  <br /></td></tr>
<tr class="separator:a8d4ae9c6c770d54f44b03327eb22e7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa081fd14b225407c25d4e449c6f5669c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa081fd14b225407c25d4e449c6f5669c.html#aa081fd14b225407c25d4e449c6f5669c">log_rising_factorial</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="separator:aa081fd14b225407c25d4e449c6f5669c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ff05bb4af6475162c98f06f5ccd186"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a57ff05bb4af6475162c98f06f5ccd186.html#a57ff05bb4af6475162c98f06f5ccd186">log_rising_factorial</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:a57ff05bb4af6475162c98f06f5ccd186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad383a9d188278c83646bc396a7b61667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad383a9d188278c83646bc396a7b61667.html#ad383a9d188278c83646bc396a7b61667">log_rising_factorial</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="separator:ad383a9d188278c83646bc396a7b61667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace802519de7ab3825f5c25a206f0ce90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ace802519de7ab3825f5c25a206f0ce90.html#ace802519de7ab3825f5c25a206f0ce90">log_sum_exp</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:ace802519de7ab3825f5c25a206f0ce90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials.  <br /></td></tr>
<tr class="separator:ace802519de7ab3825f5c25a206f0ce90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411ba67a946581565fcf6e7b69792150"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a411ba67a946581565fcf6e7b69792150.html#a411ba67a946581565fcf6e7b69792150">log_sum_exp</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:a411ba67a946581565fcf6e7b69792150"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials.  <br /></td></tr>
<tr class="separator:a411ba67a946581565fcf6e7b69792150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c8fa3248ed5b8d83ad12676bec8c91f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1c8fa3248ed5b8d83ad12676bec8c91f.html#a1c8fa3248ed5b8d83ad12676bec8c91f">log_sum_exp</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a1c8fa3248ed5b8d83ad12676bec8c91f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials.  <br /></td></tr>
<tr class="separator:a1c8fa3248ed5b8d83ad12676bec8c91f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae39ae6449b70b2437c9a55501bd865"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga51f433bbb5e3f53af4ef6dc9bc84b7af.html#ga51f433bbb5e3f53af4ef6dc9bc84b7af">require_eigen_st</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga473bd4130f7623863172475fcb56344a.html#ga473bd4130f7623863172475fcb56344a">require_not_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7ae39ae6449b70b2437c9a55501bd865"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7ae39ae6449b70b2437c9a55501bd865.html#a7ae39ae6449b70b2437c9a55501bd865">log_sum_exp</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a7ae39ae6449b70b2437c9a55501bd865"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials of the input.  <br /></td></tr>
<tr class="separator:a7ae39ae6449b70b2437c9a55501bd865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb7aed98e9802cf82ffbf130e684545"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6bb7aed98e9802cf82ffbf130e684545"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6bb7aed98e9802cf82ffbf130e684545.html#a6bb7aed98e9802cf82ffbf130e684545">log_sum_exp</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a6bb7aed98e9802cf82ffbf130e684545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log sum of exponentials of the input.  <br /></td></tr>
<tr class="separator:a6bb7aed98e9802cf82ffbf130e684545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99df157eadf939eff9ad6cfed7166be"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae99df157eadf939eff9ad6cfed7166be"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae99df157eadf939eff9ad6cfed7166be.html#ae99df157eadf939eff9ad6cfed7166be">logit</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;u)</td></tr>
<tr class="memdesc:ae99df157eadf939eff9ad6cfed7166be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the log odds of the specified argument.  <br /></td></tr>
<tr class="separator:ae99df157eadf939eff9ad6cfed7166be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8592bb8609545a2daffb8abfbbdb3c55"><td class="memTemplParams" colspan="2">template&lt;typename Ta , typename Tb , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; Ta, Tb &gt; *  = nullptr, <a class="el" href="group__autodiff__types_ga6616a05cabec4f81562db410ade4d2a5.html#ga6616a05cabec4f81562db410ade4d2a5">require_any_st_autodiff</a>&lt; Ta, Tb &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8592bb8609545a2daffb8abfbbdb3c55"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; Ta, Tb &gt;, -1, Tb::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8592bb8609545a2daffb8abfbbdb3c55.html#a8592bb8609545a2daffb8abfbbdb3c55">matrix_exp_multiply</a> (const Ta &amp;A, const Tb &amp;B)</td></tr>
<tr class="memdesc:a8592bb8609545a2daffb8abfbbdb3c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper of matrix_exp_action function for a more literal name.  <br /></td></tr>
<tr class="separator:a8592bb8609545a2daffb8abfbbdb3c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9a33855beb4a793b86e195d6d75d31"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aad9a33855beb4a793b86e195d6d75d31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_a6467d85854e3794e24a3218113dd08ca.html#a6467d85854e3794e24a3218113dd08ca">plain_type_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aad9a33855beb4a793b86e195d6d75d31.html#aad9a33855beb4a793b86e195d6d75d31">matrix_power</a> (const T &amp;M, const int n)</td></tr>
<tr class="memdesc:aad9a33855beb4a793b86e195d6d75d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nth power of the specific matrix.  <br /></td></tr>
<tr class="separator:aad9a33855beb4a793b86e195d6d75d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8181dae88ac0081edbd88cc23b77d3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__var__types_gad4fb966d630ab09756dbc3a1bfd495d4.html#gad4fb966d630ab09756dbc3a1bfd495d4">require_any_st_var</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4a8181dae88ac0081edbd88cc23b77d3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4a8181dae88ac0081edbd88cc23b77d3.html#a4a8181dae88ac0081edbd88cc23b77d3">mdivide_left</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:a4a8181dae88ac0081edbd88cc23b77d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution <code>X</code> of <code>AX = B</code>.  <br /></td></tr>
<tr class="separator:a4a8181dae88ac0081edbd88cc23b77d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed89b2ce5e47d085f52db7438f43300"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__var__types_gad4fb966d630ab09756dbc3a1bfd495d4.html#gad4fb966d630ab09756dbc3a1bfd495d4">require_any_st_var</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abed89b2ce5e47d085f52db7438f43300"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abed89b2ce5e47d085f52db7438f43300.html#abed89b2ce5e47d085f52db7438f43300">mdivide_left_ldlt</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T1 &gt; &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:abed89b2ce5e47d085f52db7438f43300"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=b given an <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html" title="LDLT_factor is a structure that holds a matrix of type T and the LDLT of its values.">LDLT_factor</a> of A.  <br /></td></tr>
<tr class="separator:abed89b2ce5e47d085f52db7438f43300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098e7f87f50afdd59ace85cc43fe0e56"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__matrix__base__types_ga9b37f9344722276cf99c50d0afc4ff03.html#ga9b37f9344722276cf99c50d0afc4ff03">require_all_eigen_matrix_base_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a098e7f87f50afdd59ace85cc43fe0e56"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a098e7f87f50afdd59ace85cc43fe0e56.html#a098e7f87f50afdd59ace85cc43fe0e56">mdivide_left_spd</a> (const EigMat1 &amp;A, const EigMat2 &amp;b)</td></tr>
<tr class="separator:a098e7f87f50afdd59ace85cc43fe0e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903d1a68bcba2cd689405f1ce28de093"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__matrix__base__types_ga98a5a34d38ab300e936c2ec66794bcca.html#ga98a5a34d38ab300e936c2ec66794bcca">require_eigen_matrix_base_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, EigMat1 &gt; *  = nullptr, <a class="el" href="group__eigen__matrix__base__types_ga98a5a34d38ab300e936c2ec66794bcca.html#ga98a5a34d38ab300e936c2ec66794bcca">require_eigen_matrix_base_vt</a>&lt; std::is_arithmetic, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a903d1a68bcba2cd689405f1ce28de093"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, EigMat1::RowsAtCompileTime, EigMat2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a903d1a68bcba2cd689405f1ce28de093.html#a903d1a68bcba2cd689405f1ce28de093">mdivide_left_spd</a> (const EigMat1 &amp;A, const EigMat2 &amp;b)</td></tr>
<tr class="separator:a903d1a68bcba2cd689405f1ce28de093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb3e0bbefb4bbfc18dbb320c80dab71"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_gaf9240f628acb5b6ce46e70cd20f93e0f.html#gaf9240f628acb5b6ce46e70cd20f93e0f">require_any_var_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abeb3e0bbefb4bbfc18dbb320c80dab71"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abeb3e0bbefb4bbfc18dbb320c80dab71.html#abeb3e0bbefb4bbfc18dbb320c80dab71">mdivide_left_spd</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:abeb3e0bbefb4bbfc18dbb320c80dab71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the solution of the system Ax=B where A is symmetric positive definite.  <br /></td></tr>
<tr class="separator:abeb3e0bbefb4bbfc18dbb320c80dab71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe54791e42c0e781c3fcb0aa362d3a94"><td class="memTemplParams" colspan="2">template&lt;Eigen::UpLoType TriView, typename T1 , typename T2 , <a class="el" href="group__eigen__types_ga06fcddbaf041c31d2c20c8b006ebba79.html#ga06fcddbaf041c31d2c20c8b006ebba79">require_all_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abe54791e42c0e781c3fcb0aa362d3a94"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abe54791e42c0e781c3fcb0aa362d3a94.html#abe54791e42c0e781c3fcb0aa362d3a94">mdivide_left_tri</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="separator:abe54791e42c0e781c3fcb0aa362d3a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b0904ff1c7a95f87d86491bbededfd"><td class="memTemplParams" colspan="2">template&lt;Eigen::UpLoType TriView, typename T1 , typename T2 , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; std::is_arithmetic, T1 &gt; *  = nullptr, <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a24b0904ff1c7a95f87d86491bbededfd"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, T1::RowsAtCompileTime, T2::ColsAtCompileTime &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a24b0904ff1c7a95f87d86491bbededfd.html#a24b0904ff1c7a95f87d86491bbededfd">mdivide_left_tri</a> (const T1 &amp;A, const T2 &amp;b)</td></tr>
<tr class="separator:a24b0904ff1c7a95f87d86491bbededfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb1f488a4e237404d4c19238ee0095f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acb1f488a4e237404d4c19238ee0095f0.html#acb1f488a4e237404d4c19238ee0095f0">modified_bessel_first_kind</a> (int v, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="separator:acb1f488a4e237404d4c19238ee0095f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a635aeb34fe4c2f0feb6f6de54a4b1c98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a635aeb34fe4c2f0feb6f6de54a4b1c98.html#a635aeb34fe4c2f0feb6f6de54a4b1c98">modified_bessel_second_kind</a> (int v, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="separator:a635aeb34fe4c2f0feb6f6de54a4b1c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c5d1cba05e082e468394178fb77b82"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="namespacestan_a3671feedf945127c24a500b77adc594c.html#a3671feedf945127c24a500b77adc594c">require_return_type_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T1, T2 &gt; *  = nullptr, <a class="el" href="namespacestan_a239a870a9b8b94102aac34d707938d6a.html#a239a870a9b8b94102aac34d707938d6a">require_not_row_and_col_vector_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad6c5d1cba05e082e468394178fb77b82"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad6c5d1cba05e082e468394178fb77b82.html#ad6c5d1cba05e082e468394178fb77b82">multiply</a> (T1 &amp;&amp;A, T2 &amp;&amp;B)</td></tr>
<tr class="memdesc:ad6c5d1cba05e082e468394178fb77b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of two matrices.  <br /></td></tr>
<tr class="separator:ad6c5d1cba05e082e468394178fb77b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7061a9c697c18e3a85737f37eb5d94c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="namespacestan_a3671feedf945127c24a500b77adc594c.html#a3671feedf945127c24a500b77adc594c">require_return_type_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T1, T2 &gt; *  = nullptr, <a class="el" href="namespacestan_ae507d2c91337fb5e46024439310b5f70.html#ae507d2c91337fb5e46024439310b5f70">require_row_and_col_vector_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa7061a9c697c18e3a85737f37eb5d94c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa7061a9c697c18e3a85737f37eb5d94c.html#aa7061a9c697c18e3a85737f37eb5d94c">multiply</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:aa7061a9c697c18e3a85737f37eb5d94c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the product of a row vector times a column vector as a scalar.  <br /></td></tr>
<tr class="separator:aa7061a9c697c18e3a85737f37eb5d94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f3f5052636839e26caacc2dda78acd"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__matrix__types_ga3a8b7e7f43a20a6e3ca35cae5b956cbd.html#ga3a8b7e7f43a20a6e3ca35cae5b956cbd">require_not_matrix_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T2 &gt; *  = nullptr, <a class="el" href="namespacestan_a3671feedf945127c24a500b77adc594c.html#a3671feedf945127c24a500b77adc594c">require_return_type_t</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T1, T2 &gt; *  = nullptr, <a class="el" href="namespacestan_a239a870a9b8b94102aac34d707938d6a.html#a239a870a9b8b94102aac34d707938d6a">require_not_row_and_col_vector_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a08f3f5052636839e26caacc2dda78acd"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a08f3f5052636839e26caacc2dda78acd.html#a08f3f5052636839e26caacc2dda78acd">multiply</a> (const T1 &amp;a, T2 &amp;&amp;B)</td></tr>
<tr class="memdesc:a08f3f5052636839e26caacc2dda78acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified matrix multiplied by specified scalar where at least one input has a scalar type of a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code>.  <br /></td></tr>
<tr class="separator:a08f3f5052636839e26caacc2dda78acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f60d393f1ab5eb58ba12397d5e0fe00"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__matrix__types_ga3a8b7e7f43a20a6e3ca35cae5b956cbd.html#ga3a8b7e7f43a20a6e3ca35cae5b956cbd">require_not_matrix_t</a>&lt; T2 &gt; *  = nullptr, <a class="el" href="group__var__types_gad4fb966d630ab09756dbc3a1bfd495d4.html#gad4fb966d630ab09756dbc3a1bfd495d4">require_any_st_var</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__complex__types_ga3d92736c03356df12307fb596d0fd805.html#ga3d92736c03356df12307fb596d0fd805">require_not_complex_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T1 &gt; &gt; *  = nullptr, <a class="el" href="group__complex__types_ga3d92736c03356df12307fb596d0fd805.html#ga3d92736c03356df12307fb596d0fd805">require_not_complex_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T2 &gt; &gt; *  = nullptr, <a class="el" href="namespacestan_a239a870a9b8b94102aac34d707938d6a.html#a239a870a9b8b94102aac34d707938d6a">require_not_row_and_col_vector_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1f60d393f1ab5eb58ba12397d5e0fe00"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1f60d393f1ab5eb58ba12397d5e0fe00.html#a1f60d393f1ab5eb58ba12397d5e0fe00">multiply</a> (T1 &amp;&amp;A, T2 &amp;&amp;B)</td></tr>
<tr class="memdesc:a1f60d393f1ab5eb58ba12397d5e0fe00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return specified matrix multiplied by specified scalar where at least one input has a scalar type of a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code>.  <br /></td></tr>
<tr class="separator:a1f60d393f1ab5eb58ba12397d5e0fe00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434dc59c697c4f61cee354b4bbeed7af"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__var__matrix__types_gaf9240f628acb5b6ce46e70cd20f93e0f.html#gaf9240f628acb5b6ce46e70cd20f93e0f">require_any_var_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a434dc59c697c4f61cee354b4bbeed7af"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a434dc59c697c4f61cee354b4bbeed7af.html#a434dc59c697c4f61cee354b4bbeed7af">operator*</a> (T1 &amp;&amp;a, T2 &amp;&amp;b)</td></tr>
<tr class="memdesc:a434dc59c697c4f61cee354b4bbeed7af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator overload for multiplying a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Matrix&gt;</code>.  <br /></td></tr>
<tr class="separator:a434dc59c697c4f61cee354b4bbeed7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da7e77b75bf5f288ddc7c546f941c70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3da7e77b75bf5f288ddc7c546f941c70.html#a3da7e77b75bf5f288ddc7c546f941c70">multiply_log</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a3da7e77b75bf5f288ddc7c546f941c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a*log(b).  <br /></td></tr>
<tr class="separator:a3da7e77b75bf5f288ddc7c546f941c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad003d3402294c4b06e2e7ec4ed8b117b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad003d3402294c4b06e2e7ec4ed8b117b.html#ad003d3402294c4b06e2e7ec4ed8b117b">multiply_log</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:ad003d3402294c4b06e2e7ec4ed8b117b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a*log(b).  <br /></td></tr>
<tr class="separator:ad003d3402294c4b06e2e7ec4ed8b117b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b018469138223a1ffb1bb533855a00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a78b018469138223a1ffb1bb533855a00.html#a78b018469138223a1ffb1bb533855a00">multiply_log</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a78b018469138223a1ffb1bb533855a00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of a*log(b).  <br /></td></tr>
<tr class="separator:a78b018469138223a1ffb1bb533855a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238fefb3948c85a4a691440f4259d7b1"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a238fefb3948c85a4a691440f4259d7b1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a238fefb3948c85a4a691440f4259d7b1.html#a238fefb3948c85a4a691440f4259d7b1">multiply_lower_tri_self_transpose</a> (const T &amp;L)</td></tr>
<tr class="separator:a238fefb3948c85a4a691440f4259d7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c041fd900c60e610c9beba69630bd3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4c041fd900c60e610c9beba69630bd3a.html#a4c041fd900c60e610c9beba69630bd3a">norm</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a4c041fd900c60e610c9beba69630bd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the squared magnitude of the complex argument.  <br /></td></tr>
<tr class="separator:a4c041fd900c60e610c9beba69630bd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed9eb3c5608e15f33d215208646b734"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__vector__types_ga896401ad33967867f49cd60ca10d990e.html#ga896401ad33967867f49cd60ca10d990e">require_eigen_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9ed9eb3c5608e15f33d215208646b734"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ed9eb3c5608e15f33d215208646b734.html#a9ed9eb3c5608e15f33d215208646b734">norm1</a> (const T &amp;v)</td></tr>
<tr class="memdesc:a9ed9eb3c5608e15f33d215208646b734"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the L1 norm of a vector of var.  <br /></td></tr>
<tr class="separator:a9ed9eb3c5608e15f33d215208646b734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec92d584fff400826bdd7f10180db4fb"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__vector__types_ga896401ad33967867f49cd60ca10d990e.html#ga896401ad33967867f49cd60ca10d990e">require_eigen_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aec92d584fff400826bdd7f10180db4fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aec92d584fff400826bdd7f10180db4fb.html#aec92d584fff400826bdd7f10180db4fb">norm2</a> (const T &amp;v)</td></tr>
<tr class="memdesc:aec92d584fff400826bdd7f10180db4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the L2 norm of a vector of var.  <br /></td></tr>
<tr class="separator:aec92d584fff400826bdd7f10180db4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce972c51c4f103eedca6e7a0920dc72"><td class="memTemplParams" colspan="2">template&lt;typename Var1 , typename Var2 , <a class="el" href="group__var__types_gab1027292c8c5b7c1da51c40fcd93fd3f.html#gab1027292c8c5b7c1da51c40fcd93fd3f">require_all_st_var</a>&lt; Var1, Var2 &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga613a895eb09b0a2c56cf757f08e3b1d0.html#ga613a895eb09b0a2c56cf757f08e3b1d0">require_all_not_std_vector_t</a>&lt; Var1, Var2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8ce972c51c4f103eedca6e7a0920dc72"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8ce972c51c4f103eedca6e7a0920dc72.html#a8ce972c51c4f103eedca6e7a0920dc72">owens_t</a> (const Var1 &amp;h, const Var2 &amp;a)</td></tr>
<tr class="memdesc:a8ce972c51c4f103eedca6e7a0920dc72"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Owen's T function of h and a.  <br /></td></tr>
<tr class="separator:a8ce972c51c4f103eedca6e7a0920dc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bb56fce707d5e370839fc056d83eb6"><td class="memTemplParams" colspan="2">template&lt;typename Var , typename Arith , <a class="el" href="group__arithmetic__types_ga948d431ec5773ff848a6bfa0d0b7aa79.html#ga948d431ec5773ff848a6bfa0d0b7aa79">require_st_arithmetic</a>&lt; Arith &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga613a895eb09b0a2c56cf757f08e3b1d0.html#ga613a895eb09b0a2c56cf757f08e3b1d0">require_all_not_std_vector_t</a>&lt; Var, Arith &gt; *  = nullptr, <a class="el" href="group__var__types_ga9cd233f257c8219f5b318a96ca31c6f2.html#ga9cd233f257c8219f5b318a96ca31c6f2">require_st_var</a>&lt; Var &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab0bb56fce707d5e370839fc056d83eb6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab0bb56fce707d5e370839fc056d83eb6.html#ab0bb56fce707d5e370839fc056d83eb6">owens_t</a> (const Var &amp;h, const Arith &amp;a)</td></tr>
<tr class="memdesc:ab0bb56fce707d5e370839fc056d83eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Owen's T function of h and a.  <br /></td></tr>
<tr class="separator:ab0bb56fce707d5e370839fc056d83eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb8be1f60a252a12ff25e4114c9c1a0"><td class="memTemplParams" colspan="2">template&lt;typename Arith , typename Var , <a class="el" href="group__arithmetic__types_ga948d431ec5773ff848a6bfa0d0b7aa79.html#ga948d431ec5773ff848a6bfa0d0b7aa79">require_st_arithmetic</a>&lt; Arith &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga613a895eb09b0a2c56cf757f08e3b1d0.html#ga613a895eb09b0a2c56cf757f08e3b1d0">require_all_not_std_vector_t</a>&lt; Var, Arith &gt; *  = nullptr, <a class="el" href="group__var__types_ga9cd233f257c8219f5b318a96ca31c6f2.html#ga9cd233f257c8219f5b318a96ca31c6f2">require_st_var</a>&lt; Var &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5fb8be1f60a252a12ff25e4114c9c1a0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5fb8be1f60a252a12ff25e4114c9c1a0.html#a5fb8be1f60a252a12ff25e4114c9c1a0">owens_t</a> (const Arith &amp;h, const Var &amp;a)</td></tr>
<tr class="memdesc:a5fb8be1f60a252a12ff25e4114c9c1a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Owen's T function of h and a.  <br /></td></tr>
<tr class="separator:a5fb8be1f60a252a12ff25e4114c9c1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdc45f7a61effed182f9339318a44b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8cdc45f7a61effed182f9339318a44b8.html#a8cdc45f7a61effed182f9339318a44b8">Phi</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a8cdc45f7a61effed182f9339318a44b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The unit normal cumulative density function for variables (stan).  <br /></td></tr>
<tr class="separator:a8cdc45f7a61effed182f9339318a44b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0888540b70220ffd69e0a249a1625f88"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0888540b70220ffd69e0a249a1625f88"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0888540b70220ffd69e0a249a1625f88.html#a0888540b70220ffd69e0a249a1625f88">Phi</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a0888540b70220ffd69e0a249a1625f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elementwise unit normal cumulative density function for varmat types.  <br /></td></tr>
<tr class="separator:a0888540b70220ffd69e0a249a1625f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a33b2b613aa294e78d92704f9b23db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a62a33b2b613aa294e78d92704f9b23db.html#a62a33b2b613aa294e78d92704f9b23db">Phi_approx</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a62a33b2b613aa294e78d92704f9b23db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximation of the unit normal CDF for variables (stan).  <br /></td></tr>
<tr class="separator:a62a33b2b613aa294e78d92704f9b23db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6681fe46a4c8fae11d60dd80e850d4eb"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6681fe46a4c8fae11d60dd80e850d4eb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6681fe46a4c8fae11d60dd80e850d4eb.html#a6681fe46a4c8fae11d60dd80e850d4eb">Phi_approx</a> (const T &amp;a)</td></tr>
<tr class="separator:a6681fe46a4c8fae11d60dd80e850d4eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434bccb1f84419920deb38c6c0208a61"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a434bccb1f84419920deb38c6c0208a61.html#a434bccb1f84419920deb38c6c0208a61">polar</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;r, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;theta)</td></tr>
<tr class="memdesc:a434bccb1f84419920deb38c6c0208a61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns complex number with specified magnitude and phase angle.  <br /></td></tr>
<tr class="separator:a434bccb1f84419920deb38c6c0208a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82051e297ac97c602e205248a9d7edbb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a82051e297ac97c602e205248a9d7edbb"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a82051e297ac97c602e205248a9d7edbb.html#a82051e297ac97c602e205248a9d7edbb">polar</a> (T r, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;theta)</td></tr>
<tr class="memdesc:a82051e297ac97c602e205248a9d7edbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns complex number with specified magnitude and phase angle.  <br /></td></tr>
<tr class="separator:a82051e297ac97c602e205248a9d7edbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99d4f8bcb5133784b10ad29a59dfac1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac99d4f8bcb5133784b10ad29a59dfac1"><td class="memTemplItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac99d4f8bcb5133784b10ad29a59dfac1.html#ac99d4f8bcb5133784b10ad29a59dfac1">polar</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;r, T theta)</td></tr>
<tr class="memdesc:ac99d4f8bcb5133784b10ad29a59dfac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns complex number with specified magnitude and phase angle.  <br /></td></tr>
<tr class="separator:ac99d4f8bcb5133784b10ad29a59dfac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add99d47bc66aa42e071dece3b51b1ba0"><td class="memTemplParams" colspan="2">template&lt;typename Scal1 , typename Scal2 , <a class="el" href="group__var__types_ga6d733e03bef0f79faee9c5cc6dd8711c.html#ga6d733e03bef0f79faee9c5cc6dd8711c">require_any_var_t</a>&lt; <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; Scal1 &gt;, <a class="el" href="namespacestan_ac0fcd9f3e82f72b645ce2eaf9d9a3eea.html#ac0fcd9f3e82f72b645ce2eaf9d9a3eea">base_type_t</a>&lt; Scal2 &gt; &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; Scal1, Scal2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:add99d47bc66aa42e071dece3b51b1ba0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_add99d47bc66aa42e071dece3b51b1ba0.html#add99d47bc66aa42e071dece3b51b1ba0">pow</a> (const Scal1 &amp;base, const Scal2 &amp;exponent)</td></tr>
<tr class="memdesc:add99d47bc66aa42e071dece3b51b1ba0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base raised to the power of the exponent (cmath).  <br /></td></tr>
<tr class="separator:add99d47bc66aa42e071dece3b51b1ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157195dd19270eb1233a50d5412ef439"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , <a class="el" href="group__var__or__arithmetic__types_ga5061e6f2e948a07b90bd6b0cde025e9e.html#ga5061e6f2e948a07b90bd6b0cde025e9e">require_all_st_var_or_arithmetic</a>&lt; Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="group__matrix__types_ga70c16a1cddf15a4e247b27efdf8fe3d3.html#ga70c16a1cddf15a4e247b27efdf8fe3d3">require_any_matrix_st</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5c53542c941050f5955538f4068266ae.html#ga5c53542c941050f5955538f4068266ae">require_all_not_stan_scalar_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a157195dd19270eb1233a50d5412ef439"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a157195dd19270eb1233a50d5412ef439.html#a157195dd19270eb1233a50d5412ef439">pow</a> (const Mat1 &amp;base, const Mat2 &amp;exponent)</td></tr>
<tr class="memdesc:a157195dd19270eb1233a50d5412ef439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base raised to the power of the exponent (cmath).  <br /></td></tr>
<tr class="separator:a157195dd19270eb1233a50d5412ef439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5f02cbf4087632e65c55ef4aa01ba8"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Scal1 , <a class="el" href="group__var__or__arithmetic__types_ga5061e6f2e948a07b90bd6b0cde025e9e.html#ga5061e6f2e948a07b90bd6b0cde025e9e">require_all_st_var_or_arithmetic</a>&lt; Mat1, Scal1 &gt; *  = nullptr, <a class="el" href="group__matrix__types_gabb3c2790817a1e89e13bdbf460bce37b.html#gabb3c2790817a1e89e13bdbf460bce37b">require_all_matrix_st</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, Mat1 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal1 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9e5f02cbf4087632e65c55ef4aa01ba8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9e5f02cbf4087632e65c55ef4aa01ba8.html#a9e5f02cbf4087632e65c55ef4aa01ba8">pow</a> (const Mat1 &amp;base, const Scal1 &amp;exponent)</td></tr>
<tr class="memdesc:a9e5f02cbf4087632e65c55ef4aa01ba8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base raised to the power of the exponent (cmath).  <br /></td></tr>
<tr class="separator:a9e5f02cbf4087632e65c55ef4aa01ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10658674cb2b0da30f637561df9b9594"><td class="memTemplParams" colspan="2">template&lt;typename Scal1 , typename Mat1 , <a class="el" href="group__var__or__arithmetic__types_ga5061e6f2e948a07b90bd6b0cde025e9e.html#ga5061e6f2e948a07b90bd6b0cde025e9e">require_all_st_var_or_arithmetic</a>&lt; Scal1, Mat1 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; Scal1 &gt; *  = nullptr, <a class="el" href="group__matrix__types_gabb3c2790817a1e89e13bdbf460bce37b.html#gabb3c2790817a1e89e13bdbf460bce37b">require_all_matrix_st</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, Mat1 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a10658674cb2b0da30f637561df9b9594"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a10658674cb2b0da30f637561df9b9594.html#a10658674cb2b0da30f637561df9b9594">pow</a> (Scal1 base, const Mat1 &amp;exponent)</td></tr>
<tr class="memdesc:a10658674cb2b0da30f637561df9b9594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base scalar raised to the power of the exponent matrix elementwise.  <br /></td></tr>
<tr class="separator:a10658674cb2b0da30f637561df9b9594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccbe1638f463027973553dec7175dbc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0ccbe1638f463027973553dec7175dbc.html#a0ccbe1638f463027973553dec7175dbc">primitive_value</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;v)</td></tr>
<tr class="memdesc:a0ccbe1638f463027973553dec7175dbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the primitive double value for the specified autodiff variable.  <br /></td></tr>
<tr class="separator:a0ccbe1638f463027973553dec7175dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74ed7d866819bcef2174af380ac29ef"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab74ed7d866819bcef2174af380ac29ef.html#ab74ed7d866819bcef2174af380ac29ef">proj</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:ab74ed7d866819bcef2174af380ac29ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the projection of the complex argument onto the Riemann sphere.  <br /></td></tr>
<tr class="separator:ab74ed7d866819bcef2174af380ac29ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f478f4bee63e3d9448ed635fbf747a8"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga76e63e3ea85c77800e3a4cda6aed0357.html#ga76e63e3ea85c77800e3a4cda6aed0357">require_not_eigen_col_vector_t</a>&lt; EigMat2 &gt; *  = nullptr, <a class="el" href="group__var__types_ga3005eb7ae8907ba19f66470146dfd6b6.html#ga3005eb7ae8907ba19f66470146dfd6b6">require_any_vt_var</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a4f478f4bee63e3d9448ed635fbf747a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a3fe75d9025a62ed58292f17f09ce61da.html#a3fe75d9025a62ed58292f17f09ce61da">promote_scalar_t</a>&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, EigMat2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4f478f4bee63e3d9448ed635fbf747a8.html#a4f478f4bee63e3d9448ed635fbf747a8">quad_form</a> (const EigMat1 &amp;A, const EigMat2 &amp;B, bool symmetric=false)</td></tr>
<tr class="memdesc:a4f478f4bee63e3d9448ed635fbf747a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \).  <br /></td></tr>
<tr class="separator:a4f478f4bee63e3d9448ed635fbf747a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fd97336bfb1a094fef97eac5d6fbd0"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , typename ColVec , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; ColVec &gt; *  = nullptr, <a class="el" href="group__var__types_ga3005eb7ae8907ba19f66470146dfd6b6.html#ga3005eb7ae8907ba19f66470146dfd6b6">require_any_vt_var</a>&lt; EigMat, ColVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a34fd97336bfb1a094fef97eac5d6fbd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a34fd97336bfb1a094fef97eac5d6fbd0.html#a34fd97336bfb1a094fef97eac5d6fbd0">quad_form</a> (const EigMat &amp;A, const ColVec &amp;B, bool symmetric=false)</td></tr>
<tr class="memdesc:a34fd97336bfb1a094fef97eac5d6fbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \).  <br /></td></tr>
<tr class="separator:a34fd97336bfb1a094fef97eac5d6fbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a05ca20655977a6470770ae52b896c"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="group__col__vector__types_ga91963f6a218d172b07857bf3d5a8aa86.html#ga91963f6a218d172b07857bf3d5a8aa86">require_not_col_vector_t</a>&lt; Mat2 &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_gaf9240f628acb5b6ce46e70cd20f93e0f.html#gaf9240f628acb5b6ce46e70cd20f93e0f">require_any_var_matrix_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa2a05ca20655977a6470770ae52b896c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa2a05ca20655977a6470770ae52b896c.html#aa2a05ca20655977a6470770ae52b896c">quad_form</a> (const Mat1 &amp;A, const Mat2 &amp;B, bool symmetric=false)</td></tr>
<tr class="memdesc:aa2a05ca20655977a6470770ae52b896c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \).  <br /></td></tr>
<tr class="separator:aa2a05ca20655977a6470770ae52b896c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d4202bac72da2ba0fddf453b694f2c"><td class="memTemplParams" colspan="2">template&lt;typename Mat , typename Vec , <a class="el" href="group__matrix__types_ga32daaff2841306298c81dc15071b7693.html#ga32daaff2841306298c81dc15071b7693">require_matrix_t</a>&lt; Mat &gt; *  = nullptr, <a class="el" href="group__col__vector__types_ga58096049cb8906ec6ad5f44f1e6fe082.html#ga58096049cb8906ec6ad5f44f1e6fe082">require_col_vector_t</a>&lt; Vec &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_gaf9240f628acb5b6ce46e70cd20f93e0f.html#gaf9240f628acb5b6ce46e70cd20f93e0f">require_any_var_matrix_t</a>&lt; Mat, Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a41d4202bac72da2ba0fddf453b694f2c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a41d4202bac72da2ba0fddf453b694f2c.html#a41d4202bac72da2ba0fddf453b694f2c">quad_form</a> (const Mat &amp;A, const Vec &amp;B, bool symmetric=false)</td></tr>
<tr class="memdesc:a41d4202bac72da2ba0fddf453b694f2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \).  <br /></td></tr>
<tr class="separator:a41d4202bac72da2ba0fddf453b694f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcd98e2772811936c1bfc6e441aa4a7"><td class="memTemplParams" colspan="2">template&lt;typename EigMat1 , typename EigMat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr, <a class="el" href="group__var__types_ga3005eb7ae8907ba19f66470146dfd6b6.html#ga3005eb7ae8907ba19f66470146dfd6b6">require_any_vt_var</a>&lt; EigMat1, EigMat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aabcd98e2772811936c1bfc6e441aa4a7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aabcd98e2772811936c1bfc6e441aa4a7.html#aabcd98e2772811936c1bfc6e441aa4a7">quad_form_sym</a> (const EigMat1 &amp;A, const EigMat2 &amp;B)</td></tr>
<tr class="memdesc:aabcd98e2772811936c1bfc6e441aa4a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the quadratic form \( B^T A B \) of a symmetric matrix.  <br /></td></tr>
<tr class="separator:aabcd98e2772811936c1bfc6e441aa4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5764580f874bfb327f5e737d3242fea"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__vector__types_ga7b9869e92fcfb027eedfe8de77507769.html#ga7b9869e92fcfb027eedfe8de77507769">require_var_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa5764580f874bfb327f5e737d3242fea"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa5764580f874bfb327f5e737d3242fea.html#aa5764580f874bfb327f5e737d3242fea">read_corr_L</a> (const T &amp;CPCs, size_t K)</td></tr>
<tr class="memdesc:aa5764580f874bfb327f5e737d3242fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations.  <br /></td></tr>
<tr class="separator:aa5764580f874bfb327f5e737d3242fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c6412c7e37ad9a1d875fd86993a332"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__var__vector__types_ga7b9869e92fcfb027eedfe8de77507769.html#ga7b9869e92fcfb027eedfe8de77507769">require_var_vector_t</a>&lt; T1 &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga5003c32d9e63471c92ab63280a61b8ae.html#ga5003c32d9e63471c92ab63280a61b8ae">require_stan_scalar_t</a>&lt; T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa7c6412c7e37ad9a1d875fd86993a332"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa7c6412c7e37ad9a1d875fd86993a332.html#aa7c6412c7e37ad9a1d875fd86993a332">read_corr_L</a> (const T1 &amp;CPCs, size_t K, T2 &amp;log_prob)</td></tr>
<tr class="memdesc:aa7c6412c7e37ad9a1d875fd86993a332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Cholesky factor of the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations, incrementing the specified scalar reference with the log absolute determinant of the Jacobian of the transformation.  <br /></td></tr>
<tr class="separator:aa7c6412c7e37ad9a1d875fd86993a332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aef1080f9df7b6de854cc939da8127c"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , <a class="el" href="group__var__vector__types_ga7b9869e92fcfb027eedfe8de77507769.html#ga7b9869e92fcfb027eedfe8de77507769">require_var_vector_t</a>&lt; T_CPCs &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3aef1080f9df7b6de854cc939da8127c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3aef1080f9df7b6de854cc939da8127c.html#a3aef1080f9df7b6de854cc939da8127c">read_corr_matrix</a> (const T_CPCs &amp;CPCs, size_t K)</td></tr>
<tr class="memdesc:a3aef1080f9df7b6de854cc939da8127c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations.  <br /></td></tr>
<tr class="separator:a3aef1080f9df7b6de854cc939da8127c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721420100ea393f3fbe76c5be8272c7e"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , <a class="el" href="group__var__vector__types_ga7b9869e92fcfb027eedfe8de77507769.html#ga7b9869e92fcfb027eedfe8de77507769">require_var_vector_t</a>&lt; T_CPCs &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a721420100ea393f3fbe76c5be8272c7e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a721420100ea393f3fbe76c5be8272c7e.html#a721420100ea393f3fbe76c5be8272c7e">read_corr_matrix</a> (const T_CPCs &amp;CPCs, size_t K, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T_CPCs &gt; &amp;log_prob)</td></tr>
<tr class="memdesc:a721420100ea393f3fbe76c5be8272c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the correlation matrix of the specified dimensionality corresponding to the specified canonical partial correlations, incrementing the specified scalar reference with the log absolute determinant of the Jacobian of the transformation.  <br /></td></tr>
<tr class="separator:a721420100ea393f3fbe76c5be8272c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3616c201e1d4e6bfc8cb2c7b3766cb"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , typename T_sds , <a class="el" href="group__var__vector__types_ga79377c870c4afd3682311972ce62b63a.html#ga79377c870c4afd3682311972ce62b63a">require_any_var_vector_t</a>&lt; T_CPCs, T_sds &gt; *  = nullptr, <a class="el" href="group__same__types_gafb31dadf505ab2b2cb62931dfc09a625.html#gafb31dadf505ab2b2cb62931dfc09a625">require_vt_same</a>&lt; T_CPCs, T_sds &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ade3616c201e1d4e6bfc8cb2c7b3766cb"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ade3616c201e1d4e6bfc8cb2c7b3766cb.html#ade3616c201e1d4e6bfc8cb2c7b3766cb">read_cov_L</a> (const T_CPCs &amp;CPCs, const T_sds &amp;sds, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T_CPCs &gt; &amp;log_prob)</td></tr>
<tr class="memdesc:ade3616c201e1d4e6bfc8cb2c7b3766cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the function that should be called prior to evaluating the density of any elliptical distribution.  <br /></td></tr>
<tr class="separator:ade3616c201e1d4e6bfc8cb2c7b3766cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af430764ca230dc39e3e215f9e9f2b718"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , typename T_sds , <a class="el" href="group__var__vector__types_gafefbf7d697343b6b73101e76f6cfe08f.html#gafefbf7d697343b6b73101e76f6cfe08f">require_all_var_vector_t</a>&lt; T_CPCs, T_sds &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af430764ca230dc39e3e215f9e9f2b718"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af430764ca230dc39e3e215f9e9f2b718.html#af430764ca230dc39e3e215f9e9f2b718">read_cov_matrix</a> (const T_CPCs &amp;CPCs, const T_sds &amp;sds, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T_CPCs &gt; &amp;log_prob)</td></tr>
<tr class="memdesc:af430764ca230dc39e3e215f9e9f2b718"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generally worse alternative to call prior to evaluating the density of an elliptical distribution.  <br /></td></tr>
<tr class="separator:af430764ca230dc39e3e215f9e9f2b718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4fbb91a0439131d8672e2cb1faf671"><td class="memTemplParams" colspan="2">template&lt;typename T_CPCs , typename T_sds , <a class="el" href="group__var__vector__types_gafefbf7d697343b6b73101e76f6cfe08f.html#gafefbf7d697343b6b73101e76f6cfe08f">require_all_var_vector_t</a>&lt; T_CPCs, T_sds &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abc4fbb91a0439131d8672e2cb1faf671"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::MatrixXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abc4fbb91a0439131d8672e2cb1faf671.html#abc4fbb91a0439131d8672e2cb1faf671">read_cov_matrix</a> (const T_CPCs &amp;CPCs, const T_sds &amp;sds)</td></tr>
<tr class="memdesc:abc4fbb91a0439131d8672e2cb1faf671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a covariance matrix from CPCs and standard deviations.  <br /></td></tr>
<tr class="separator:abc4fbb91a0439131d8672e2cb1faf671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267f6f928b29d06f15a7084044260ab8"><td class="memTemplParams" colspan="2">template&lt;typename Ret , typename Vec , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; Ret &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; Vec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a267f6f928b29d06f15a7084044260ab8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a267f6f928b29d06f15a7084044260ab8.html#a267f6f928b29d06f15a7084044260ab8">rep_matrix</a> (const Vec &amp;x, int n)</td></tr>
<tr class="memdesc:a267f6f928b29d06f15a7084044260ab8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Impl of rep_matrix returning a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Eigen::Matrix&gt;</code> from a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code> with an inner <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vector type.  <br /></td></tr>
<tr class="separator:a267f6f928b29d06f15a7084044260ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35656cc627ac0d8fec00c9ff145875cc"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; T_ret &gt; *  = nullptr, <a class="el" href="group__eigen__row__vector__types_ga2aff7daad297cba7bc223382ac23d8ff.html#ga2aff7daad297cba7bc223382ac23d8ff">require_eigen_row_vector_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_ret &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a35656cc627ac0d8fec00c9ff145875cc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a35656cc627ac0d8fec00c9ff145875cc.html#a35656cc627ac0d8fec00c9ff145875cc">rep_row_vector</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> x, int n)</td></tr>
<tr class="memdesc:a35656cc627ac0d8fec00c9ff145875cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Vector&gt;</code>.  <br /></td></tr>
<tr class="separator:a35656cc627ac0d8fec00c9ff145875cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b45872b1ffc5df2700aa32653e3b50"><td class="memTemplParams" colspan="2">template&lt;typename T_ret , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; T_ret &gt; *  = nullptr, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T_ret &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab0b45872b1ffc5df2700aa32653e3b50"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab0b45872b1ffc5df2700aa32653e3b50.html#ab0b45872b1ffc5df2700aa32653e3b50">rep_vector</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> x, int n)</td></tr>
<tr class="memdesc:ab0b45872b1ffc5df2700aa32653e3b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Vector&gt;</code>.  <br /></td></tr>
<tr class="separator:ab0b45872b1ffc5df2700aa32653e3b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f816575a235ef07b3e9e62478d3ee42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8f816575a235ef07b3e9e62478d3ee42.html#a8f816575a235ef07b3e9e62478d3ee42">rising_factorial</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, int b)</td></tr>
<tr class="separator:a8f816575a235ef07b3e9e62478d3ee42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab259f70f4c7ebcdf3e032f01efb66c02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab259f70f4c7ebcdf3e032f01efb66c02.html#ab259f70f4c7ebcdf3e032f01efb66c02">round</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:ab259f70f4c7ebcdf3e032f01efb66c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the rounded form of the specified variable (C99).  <br /></td></tr>
<tr class="separator:ab259f70f4c7ebcdf3e032f01efb66c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2846fc4fd070a4fb013a256816c75ac9"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="group__eigen__types_gae64cf4d09f74bffc664e44cfdc368ffc.html#gae64cf4d09f74bffc664e44cfdc368ffc">require_any_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2846fc4fd070a4fb013a256816c75ac9"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Mat1::RowsAtCompileTime, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2846fc4fd070a4fb013a256816c75ac9.html#a2846fc4fd070a4fb013a256816c75ac9">rows_dot_product</a> (const Mat1 &amp;v1, const Mat2 &amp;v2)</td></tr>
<tr class="memdesc:a2846fc4fd070a4fb013a256816c75ac9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of rows of the specified matrices.  <br /></td></tr>
<tr class="separator:a2846fc4fd070a4fb013a256816c75ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999e544019c0e28886933b4c93072553"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_gaf9240f628acb5b6ce46e70cd20f93e0f.html#gaf9240f628acb5b6ce46e70cd20f93e0f">require_any_var_matrix_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a999e544019c0e28886933b4c93072553"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a999e544019c0e28886933b4c93072553.html#a999e544019c0e28886933b4c93072553">rows_dot_product</a> (const Mat1 &amp;v1, const Mat2 &amp;v2)</td></tr>
<tr class="memdesc:a999e544019c0e28886933b4c93072553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of rows of the specified matrices.  <br /></td></tr>
<tr class="separator:a999e544019c0e28886933b4c93072553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab87df36a5b85f5a24835fb4faf333a6f"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab87df36a5b85f5a24835fb4faf333a6f"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Mat::RowsAtCompileTime, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab87df36a5b85f5a24835fb4faf333a6f.html#ab87df36a5b85f5a24835fb4faf333a6f">rows_dot_self</a> (const Mat &amp;x)</td></tr>
<tr class="memdesc:ab87df36a5b85f5a24835fb4faf333a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of each row of a matrix with itself.  <br /></td></tr>
<tr class="separator:ab87df36a5b85f5a24835fb4faf333a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab314fd37bd2a8316d44fed7e6ac6ae5f"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab314fd37bd2a8316d44fed7e6ac6ae5f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab314fd37bd2a8316d44fed7e6ac6ae5f.html#ab314fd37bd2a8316d44fed7e6ac6ae5f">rows_dot_self</a> (const Mat &amp;x)</td></tr>
<tr class="memdesc:ab314fd37bd2a8316d44fed7e6ac6ae5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the dot product of row row of a matrix with itself.  <br /></td></tr>
<tr class="separator:ab314fd37bd2a8316d44fed7e6ac6ae5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb57f17d92038aa778bd67136a3ccde"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga51f433bbb5e3f53af4ef6dc9bc84b7af.html#ga51f433bbb5e3f53af4ef6dc9bc84b7af">require_eigen_st</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a1bb57f17d92038aa778bd67136a3ccde"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1bb57f17d92038aa778bd67136a3ccde.html#a1bb57f17d92038aa778bd67136a3ccde">sd</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a1bb57f17d92038aa778bd67136a3ccde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample standard deviation of a variable which inherits from EigenBase.  <br /></td></tr>
<tr class="separator:a1bb57f17d92038aa778bd67136a3ccde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef0ad5fb85ef3b77bb2196c36485198"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__std__vector__types_ga513b41fcdff562ebb8bc2cd5e3ea8faa.html#ga513b41fcdff562ebb8bc2cd5e3ea8faa">require_std_vector_st</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9ef0ad5fb85ef3b77bb2196c36485198"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ef0ad5fb85ef3b77bb2196c36485198.html#a9ef0ad5fb85ef3b77bb2196c36485198">sd</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a9ef0ad5fb85ef3b77bb2196c36485198"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample standard deviation of the specified std vector, column vector, row vector, matrix, or std vector of any of these types.  <br /></td></tr>
<tr class="separator:a9ef0ad5fb85ef3b77bb2196c36485198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae306538402ac590b8b84e6ed58989629"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae306538402ac590b8b84e6ed58989629.html#ae306538402ac590b8b84e6ed58989629">sin</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:ae306538402ac590b8b84e6ed58989629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sine of a radian-scaled variable (cmath).  <br /></td></tr>
<tr class="separator:ae306538402ac590b8b84e6ed58989629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7434c28c0c2c2d63c674cdab45a031e7"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7434c28c0c2c2d63c674cdab45a031e7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7434c28c0c2c2d63c674cdab45a031e7.html#a7434c28c0c2c2d63c674cdab45a031e7">sin</a> (const VarMat &amp;a)</td></tr>
<tr class="memdesc:a7434c28c0c2c2d63c674cdab45a031e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sine of a radian-scaled variable (cmath).  <br /></td></tr>
<tr class="separator:a7434c28c0c2c2d63c674cdab45a031e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4270f5cef384732cd935f6efb113505d"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4270f5cef384732cd935f6efb113505d.html#a4270f5cef384732cd935f6efb113505d">sin</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a4270f5cef384732cd935f6efb113505d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sine of the complex argument.  <br /></td></tr>
<tr class="separator:a4270f5cef384732cd935f6efb113505d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d74ca247a7cafe2d08f7c642209022"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a25d74ca247a7cafe2d08f7c642209022"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a25d74ca247a7cafe2d08f7c642209022.html#a25d74ca247a7cafe2d08f7c642209022">singular_values</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a25d74ca247a7cafe2d08f7c642209022"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the singular values of the specified matrix.  <br /></td></tr>
<tr class="separator:a25d74ca247a7cafe2d08f7c642209022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241b79300774f40a6e67b7156b494462"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a241b79300774f40a6e67b7156b494462.html#a241b79300774f40a6e67b7156b494462">sinh</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a241b79300774f40a6e67b7156b494462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic sine of the specified variable (cmath).  <br /></td></tr>
<tr class="separator:a241b79300774f40a6e67b7156b494462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971a11c14a0fd7d83ddbb2b06f29c92c"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a971a11c14a0fd7d83ddbb2b06f29c92c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a971a11c14a0fd7d83ddbb2b06f29c92c.html#a971a11c14a0fd7d83ddbb2b06f29c92c">sinh</a> (const VarMat &amp;a)</td></tr>
<tr class="memdesc:a971a11c14a0fd7d83ddbb2b06f29c92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic of a radian-scaled variable (cmath).  <br /></td></tr>
<tr class="separator:a971a11c14a0fd7d83ddbb2b06f29c92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f80b846aa506a0530ce935cb0c6011"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a20f80b846aa506a0530ce935cb0c6011.html#a20f80b846aa506a0530ce935cb0c6011">sinh</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a20f80b846aa506a0530ce935cb0c6011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic sine of the complex argument.  <br /></td></tr>
<tr class="separator:a20f80b846aa506a0530ce935cb0c6011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97203c1dea7e34e9bbf1ebd9dc064c06"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a97203c1dea7e34e9bbf1ebd9dc064c06"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a97203c1dea7e34e9bbf1ebd9dc064c06.html#a97203c1dea7e34e9bbf1ebd9dc064c06">softmax</a> (const Mat &amp;alpha)</td></tr>
<tr class="memdesc:a97203c1dea7e34e9bbf1ebd9dc064c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the softmax of the specified <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> vector.  <br /></td></tr>
<tr class="separator:a97203c1dea7e34e9bbf1ebd9dc064c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab438f4b0a11d8551fe5605237f655730"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab438f4b0a11d8551fe5605237f655730.html#ab438f4b0a11d8551fe5605237f655730">sqrt</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:ab438f4b0a11d8551fe5605237f655730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of the specified variable (cmath).  <br /></td></tr>
<tr class="separator:ab438f4b0a11d8551fe5605237f655730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409cc3a1e2a6a5e76b0475264c7c9d18"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a409cc3a1e2a6a5e76b0475264c7c9d18"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a409cc3a1e2a6a5e76b0475264c7c9d18.html#a409cc3a1e2a6a5e76b0475264c7c9d18">sqrt</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a409cc3a1e2a6a5e76b0475264c7c9d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return elementwise square root of vector.  <br /></td></tr>
<tr class="separator:a409cc3a1e2a6a5e76b0475264c7c9d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798ba24ec975139668686400a6d1e76d"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a798ba24ec975139668686400a6d1e76d.html#a798ba24ec975139668686400a6d1e76d">sqrt</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a798ba24ec975139668686400a6d1e76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square root of the complex argument.  <br /></td></tr>
<tr class="separator:a798ba24ec975139668686400a6d1e76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b349cd070427c412c2c0a0d32327b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa1b349cd070427c412c2c0a0d32327b5.html#aa1b349cd070427c412c2c0a0d32327b5">square</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:aa1b349cd070427c412c2c0a0d32327b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the square of the input variable.  <br /></td></tr>
<tr class="separator:aa1b349cd070427c412c2c0a0d32327b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96eaa2f4afd30db9c2cf0e3bdfaf5df"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae96eaa2f4afd30db9c2cf0e3bdfaf5df"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae96eaa2f4afd30db9c2cf0e3bdfaf5df.html#ae96eaa2f4afd30db9c2cf0e3bdfaf5df">square</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae96eaa2f4afd30db9c2cf0e3bdfaf5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise square of x.  <br /></td></tr>
<tr class="separator:ae96eaa2f4afd30db9c2cf0e3bdfaf5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ff53e8fd4aa89af1e8f95cf669529e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a61ff53e8fd4aa89af1e8f95cf669529e.html#a61ff53e8fd4aa89af1e8f95cf669529e">squared_distance</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a61ff53e8fd4aa89af1e8f95cf669529e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance.  <br /></td></tr>
<tr class="separator:a61ff53e8fd4aa89af1e8f95cf669529e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2919d7ff701b0c109254090471c8be30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2919d7ff701b0c109254090471c8be30.html#a2919d7ff701b0c109254090471c8be30">squared_distance</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a, double b)</td></tr>
<tr class="memdesc:a2919d7ff701b0c109254090471c8be30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance.  <br /></td></tr>
<tr class="separator:a2919d7ff701b0c109254090471c8be30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267a694b865507ce2aff00f83de31d5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a267a694b865507ce2aff00f83de31d5b.html#a267a694b865507ce2aff00f83de31d5b">squared_distance</a> (double a, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;b)</td></tr>
<tr class="memdesc:a267a694b865507ce2aff00f83de31d5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the squared distance.  <br /></td></tr>
<tr class="separator:a267a694b865507ce2aff00f83de31d5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43923273fec40cf29005e2d1d0335f9"><td class="memTemplParams" colspan="2">template&lt;typename EigVecVar1 , typename EigVecVar2 , <a class="el" href="group__eigen__vector__types_ga78109e803a8f77575fbac2f5940550eb.html#ga78109e803a8f77575fbac2f5940550eb">require_all_eigen_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, EigVecVar1, EigVecVar2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa43923273fec40cf29005e2d1d0335f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa43923273fec40cf29005e2d1d0335f9.html#aa43923273fec40cf29005e2d1d0335f9">squared_distance</a> (const EigVecVar1 &amp;v1, const EigVecVar2 &amp;v2)</td></tr>
<tr class="separator:aa43923273fec40cf29005e2d1d0335f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683327eb4ba74872ddf550de5bd30da4"><td class="memTemplParams" colspan="2">template&lt;typename EigVecVar , typename EigVecArith , <a class="el" href="group__eigen__vector__types_ga896401ad33967867f49cd60ca10d990e.html#ga896401ad33967867f49cd60ca10d990e">require_eigen_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, EigVecVar &gt; *  = nullptr, <a class="el" href="group__eigen__vector__types_ga896401ad33967867f49cd60ca10d990e.html#ga896401ad33967867f49cd60ca10d990e">require_eigen_vector_vt</a>&lt; std::is_arithmetic, EigVecArith &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a683327eb4ba74872ddf550de5bd30da4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a683327eb4ba74872ddf550de5bd30da4.html#a683327eb4ba74872ddf550de5bd30da4">squared_distance</a> (const EigVecVar &amp;v1, const EigVecArith &amp;v2)</td></tr>
<tr class="separator:a683327eb4ba74872ddf550de5bd30da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95a11718edba243ef87525eac8b1529"><td class="memTemplParams" colspan="2">template&lt;typename EigVecArith , typename EigVecVar , <a class="el" href="group__eigen__vector__types_ga896401ad33967867f49cd60ca10d990e.html#ga896401ad33967867f49cd60ca10d990e">require_eigen_vector_vt</a>&lt; std::is_arithmetic, EigVecArith &gt; *  = nullptr, <a class="el" href="group__eigen__vector__types_ga896401ad33967867f49cd60ca10d990e.html#ga896401ad33967867f49cd60ca10d990e">require_eigen_vector_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, EigVecVar &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac95a11718edba243ef87525eac8b1529"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac95a11718edba243ef87525eac8b1529.html#ac95a11718edba243ef87525eac8b1529">squared_distance</a> (const EigVecArith &amp;v1, const EigVecVar &amp;v2)</td></tr>
<tr class="separator:ac95a11718edba243ef87525eac8b1529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c719996e0349809cf0aee7f41b7590"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__vector__types_ga1b4c392b9d20db66ae254ef9833f9717.html#ga1b4c392b9d20db66ae254ef9833f9717">require_all_vector_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__var__vector__types_ga79377c870c4afd3682311972ce62b63a.html#ga79377c870c4afd3682311972ce62b63a">require_any_var_vector_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a98c719996e0349809cf0aee7f41b7590"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a98c719996e0349809cf0aee7f41b7590.html#a98c719996e0349809cf0aee7f41b7590">squared_distance</a> (const T1 &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:a98c719996e0349809cf0aee7f41b7590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the squared distance between the elements in two inputs.  <br /></td></tr>
<tr class="separator:a98c719996e0349809cf0aee7f41b7590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab45f57a15327ae4f94a1aef0bcd869f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab45f57a15327ae4f94a1aef0bcd869f.html#aab45f57a15327ae4f94a1aef0bcd869f">stan_print</a> (std::ostream *o, const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="separator:aab45f57a15327ae4f94a1aef0bcd869f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686aa4165aa247ce689d222b67735810"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a686aa4165aa247ce689d222b67735810.html#a686aa4165aa247ce689d222b67735810">step</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a686aa4165aa247ce689d222b67735810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the step, or heaviside, function applied to the specified variable (stan).  <br /></td></tr>
<tr class="separator:a686aa4165aa247ce689d222b67735810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619275173fb7baa7e80adbd6910134ee"><td class="memTemplParams" colspan="2">template&lt;typename Alloc &gt; </td></tr>
<tr class="memitem:a619275173fb7baa7e80adbd6910134ee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a619275173fb7baa7e80adbd6910134ee.html#a619275173fb7baa7e80adbd6910134ee">sum</a> (const std::vector&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Alloc &gt; &amp;m)</td></tr>
<tr class="memdesc:a619275173fb7baa7e80adbd6910134ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of the entries of the specified vector.  <br /></td></tr>
<tr class="separator:a619275173fb7baa7e80adbd6910134ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad427d34dc4cfecbaa710e3d505b1f0ca"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad427d34dc4cfecbaa710e3d505b1f0ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad427d34dc4cfecbaa710e3d505b1f0ca.html#ad427d34dc4cfecbaa710e3d505b1f0ca">sum</a> (T &amp;&amp;x)</td></tr>
<tr class="memdesc:ad427d34dc4cfecbaa710e3d505b1f0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of the coefficients of the specified matrix.  <br /></td></tr>
<tr class="separator:ad427d34dc4cfecbaa710e3d505b1f0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7289f0bd967277517ba275652b09e94a"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a7289f0bd967277517ba275652b09e94a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7289f0bd967277517ba275652b09e94a.html#a7289f0bd967277517ba275652b09e94a">svd</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a7289f0bd967277517ba275652b09e94a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given input matrix m, return the singular value decomposition (U,D,V) such that <code>m = U*diag(D)*V^{T}</code>  <br /></td></tr>
<tr class="separator:a7289f0bd967277517ba275652b09e94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc39c0b4f48e122011c1a6d1595ae85"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2fc39c0b4f48e122011c1a6d1595ae85"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2fc39c0b4f48e122011c1a6d1595ae85.html#a2fc39c0b4f48e122011c1a6d1595ae85">svd_U</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a2fc39c0b4f48e122011c1a6d1595ae85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given input matrix m, return matrix U where <code>m = UDV^{T}</code>  <br /></td></tr>
<tr class="separator:a2fc39c0b4f48e122011c1a6d1595ae85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaa3532f2b8ced3ad957075a9cf9165f"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acaa3532f2b8ced3ad957075a9cf9165f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acaa3532f2b8ced3ad957075a9cf9165f.html#acaa3532f2b8ced3ad957075a9cf9165f">svd_V</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:acaa3532f2b8ced3ad957075a9cf9165f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given input matrix m, return matrix V where <code>m = UDV^{T}</code>  <br /></td></tr>
<tr class="separator:acaa3532f2b8ced3ad957075a9cf9165f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8320fd61a3c0c73f2ab8d78d949e58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adf8320fd61a3c0c73f2ab8d78d949e58.html#adf8320fd61a3c0c73f2ab8d78d949e58">tan</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:adf8320fd61a3c0c73f2ab8d78d949e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tangent of a radian-scaled variable (cmath).  <br /></td></tr>
<tr class="separator:adf8320fd61a3c0c73f2ab8d78d949e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037201c6eba2c196faf3e93f58e0dc4b"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a037201c6eba2c196faf3e93f58e0dc4b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a037201c6eba2c196faf3e93f58e0dc4b.html#a037201c6eba2c196faf3e93f58e0dc4b">tan</a> (const VarMat &amp;a)</td></tr>
<tr class="memdesc:a037201c6eba2c196faf3e93f58e0dc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tangent of a radian-scaled variable (cmath).  <br /></td></tr>
<tr class="separator:a037201c6eba2c196faf3e93f58e0dc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92045febdeb4157a3f4a2236981abcba"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a92045febdeb4157a3f4a2236981abcba.html#a92045febdeb4157a3f4a2236981abcba">tan</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:a92045febdeb4157a3f4a2236981abcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tangent of the complex argument.  <br /></td></tr>
<tr class="separator:a92045febdeb4157a3f4a2236981abcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d342831ec24762b18f71ba4fba54621"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6d342831ec24762b18f71ba4fba54621.html#a6d342831ec24762b18f71ba4fba54621">tanh</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a6d342831ec24762b18f71ba4fba54621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic tangent of the specified variable (cmath).  <br /></td></tr>
<tr class="separator:a6d342831ec24762b18f71ba4fba54621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad087da016f682bc2ce1899d8d02389fe"><td class="memTemplParams" colspan="2">template&lt;typename VarMat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; VarMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad087da016f682bc2ce1899d8d02389fe"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad087da016f682bc2ce1899d8d02389fe.html#ad087da016f682bc2ce1899d8d02389fe">tanh</a> (const VarMat &amp;a)</td></tr>
<tr class="memdesc:ad087da016f682bc2ce1899d8d02389fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic tangent of elements of a.  <br /></td></tr>
<tr class="separator:ad087da016f682bc2ce1899d8d02389fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2c5ad3ce6875721ebb1c49abed9e2b"><td class="memItemLeft" align="right" valign="top">std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_add2c5ad3ce6875721ebb1c49abed9e2b.html#add2c5ad3ce6875721ebb1c49abed9e2b">tanh</a> (const std::complex&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;z)</td></tr>
<tr class="memdesc:add2c5ad3ce6875721ebb1c49abed9e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the hyperbolic tangent of the complex argument.  <br /></td></tr>
<tr class="separator:add2c5ad3ce6875721ebb1c49abed9e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e795209f13f6c4f9c273b560143ecf7"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a2e795209f13f6c4f9c273b560143ecf7"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2e795209f13f6c4f9c273b560143ecf7.html#a2e795209f13f6c4f9c273b560143ecf7">tcrossprod</a> (const T &amp;M)</td></tr>
<tr class="memdesc:a2e795209f13f6c4f9c273b560143ecf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of post-multiplying a matrix by its own transpose.  <br /></td></tr>
<tr class="separator:a2e795209f13f6c4f9c273b560143ecf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfeb8acb79c37f69d755a27ad515323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afdfeb8acb79c37f69d755a27ad515323.html#afdfeb8acb79c37f69d755a27ad515323">tgamma</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:afdfeb8acb79c37f69d755a27ad515323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the Gamma function applied to the specified variable (C99).  <br /></td></tr>
<tr class="separator:afdfeb8acb79c37f69d755a27ad515323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec682a7e94f3a897173c557f19f5d85d"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aec682a7e94f3a897173c557f19f5d85d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aec682a7e94f3a897173c557f19f5d85d.html#aec682a7e94f3a897173c557f19f5d85d">tgamma</a> (const T &amp;a)</td></tr>
<tr class="memdesc:aec682a7e94f3a897173c557f19f5d85d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return elementwise gamma function.  <br /></td></tr>
<tr class="separator:aec682a7e94f3a897173c557f19f5d85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09d3c79cd03c7ece9542fa688290469"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__same__types_ga151adb676402a791de98a5d743d7a10d.html#ga151adb676402a791de98a5d743d7a10d">require_not_same_t</a>&lt; T, <a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">arena_t</a>&lt; T &gt; &gt; *  = nullptr, <a class="el" href="group__container__types_ga459f89baca338578dee731a64a13cbe0.html#ga459f89baca338578dee731a64a13cbe0">require_not_container_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__matrix__cl__types_ga1af53d2ea2874ab39e60e796c8f2c074.html#ga1af53d2ea2874ab39e60e796c8f2c074">require_not_matrix_cl_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab09d3c79cd03c7ece9542fa688290469"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">arena_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab09d3c79cd03c7ece9542fa688290469.html#ab09d3c79cd03c7ece9542fa688290469">to_arena</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ab09d3c79cd03c7ece9542fa688290469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts given argument into a type that either has any dynamic allocation on AD stack or schedules its destructor to be called when AD stack memory is recovered.  <br /></td></tr>
<tr class="separator:ab09d3c79cd03c7ece9542fa688290469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3d328ec2b9003680865ffe4cd7e784"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__same__types_ga29595127b6ba2b597e5723c80dee1b61.html#ga29595127b6ba2b597e5723c80dee1b61">require_same_t</a>&lt; T, <a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">arena_t</a>&lt; T &gt; &gt; *  = nullptr, <a class="el" href="group__matrix__cl__types_ga1af53d2ea2874ab39e60e796c8f2c074.html#ga1af53d2ea2874ab39e60e796c8f2c074">require_not_matrix_cl_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8d3d328ec2b9003680865ffe4cd7e784"><td class="memTemplItemLeft" align="right" valign="top">std::remove_reference_t&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8d3d328ec2b9003680865ffe4cd7e784.html#a8d3d328ec2b9003680865ffe4cd7e784">to_arena</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:a8d3d328ec2b9003680865ffe4cd7e784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts given argument into a type that either has any dynamic allocation on AD stack or schedules its destructor to be called when AD stack memory is recovered.  <br /></td></tr>
<tr class="separator:a8d3d328ec2b9003680865ffe4cd7e784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd98fc441ea93c73067072b5beb1001b"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__same__types_ga151adb676402a791de98a5d743d7a10d.html#ga151adb676402a791de98a5d743d7a10d">require_not_same_t</a>&lt; T, <a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">arena_t</a>&lt; T &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:acd98fc441ea93c73067072b5beb1001b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">arena_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acd98fc441ea93c73067072b5beb1001b.html#acd98fc441ea93c73067072b5beb1001b">to_arena</a> (const T &amp;a)</td></tr>
<tr class="memdesc:acd98fc441ea93c73067072b5beb1001b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts given argument into a type that either has any dynamic allocation on AD stack or schedules its destructor to be called when AD stack memory is recovered.  <br /></td></tr>
<tr class="separator:acd98fc441ea93c73067072b5beb1001b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67577bff9a5c9d36e095af09bb29e22"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af67577bff9a5c9d36e095af09bb29e22"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T, <a class="el" href="structstan_1_1math_1_1arena__allocator.html">arena_allocator</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af67577bff9a5c9d36e095af09bb29e22.html#af67577bff9a5c9d36e095af09bb29e22">to_arena</a> (const std::vector&lt; T, <a class="el" href="structstan_1_1math_1_1arena__allocator.html">arena_allocator</a>&lt; T &gt; &gt; &amp;a)</td></tr>
<tr class="memdesc:af67577bff9a5c9d36e095af09bb29e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts given argument into a type that either has any dynamic allocation on AD stack or schedules its destructor to be called when AD stack memory is recovered.  <br /></td></tr>
<tr class="separator:af67577bff9a5c9d36e095af09bb29e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3226f2fbdd5e8b1b03c82151413b44"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__same__types_ga29595127b6ba2b597e5723c80dee1b61.html#ga29595127b6ba2b597e5723c80dee1b61">require_same_t</a>&lt; T, <a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">arena_t</a>&lt; T &gt; &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5a3226f2fbdd5e8b1b03c82151413b44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">arena_t</a>&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5a3226f2fbdd5e8b1b03c82151413b44.html#a5a3226f2fbdd5e8b1b03c82151413b44">to_arena</a> (const std::vector&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:a5a3226f2fbdd5e8b1b03c82151413b44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts given argument into a type that has any dynamic allocation on AD stack.  <br /></td></tr>
<tr class="separator:a5a3226f2fbdd5e8b1b03c82151413b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6cca281d73b87228a1a73f518222cf8"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename T , std::enable_if_t&lt;!Condition &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab6cca281d73b87228a1a73f518222cf8"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab6cca281d73b87228a1a73f518222cf8.html#ab6cca281d73b87228a1a73f518222cf8">to_arena_if</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ab6cca281d73b87228a1a73f518222cf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the condition is true, converts given argument into a type that has any dynamic allocation on AD stack.  <br /></td></tr>
<tr class="separator:ab6cca281d73b87228a1a73f518222cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eaedb14279ba5ec02663a128c4744b8"><td class="memTemplParams" colspan="2">template&lt;bool Condition, typename T , std::enable_if_t&lt; Condition &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9eaedb14279ba5ec02663a128c4744b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_ab8a8d862930229bc6ac4f3ac13514585.html#ab8a8d862930229bc6ac4f3ac13514585">arena_t</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9eaedb14279ba5ec02663a128c4744b8.html#a9eaedb14279ba5ec02663a128c4744b8">to_arena_if</a> (const T &amp;a)</td></tr>
<tr class="separator:a9eaedb14279ba5ec02663a128c4744b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3019a6ba4afceaf692b2283cc1fc75b"><td class="memTemplParams" colspan="2">template&lt;int Options = Eigen::ColMajor, typename VarMatrix , typename Vec1 , typename Vec2 , <a class="el" href="group__var__types_gab0d7285b1a3ce33eb11e113827345d30.html#gab0d7285b1a3ce33eb11e113827345d30">require_var_t</a>&lt; VarMatrix &gt; *  = nullptr, <a class="el" href="group__eigen__dense__base__types_ga832fc80ea0f3c9c728c1fefd681be76d.html#ga832fc80ea0f3c9c728c1fefd681be76d">require_eigen_dense_base_t</a>&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; VarMatrix &gt; &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga9ed7c65cf5f86dd50b639dc85ec56a86.html#ga9ed7c65cf5f86dd50b639dc85ec56a86">require_all_std_vector_vt</a>&lt; std::is_integral, Vec1, Vec2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aa3019a6ba4afceaf692b2283cc1fc75b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa3019a6ba4afceaf692b2283cc1fc75b.html#aa3019a6ba4afceaf692b2283cc1fc75b">to_soa_sparse_matrix</a> (int m, int n, VarMatrix &amp;&amp;w, Vec1 &amp;&amp;u, Vec2 &amp;&amp;v)</td></tr>
<tr class="memdesc:aa3019a6ba4afceaf692b2283cc1fc75b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sparse matrix from the given SoA matrix and indexes.  <br /></td></tr>
<tr class="separator:aa3019a6ba4afceaf692b2283cc1fc75b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ae7c753e10a83f432af40bcc14e687"><td class="memTemplParams" colspan="2">template&lt;int Options = Eigen::ColMajor, typename MatrixVar , typename Vec1 , typename Vec2 , <a class="el" href="group__eigen__dense__base__types_ga79c34d1cf87ed443d70cab727ea3da73.html#ga79c34d1cf87ed443d70cab727ea3da73">require_eigen_dense_base_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, MatrixVar &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga9ed7c65cf5f86dd50b639dc85ec56a86.html#ga9ed7c65cf5f86dd50b639dc85ec56a86">require_all_std_vector_vt</a>&lt; std::is_integral, Vec1, Vec2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a89ae7c753e10a83f432af40bcc14e687"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a89ae7c753e10a83f432af40bcc14e687.html#a89ae7c753e10a83f432af40bcc14e687">to_soa_sparse_matrix</a> (int m, int n, MatrixVar &amp;&amp;w, Vec1 &amp;&amp;u, Vec2 &amp;&amp;v)</td></tr>
<tr class="memdesc:a89ae7c753e10a83f432af40bcc14e687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sparse matrix from the given AoS matrix of vars and indexes.  <br /></td></tr>
<tr class="separator:a89ae7c753e10a83f432af40bcc14e687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb39e378f9955c793f230e0966b10b0"><td class="memTemplParams" colspan="2">template&lt;int Options = Eigen::ColMajor, typename Mat , typename Vec1 , typename Vec2 , <a class="el" href="group__eigen__dense__base__types_ga79c34d1cf87ed443d70cab727ea3da73.html#ga79c34d1cf87ed443d70cab727ea3da73">require_eigen_dense_base_vt</a>&lt; std::is_arithmetic, Mat &gt; *  = nullptr, <a class="el" href="group__std__vector__types_ga9ed7c65cf5f86dd50b639dc85ec56a86.html#ga9ed7c65cf5f86dd50b639dc85ec56a86">require_all_std_vector_vt</a>&lt; std::is_integral, Vec1, Vec2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aefb39e378f9955c793f230e0966b10b0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aefb39e378f9955c793f230e0966b10b0.html#aefb39e378f9955c793f230e0966b10b0">to_soa_sparse_matrix</a> (int m, int n, Mat &amp;&amp;w, Vec1 &amp;&amp;u, Vec2 &amp;&amp;v)</td></tr>
<tr class="memdesc:aefb39e378f9955c793f230e0966b10b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a sparse matrix from the given matrix of floats and indexes.  <br /></td></tr>
<tr class="separator:aefb39e378f9955c793f230e0966b10b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aa3540b09f1cb6232de90cb992dabfa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0aa3540b09f1cb6232de90cb992dabfa.html#a0aa3540b09f1cb6232de90cb992dabfa">to_var</a> (double x)</td></tr>
<tr class="memdesc:a0aa3540b09f1cb6232de90cb992dabfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <br /></td></tr>
<tr class="separator:a0aa3540b09f1cb6232de90cb992dabfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae4c448183cd4c647e92fb97b59ef58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afae4c448183cd4c647e92fb97b59ef58.html#afae4c448183cd4c647e92fb97b59ef58">to_var</a> (<a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:afae4c448183cd4c647e92fb97b59ef58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var for non-const var input.  <br /></td></tr>
<tr class="separator:afae4c448183cd4c647e92fb97b59ef58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe953b25e6603e8227d3d40058b34346"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abe953b25e6603e8227d3d40058b34346.html#abe953b25e6603e8227d3d40058b34346">to_var</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;x)</td></tr>
<tr class="memdesc:abe953b25e6603e8227d3d40058b34346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var for const var input.  <br /></td></tr>
<tr class="separator:abe953b25e6603e8227d3d40058b34346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f519c413a80e3ac454526bf461cb73"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a55f519c413a80e3ac454526bf461cb73.html#a55f519c413a80e3ac454526bf461cb73">to_var</a> (const std::vector&lt; double &gt; &amp;v)</td></tr>
<tr class="memdesc:a55f519c413a80e3ac454526bf461cb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <br /></td></tr>
<tr class="separator:a55f519c413a80e3ac454526bf461cb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a05bae0e3b69f691ad2a4a4ccdb7d8d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2a05bae0e3b69f691ad2a4a4ccdb7d8d.html#a2a05bae0e3b69f691ad2a4a4ccdb7d8d">to_var</a> (const std::vector&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a2a05bae0e3b69f691ad2a4a4ccdb7d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var to for const input vector of var.  <br /></td></tr>
<tr class="separator:a2a05bae0e3b69f691ad2a4a4ccdb7d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e780c0e3f3885f192363a368733504d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6e780c0e3f3885f192363a368733504d.html#a6e780c0e3f3885f192363a368733504d">to_var</a> (std::vector&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a6e780c0e3f3885f192363a368733504d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var to for non-const input vector of var.  <br /></td></tr>
<tr class="separator:a6e780c0e3f3885f192363a368733504d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ac82e2c2773d5f460b49dd3b207f56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a3a1b132685d7ca52bbeb05731a5674d5.html#a3a1b132685d7ca52bbeb05731a5674d5">matrix_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a12ac82e2c2773d5f460b49dd3b207f56.html#a12ac82e2c2773d5f460b49dd3b207f56">to_var</a> (const <a class="el" href="namespacestan_1_1math_aca2e8a0b7c1cca979b7ff43cbb75ca65.html#aca2e8a0b7c1cca979b7ff43cbb75ca65">matrix_d</a> &amp;m)</td></tr>
<tr class="memdesc:a12ac82e2c2773d5f460b49dd3b207f56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <br /></td></tr>
<tr class="separator:a12ac82e2c2773d5f460b49dd3b207f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b996e9f8b83954dee4456f1afbfac3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a3a1b132685d7ca52bbeb05731a5674d5.html#a3a1b132685d7ca52bbeb05731a5674d5">matrix_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2b996e9f8b83954dee4456f1afbfac3c.html#a2b996e9f8b83954dee4456f1afbfac3c">to_var</a> (<a class="el" href="namespacestan_1_1math_a3a1b132685d7ca52bbeb05731a5674d5.html#a3a1b132685d7ca52bbeb05731a5674d5">matrix_v</a> &amp;m)</td></tr>
<tr class="memdesc:a2b996e9f8b83954dee4456f1afbfac3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var for non-const matrices of vars.  <br /></td></tr>
<tr class="separator:a2b996e9f8b83954dee4456f1afbfac3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd234e430de0461285227db0acd221e8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a3a1b132685d7ca52bbeb05731a5674d5.html#a3a1b132685d7ca52bbeb05731a5674d5">matrix_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_acd234e430de0461285227db0acd221e8.html#acd234e430de0461285227db0acd221e8">to_var</a> (const <a class="el" href="namespacestan_1_1math_a3a1b132685d7ca52bbeb05731a5674d5.html#a3a1b132685d7ca52bbeb05731a5674d5">matrix_v</a> &amp;m)</td></tr>
<tr class="memdesc:acd234e430de0461285227db0acd221e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var for const matrices of vars.  <br /></td></tr>
<tr class="separator:acd234e430de0461285227db0acd221e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c88a848b4593ca978bb64d78053eee5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_aab8c89394ec1b09c99d6a5bd2eabfba5.html#aab8c89394ec1b09c99d6a5bd2eabfba5">vector_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3c88a848b4593ca978bb64d78053eee5.html#a3c88a848b4593ca978bb64d78053eee5">to_var</a> (const <a class="el" href="namespacestan_1_1math_a4954408ac287ec405ca9b7bf59b3c19b.html#a4954408ac287ec405ca9b7bf59b3c19b">vector_d</a> &amp;v)</td></tr>
<tr class="memdesc:a3c88a848b4593ca978bb64d78053eee5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <br /></td></tr>
<tr class="separator:a3c88a848b4593ca978bb64d78053eee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373cf69331d93d1b94525cf830f3bb57"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_aab8c89394ec1b09c99d6a5bd2eabfba5.html#aab8c89394ec1b09c99d6a5bd2eabfba5">vector_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a373cf69331d93d1b94525cf830f3bb57.html#a373cf69331d93d1b94525cf830f3bb57">to_var</a> (const <a class="el" href="namespacestan_1_1math_aab8c89394ec1b09c99d6a5bd2eabfba5.html#aab8c89394ec1b09c99d6a5bd2eabfba5">vector_v</a> &amp;v)</td></tr>
<tr class="memdesc:a373cf69331d93d1b94525cf830f3bb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var for const column vector of vars.  <br /></td></tr>
<tr class="separator:a373cf69331d93d1b94525cf830f3bb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4752e9a89d25a2962d40554945835d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_aab8c89394ec1b09c99d6a5bd2eabfba5.html#aab8c89394ec1b09c99d6a5bd2eabfba5">vector_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae4752e9a89d25a2962d40554945835d2.html#ae4752e9a89d25a2962d40554945835d2">to_var</a> (<a class="el" href="namespacestan_1_1math_aab8c89394ec1b09c99d6a5bd2eabfba5.html#aab8c89394ec1b09c99d6a5bd2eabfba5">vector_v</a> &amp;v)</td></tr>
<tr class="memdesc:ae4752e9a89d25a2962d40554945835d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var for non-const column vector of vars.  <br /></td></tr>
<tr class="separator:ae4752e9a89d25a2962d40554945835d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf81f695d1c8f4c76e29fc31a496613a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a42483d058e437874b89ced9a3add3e9b.html#a42483d058e437874b89ced9a3add3e9b">row_vector_v</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaf81f695d1c8f4c76e29fc31a496613a.html#aaf81f695d1c8f4c76e29fc31a496613a">to_var</a> (const <a class="el" href="namespacestan_1_1math_abc78fff4ae93add582ece429d038796a.html#abc78fff4ae93add582ece429d038796a">row_vector_d</a> &amp;rv)</td></tr>
<tr class="memdesc:aaf81f695d1c8f4c76e29fc31a496613a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to an automatic differentiation variable.  <br /></td></tr>
<tr class="separator:aaf81f695d1c8f4c76e29fc31a496613a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b49face690c9e98057d97ec18380c67"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacestan_1_1math_a42483d058e437874b89ced9a3add3e9b.html#a42483d058e437874b89ced9a3add3e9b">row_vector_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2b49face690c9e98057d97ec18380c67.html#a2b49face690c9e98057d97ec18380c67">to_var</a> (const <a class="el" href="namespacestan_1_1math_a42483d058e437874b89ced9a3add3e9b.html#a42483d058e437874b89ced9a3add3e9b">row_vector_v</a> &amp;rv)</td></tr>
<tr class="memdesc:a2b49face690c9e98057d97ec18380c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var for const row vector of vars.  <br /></td></tr>
<tr class="separator:a2b49face690c9e98057d97ec18380c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e98d916d46516926e8902d60d5c81a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_a42483d058e437874b89ced9a3add3e9b.html#a42483d058e437874b89ced9a3add3e9b">row_vector_v</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad8e98d916d46516926e8902d60d5c81a.html#ad8e98d916d46516926e8902d60d5c81a">to_var</a> (<a class="el" href="namespacestan_1_1math_a42483d058e437874b89ced9a3add3e9b.html#a42483d058e437874b89ced9a3add3e9b">row_vector_v</a> &amp;rv)</td></tr>
<tr class="memdesc:ad8e98d916d46516926e8902d60d5c81a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of to_var for non-const row vector of vars.  <br /></td></tr>
<tr class="separator:ad8e98d916d46516926e8902d60d5c81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a03ecaef219a0b5f4fadbf3dede030"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab5a03ecaef219a0b5f4fadbf3dede030"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; Eigen::Matrix&lt; double, T::RowsAtCompileTime, T::ColsAtCompileTime &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab5a03ecaef219a0b5f4fadbf3dede030.html#ab5a03ecaef219a0b5f4fadbf3dede030">to_var_value</a> (const T &amp;a)</td></tr>
<tr class="memdesc:ab5a03ecaef219a0b5f4fadbf3dede030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts an <a class="el" href="namespace_eigen.html" title="(Expert) Numerical traits for algorithmic differentiation variables.">Eigen</a> matrix (or vector or row_vector) or expression of <code>var</code>s into <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code>.  <br /></td></tr>
<tr class="separator:ab5a03ecaef219a0b5f4fadbf3dede030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73566ce6a0c149e31fb9b7837efb351"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__var__types_gab0d7285b1a3ce33eb11e113827345d30.html#gab0d7285b1a3ce33eb11e113827345d30">require_var_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ac73566ce6a0c149e31fb9b7837efb351"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac73566ce6a0c149e31fb9b7837efb351.html#ac73566ce6a0c149e31fb9b7837efb351">to_var_value</a> (T &amp;&amp;a)</td></tr>
<tr class="memdesc:ac73566ce6a0c149e31fb9b7837efb351"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a no-op for var_values.  <br /></td></tr>
<tr class="separator:ac73566ce6a0c149e31fb9b7837efb351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf51d7701dd3ad82c3b0a313518d88d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeaf51d7701dd3ad82c3b0a313518d88d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aeaf51d7701dd3ad82c3b0a313518d88d.html#aeaf51d7701dd3ad82c3b0a313518d88d">to_var_value</a> (const std::vector&lt; T &gt; &amp;a)</td></tr>
<tr class="memdesc:aeaf51d7701dd3ad82c3b0a313518d88d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the elements of the <code>std::vector</code> input to <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a></code> types if possible.  <br /></td></tr>
<tr class="separator:aeaf51d7701dd3ad82c3b0a313518d88d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab102289c580edd2ef0a36a674b969271"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga58d00afce3fb9f594503231c52b2db40.html#ga58d00afce3fb9f594503231c52b2db40">require_eigen_t</a>&lt; EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ab102289c580edd2ef0a36a674b969271"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab102289c580edd2ef0a36a674b969271.html#ab102289c580edd2ef0a36a674b969271">to_vector</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; EigMat &gt; &amp;x)</td></tr>
<tr class="memdesc:ab102289c580edd2ef0a36a674b969271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshape a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;Matrix&gt;</code> to a <code><a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt;ColumnVector&gt;</code>.  <br /></td></tr>
<tr class="separator:ab102289c580edd2ef0a36a674b969271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381a6b048c0d3ecf8ffe317b5567d3d9"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__rev__matrix__types_ga4e59582149b6984c54b85901e74b55a3.html#ga4e59582149b6984c54b85901e74b55a3">require_rev_matrix_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a381a6b048c0d3ecf8ffe317b5567d3d9"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a381a6b048c0d3ecf8ffe317b5567d3d9.html#a381a6b048c0d3ecf8ffe317b5567d3d9">trace</a> (const T &amp;m)</td></tr>
<tr class="memdesc:a381a6b048c0d3ecf8ffe317b5567d3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trace of the specified matrix.  <br /></td></tr>
<tr class="separator:a381a6b048c0d3ecf8ffe317b5567d3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155c353bdd346e1ee8895bac6c580909"><td class="memTemplParams" colspan="2">template&lt;typename Td , typename Ta , typename Tb , <a class="el" href="group__col__vector__types_ga91963f6a218d172b07857bf3d5a8aa86.html#ga91963f6a218d172b07857bf3d5a8aa86">require_not_col_vector_t</a>&lt; Td &gt; *  = nullptr, <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; Td, Ta, Tb &gt; *  = nullptr, <a class="el" href="group__var__types_gad4fb966d630ab09756dbc3a1bfd495d4.html#gad4fb966d630ab09756dbc3a1bfd495d4">require_any_st_var</a>&lt; Td, Ta, Tb &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a155c353bdd346e1ee8895bac6c580909"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a155c353bdd346e1ee8895bac6c580909.html#a155c353bdd346e1ee8895bac6c580909">trace_gen_inv_quad_form_ldlt</a> (const Td &amp;D, <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; Ta &gt; &amp;A, const Tb &amp;B)</td></tr>
<tr class="memdesc:a155c353bdd346e1ee8895bac6c580909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the trace of an inverse quadratic form premultiplied by a square matrix.  <br /></td></tr>
<tr class="separator:a155c353bdd346e1ee8895bac6c580909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f14f59ccbad883d17f60885bca6a2b1"><td class="memTemplParams" colspan="2">template&lt;typename Td , typename Ta , typename Tb , <a class="el" href="group__col__vector__types_ga58096049cb8906ec6ad5f44f1e6fe082.html#ga58096049cb8906ec6ad5f44f1e6fe082">require_col_vector_t</a>&lt; Td &gt; *  = nullptr, <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; Ta, Tb &gt; *  = nullptr, <a class="el" href="group__var__types_gad4fb966d630ab09756dbc3a1bfd495d4.html#gad4fb966d630ab09756dbc3a1bfd495d4">require_any_st_var</a>&lt; Td, Ta, Tb &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a8f14f59ccbad883d17f60885bca6a2b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8f14f59ccbad883d17f60885bca6a2b1.html#a8f14f59ccbad883d17f60885bca6a2b1">trace_gen_inv_quad_form_ldlt</a> (const Td &amp;D, const <a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; Ta &gt; &amp;A, const Tb &amp;B)</td></tr>
<tr class="memdesc:a8f14f59ccbad883d17f60885bca6a2b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the trace of an inverse quadratic form.  <br /></td></tr>
<tr class="separator:a8f14f59ccbad883d17f60885bca6a2b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117ac9ee22077e7e02b3d06494a9d607"><td class="memTemplParams" colspan="2">template&lt;typename Td , typename Ta , typename Tb , typename  = require_any_var_t&lt;value_type_t&lt;Td&gt;, value_type_t&lt;Ta&gt;,                                       value_type_t&lt;Tb&gt;&gt;, typename  = require_all_eigen_t&lt;Td, Ta, Tb&gt;&gt; </td></tr>
<tr class="memitem:a117ac9ee22077e7e02b3d06494a9d607"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a117ac9ee22077e7e02b3d06494a9d607.html#a117ac9ee22077e7e02b3d06494a9d607">trace_gen_quad_form</a> (const Td &amp;D, const Ta &amp;A, const Tb &amp;B)</td></tr>
<tr class="memdesc:a117ac9ee22077e7e02b3d06494a9d607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the trace of D times the quadratic form of B and A.  <br /></td></tr>
<tr class="separator:a117ac9ee22077e7e02b3d06494a9d607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ae71980a3d13d358fdd4a52d8ada6a"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; T1, T2 &gt; *  = nullptr, <a class="el" href="group__var__types_gad4fb966d630ab09756dbc3a1bfd495d4.html#gad4fb966d630ab09756dbc3a1bfd495d4">require_any_st_var</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad4ae71980a3d13d358fdd4a52d8ada6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad4ae71980a3d13d358fdd4a52d8ada6a.html#ad4ae71980a3d13d358fdd4a52d8ada6a">trace_inv_quad_form_ldlt</a> (<a class="el" href="classstan_1_1math_1_1_l_d_l_t__factor.html">LDLT_factor</a>&lt; T1 &gt; &amp;A, const T2 &amp;B)</td></tr>
<tr class="memdesc:ad4ae71980a3d13d358fdd4a52d8ada6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the trace of an inverse quadratic form premultiplied by a square matrix.  <br /></td></tr>
<tr class="separator:ad4ae71980a3d13d358fdd4a52d8ada6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a273f011fead1620ecc263dc652b76527"><td class="memTemplParams" colspan="2">template&lt;typename Mat1 , typename Mat2 , <a class="el" href="group__matrix__types_gaf571cd97ea582011192429cf63696f97.html#gaf571cd97ea582011192429cf63696f97">require_all_matrix_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr, <a class="el" href="group__var__matrix__types_gaf9240f628acb5b6ce46e70cd20f93e0f.html#gaf9240f628acb5b6ce46e70cd20f93e0f">require_any_var_matrix_t</a>&lt; Mat1, Mat2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a273f011fead1620ecc263dc652b76527"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a273f011fead1620ecc263dc652b76527.html#a273f011fead1620ecc263dc652b76527">trace_quad_form</a> (const Mat1 &amp;A, const Mat2 &amp;B)</td></tr>
<tr class="memdesc:a273f011fead1620ecc263dc652b76527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute trace(B^T A B).  <br /></td></tr>
<tr class="separator:a273f011fead1620ecc263dc652b76527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7148d5c579f4dab06d820585a8ec021b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7148d5c579f4dab06d820585a8ec021b.html#a7148d5c579f4dab06d820585a8ec021b">trigamma</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;u)</td></tr>
<tr class="memdesc:a7148d5c579f4dab06d820585a8ec021b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the trigamma function at the specified argument (i.e., the second derivative of the log Gamma function at the specified argument).  <br /></td></tr>
<tr class="separator:a7148d5c579f4dab06d820585a8ec021b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e85e1eba4076438c72cd986fde40e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a80e85e1eba4076438c72cd986fde40e8.html#a80e85e1eba4076438c72cd986fde40e8">trunc</a> (const <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &amp;a)</td></tr>
<tr class="memdesc:a80e85e1eba4076438c72cd986fde40e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the truncation of the specified variable (C99).  <br /></td></tr>
<tr class="separator:a80e85e1eba4076438c72cd986fde40e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fb3cfff0ab172b075436d6da7f7f4c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa9fb3cfff0ab172b075436d6da7f7f4c"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa9fb3cfff0ab172b075436d6da7f7f4c.html#aa9fb3cfff0ab172b075436d6da7f7f4c">value_of</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:aa9fb3cfff0ab172b075436d6da7f7f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified variable.  <br /></td></tr>
<tr class="separator:aa9fb3cfff0ab172b075436d6da7f7f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc565f4971436421d4c85d4b6bd1adb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7fc565f4971436421d4c85d4b6bd1adb"><td class="memTemplItemLeft" align="right" valign="top">auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a7fc565f4971436421d4c85d4b6bd1adb.html#a7fc565f4971436421d4c85d4b6bd1adb">value_of_rec</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:a7fc565f4971436421d4c85d4b6bd1adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the value of the specified variable.  <br /></td></tr>
<tr class="separator:a7fc565f4971436421d4c85d4b6bd1adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0400489c86a0f208ed17371ab97254f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac0400489c86a0f208ed17371ab97254f.html#ac0400489c86a0f208ed17371ab97254f">variance</a> (const std::vector&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:ac0400489c86a0f208ed17371ab97254f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample variance of the specified standard vector.  <br /></td></tr>
<tr class="separator:ac0400489c86a0f208ed17371ab97254f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40726361af6601f89530a5c1db6df513"><td class="memTemplParams" colspan="2">template&lt;typename EigMat , <a class="el" href="group__eigen__types_ga45feac0cfd40358ee2842a7f5cce57ea.html#ga45feac0cfd40358ee2842a7f5cce57ea">require_eigen_vt</a>&lt; <a class="el" href="structstan_1_1is__var.html">is_var</a>, EigMat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a40726361af6601f89530a5c1db6df513"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a40726361af6601f89530a5c1db6df513.html#a40726361af6601f89530a5c1db6df513">variance</a> (const EigMat &amp;m)</td></tr>
<tr class="memdesc:a40726361af6601f89530a5c1db6df513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample variance of the specified vector, row vector, or matrix.  <br /></td></tr>
<tr class="separator:a40726361af6601f89530a5c1db6df513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce0ad49d02d149aaf8a0805bc96bc9c"><td class="memTemplParams" colspan="2">template&lt;typename Mat , <a class="el" href="group__var__matrix__types_ga36b69286a639fc88718de93b0db9c172.html#ga36b69286a639fc88718de93b0db9c172">require_var_matrix_t</a>&lt; Mat &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3ce0ad49d02d149aaf8a0805bc96bc9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3ce0ad49d02d149aaf8a0805bc96bc9c.html#a3ce0ad49d02d149aaf8a0805bc96bc9c">variance</a> (const Mat &amp;x)</td></tr>
<tr class="memdesc:a3ce0ad49d02d149aaf8a0805bc96bc9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the sample variance of the <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a> matrix Raise domain error if size is not greater than zero.  <br /></td></tr>
<tr class="separator:a3ce0ad49d02d149aaf8a0805bc96bc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae5580b995717bc378c2345db708901"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 , typename T_u , typename T_f &gt; </td></tr>
<tr class="memitem:a6ae5580b995717bc378c2345db708901"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; T2, -1, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6ae5580b995717bc378c2345db708901.html#a6ae5580b995717bc378c2345db708901">algebra_solver_fp</a> (const F &amp;f, const Eigen::Matrix&lt; T1, -1, 1 &gt; &amp;x, const Eigen::Matrix&lt; T2, -1, 1 &gt; &amp;y, const std::vector&lt; double &gt; &amp;x_r, const std::vector&lt; int &gt; &amp;x_i, const std::vector&lt; T_u &gt; &amp;u_scale, const std::vector&lt; T_f &gt; &amp;f_scale, std::ostream *msgs=nullptr, double f_tol=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-8, int max_num_steps=200)</td></tr>
<tr class="memdesc:a6ae5580b995717bc378c2345db708901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a fixed pointer to the specified system of algebraic equations of form.  <br /></td></tr>
<tr class="separator:a6ae5580b995717bc378c2345db708901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af651e03101be764ba7569888ae4d73"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a2af651e03101be764ba7569888ae4d73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2af651e03101be764ba7569888ae4d73.html#a2af651e03101be764ba7569888ae4d73">algebra_solver_check</a> (const Eigen::Matrix&lt; T1, Eigen::Dynamic, 1 &gt; &amp;x, const Eigen::Matrix&lt; T2, Eigen::Dynamic, 1 &gt; y, const std::vector&lt; double &gt; &amp;dat, const std::vector&lt; int &gt; &amp;dat_int, double function_tolerance, long int max_num_steps)</td></tr>
<tr class="separator:a2af651e03101be764ba7569888ae4d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4111e32e382a574e78391239daeaaf96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4111e32e382a574e78391239daeaaf96.html#a4111e32e382a574e78391239daeaaf96">cvodes_set_options</a> (void *cvodes_mem, long int max_num_steps)</td></tr>
<tr class="separator:a4111e32e382a574e78391239daeaaf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc8742e7e9d1e4258722e3e97a254dd"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_yy , typename T_yp , typename... T_Args, <a class="el" href="group__eigen__col__vector__types_gadba3a075f0d641022a8da364d3159bfa.html#gadba3a075f0d641022a8da364d3159bfa">require_all_eigen_col_vector_t</a>&lt; T_yy, T_yp &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aacc8742e7e9d1e4258722e3e97a254dd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_yy, T_yp, T_Args... &gt;, -1, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aacc8742e7e9d1e4258722e3e97a254dd.html#aacc8742e7e9d1e4258722e3e97a254dd">dae_tol_impl</a> (const char *func, const F &amp;f, const T_yy &amp;yy0, const T_yp &amp;yp0, double t0, const std::vector&lt; double &gt; &amp;ts, double rtol, double atol, int64_t max_num_steps, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:aacc8742e7e9d1e4258722e3e97a254dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the DAE initial value problem f(t, y, y')=0, y(t0) = yy0, y'(t0)=yp0 at a set of times, { t1, t2, t3, ... } using IDAS.  <br /></td></tr>
<tr class="separator:aacc8742e7e9d1e4258722e3e97a254dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e45bd835784800e3aaf4574d7f2557"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_yy , typename T_yp , typename... T_Args, <a class="el" href="group__eigen__col__vector__types_gadba3a075f0d641022a8da364d3159bfa.html#gadba3a075f0d641022a8da364d3159bfa">require_all_eigen_col_vector_t</a>&lt; T_yy, T_yp &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a80e45bd835784800e3aaf4574d7f2557"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_yy, T_yp, T_Args... &gt;, -1, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a80e45bd835784800e3aaf4574d7f2557.html#a80e45bd835784800e3aaf4574d7f2557">dae_tol</a> (const F &amp;f, const T_yy &amp;yy0, const T_yp &amp;yp0, double t0, const std::vector&lt; double &gt; &amp;ts, double rtol, double atol, int64_t max_num_steps, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a80e45bd835784800e3aaf4574d7f2557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the DAE initial value problem f(t, y, y')=0, y(t0) = yy0, y'(t0)=yp0 at a set of times, { t1, t2, t3, ... } using IDAS.  <br /></td></tr>
<tr class="separator:a80e45bd835784800e3aaf4574d7f2557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad90bc72f613c224ba8a733bec196f74"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_yy , typename T_yp , typename... T_Args, <a class="el" href="group__eigen__col__vector__types_gadba3a075f0d641022a8da364d3159bfa.html#gadba3a075f0d641022a8da364d3159bfa">require_all_eigen_col_vector_t</a>&lt; T_yy, T_yp &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aad90bc72f613c224ba8a733bec196f74"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_yy, T_yp, T_Args... &gt;, -1, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aad90bc72f613c224ba8a733bec196f74.html#aad90bc72f613c224ba8a733bec196f74">dae</a> (const F &amp;f, const T_yy &amp;yy0, const T_yp &amp;yp0, double t0, const std::vector&lt; double &gt; &amp;ts, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:aad90bc72f613c224ba8a733bec196f74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the DAE initial value problem f(t, y, y')=0, y(t0) = yy0, y'(t0)=yp0 at a set of times, { t1, t2, t3, ... } using IDAS, assuming default controls (relative tol, absolute tol, max number of steps) = (1.e-10, 1.e-10, 1e8).  <br /></td></tr>
<tr class="separator:aad90bc72f613c224ba8a733bec196f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4666717786c59b911d557d8865a41d74"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a4666717786c59b911d557d8865a41d74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4666717786c59b911d557d8865a41d74.html#a4666717786c59b911d557d8865a41d74">gradient</a> (const F &amp;f, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, double &amp;fx, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;grad_fx)</td></tr>
<tr class="memdesc:a4666717786c59b911d557d8865a41d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value and the gradient of the specified function at the specified argument.  <br /></td></tr>
<tr class="separator:a4666717786c59b911d557d8865a41d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53b95899f2dc2953d283f8301574969"><td class="memTemplParams" colspan="2">template&lt;typename F , typename EigVec , typename InputIt , <a class="el" href="group__eigen__vector__types_ga896401ad33967867f49cd60ca10d990e.html#ga896401ad33967867f49cd60ca10d990e">require_eigen_vector_vt</a>&lt; std::is_arithmetic, EigVec &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae53b95899f2dc2953d283f8301574969"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae53b95899f2dc2953d283f8301574969.html#ae53b95899f2dc2953d283f8301574969">gradient</a> (const F &amp;f, const EigVec &amp;x, double &amp;fx, InputIt first_grad_fx, InputIt last_grad_fx)</td></tr>
<tr class="memdesc:ae53b95899f2dc2953d283f8301574969"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the value and the gradient of the specified function at the specified argument.  <br /></td></tr>
<tr class="separator:ae53b95899f2dc2953d283f8301574969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dea17eae54fb4ef8255f808390a3cdb"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_param , typename T_t0 , typename T_ts &gt; </td></tr>
<tr class="memitem:a1dea17eae54fb4ef8255f808390a3cdb"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y0, T_param, T_t0, T_ts &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1dea17eae54fb4ef8255f808390a3cdb.html#a1dea17eae54fb4ef8255f808390a3cdb">integrate_ode_adams</a> (const F &amp;f, const std::vector&lt; T_y0 &gt; &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, const std::vector&lt; T_param &gt; &amp;theta, const std::vector&lt; double &gt; &amp;x, const std::vector&lt; int &gt; &amp;x_int, std::ostream *msgs=nullptr, double relative_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-10, double absolute_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-10, long int max_num_steps=1e8)</td></tr>
<tr class="separator:a1dea17eae54fb4ef8255f808390a3cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e304c93f4424ea1eb9ead72b72cd484"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_param , typename T_t0 , typename T_ts &gt; </td></tr>
<tr class="memitem:a4e304c93f4424ea1eb9ead72b72cd484"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">return_type_t</a>&lt; T_y0, T_param, T_t0, T_ts &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4e304c93f4424ea1eb9ead72b72cd484.html#a4e304c93f4424ea1eb9ead72b72cd484">integrate_ode_bdf</a> (const F &amp;f, const std::vector&lt; T_y0 &gt; &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, const std::vector&lt; T_param &gt; &amp;theta, const std::vector&lt; double &gt; &amp;x, const std::vector&lt; int &gt; &amp;x_int, std::ostream *msgs=nullptr, double relative_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-10, double absolute_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-10, long int max_num_steps=1e8)</td></tr>
<tr class="separator:a4e304c93f4424ea1eb9ead72b72cd484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ceeaed84c0c91fea1c362395f4e464c"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a9ceeaed84c0c91fea1c362395f4e464c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9ceeaed84c0c91fea1c362395f4e464c.html#a9ceeaed84c0c91fea1c362395f4e464c">jacobian</a> (const F &amp;f, const Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;x, Eigen::Matrix&lt; double, Eigen::Dynamic, 1 &gt; &amp;fx, Eigen::Matrix&lt; double, Eigen::Dynamic, Eigen::Dynamic &gt; &amp;J)</td></tr>
<tr class="separator:a9ceeaed84c0c91fea1c362395f4e464c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcd0bbd80073fb7a910f5f6e36a702e"><td class="memTemplParams" colspan="2">template&lt;typename F1 , typename... Args&gt; </td></tr>
<tr class="memitem:afdcd0bbd80073fb7a910f5f6e36a702e"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_afdcd0bbd80073fb7a910f5f6e36a702e.html#afdcd0bbd80073fb7a910f5f6e36a702e">kinsol_solve</a> (const F1 &amp;f, const Eigen::VectorXd &amp;x, const double scaling_step_tol, const double function_tolerance, const int64_t max_num_steps, const bool custom_jacobian, const int steps_eval_jacobian, const int global_line_search, std::ostream *const msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:afdcd0bbd80073fb7a910f5f6e36a702e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution to the specified algebraic system, given an initial guess.  <br /></td></tr>
<tr class="separator:afdcd0bbd80073fb7a910f5f6e36a702e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4148d10c3b1f132e2170ec361a6874"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... T_Args, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0a4148d10c3b1f132e2170ec361a6874"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, T_Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0a4148d10c3b1f132e2170ec361a6874.html#a0a4148d10c3b1f132e2170ec361a6874">ode_adams_tol_impl</a> (const char *function_name, const F &amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance, double absolute_tolerance, long int max_num_steps, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a0a4148d10c3b1f132e2170ec361a6874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ... } using the non-stiff Adams-Moulton solver from CVODES.  <br /></td></tr>
<tr class="separator:a0a4148d10c3b1f132e2170ec361a6874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658253884b69b57e3d6862436ed13707"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... T_Args, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a658253884b69b57e3d6862436ed13707"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, T_Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a658253884b69b57e3d6862436ed13707.html#a658253884b69b57e3d6862436ed13707">ode_adams_tol</a> (const F &amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance, double absolute_tolerance, long int max_num_steps, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a658253884b69b57e3d6862436ed13707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ... } using the non-stiff Adams-Moulton solver from CVODES.  <br /></td></tr>
<tr class="separator:a658253884b69b57e3d6862436ed13707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94006a2142cd98214165b4986fe2e13"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... T_Args, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af94006a2142cd98214165b4986fe2e13"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, T_Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af94006a2142cd98214165b4986fe2e13.html#af94006a2142cd98214165b4986fe2e13">ode_adams</a> (const F &amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:af94006a2142cd98214165b4986fe2e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ... } using the non-stiff Adams-Moulton solver in CVODES with defaults for relative_tolerance, absolute_tolerance, and max_num_steps.  <br /></td></tr>
<tr class="separator:af94006a2142cd98214165b4986fe2e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055a253d0596a1266c5dcb03b4385583"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename T_abs_tol_fwd , typename T_abs_tol_bwd , typename... T_Args, <a class="el" href="group__eigen__col__vector__types_gadba3a075f0d641022a8da364d3159bfa.html#gadba3a075f0d641022a8da364d3159bfa">require_all_eigen_col_vector_t</a>&lt; T_y0, T_abs_tol_fwd, T_abs_tol_bwd &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga6edc00dc67d479efca08150a952d7588.html#ga6edc00dc67d479efca08150a952d7588">require_any_not_st_arithmetic</a>&lt; T_y0, T_t0, T_ts, T_Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a055a253d0596a1266c5dcb03b4385583"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a055a253d0596a1266c5dcb03b4385583.html#a055a253d0596a1266c5dcb03b4385583">ode_adjoint_impl</a> (const char *function_name, F &amp;&amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance_forward, const T_abs_tol_fwd &amp;absolute_tolerance_forward, double relative_tolerance_backward, const T_abs_tol_bwd &amp;absolute_tolerance_backward, double relative_tolerance_quadrature, double absolute_tolerance_quadrature, long int max_num_steps, long int num_steps_between_checkpoints, int interpolation_polynomial, int solver_forward, int solver_backward, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a055a253d0596a1266c5dcb03b4385583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ... } using the stiff backward differentiation formula BDF solver or the non-stiff Adams solver from CVODES.  <br /></td></tr>
<tr class="separator:a055a253d0596a1266c5dcb03b4385583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69fba1070cc7a963fa18a10d7c52d484"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename T_abs_tol_fwd , typename T_abs_tol_bwd , typename... T_Args, <a class="el" href="group__eigen__col__vector__types_gadba3a075f0d641022a8da364d3159bfa.html#gadba3a075f0d641022a8da364d3159bfa">require_all_eigen_col_vector_t</a>&lt; T_y0, T_abs_tol_fwd, T_abs_tol_bwd &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga3ccb7bb7ca23838c90e98961789c1153.html#ga3ccb7bb7ca23838c90e98961789c1153">require_all_st_arithmetic</a>&lt; T_y0, T_t0, T_ts, T_Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a69fba1070cc7a963fa18a10d7c52d484"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::VectorXd &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a69fba1070cc7a963fa18a10d7c52d484.html#a69fba1070cc7a963fa18a10d7c52d484">ode_adjoint_impl</a> (const char *function_name, F &amp;&amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance_forward, const T_abs_tol_fwd &amp;absolute_tolerance_forward, double relative_tolerance_backward, const T_abs_tol_bwd &amp;absolute_tolerance_backward, double relative_tolerance_quadrature, double absolute_tolerance_quadrature, long int max_num_steps, long int num_steps_between_checkpoints, int interpolation_polynomial, int solver_forward, int solver_backward, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a69fba1070cc7a963fa18a10d7c52d484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ... } using the stiff backward differentiation formula BDF solver or the non-stiff Adams solver from CVODES.  <br /></td></tr>
<tr class="separator:a69fba1070cc7a963fa18a10d7c52d484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0082fb6580a5ca3a9e10762b94753aed"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename T_abs_tol_fwd , typename T_abs_tol_bwd , typename... T_Args, <a class="el" href="group__eigen__col__vector__types_gadba3a075f0d641022a8da364d3159bfa.html#gadba3a075f0d641022a8da364d3159bfa">require_all_eigen_col_vector_t</a>&lt; T_y0, T_abs_tol_fwd, T_abs_tol_bwd &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0082fb6580a5ca3a9e10762b94753aed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0082fb6580a5ca3a9e10762b94753aed.html#a0082fb6580a5ca3a9e10762b94753aed">ode_adjoint_tol_ctl</a> (F &amp;&amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance_forward, const T_abs_tol_fwd &amp;absolute_tolerance_forward, double relative_tolerance_backward, const T_abs_tol_bwd &amp;absolute_tolerance_backward, double relative_tolerance_quadrature, double absolute_tolerance_quadrature, long int max_num_steps, long int num_steps_between_checkpoints, int interpolation_polynomial, int solver_forward, int solver_backward, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a0082fb6580a5ca3a9e10762b94753aed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ... } using the stiff backward differentiation formula BDF solver or the non-stiff Adams solver from CVODES.  <br /></td></tr>
<tr class="separator:a0082fb6580a5ca3a9e10762b94753aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44454f6f6a645d94b12d580e00790742"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... T_Args, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a44454f6f6a645d94b12d580e00790742"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, T_Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a44454f6f6a645d94b12d580e00790742.html#a44454f6f6a645d94b12d580e00790742">ode_bdf_tol_impl</a> (const char *function_name, const F &amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance, double absolute_tolerance, long int max_num_steps, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a44454f6f6a645d94b12d580e00790742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ... } using the stiff backward differentiation formula BDF solver from CVODES.  <br /></td></tr>
<tr class="separator:a44454f6f6a645d94b12d580e00790742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf870ab11b252d91a6ac16b9b8eb640f"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... T_Args, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:aaf870ab11b252d91a6ac16b9b8eb640f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, T_Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aaf870ab11b252d91a6ac16b9b8eb640f.html#aaf870ab11b252d91a6ac16b9b8eb640f">ode_bdf_tol</a> (const F &amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, double relative_tolerance, double absolute_tolerance, long int max_num_steps, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:aaf870ab11b252d91a6ac16b9b8eb640f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ... } using the stiff backward differentiation formula BDF solver from CVODES.  <br /></td></tr>
<tr class="separator:aaf870ab11b252d91a6ac16b9b8eb640f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f571b8865c861275921863b2eb49b8b"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0 , typename T_t0 , typename T_ts , typename... T_Args, <a class="el" href="group__eigen__col__vector__types_ga2d884dd17cfd961ad12df40a9ba3aaa2.html#ga2d884dd17cfd961ad12df40a9ba3aaa2">require_eigen_col_vector_t</a>&lt; T_y0 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a6f571b8865c861275921863b2eb49b8b"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_y0, T_t0, T_ts, T_Args... &gt;, Eigen::Dynamic, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6f571b8865c861275921863b2eb49b8b.html#a6f571b8865c861275921863b2eb49b8b">ode_bdf</a> (const F &amp;f, const T_y0 &amp;y0, const T_t0 &amp;t0, const std::vector&lt; T_ts &gt; &amp;ts, std::ostream *msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a6f571b8865c861275921863b2eb49b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve the ODE initial value problem y' = f(t, y), y(t0) = y0 at a set of times, { t1, t2, t3, ... } using the stiff backward differentiation formula (BDF) solver in CVODES with defaults for relative_tolerance, absolute_tolerance, and max_num_steps.  <br /></td></tr>
<tr class="separator:a6f571b8865c861275921863b2eb49b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744a8f76806a60a1c2264b1d88631adf"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T_y0_t0 , typename T_t0 , typename T_t , typename... Args, <a class="el" href="group__autodiff__types_ga6b677072627547a42cf26c004ec18aa1.html#ga6b677072627547a42cf26c004ec18aa1">require_any_autodiff_t</a>&lt; T_y0_t0, T_t0, T_t, <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; Args &gt;... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a744a8f76806a60a1c2264b1d88631adf"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a744a8f76806a60a1c2264b1d88631adf.html#a744a8f76806a60a1c2264b1d88631adf">ode_store_sensitivities</a> (const F &amp;f, const std::vector&lt; double &gt; &amp;coupled_state, const Eigen::Matrix&lt; T_y0_t0, Eigen::Dynamic, 1 &gt; &amp;y0, const T_t0 &amp;t0, const T_t &amp;t, std::ostream *msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:a744a8f76806a60a1c2264b1d88631adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build output vars for a state of the ODE solve, storing the sensitivities precomputed using the forward sensitivity problem in precomputed varis.  <br /></td></tr>
<tr class="separator:a744a8f76806a60a1c2264b1d88631adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bab2a705eae51f9e46c97fee0fa96c3"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... Args, <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga3ccb7bb7ca23838c90e98961789c1153.html#ga3ccb7bb7ca23838c90e98961789c1153">require_all_st_arithmetic</a>&lt; Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a0bab2a705eae51f9e46c97fee0fa96c3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0bab2a705eae51f9e46c97fee0fa96c3.html#a0bab2a705eae51f9e46c97fee0fa96c3">solve_newton_tol</a> (const F &amp;f, const T &amp;x, const double scaling_step_size, const double function_tolerance, const int64_t max_num_steps, std::ostream *const msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:a0bab2a705eae51f9e46c97fee0fa96c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution to the specified system of algebraic equations given an initial guess, and parameters and data, which get passed into the algebraic system.  <br /></td></tr>
<tr class="separator:a0bab2a705eae51f9e46c97fee0fa96c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629313909fc38043ddc32c86ae04075d"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... T_Args, <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__types_gad4fb966d630ab09756dbc3a1bfd495d4.html#gad4fb966d630ab09756dbc3a1bfd495d4">require_any_st_var</a>&lt; T_Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a629313909fc38043ddc32c86ae04075d"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a629313909fc38043ddc32c86ae04075d.html#a629313909fc38043ddc32c86ae04075d">solve_newton_tol</a> (const F &amp;f, const T &amp;x, const double scaling_step_size, const double function_tolerance, const int64_t max_num_steps, std::ostream *const msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a629313909fc38043ddc32c86ae04075d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution to the specified system of algebraic equations given an initial guess, and parameters and data, which get passed into the algebraic system.  <br /></td></tr>
<tr class="separator:a629313909fc38043ddc32c86ae04075d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c71cf8d667ef4f5e3365e1d962ba69"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... T_Args, <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ae0c71cf8d667ef4f5e3365e1d962ba69"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_Args... &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ae0c71cf8d667ef4f5e3365e1d962ba69.html#ae0c71cf8d667ef4f5e3365e1d962ba69">solve_newton</a> (const F &amp;f, const T &amp;x, std::ostream *const msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:ae0c71cf8d667ef4f5e3365e1d962ba69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution to the specified system of algebraic equations given an initial guess, and parameters and data, which get passed into the algebraic system.  <br /></td></tr>
<tr class="separator:ae0c71cf8d667ef4f5e3365e1d962ba69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9345caa9dcd8d90ae16428dbf5572695"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 , <a class="el" href="group__eigen__vector__types_gaf8c3e4d9b301746f5374ae7237eeab66.html#gaf8c3e4d9b301746f5374ae7237eeab66">require_all_eigen_vector_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a9345caa9dcd8d90ae16428dbf5572695"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_a9f6abe3bad95e25c29cc69722502dc41.html#a9f6abe3bad95e25c29cc69722502dc41">scalar_type_t</a>&lt; T2 &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9345caa9dcd8d90ae16428dbf5572695.html#a9345caa9dcd8d90ae16428dbf5572695">algebra_solver_newton</a> (const F &amp;f, const T1 &amp;x, const T2 &amp;y, const std::vector&lt; double &gt; &amp;dat, const std::vector&lt; int &gt; &amp;dat_int, std::ostream *const msgs=nullptr, const double scaling_step_size=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-3, const double function_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-6, const long int max_num_steps=200)</td></tr>
<tr class="memdesc:a9345caa9dcd8d90ae16428dbf5572695"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution to the specified system of algebraic equations given an initial guess, and parameters and data, which get passed into the algebraic system.  <br /></td></tr>
<tr class="separator:a9345caa9dcd8d90ae16428dbf5572695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86def6f35a1bf0123cb5e34caf336d13"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... Args, <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a86def6f35a1bf0123cb5e34caf336d13"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a86def6f35a1bf0123cb5e34caf336d13.html#a86def6f35a1bf0123cb5e34caf336d13">solve_powell_call_solver</a> (const F &amp;f, T &amp;x, std::ostream *const msgs, const double relative_tolerance, const double function_tolerance, const int64_t max_num_steps, const Args &amp;... args)</td></tr>
<tr class="memdesc:a86def6f35a1bf0123cb5e34caf336d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve algebraic equations using Powell solver.  <br /></td></tr>
<tr class="separator:a86def6f35a1bf0123cb5e34caf336d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52c0f68ca454417c996705ddad614f2"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... Args, <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__arithmetic__types_ga3ccb7bb7ca23838c90e98961789c1153.html#ga3ccb7bb7ca23838c90e98961789c1153">require_all_st_arithmetic</a>&lt; Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:af52c0f68ca454417c996705ddad614f2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::VectorXd&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af52c0f68ca454417c996705ddad614f2.html#af52c0f68ca454417c996705ddad614f2">solve_powell_tol</a> (const F &amp;f, const T &amp;x, const double relative_tolerance, const double function_tolerance, const int64_t max_num_steps, std::ostream *const msgs, const Args &amp;... args)</td></tr>
<tr class="memdesc:af52c0f68ca454417c996705ddad614f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution to the specified system of algebraic equations given an initial guess, and parameters and data, which get passed into the algebraic system.  <br /></td></tr>
<tr class="separator:af52c0f68ca454417c996705ddad614f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab048f340acce81dff816a11ed501e3"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... T_Args, <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a5ab048f340acce81dff816a11ed501e3"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_gacbaff683cd2683209e6855e2c7aaeffe.html#gacbaff683cd2683209e6855e2c7aaeffe">stan::return_type_t</a>&lt; T_Args... &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5ab048f340acce81dff816a11ed501e3.html#a5ab048f340acce81dff816a11ed501e3">solve_powell</a> (const F &amp;f, const T &amp;x, std::ostream *const msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:a5ab048f340acce81dff816a11ed501e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution to the specified system of algebraic equations given an initial guess, and parameters and data, which get passed into the algebraic system.  <br /></td></tr>
<tr class="separator:a5ab048f340acce81dff816a11ed501e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dec4a25f0aa8034407eba5de7a69e2"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T1 , typename T2 , <a class="el" href="group__eigen__vector__types_gaf8c3e4d9b301746f5374ae7237eeab66.html#gaf8c3e4d9b301746f5374ae7237eeab66">require_all_eigen_vector_t</a>&lt; T1, T2 &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a20dec4a25f0aa8034407eba5de7a69e2"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="group__type__trait_ga57121ded0440567e8dfb0d80b1290922.html#ga57121ded0440567e8dfb0d80b1290922">value_type_t</a>&lt; T2 &gt;, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a20dec4a25f0aa8034407eba5de7a69e2.html#a20dec4a25f0aa8034407eba5de7a69e2">algebra_solver</a> (const F &amp;f, const T1 &amp;x, const T2 &amp;y, const std::vector&lt; double &gt; &amp;dat, const std::vector&lt; int &gt; &amp;dat_int, std::ostream *msgs=nullptr, const double relative_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-10, const double function_tolerance=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>-6, const int64_t max_num_steps=1<a class="el" href="namespacestan_1_1math_a3a7127a28f51e5042f0bc4301409dd2f.html#a3a7127a28f51e5042f0bc4301409dd2f">e</a>+3)</td></tr>
<tr class="memdesc:a20dec4a25f0aa8034407eba5de7a69e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution to the specified system of algebraic equations given an initial guess, and parameters and data, which get passed into the algebraic system.  <br /></td></tr>
<tr class="separator:a20dec4a25f0aa8034407eba5de7a69e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13f97e183fb00b9aad653431fc1e4dd"><td class="memTemplParams" colspan="2">template&lt;typename F , typename T , typename... T_Args, <a class="el" href="group__eigen__vector__types_ga80033ba22a52674ccb5e966be1abb6dc.html#ga80033ba22a52674ccb5e966be1abb6dc">require_eigen_vector_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__var__types_gad4fb966d630ab09756dbc3a1bfd495d4.html#gad4fb966d630ab09756dbc3a1bfd495d4">require_any_st_var</a>&lt; T_Args... &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:ad13f97e183fb00b9aad653431fc1e4dd"><td class="memTemplItemLeft" align="right" valign="top">Eigen::Matrix&lt; <a class="el" href="namespacestan_1_1math_abf1141ed12907bf4b7c268faa6126762.html#abf1141ed12907bf4b7c268faa6126762">var</a>, Eigen::Dynamic, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad13f97e183fb00b9aad653431fc1e4dd.html#ad13f97e183fb00b9aad653431fc1e4dd">solve_powell_tol</a> (const F &amp;f, const T &amp;x, const double relative_tolerance, const double function_tolerance, const int64_t max_num_steps, std::ostream *const msgs, const T_Args &amp;... args)</td></tr>
<tr class="memdesc:ad13f97e183fb00b9aad653431fc1e4dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the solution to the specified system of algebraic equations given an initial guess, and parameters and data, which get passed into the algebraic system.  <br /></td></tr>
<tr class="separator:ad13f97e183fb00b9aad653431fc1e4dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8b1a4214b4e3a9f40365632dacf676"><td class="memTemplParams" colspan="2">template&lt;typename T , <a class="el" href="group__stan__scalar__or__eigen__types_ga027699aeeab5c068a93df2a4693c8bda.html#ga027699aeeab5c068a93df2a4693c8bda">require_stan_scalar_or_eigen_t</a>&lt; T &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a3f8b1a4214b4e3a9f40365632dacf676"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3f8b1a4214b4e3a9f40365632dacf676.html#a3f8b1a4214b4e3a9f40365632dacf676">std_normal_log_qf</a> (const <a class="el" href="classstan_1_1math_1_1var__value.html">var_value</a>&lt; T &gt; &amp;log_p)</td></tr>
<tr class="memdesc:a3f8b1a4214b4e3a9f40365632dacf676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the elementwise inverse of unit normal cumulative density function.  <br /></td></tr>
<tr class="separator:a3f8b1a4214b4e3a9f40365632dacf676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a96a673af9fbadb650458832df56d4d2d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; T &gt; *  = nullptr, <a class="el" href="group__stan__scalar__types_ga354988e53bb2c7810e74e3f9c4ab537b.html#ga354988e53bb2c7810e74e3f9c4ab537b">require_all_stan_scalar_t</a>&lt; L, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a96a673af9fbadb650458832df56d4d2d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a96a673af9fbadb650458832df56d4d2d.html#a96a673af9fbadb650458832df56d4d2d">lub_free</a> (T &amp;&amp;y, L &amp;&amp;lb, U &amp;&amp;ub)</td></tr>
<tr class="memdesc:a96a673af9fbadb650458832df56d4d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">lub_free Return the unconstrained variable that transforms to the y given the specified bounds.  <br /></td></tr>
<tr class="separator:a96a673af9fbadb650458832df56d4d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae0ebc0ebdfc6cf598b6c47adc360e3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__eigen__types_ga53ddfa0f3f9bf9e64ce2cbe4082b31a8.html#ga53ddfa0f3f9bf9e64ce2cbe4082b31a8">require_all_eigen_t</a>&lt; T, L, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:abae0ebc0ebdfc6cf598b6c47adc360e3"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_abae0ebc0ebdfc6cf598b6c47adc360e3.html#abae0ebc0ebdfc6cf598b6c47adc360e3">lub_free</a> (T &amp;&amp;y, L &amp;&amp;lb, U &amp;&amp;ub)</td></tr>
<tr class="memdesc:abae0ebc0ebdfc6cf598b6c47adc360e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for matrix constrained variable, matrix upper bound, matrix lower bound.  <br /></td></tr>
<tr class="separator:abae0ebc0ebdfc6cf598b6c47adc360e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc80b7a9f3e799d0a50ad2ad0ebea14f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__std__vector__types_ga613a895eb09b0a2c56cf757f08e3b1d0.html#ga613a895eb09b0a2c56cf757f08e3b1d0">require_all_not_std_vector_t</a>&lt; L, U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:adc80b7a9f3e799d0a50ad2ad0ebea14f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adc80b7a9f3e799d0a50ad2ad0ebea14f.html#adc80b7a9f3e799d0a50ad2ad0ebea14f">lub_free</a> (const std::vector&lt; T &gt; y, const L &amp;lb, const U &amp;ub)</td></tr>
<tr class="memdesc:adc80b7a9f3e799d0a50ad2ad0ebea14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for <code>std::vector</code> constrained variable.  <br /></td></tr>
<tr class="separator:adc80b7a9f3e799d0a50ad2ad0ebea14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e3c8fff85dcf669c7f5814836cea6a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; L &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a11e3c8fff85dcf669c7f5814836cea6a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a11e3c8fff85dcf669c7f5814836cea6a.html#a11e3c8fff85dcf669c7f5814836cea6a">lub_free</a> (const std::vector&lt; T &gt; y, const L &amp;lb, const std::vector&lt; U &gt; &amp;ub)</td></tr>
<tr class="memdesc:a11e3c8fff85dcf669c7f5814836cea6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for <code>std::vector</code> constrained variable and <code>std::vector</code> upper bound.  <br /></td></tr>
<tr class="separator:a11e3c8fff85dcf669c7f5814836cea6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a61e59adbf26885de6d91ee4751798"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U , <a class="el" href="group__std__vector__types_ga0af219a43381a19e0d730d1d1b2e59f6.html#ga0af219a43381a19e0d730d1d1b2e59f6">require_not_std_vector_t</a>&lt; U &gt; *  = nullptr&gt; </td></tr>
<tr class="memitem:a03a61e59adbf26885de6d91ee4751798"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a03a61e59adbf26885de6d91ee4751798.html#a03a61e59adbf26885de6d91ee4751798">lub_free</a> (const std::vector&lt; T &gt; y, const std::vector&lt; L &gt; &amp;lb, const U &amp;ub)</td></tr>
<tr class="memdesc:a03a61e59adbf26885de6d91ee4751798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for <code>std::vector</code> constrained variable and <code>std::vector</code> lower bound.  <br /></td></tr>
<tr class="separator:a03a61e59adbf26885de6d91ee4751798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9a80d88d9e55c1fd07de3ad5fb3157"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:aab9a80d88d9e55c1fd07de3ad5fb3157"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aab9a80d88d9e55c1fd07de3ad5fb3157.html#aab9a80d88d9e55c1fd07de3ad5fb3157">lub_free</a> (const std::vector&lt; T &gt; y, const std::vector&lt; L &gt; &amp;lb, const std::vector&lt; U &gt; &amp;ub)</td></tr>
<tr class="memdesc:aab9a80d88d9e55c1fd07de3ad5fb3157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for <code>std::vector</code> constrained variable and <code>std::vector</code> constraints.  <br /></td></tr>
<tr class="separator:aab9a80d88d9e55c1fd07de3ad5fb3157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7b614cf4be4edb802dc399d0a20577"><td class="memTemplParams" colspan="2">template&lt;typename T , typename L , typename U &gt; </td></tr>
<tr class="memitem:a8f7b614cf4be4edb802dc399d0a20577"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8f7b614cf4be4edb802dc399d0a20577.html#a8f7b614cf4be4edb802dc399d0a20577">lub_free</a> (T &amp;&amp;y, const std::tuple&lt; L, U &gt; &amp;bounds)</td></tr>
<tr class="memdesc:a8f7b614cf4be4edb802dc399d0a20577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for tuple of bounds, simply delegates to the appropriate overload.  <br /></td></tr>
<tr class="separator:a8f7b614cf4be4edb802dc399d0a20577"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac077c45a1bee62fe39ab275715813db5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classstan_1_1math_1_1opencl__context.html">opencl_context</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ac077c45a1bee62fe39ab275715813db5.html#ac077c45a1bee62fe39ab275715813db5">opencl_context</a></td></tr>
<tr class="separator:ac077c45a1bee62fe39ab275715813db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece739c5a2672028f0c7848045b89f08"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aece739c5a2672028f0c7848045b89f08.html#aece739c5a2672028f0c7848045b89f08">CONSTRAINT_TOLERANCE</a> = 1E-8</td></tr>
<tr class="memdesc:aece739c5a2672028f0c7848045b89f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tolerance for checking arithmetic bounds in rank and in simplexes.  <br /></td></tr>
<tr class="separator:aece739c5a2672028f0c7848045b89f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28af31756798a98947ed5351b67fd9c4"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a28af31756798a98947ed5351b67fd9c4.html#a28af31756798a98947ed5351b67fd9c4">EPSILON</a> = std::numeric_limits&lt;double&gt;::epsilon()</td></tr>
<tr class="memdesc:a28af31756798a98947ed5351b67fd9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smallest positive value.  <br /></td></tr>
<tr class="separator:a28af31756798a98947ed5351b67fd9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af856ce6d38a5ec3da54c22bbbeab1ef7"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_af856ce6d38a5ec3da54c22bbbeab1ef7.html#af856ce6d38a5ec3da54c22bbbeab1ef7">INFTY</a> = std::numeric_limits&lt;double&gt;::infinity()</td></tr>
<tr class="memdesc:af856ce6d38a5ec3da54c22bbbeab1ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Positive infinity.  <br /></td></tr>
<tr class="separator:af856ce6d38a5ec3da54c22bbbeab1ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64898a2ef4ecd64e10f379b692cbc307"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a64898a2ef4ecd64e10f379b692cbc307.html#a64898a2ef4ecd64e10f379b692cbc307">NEGATIVE_INFTY</a> = -<a class="el" href="namespacestan_1_1math_af856ce6d38a5ec3da54c22bbbeab1ef7.html#af856ce6d38a5ec3da54c22bbbeab1ef7">INFTY</a></td></tr>
<tr class="memdesc:a64898a2ef4ecd64e10f379b692cbc307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negative infinity.  <br /></td></tr>
<tr class="separator:a64898a2ef4ecd64e10f379b692cbc307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca7e4ef68cbab81021c58ea583edad9"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a1ca7e4ef68cbab81021c58ea583edad9.html#a1ca7e4ef68cbab81021c58ea583edad9">NOT_A_NUMBER</a> = std::numeric_limits&lt;double&gt;::quiet_NaN()</td></tr>
<tr class="memdesc:a1ca7e4ef68cbab81021c58ea583edad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Quiet) not-a-number value.  <br /></td></tr>
<tr class="separator:a1ca7e4ef68cbab81021c58ea583edad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9553730930966dc7e05d451ae28bc64"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ab9553730930966dc7e05d451ae28bc64.html#ab9553730930966dc7e05d451ae28bc64">TWO_PI</a> = boost::math::constants::two_pi&lt;double&gt;()</td></tr>
<tr class="memdesc:ab9553730930966dc7e05d451ae28bc64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Twice the value of \( \pi \), \( 2\pi \).  <br /></td></tr>
<tr class="separator:ab9553730930966dc7e05d451ae28bc64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0489b13217420005c7ee4bd1967e538e"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a0489b13217420005c7ee4bd1967e538e.html#a0489b13217420005c7ee4bd1967e538e">LOG_ZERO</a> = -<a class="el" href="namespacestan_1_1math_af856ce6d38a5ec3da54c22bbbeab1ef7.html#af856ce6d38a5ec3da54c22bbbeab1ef7">INFTY</a></td></tr>
<tr class="memdesc:a0489b13217420005c7ee4bd1967e538e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 0, \( \log 0 \).  <br /></td></tr>
<tr class="separator:a0489b13217420005c7ee4bd1967e538e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6367c20993309bad780502a4497408"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_adc6367c20993309bad780502a4497408.html#adc6367c20993309bad780502a4497408">LOG_EPSILON</a> = std::log(<a class="el" href="namespacestan_1_1math_a28af31756798a98947ed5351b67fd9c4.html#a28af31756798a98947ed5351b67fd9c4">EPSILON</a>)</td></tr>
<tr class="memdesc:adc6367c20993309bad780502a4497408"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of machine precision \( \epsilon \), \( \log \epsilon \).  <br /></td></tr>
<tr class="separator:adc6367c20993309bad780502a4497408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d08de1e5731f6fb99b24ddf57aa5b7"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a75d08de1e5731f6fb99b24ddf57aa5b7.html#a75d08de1e5731f6fb99b24ddf57aa5b7">LOG_TWO</a> = boost::math::constants::ln_two&lt;double&gt;()</td></tr>
<tr class="memdesc:a75d08de1e5731f6fb99b24ddf57aa5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 2, \( \log 2 \).  <br /></td></tr>
<tr class="separator:a75d08de1e5731f6fb99b24ddf57aa5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc001edc0e78a0a7afe9b9e81468917"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a9bc001edc0e78a0a7afe9b9e81468917.html#a9bc001edc0e78a0a7afe9b9e81468917">LOG_PI</a> = 1.14472988584940017414342735135</td></tr>
<tr class="memdesc:a9bc001edc0e78a0a7afe9b9e81468917"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of \( \pi \), \( \log \pi \).  <br /></td></tr>
<tr class="separator:a9bc001edc0e78a0a7afe9b9e81468917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15417f324298da63a581fe6d70b7d0dc"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a15417f324298da63a581fe6d70b7d0dc.html#a15417f324298da63a581fe6d70b7d0dc">LOG_HALF</a> = -<a class="el" href="namespacestan_1_1math_a75d08de1e5731f6fb99b24ddf57aa5b7.html#a75d08de1e5731f6fb99b24ddf57aa5b7">LOG_TWO</a></td></tr>
<tr class="memdesc:a15417f324298da63a581fe6d70b7d0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 0.5, \( \log 0.5 = \log 1 - \log 2 \).  <br /></td></tr>
<tr class="separator:a15417f324298da63a581fe6d70b7d0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb7509c1b5cc085a825b6e00223d52b"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a3bb7509c1b5cc085a825b6e00223d52b.html#a3bb7509c1b5cc085a825b6e00223d52b">LOG_TWO_PI</a> = <a class="el" href="namespacestan_1_1math_a75d08de1e5731f6fb99b24ddf57aa5b7.html#a75d08de1e5731f6fb99b24ddf57aa5b7">LOG_TWO</a> + <a class="el" href="namespacestan_1_1math_a9bc001edc0e78a0a7afe9b9e81468917.html#a9bc001edc0e78a0a7afe9b9e81468917">LOG_PI</a></td></tr>
<tr class="memdesc:a3bb7509c1b5cc085a825b6e00223d52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 2 plus the natural logarithm of \( \pi \), \( \log(2\pi) \).  <br /></td></tr>
<tr class="separator:a3bb7509c1b5cc085a825b6e00223d52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4416329e25eb5a3759fd5c7615a61c8d"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4416329e25eb5a3759fd5c7615a61c8d.html#a4416329e25eb5a3759fd5c7615a61c8d">LOG_PI_OVER_FOUR</a> = 0.25 * <a class="el" href="namespacestan_1_1math_a9bc001edc0e78a0a7afe9b9e81468917.html#a9bc001edc0e78a0a7afe9b9e81468917">LOG_PI</a></td></tr>
<tr class="memdesc:a4416329e25eb5a3759fd5c7615a61c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of one quarter the natural logarithm of \( \pi \), \( \log(\pi) / 4 \).  <br /></td></tr>
<tr class="separator:a4416329e25eb5a3759fd5c7615a61c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4a45ff044b48cbb5f01d2cdf432f68"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8b4a45ff044b48cbb5f01d2cdf432f68.html#a8b4a45ff044b48cbb5f01d2cdf432f68">LOG_SQRT_PI</a> = <a class="el" href="namespacestan_1_1math_a9bc001edc0e78a0a7afe9b9e81468917.html#a9bc001edc0e78a0a7afe9b9e81468917">LOG_PI</a> / 2</td></tr>
<tr class="memdesc:a8b4a45ff044b48cbb5f01d2cdf432f68"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of the square root of \( \pi \), \( \log(sqrt{\pi}) \).  <br /></td></tr>
<tr class="separator:a8b4a45ff044b48cbb5f01d2cdf432f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bc64a6dbd8e9034abd4731d4b81062"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a52bc64a6dbd8e9034abd4731d4b81062.html#a52bc64a6dbd8e9034abd4731d4b81062">LOG_TEN</a> = boost::math::constants::ln_ten&lt;double&gt;()</td></tr>
<tr class="memdesc:a52bc64a6dbd8e9034abd4731d4b81062"><td class="mdescLeft">&#160;</td><td class="mdescRight">The natural logarithm of 10, \( \log 10 \).  <br /></td></tr>
<tr class="separator:a52bc64a6dbd8e9034abd4731d4b81062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9a334555c7e8e6bb05d53d153971fd"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6b9a334555c7e8e6bb05d53d153971fd.html#a6b9a334555c7e8e6bb05d53d153971fd">SQRT_TWO</a> = boost::math::constants::root_two&lt;double&gt;()</td></tr>
<tr class="memdesc:a6b9a334555c7e8e6bb05d53d153971fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the square root of 2, \( \sqrt{2} \).  <br /></td></tr>
<tr class="separator:a6b9a334555c7e8e6bb05d53d153971fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6deae732f2a24a4c91d1aea01eddc296"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a6deae732f2a24a4c91d1aea01eddc296.html#a6deae732f2a24a4c91d1aea01eddc296">SQRT_PI</a> = boost::math::constants::root_pi&lt;double&gt;()</td></tr>
<tr class="memdesc:a6deae732f2a24a4c91d1aea01eddc296"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the square root of \( \pi \), \( \sqrt{\pi} \).  <br /></td></tr>
<tr class="separator:a6deae732f2a24a4c91d1aea01eddc296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa751c757b29468e3cb242fae5c8bdef9"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aa751c757b29468e3cb242fae5c8bdef9.html#aa751c757b29468e3cb242fae5c8bdef9">SQRT_TWO_PI</a> = boost::math::constants::root_two_pi&lt;double&gt;()</td></tr>
<tr class="memdesc:aa751c757b29468e3cb242fae5c8bdef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the square root of \( 2\pi \), \( \sqrt{2\pi} \).  <br /></td></tr>
<tr class="separator:aa751c757b29468e3cb242fae5c8bdef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2403a9e86787dcb725562ff781b853c2"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a2403a9e86787dcb725562ff781b853c2.html#a2403a9e86787dcb725562ff781b853c2">SQRT_TWO_OVER_SQRT_PI</a> = <a class="el" href="namespacestan_1_1math_a6b9a334555c7e8e6bb05d53d153971fd.html#a6b9a334555c7e8e6bb05d53d153971fd">SQRT_TWO</a> / <a class="el" href="namespacestan_1_1math_a6deae732f2a24a4c91d1aea01eddc296.html#a6deae732f2a24a4c91d1aea01eddc296">SQRT_PI</a></td></tr>
<tr class="memdesc:a2403a9e86787dcb725562ff781b853c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The square root of 2 divided by the square root of \( \pi \), \( \sqrt{2} / \sqrt{\pi} \).  <br /></td></tr>
<tr class="separator:a2403a9e86787dcb725562ff781b853c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f300ea7d2367d21741ad731072a8f0d"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a5f300ea7d2367d21741ad731072a8f0d.html#a5f300ea7d2367d21741ad731072a8f0d">INV_SQRT_TWO</a> = boost::math::constants::one_div_root_two&lt;double&gt;()</td></tr>
<tr class="memdesc:a5f300ea7d2367d21741ad731072a8f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of 1 over the square root of 2, \( 1 / \sqrt{2} \).  <br /></td></tr>
<tr class="separator:a5f300ea7d2367d21741ad731072a8f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7b12c46cb271490a0ef92e76b068de"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aae7b12c46cb271490a0ef92e76b068de.html#aae7b12c46cb271490a0ef92e76b068de">INV_SQRT_PI</a> = boost::math::constants::one_div_root_pi&lt;double&gt;()</td></tr>
<tr class="memdesc:aae7b12c46cb271490a0ef92e76b068de"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of 1 over the square root of \( \pi \), \( 1 / \sqrt{\pi} \).  <br /></td></tr>
<tr class="separator:aae7b12c46cb271490a0ef92e76b068de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dcd6f480d9e53bf99be0a0ff967b88"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a60dcd6f480d9e53bf99be0a0ff967b88.html#a60dcd6f480d9e53bf99be0a0ff967b88">INV_SQRT_TWO_PI</a> = boost::math::constants::one_div_root_two_pi&lt;double&gt;()</td></tr>
<tr class="memdesc:a60dcd6f480d9e53bf99be0a0ff967b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of 1 over the square root of \( 2\pi \), \( 1 / \sqrt{2\pi} \).  <br /></td></tr>
<tr class="separator:a60dcd6f480d9e53bf99be0a0ff967b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba20a8bafd6456338197d25c01ba61ec"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_aba20a8bafd6456338197d25c01ba61ec.html#aba20a8bafd6456338197d25c01ba61ec">TWO_OVER_SQRT_PI</a> = boost::math::constants::two_div_root_pi&lt;double&gt;()</td></tr>
<tr class="memdesc:aba20a8bafd6456338197d25c01ba61ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of 2 over the square root of \( \pi \), \( 2 / \sqrt{\pi} \).  <br /></td></tr>
<tr class="separator:aba20a8bafd6456338197d25c01ba61ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08489116f12293545f5fcf324658fdaf"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a08489116f12293545f5fcf324658fdaf.html#a08489116f12293545f5fcf324658fdaf">HALF_LOG_TWO</a> = 0.5 * <a class="el" href="namespacestan_1_1math_a75d08de1e5731f6fb99b24ddf57aa5b7.html#a75d08de1e5731f6fb99b24ddf57aa5b7">LOG_TWO</a></td></tr>
<tr class="memdesc:a08489116f12293545f5fcf324658fdaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of half the natural logarithm 2, \( \log(2) / 2 \).  <br /></td></tr>
<tr class="separator:a08489116f12293545f5fcf324658fdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada94d437be87ce16d3c2a3dc15b28232"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ada94d437be87ce16d3c2a3dc15b28232.html#ada94d437be87ce16d3c2a3dc15b28232">HALF_LOG_TWO_PI</a> = 0.5 * <a class="el" href="namespacestan_1_1math_a3bb7509c1b5cc085a825b6e00223d52b.html#a3bb7509c1b5cc085a825b6e00223d52b">LOG_TWO_PI</a></td></tr>
<tr class="memdesc:ada94d437be87ce16d3c2a3dc15b28232"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of half the natural logarithm \( 2\pi \), \( \log(2\pi) / 2 \).  <br /></td></tr>
<tr class="separator:ada94d437be87ce16d3c2a3dc15b28232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f7f156224f9e60c2fb3e99034212eb"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a59f7f156224f9e60c2fb3e99034212eb.html#a59f7f156224f9e60c2fb3e99034212eb">NEG_LOG_SQRT_TWO_PI</a> = -std::log(<a class="el" href="namespacestan_1_1math_aa751c757b29468e3cb242fae5c8bdef9.html#aa751c757b29468e3cb242fae5c8bdef9">SQRT_TWO_PI</a>)</td></tr>
<tr class="memdesc:a59f7f156224f9e60c2fb3e99034212eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of minus the natural logarithm of the square root of \( 2\pi \), \( -\log(\sqrt{2\pi}) \).  <br /></td></tr>
<tr class="separator:a59f7f156224f9e60c2fb3e99034212eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea938c86917d89bbd13e4edcbecb1be"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a4ea938c86917d89bbd13e4edcbecb1be.html#a4ea938c86917d89bbd13e4edcbecb1be">POISSON_MAX_RATE</a> = std::pow(2.0, 30)</td></tr>
<tr class="memdesc:a4ea938c86917d89bbd13e4edcbecb1be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Largest rate parameter allowed in Poisson RNG.  <br /></td></tr>
<tr class="separator:a4ea938c86917d89bbd13e4edcbecb1be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad739ae95d8525331e40a226c6330700b"><td class="memItemLeft" align="right" valign="top">constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad739ae95d8525331e40a226c6330700b.html#ad739ae95d8525331e40a226c6330700b">lgamma_stirling_diff_useful</a> = 10</td></tr>
<tr class="separator:ad739ae95d8525331e40a226c6330700b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a063d6b0347cc193b69270211e8aadd"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a8a063d6b0347cc193b69270211e8aadd.html#a8a063d6b0347cc193b69270211e8aadd">MAJOR_VERSION</a> = &quot;5&quot;</td></tr>
<tr class="memdesc:a8a063d6b0347cc193b69270211e8aadd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Major version number for Stan math library.  <br /></td></tr>
<tr class="separator:a8a063d6b0347cc193b69270211e8aadd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60295ca22b8701af9a3ccf3b607231f4"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_a60295ca22b8701af9a3ccf3b607231f4.html#a60295ca22b8701af9a3ccf3b607231f4">MINOR_VERSION</a> = &quot;0&quot;</td></tr>
<tr class="memdesc:a60295ca22b8701af9a3ccf3b607231f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minor version number for Stan math library.  <br /></td></tr>
<tr class="separator:a60295ca22b8701af9a3ccf3b607231f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4c620fffa8fa7ddd68ffb46fb64667b"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestan_1_1math_ad4c620fffa8fa7ddd68ffb46fb64667b.html#ad4c620fffa8fa7ddd68ffb46fb64667b">PATCH_VERSION</a> = &quot;0&quot;</td></tr>
<tr class="memdesc:ad4c620fffa8fa7ddd68ffb46fb64667b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Patch version for Stan math library.  <br /></td></tr>
<tr class="separator:ad4c620fffa8fa7ddd68ffb46fb64667b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->

<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacestan.html">stan</a></li><li class="navelem"><a class="el" href="namespacestan_1_1math.html">math</a></li>
    <li class="footer">
    <div class="contents" style="font-size:100%;">
      <span style="float:left; margin=0 1em 0 1em;">
      &nbsp;&nbsp;&nbsp;&nbsp;
      [ <a href="http://mc-stan.org/">Stan Home Page</a> ]
      </span>
      <span style="float:right; margin=0 1em 0 1em;">
      <i>&copy; 2011&ndash;2019,
      Stan Development Team.
      &nbsp;&nbsp;&nbsp;&nbsp;
      </i>
      </span>
    </div> </li>
  </ul>
</div>
</body>
</html>
