#ifndef STAN_MATH_PRIM_FUN_POLAR_HPP
#define STAN_MATH_PRIM_FUN_POLAR_HPP

#include <stan/math/prim/fun/cos.hpp>
#include <stan/math/prim/fun/is_inf.hpp>
#include <stan/math/prim/meta.hpp>
#include <cmath>
#include <complex>
#include <limits>

namespace stan {
namespace math {
namespace internal {
/**
 * Returns complex number with specified magnitude and phase angle.
 *
 * @param[in] r magnitude
 * @param[in] theta phase angle
 * @return complex number with magnitude and phase angle
 */
template <typename U, typename V>
inline auto complex_polar(const U& r, const V& theta) {
  using std::cos;
  using std::sin;
  if (!(r >= 0) || is_inf(theta)) {
    return complex_return_t<U, V>{std::numeric_limits<double>::quiet_NaN()};
  }
  return complex_return_t<U, V>{r * cos(theta), r * sin(theta)};
}
}  // namespace internal

/**
 * Returns the complex number with specified magnitude and phase angle.
 *
 * @param[in] r magnitude
 * @param[in] theta phase angle
 * @return complex number with magnitude and phase angle
 */
inline stan::math::complex<double> polar(double r, double theta) {
  return internal::complex_polar(r, theta);
}
inline stan::math::complex<double> polar(double r, int theta) {
  return internal::complex_polar(r, static_cast<double>(theta));
}
inline stan::math::complex<double> polar(int r, double theta) {
  return internal::complex_polar(static_cast<double>(r), theta);
}
inline stan::math::complex<double> polar(int r, int theta) {
  return internal::complex_polar(static_cast<double>(r),
                                 static_cast<double>(theta));
}

}  // namespace math
}  // namespace stan

#endif
