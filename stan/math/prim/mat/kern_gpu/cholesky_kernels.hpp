#ifndef STAN_MATH_PRIM_MAT_KERN_GPU_CHOLESKY_KERNEL_HPP
#define STAN_MATH_PRIM_MAT_KERN_GPU_CHOLESKY_KERNEL_HPP

#include <string>

#if defined(__APPLE__) || defined(__MACOSX)
#include <OpenCL/cl.hpp>
#else
#include <CL/cl.hpp>
#endif


/** @file stan/math/prim/mat/kern_gpu/cholesky_kernels.hpp
    @brief 
*/

namespace stan {
  namespace math {
    namespace kernel_sources{

      static std::string cholesky_block= 
    "__kernel void cholesky_block(__global double *b,int offset,int M, int n,__global double *V, __global double *d)	\n"
    "{		\n"
    "	int f=get_local_id(0);	\n"
    "	int arrSize=n;	\n"
    "	for (int i = 0; i < n; i++){	\n"
    "		d[i*n+f]=b[(i+offset)*M+f+offset];	\n"
    "		if(i==f)	\n"
    "			V[i*n+f]=1.0;	\n"
    "		else	\n"
    "			V[i*n+f]=0.0;	\n"
    "	}	\n"
    "	barrier(CLK_LOCAL_MEM_FENCE);		\n"
    "		\n"
    "	double sig;	\n"
    "	for (int i=0;i<n-1;i++){	\n"
    "		sig=sqrt(d[i*n+i]);	\n"
    "		if(f==0){	\n"
    "			d[i*n+i]=sig;	\n"
    "		}	\n"
    "		barrier(CLK_LOCAL_MEM_FENCE);	\n"
    "		if(f>=(i+1))	\n"
    "			d[f*n+i]=d[f*n+i]/sig;			\n"
    "		barrier(CLK_LOCAL_MEM_FENCE);	\n"
    "		for(int k=i+1;k<n&&k<arrSize;k++){	\n"
    "		  if(f>=(i+1))	\n"
    "		  	d[k*n+f]=d[k*n+f]-d[k*n+i]*d[f*n+i];		  	\n"
    "		}	\n"
    "		barrier(CLK_LOCAL_MEM_FENCE);	\n"
    "	}	\n"
    "		\n"
    "	barrier(CLK_LOCAL_MEM_FENCE);	\n"
    "	if(f==0){	\n"
    "		d[(n-1)*n+n-1]=sqrt(d[(n-1)*n+n-1]);		\n"
    "	}	\n"
    "	barrier(CLK_LOCAL_MEM_FENCE);	\n"
    "	for(int p=f+1;p<n;p++){	\n"
    "		d[f*n+p]=0;	\n"
    "	}	\n"
    "		\n"
    "		\n"
    "	barrier(CLK_LOCAL_MEM_FENCE);		\n"
    "	//write to matrix	\n"
    "	for (int i = 0; i < n; i++){	\n"
    "		b[(i+offset)*M+f+offset]=d[i*n+f];	\n"
    "	}	\n"
    "	barrier(CLK_LOCAL_MEM_FENCE);		\n"
    "	double faktor;	\n"
    "	for (int i = 0; i < n; i++){	\n"
    "		if(i>0){	\n"
    "			barrier(CLK_LOCAL_MEM_FENCE);	\n"
    "			for (int j = i; j < n; j++) {	\n"
    "				faktor=d[j*n+i-1];	\n"
    "				V[j*n+f]=V[j*n+f]-faktor*V[(i-1)*n+f];	\n"
    "				barrier(CLK_LOCAL_MEM_FENCE);	\n"
    "			}	\n"
    "		}	\n"
    "		faktor=d[i*n+i];	\n"
    "		V[i*n+f]=V[i*n+f]/faktor;	\n"
    "		barrier(CLK_LOCAL_MEM_FENCE);		\n"
    "	}		\n"
    "}	\n";

      static std::string cholesky_left_mid_update= 
    "#define TS3	16	\n"
    "__kernel void cholesky_left_update(__global double* l,__global double* ap, __global double* temp,int offset,int block,int M, int max_threads){	\n"
    "		\n"
    "		\n"
    "	int k;	\n"
    "	const int row = get_local_id(0);	\n"
    "    const int col = get_local_id(1);	\n"
    "    const int i = TS3*get_group_id(0) + row;	\n"
    "    const int j = TS3*get_group_id(1) + col;	\n"
    "		\n"
    "    __local double Asub[TS3][TS3];	\n"
    "    __local double Bsub[TS3][TS3];	\n"
    "		\n"
    "	double sum=0;	\n"
    "	const int numTiles = (block+TS3-1)/TS3;	\n"
    "		\n"
    "	for (int t=0; t<numTiles; t++) {	\n"
    "		\n"
    "		const int tiledRow = TS3*t + row;	\n"
    "		const int tiledCol = TS3*t + col;	\n"
    "		\n"
    "		if(i<max_threads && tiledCol<block){	\n"
    "			Asub[col][row] = ap[(i+offset+block)*M+offset+tiledCol];	\n"
    "		}else{	\n"
    "			Asub[col][row] = 0.0;	\n"
    "		}	\n"
    "			\n"
    "		if(j<block && tiledRow<block){	\n"
    "			Bsub[row][col] = temp[j*block+tiledRow];	\n"
    "		}else{			\n"
    "			Bsub[row][col] = 0.0;	\n"
    "		}	\n"
    "		barrier(CLK_LOCAL_MEM_FENCE);	\n"
    "		for (k=0;k<TS3;k++){	\n"
    "			sum+=Asub[k][row]*Bsub[k][col];				\n"
    "		}	\n"
    "		barrier(CLK_LOCAL_MEM_FENCE);			\n"
    "	}	\n"
    "	if(i<max_threads && j<block){ \n"
    "		l[i*block+j]=sum; \n"
    "	}		\n"
    "} \n"
    "__kernel void cholesky_mid_update(__global double* l,__global double* ap,int offset,int block,int M, int max_threads){	\n"
    "		\n"
    "	int k;	\n"
    "	const int row = get_local_id(0);	\n"
    "   const int col = get_local_id(1);	\n"
    "    const int i = TS3*get_group_id(0) + row;	\n"
    "    const int j = TS3*get_group_id(1) + col;	\n"
    "	\n"
    "    __local double Asub[TS3][TS3];	\n"
    "    __local double Bsub[TS3][TS3];	\n"
    "		\n"
    "	double sum;	\n"
    "	sum=0;	\n"
    "	//if(i< && j<max_threads){	\n"
    "			\n"
    "	const int numTiles = (block+TS3-1)/TS3;	\n"
    "	for (int t=0; t<numTiles; t++) {	\n"
    "			\n"
    "		const int tiledRow = TS3*t + row;	\n"
    "		const int tiledCol = TS3*t + col;	\n"
    "			\n"
    "		if(i<max_threads && tiledCol<max_threads){	\n"
    "			Asub[col][row] = l[i*block+tiledCol];	\n"
    "		}else{	\n"
    "			Asub[col][row] = 0.0;	\n"
    "		}	\n"
    "			\n"
    "		if(j<max_threads && tiledRow<block){	\n"
    "			Bsub[row][col] = l[j*block+tiledRow ];	\n"
    "		}else{			\n"
    "			Bsub[row][col] = 0.0;	\n"
    "		}	\n"
    "		barrier(CLK_LOCAL_MEM_FENCE);	\n"
    "		if(i<max_threads && j<max_threads && i<M && j<M){	\n"
    "			for (k=0;k<TS3;k++){	\n"
    "				sum+=Asub[k][row]*Bsub[k][col];	\n"
    "			}	\n"
    "		}	\n"
    "		barrier(CLK_LOCAL_MEM_FENCE);	\n"
    "	}	\n"
    "	if(i<max_threads && j<max_threads && i<M && j<M){	\n"
    "		ap[(i+offset+block)*M+offset+block+j]-=sum;		\n"
    "	}		\n"
    "	if(i<max_threads && j<block){	\n"
    "		ap[(i+offset+block)*M+offset+j]=l[i*block+j];	\n"
    "	}	\n"
    "}	\n";

      static std::string cholesky_zero= 

    "__kernel void cholesky_zero(__global double* A,int M){ \n"
    "		 \n"
    "		 \n"
    "	const int i = get_global_id(0);	 \n"
    "    const int j = get_global_id(1);	 \n"
    "    	 \n"
    "    if(j>i){	 \n"
    "		A[i*M+j]=0.0;	 \n"
    "    }\n"
    "} \n";

    }  
  }
}
#endif

