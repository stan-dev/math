#ifndef STAN_MATH_PRIM_MAT_KERN_GPU_MATRIX_INVERSE_KERNEL_HPP
#define STAN_MATH_PRIM_MAT_KERN_GPU_MATRIX_INVERSE_KERNEL_HPP

#include <string>

#if defined(__APPLE__) || defined(__MACOSX)
#include <OpenCL/cl.hpp>
#else
#include <CL/cl.hpp>
#endif


/** @file stanmathcl/matrix_inverse_kernels.hpp
    @brief 
*/

namespace stan {
  namespace math {
    namespace kernel_sources{

      static std::string lower_tri_inv_step1=  
    "__kernel void lower_tri_inv_step1(__global double* ap,__global double* vv, int remainder,int part_size_fixed, int M){	\n"
    "		\n"
    "	int indeks=get_global_id(0);	\n"
    "	int i=indeks*part_size_fixed;	\n"
    "	int part_size;	\n"
    "	double faktor;	\n"
    "	if(indeks<remainder){	\n"
    "		i+=indeks;	\n"
    "		part_size=part_size_fixed+1;	\n"
    "	}else{	\n"
    "		i+=remainder;	\n"
    "		part_size=part_size_fixed;	\n"
    "	}		\n"
    "	int offset=indeks*(part_size_fixed+1)*(part_size_fixed+1);	\n"
    "		\n"
    "   for(int p=0;p<part_size;p++){	\n"
    "      for(int r=0;r<part_size;r++){	\n"
    "        if(p==r)	\n"
    "          vv[offset+p*(part_size_fixed+1)+r]=1;	\n"
    "        else	\n"
    "          vv[offset+p*(part_size_fixed+1)+r]=0;	\n"
    "      }	\n"
    "    }	\n"
    "		\n"
    "    for (unsigned int ii = 0; ii < part_size; ii++){	\n"
    "      if(ii>0){	\n"
    "        for (unsigned int j = ii; j < part_size; j++) {	\n"
    "          faktor=ap[(j+i)*M+i+ii-1];	\n"
    "          for (unsigned int k = 0; k < part_size; k++) {	\n"
    "            vv[offset+j*(part_size_fixed+1)+k]=vv[offset+j*(part_size_fixed+1)+k]-faktor*vv[offset+(ii-1)*(part_size_fixed+1)+k];	\n"
    "          }	\n"
    "        }	\n"
    "	  }	\n"
    "      faktor=ap[(ii+i)*M+ii+i];	\n"
    "      for (unsigned int k = 0; k < part_size; k++) {	\n"
    "        vv[offset+ii*(part_size_fixed+1)+k]=vv[offset+ii*(part_size_fixed+1)+k]/faktor;  	\n"
    "      }	\n"
    "    }	\n"
    "		\n"
    "    for(int p=0;p<part_size;p++){	\n"
    "      for(int r=0;r<part_size;r++){	\n"
    "        ap[(p+i)*M+i+r]=vv[offset+p*(part_size_fixed+1)+r];	\n"
    "      }	\n"
    "    }	\n"
    "}	\n";
      
      static std::string lower_tri_inv_step2_3= 
    "#define WPT 4	\n"
    "#define RTS	8	\n"
    "#define TS2 32	\n"
    "__kernel void lower_tri_inv_step2(__global double* ap,__global int* sizes,__global double* MM, int repeat, int remainder,int part_size_fixed, int M){	\n"
    "	\n"
    "	int n=get_global_id(2)*2;	\n"
    "	double sum=0;	\n"
    "	int part_size1=0,part_size2=0;	\n"
    "	int offset_i,offset_j;	\n"
    "		\n"
    "	for(int r=n*repeat;r<(n+1)*repeat;r++)	\n"
    "		part_size1+= sizes[r];	\n"
    "	\n"
    "	for(int r=(n+1)*repeat;r<(n+2)*repeat;r++)	\n"
    "		part_size2+= sizes[r];	\n"
    "	int sizeM=repeat*(part_size_fixed+1);	\n"
    "	offset_i=(n+1)*repeat*part_size_fixed;offset_j=n*repeat*part_size_fixed;	\n"
    "	if(((n+1)*repeat)<=remainder)	\n"
    "		offset_i+=(n+1)*repeat;	\n"
    "	else	\n"
    "		offset_i+=remainder;	\n"
    "			\n"
    "	if((n*repeat)<=remainder)	\n"
    "		offset_j+=n*repeat;	\n"
    "	else	\n"
    "		offset_j+=remainder;	\n"
    "		\n"
    "	const int row = get_local_id(0);	\n"
    " const int col = get_local_id(1);	\n"
    "  const int i = TS2*get_group_id(0) + row;	\n"
    "  const int j = TS2*get_group_id(1) + col;	\n"
    "	\n"
    "  __local double Asub[TS2][TS2];	\n"
    "  __local double Bsub[TS2][TS2];	\n"
    "    	\n"
    "  double acc[WPT];	\n"
    "  for (int w=0; w<WPT; w++) {	\n"
    "      acc[w] = 0.0f;	\n"
    "  }	\n"
    "	\n"
    "  const int numTiles = (part_size2+TS2-1)/TS2;	\n"
    "		\n"
    "	sum=0;	\n"
    " 	\n"
    "	for (int t=0; t<numTiles; t++) {	\n"
    "		for (int w=0; w<WPT; w++) {	\n"
    "			const int tiledRow = TS2*t + row;	\n"
    "			const int tiledCol = TS2*t + col;	\n"
    "				\n"
    "			if(i<part_size2 && (tiledCol+w*RTS)<part_size1){	\n"
    "				Asub[col+w*RTS][row] = ap[(i+offset_i)*M+tiledCol+offset_j+part_size1+w*RTS];	\n"
    "			}else{	\n"
    "				Asub[col+w*RTS][row] = 0.0;	\n"
    "			}	\n"
    "					\n"
    "			if((j+w*RTS)<part_size1 && tiledRow<part_size2){	\n"
    "				Bsub[col+w*RTS][row] = ap[(tiledRow+offset_i)*M+j+offset_j+w*RTS];	\n"
    "			}else{			\n"
    "				Bsub[col+w*RTS][row] = 0.0;	\n"
    "			}	\n"
    "		}	\n"
    "				\n"
    "		barrier(CLK_LOCAL_MEM_FENCE);	\n"
    "		\n"
    "		for(int k=0;k<TS2;k++){					\n"
    "			for (int w=0; w<WPT; w++) {	\n"
    "				acc[w]+=Asub[k][row]*Bsub[col+w*RTS][k];	\n"
    "			}	\n"
    "		} 	\n"
    "		barrier(CLK_LOCAL_MEM_FENCE);	\n"
    "	}	\n"
    "	\n"
    "	for (int w=0; w<WPT; w++) {	\n"
    "		if(i<part_size2&&(j+w*RTS)<part_size1){	\n"
    "			MM[(n/2)*(sizeM)*(sizeM)+i*part_size1+j+w*RTS]=acc[w];	\n"
    "		}	\n"
    "	}	\n"
    "}	\n"
    "	\n"
    "__kernel void lower_tri_inv_step3(__global double* ap,__global int* sizes,__global double* MM, int repeat, int remainder,int part_size_fixed, int M){	\n"
    "	\n"
    "	int n=get_global_id(2)*2;	\n"
    "	double sum=0;	\n"
    "	int part_size1=0,part_size2=0;	\n"
    "	int offset_i,offset_j;	\n"
    "	for(int r=n*repeat;r<(n+1)*repeat;r++)	\n"
    "		part_size1+= sizes[r];	\n"
    "	\n"
    "	for(int r=(n+1)*repeat;r<(n+2)*repeat;r++)	\n"
    "		part_size2+= sizes[r];	\n"
    "		\n"
    "	int sizeM=repeat*(part_size_fixed+1);	\n"
    "	offset_i=(n+1)*repeat*part_size_fixed;offset_j=n*repeat*part_size_fixed;	\n"
    "	if(((n+1)*repeat)<=remainder)	\n"
    "		offset_i+=(n+1)*repeat;	\n"
    "	else	\n"
    "		offset_i+=remainder;	\n"
    "			\n"
    "	if((n*repeat)<=remainder)	\n"
    "		offset_j+=n*repeat;	\n"
    "	else	\n"
    "		offset_j+=remainder;	\n"
    "	\n"
    "		\n"
    "	const int row = get_local_id(0);	\n"
    " const int col = get_local_id(1);	\n"
    "  const int i = TS2*get_group_id(0) + row;	\n"
    "  const int j = TS2*get_group_id(1) + col;	\n"
    "	\n"
    "  __local double Asub[TS2][TS2];	\n"
    "  __local double Bsub[TS2][TS2];	\n"
    "	\n"
    "  double acc[WPT];	\n"
    "  for (int w=0; w<WPT; w++) {	\n"
    "      acc[w] = 0.0f;	\n"
    "  }	\n"
    "	\n"
    "  const int numTiles = (part_size1+TS2-1)/TS2;	\n"
    "		\n"
    "	sum=0;	\n"
    "	for (int t=0; t<numTiles; t++) {	\n"
    "		for (int w=0; w<WPT; w++) {	\n"
    "			const int tiledRow = TS2*t + row;	\n"
    "			const int tiledCol = TS2*t + col;	\n"
    "			if(i<part_size2 && (tiledCol+w*RTS)<part_size1 ){	\n"
    "				Asub[col+w*RTS][row] = MM[(n/2)*(sizeM)*(sizeM)+i*part_size1+tiledCol+w*RTS];	\n"
    "			}else{	\n"
    "				Asub[col+w*RTS][row] = 0.0;	\n"
    "			}	\n"
    "			if((j+w*RTS)<part_size1 && (j+offset_j+w*RTS)<M ){	\n"
    "				Bsub[col+w*RTS][row] = ap[(tiledRow+offset_i-part_size1)*M+j+offset_j+w*RTS];	\n"
    "			}else{			\n"
    "				Bsub[col+w*RTS][row] = 0.0;	\n"
    "			}	\n"
    "		}	\n"
    "		barrier(CLK_LOCAL_MEM_FENCE);	\n"
    "			\n"
    "		for(int k=0;k<TS2;k++){	\n"
    "			for (int w=0; w<WPT; w++) {	\n"
    "				acc[w]+=Asub[k][row]*Bsub[col+w*RTS][k];	\n"
    "			}	\n"
    "		} 		\n"
    "		barrier(CLK_LOCAL_MEM_FENCE);			\n"
    "	}	\n"
    "	for (int w=0; w<WPT; w++) {	\n"
    "		if(i<part_size2&&(j+w*RTS)<part_size1){	\n"
    "			ap[(i+offset_i)*M+j+offset_j+w*RTS]=-acc[w];	\n"
    "		}	\n"
    "	}	\n"
    "	\n"
    "} \n";

    }
  }
}
#endif

